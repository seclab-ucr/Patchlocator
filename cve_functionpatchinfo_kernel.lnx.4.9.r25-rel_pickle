(dp0
S'CVE-2018-19985'
p1
(dp2
(S'drivers/net/usb/hso.c'
p3
S'hso_probe'
p4
tp5
(dp6
S'static int hso_probe(struct usb_interface *interface,\n\t\t     const struct usb_device_id *id)\n{\n\tint mux, i, if_num, port_spec;\n\tunsigned char port_mask;\n\tstruct hso_device *hso_dev = NULL;\n\tstruct hso_shared_int *shared_int;\n\tstruct hso_device *tmp_dev = NULL;\n\n\tif (interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {\n\t\tdev_err(&interface->dev, "Not our interface\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tif_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t/* Get the interface/port specification from either driver_info or from\n\t * the device itself */\n\tif (id->driver_info) {\n\t\t/* if_num is controlled by the device, driver_info is a 0 terminated\n\t\t * array. Make sure, the access is in bounds! */\n\t\tfor (i = 0; i <= if_num; ++i)\n\t\t\tif (((u32 *)(id->driver_info))[i] == 0)\n\t\t\t\tgoto exit;\n\t\tport_spec = ((u32 *)(id->driver_info))[if_num];\n\t} else {\n\t\tport_spec = hso_get_config_data(interface);\n\t\tif (port_spec < 0)\n\t\t\tgoto exit;\n\t}\n\n\t/* Check if we need to switch to alt interfaces prior to port\n\t * configuration */\n\tif (interface->num_altsetting > 1)\n\t\tusb_set_interface(interface_to_usbdev(interface), if_num, 1);\n\tinterface->needs_remote_wakeup = 1;\n\n\t/* Allocate new hso device(s) */\n\tswitch (port_spec & HSO_INTF_MASK) {\n\tcase HSO_INTF_MUX:\n\t\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\t\t/* Create the network device */\n\t\t\tif (!disable_net) {\n\t\t\t\thso_dev = hso_create_net_device(interface,\n\t\t\t\t\t\t\t\tport_spec);\n\t\t\t\tif (!hso_dev)\n\t\t\t\t\tgoto exit;\n\t\t\t\ttmp_dev = hso_dev;\n\t\t\t}\n\t\t}\n\n\t\tif (hso_get_mux_ports(interface, &port_mask))\n\t\t\t/* TODO: de-allocate everything */\n\t\t\tgoto exit;\n\n\t\tshared_int = hso_create_shared_int(interface);\n\t\tif (!shared_int)\n\t\t\tgoto exit;\n\n\t\tfor (i = 1, mux = 0; i < 0x100; i = i << 1, mux++) {\n\t\t\tif (port_mask & i) {\n\t\t\t\thso_dev = hso_create_mux_serial_device(\n\t\t\t\t\t\tinterface, i, shared_int);\n\t\t\t\tif (!hso_dev)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_dev)\n\t\t\thso_dev = tmp_dev;\n\t\tbreak;\n\n\tcase HSO_INTF_BULK:\n\t\t/* It\'s a regular bulk interface */\n\t\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\t\tif (!disable_net)\n\t\t\t\thso_dev =\n\t\t\t\t    hso_create_net_device(interface, port_spec);\n\t\t} else {\n\t\t\thso_dev =\n\t\t\t    hso_create_bulk_serial_device(interface, port_spec);\n\t\t}\n\t\tif (!hso_dev)\n\t\t\tgoto exit;\n\t\tbreak;\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\t/* save our data pointer in this device */\n\tusb_set_intfdata(interface, hso_dev);\n\n\t/* done */\n\treturn 0;\nexit:\n\thso_free_interface(interface);\n\treturn -ENODEV;\n}'
p7
(dp8
((g3
g4
tp9
I1
tp10
(dp11
S'type'
p12
S'aft'
p13
sS'add'
p14
(dp15
(I19
I24
tp16
(lp17
S'\tif (id->driver_info) {'
p18
aS'\t\t/* if_num is controlled by the device, driver_info is a 0 terminated'
p19
aS'\t\t * array. Make sure, the access is in bounds! */'
p20
aS'\t\tfor (i = 0; i <= if_num; ++i)'
p21
aS'\t\t\tif (((u32 *)(id->driver_info))[i] == 0)'
p22
aS'\t\t\t\tgoto exit;'
p23
as(I28
I30
tp24
(lp25
S'\t\tif (port_spec < 0)'
p26
aS'\t\t\tgoto exit;'
p27
aS'\t}'
p28
as(I26
I26
tp29
(lp30
S'\t} else {'
p31
assS'arg_cnt'
p32
I2
sS'del'
p33
(dp34
(I19
I19
tp35
(lp36
S'\tif (id->driver_info)'
p37
as(I26
I26
tp38
(lp39
S'\telse'
p40
assS'func_range'
p41
(I1
I98
tp42
ssss(g3
S'hso_get_config_data'
p43
tp44
(dp45
S'static int hso_get_config_data(struct usb_interface *interface)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tu8 *config_data = kmalloc(17, GFP_KERNEL);\n\tu32 if_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\ts32 result;\n\n\tif (!config_data)\n\t\treturn -ENOMEM;\n\tif (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t    0x86, 0xC0, 0, 0, config_data, 17,\n\t\t\t    USB_CTRL_SET_TIMEOUT) != 0x11) {\n\t\tkfree(config_data);\n\t\treturn -EIO;\n\t}\n\n\t/* check if we have a valid interface */\n\tif (if_num > 16) {\n\t\tkfree(config_data);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (config_data[if_num]) {\n\tcase 0x0:\n\t\tresult = 0;\n\t\tbreak;\n\tcase 0x1:\n\t\tresult = HSO_PORT_DIAG;\n\t\tbreak;\n\tcase 0x2:\n\t\tresult = HSO_PORT_GPS;\n\t\tbreak;\n\tcase 0x3:\n\t\tresult = HSO_PORT_GPS_CONTROL;\n\t\tbreak;\n\tcase 0x4:\n\t\tresult = HSO_PORT_APP;\n\t\tbreak;\n\tcase 0x5:\n\t\tresult = HSO_PORT_APP2;\n\t\tbreak;\n\tcase 0x6:\n\t\tresult = HSO_PORT_CONTROL;\n\t\tbreak;\n\tcase 0x7:\n\t\tresult = HSO_PORT_NETWORK;\n\t\tbreak;\n\tcase 0x8:\n\t\tresult = HSO_PORT_MODEM;\n\t\tbreak;\n\tcase 0x9:\n\t\tresult = HSO_PORT_MSD;\n\t\tbreak;\n\tcase 0xa:\n\t\tresult = HSO_PORT_PCSC;\n\t\tbreak;\n\tcase 0xb:\n\t\tresult = HSO_PORT_VOICE;\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t}\n\n\tif (result)\n\t\tresult |= HSO_INTF_BULK;\n\n\tif (config_data[16] & 0x1)\n\t\tresult |= HSO_INFO_CRC_BUG;\n\n\tkfree(config_data);\n\treturn result;\n}'
p46
(dp47
((g3
g43
tp48
I1
tp49
(dp50
g14
(dp51
(I17
I22
tp52
(lp53
S'\t/* check if we have a valid interface */'
p54
aS'\tif (if_num > 16) {'
p55
aS'\t\tkfree(config_data);'
p56
aS'\t\treturn -EINVAL;'
p57
aS'\t}'
p58
aS''
p59
assg32
I1
sg12
g13
sg41
(I1
I72
tp60
sssssS'CVE-2018-13913'
p61
(dp62
(S'drivers/video/fbdev/msm/mdss_debug.c'
p63
S'mdss_debug_base_is_valid_range'
p64
tp65
(dp66
s(g63
S'mdss_debug_base_offset_write'
p67
tp68
(dp69
S'static ssize_t mdss_debug_base_offset_write(struct file *file,\n\t\t    const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct mdss_debug_base *dbg = file->private_data;\n\tu32 off = 0;\n\tu32 cnt = DEFAULT_BASE_REG_CNT;\n\tchar buf[24];\n\n\tif (!dbg)\n\t\treturn -ENODEV;\n\n\tif (count >= sizeof(buf))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\t/* end of string */\n\n\tif (off % sizeof(u32))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, "%5x %x", &off, &cnt) != 2)\n\t\treturn -EFAULT;\n\n\tif (off > dbg->max_offset)\n\t\treturn -EINVAL;\n\n\tif (cnt > (dbg->max_offset - off))\n\t\tcnt = dbg->max_offset - off;\n\n\tif (!mdss_debug_base_is_valid_range(off, cnt))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mdss_debug_lock);\n\tdbg->off = off;\n\tdbg->cnt = cnt;\n\tmutex_unlock(&mdss_debug_lock);\n\n\tpr_debug("offset=%x cnt=%x\\n", off, cnt);\n\n\treturn count;\n}'
p70
(dp71
((g63
g67
tp72
I1
tp73
(dp74
g14
(dp75
(I32
I34
tp76
(lp77
S'\tif (!mdss_debug_base_is_valid_range(off, cnt))'
p78
aS'\t\treturn -EINVAL;'
p79
ag59
assg32
I4
sg12
g13
sg41
(I1
I43
tp80
sssssS'CVE-2018-13912'
p81
(dp82
(S'drivers/media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c'
p83
S'msm_buf_mngr_subdev_ioctl'
p84
tp85
(dp86
S'static long msm_buf_mngr_subdev_ioctl(struct v4l2_subdev *sd,\n\tunsigned int cmd, void *arg)\n{\n\tint32_t rc = 0;\n\tstruct msm_buf_mngr_device *buf_mngr_dev = v4l2_get_subdevdata(sd);\n\tvoid *argp = arg;\n\n\tif (!buf_mngr_dev) {\n\t\tpr_err("%s buf manager device NULL\\n", __func__);\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\tswitch (cmd) {\n\tcase VIDIOC_MSM_BUF_MNGR_IOCTL_CMD: {\n\t\tstruct msm_camera_private_ioctl_arg k_ioctl, *ptr;\n\n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\t\tptr = arg;\n\t\tk_ioctl = *ptr;\n\t\tswitch (k_ioctl.id) {\n\t\tcase MSM_CAMERA_BUF_MNGR_IOCTL_ID_GET_BUF_BY_IDX: {\n\t\t\tstruct msm_buf_mngr_info buf_info, *tmp = NULL;\n\n\t\t\tif (k_ioctl.size != sizeof(struct msm_buf_mngr_info))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!k_ioctl.ioctl_ptr)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!is_compat_task()) {\n\t\t\t\tMSM_CAM_GET_IOCTL_ARG_PTR(&tmp,\n\t\t\t\t\t&k_ioctl.ioctl_ptr, sizeof(tmp));\n\t\t\t\tif (copy_from_user(&buf_info, tmp,\n\t\t\t\t\tsizeof(struct msm_buf_mngr_info))) {\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tk_ioctl.ioctl_ptr = (uintptr_t)&buf_info;\n\t\t\t}\n\n\t\t\targp = &k_ioctl;\n\t\t\trc = msm_cam_buf_mgr_ops(cmd, argp);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug("unimplemented id %d", k_ioctl.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_MSM_BUF_MNGR_GET_BUF:\n\tcase VIDIOC_MSM_BUF_MNGR_BUF_DONE:\n\tcase VIDIOC_MSM_BUF_MNGR_PUT_BUF:\n\tcase VIDIOC_MSM_BUF_MNGR_BUF_ERROR:\n\t\trc = msm_cam_buf_mgr_ops(cmd, argp);\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_INIT:\n\t\trc = msm_generic_buf_mngr_open(sd, NULL);\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_DEINIT:\n\t\trc = msm_generic_buf_mngr_close(sd, NULL);\n\t\tbreak;\n\tcase MSM_SD_NOTIFY_FREEZE:\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_FLUSH:\n\t\trc = msm_generic_buf_mngr_flush(buf_mngr_dev, argp);\n\t\tbreak;\n\tcase MSM_SD_UNNOTIFY_FREEZE:\n\t\tbreak;\n\tcase MSM_SD_SHUTDOWN:\n\t\tmsm_buf_mngr_sd_shutdown(buf_mngr_dev, argp);\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_CONT_CMD:\n\t\trc = msm_buf_mngr_handle_cont_cmd(buf_mngr_dev, argp);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn rc;\n}'
p87
(dp88
((g83
g84
tp89
I1
tp90
(dp91
g33
(dp92
(I29
I32
tp93
(lp94
S'#ifndef CONFIG_COMPAT'
p95
aS'\t\t\t{'
p96
aS'\t\t\t\tstruct msm_buf_mngr_info buf_info, *tmp = NULL;'
p97
ag59
as(I38
I38
tp98
(lp99
S'#endif'
p100
assg14
(dp101
(I38
I38
tp102
(lp103
g59
as(I23
I23
tp104
(lp105
S'\t\t\tstruct msm_buf_mngr_info buf_info, *tmp = NULL;'
p106
as(I29
I29
tp107
(lp108
S'\t\t\tif (!is_compat_task()) {'
p109
assg32
I3
sg12
g13
sg41
(I1
I78
tp110
sssssS'CVE-2018-20856'
p111
(dp112
(S'block/blk-core.c'
p113
S'blk_init_allocated_queue'
p114
tp115
(dp116
S'blk_init_allocated_queue(struct request_queue *q, request_fn_proc *rfn,\n\t\t\t spinlock_t *lock)\n{\n\tif (!q)\n\t\treturn NULL;\n\n\tq->fq = blk_alloc_flush_queue(q, NUMA_NO_NODE, 0);\n\tif (!q->fq)\n\t\treturn NULL;\n\n\tif (blk_init_rl(&q->root_rl, q, GFP_KERNEL))\n\t\tgoto fail;\n\n\tINIT_WORK(&q->timeout_work, blk_timeout_work);\n\tq->request_fn\t\t= rfn;\n\tq->prep_rq_fn\t\t= NULL;\n\tq->unprep_rq_fn\t\t= NULL;\n\tq->queue_flags\t\t|= QUEUE_FLAG_DEFAULT;\n\n\t/* Override internal queue lock with supplied lock pointer */\n\tif (lock)\n\t\tq->queue_lock\t\t= lock;\n\n\t/*\n\t * This also sets hw/phys segments, boundary and size\n\t */\n\tblk_queue_make_request(q, blk_queue_bio);\n\n\tq->sg_reserved_size = INT_MAX;\n\n\t/* Protect q->elevator from elevator_change */\n\tmutex_lock(&q->sysfs_lock);\n\n\t/* init elevator */\n\tif (elevator_init(q, NULL)) {\n\t\tmutex_unlock(&q->sysfs_lock);\n\t\tgoto fail;\n\t}\n\n\tmutex_unlock(&q->sysfs_lock);\n\n\treturn q;\n\nfail:\n\tblk_free_flush_queue(q->fq);\n\tq->fq = NULL;\n\treturn NULL;\n}'
p117
(dp118
((g113
g114
tp119
I1
tp120
(dp121
g14
(dp122
(I46
I46
tp123
(lp124
S'\tq->fq = NULL;'
p125
assg32
I3
sg12
g13
sg41
(I1
I48
tp126
sssssS'CVE-2018-11818'
p127
(dp128
(S'drivers/video/fbdev/msm/mdss_mdp.c'
p129
S'mdss_mdp_scaler_init'
p130
tp131
(dp132
S'static u32 mdss_mdp_scaler_init(struct mdss_data_type *mdata,\n\t\t\t\tstruct device *dev)\n{\n\tint ret;\n\tstruct device_node *node;\n\tu32 prop_val;\n\n\tif (!dev)\n\t\treturn -EPERM;\n\n\tnode = of_get_child_by_name(dev->of_node, "qcom,mdss-scaler-offsets");\n\tif (!node)\n\t\treturn 0;\n\n\tif (mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmdata->scaler_off = devm_kzalloc(&mdata->pdev->dev,\n\t\t\tsizeof(*mdata->scaler_off), GFP_KERNEL);\n\tif (!mdata->scaler_off)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_off = prop_val;\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-lut-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-lut-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_lut_off = prop_val;\n\tmdata->scaler_off->has_dest_scaler =\n\t\tof_property_read_bool(mdata->pdev->dev.of_node,\n\t\t\t\t"qcom,mdss-has-dest-scaler");\n\tif (mdata->scaler_off->has_dest_scaler) {\n\t\tret = of_property_read_u32(node,\n\t\t\t\t"qcom,mdss-dest-block-off",\n\t\t\t\t&prop_val);\n\t\tif (ret) {\n\t\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t\t"qcom,mdss-dest-block-off", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmdata->scaler_off->dest_base = mdata->mdss_io.base +\n\t\t\tprop_val;\n\t\tmdata->scaler_off->ndest_scalers =\n\t\t\tmdss_mdp_parse_dt_prop_len(mdata->pdev,\n\t\t\t\t\t"qcom,mdss-dest-scalers-off");\n\t\tmdata->scaler_off->dest_scaler_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_off)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scaler-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t\tmdata->scaler_off->dest_scaler_lut_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_lut_off)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scalers-lut-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_lut_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&mdata->scaler_off->scaler_lock);\n\treturn 0;\n}'
p133
(dp134
((g129
g130
tp135
I1
tp136
(dp137
g12
g13
sg14
(dp138
(I77
I77
tp139
(lp140
g59
as(I86
I86
tp141
(lp142
S'\tmutex_init(&mdata->scaler_off->scaler_lock);'
p143
as(I64
I64
tp144
(lp145
g59
as(I75
I75
tp146
(lp147
S'\t\tif  (!mdata->scaler_off->dest_scaler_lut_off)'
p148
as(I62
I62
tp149
(lp150
S'\t\tif  (!mdata->scaler_off->dest_scaler_off)'
p151
assg32
I2
sg33
(dp152
(I75
I76
tp153
(lp154
S'\t\tif  (!mdata->scaler_off->dest_scaler_lut_off) {'
p155
aS'\t\t\tkfree(mdata->scaler_off->dest_scaler_lut_off);'
p156
as(I64
I64
tp157
(lp158
S'\t\t}'
p159
as(I62
I63
tp160
(lp161
S'\t\tif  (!mdata->scaler_off->dest_scaler_off) {'
p162
aS'\t\t\tkfree(mdata->scaler_off->dest_scaler_off);'
p163
as(I77
I77
tp164
(lp165
S'\t\t}'
p166
assg41
(I1
I88
tp167
sssS'static u32 mdss_mdp_scaler_init(struct mdss_data_type *mdata,\n\t\t\t\tstruct device *dev)\n{\n\tint ret;\n\tstruct device_node *node;\n\tu32 prop_val;\n\n\tif (!dev)\n\t\treturn -EPERM;\n\n\tnode = of_get_child_by_name(dev->of_node, "qcom,mdss-scaler-offsets");\n\tif (!node)\n\t\treturn 0;\n\n\tif (mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmdata->scaler_off = devm_kzalloc(&mdata->pdev->dev,\n\t\t\tsizeof(*mdata->scaler_off), GFP_KERNEL);\n\tif (!mdata->scaler_off)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_off = prop_val;\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-lut-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-lut-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_lut_off = prop_val;\n\tmdata->scaler_off->has_dest_scaler =\n\t\tof_property_read_bool(mdata->pdev->dev.of_node,\n\t\t\t\t"qcom,mdss-has-dest-scaler");\n\tif (mdata->scaler_off->has_dest_scaler) {\n\t\tret = of_property_read_u32(node,\n\t\t\t\t"qcom,mdss-dest-block-off",\n\t\t\t\t&prop_val);\n\t\tif (ret) {\n\t\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t\t"qcom,mdss-dest-block-off", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmdata->scaler_off->dest_base = mdata->mdss_io.base +\n\t\t\tprop_val;\n\t\tmdata->scaler_off->ndest_scalers =\n\t\t\tmdss_mdp_parse_dt_prop_len(mdata->pdev,\n\t\t\t\t\t"qcom,mdss-dest-scalers-off");\n\t\tmdata->scaler_off->dest_scaler_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_off) {\n\t\t\tkfree(mdata->scaler_off->dest_scaler_off);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scaler-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t\tmdata->scaler_off->dest_scaler_lut_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_lut_off) {\n\t\t\tkfree(mdata->scaler_off->dest_scaler_lut_off);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scalers-lut-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_lut_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&mdata->scaler_off->scaler_lock);\n\treturn 0;\n}'
p168
(dp169
((g129
g130
tp170
I1
tp171
(dp172
g14
(dp173
(I88
I88
tp174
(lp175
S'\tmutex_init(&mdata->scaler_off->scaler_lock);'
p176
assg32
I2
sg12
g13
sg41
(I1
I90
tp177
ssss(S'drivers/video/fbdev/msm/mdss_mdp_pp.c'
p178
S'mdss_mdp_scaler_lut_cfg'
p179
tp180
(dp181
S'int mdss_mdp_scaler_lut_cfg(struct mdp_scale_data_v2 *scaler,\n\t\t\t\t\t\tchar __iomem *offset)\n{\n\tint i, j, filter;\n\tstruct mdss_data_type *mdata;\n\tchar __iomem *lut_addr;\n\tuint32_t *lut_type[QSEED3_FILTERS] = {NULL, NULL, NULL, NULL, NULL};\n\tuint32_t lut_offset, lut_len;\n\tstruct mdss_mdp_qseed3_lut_tbl *lut_tbl;\n\t/* for each filter, 4 lut regions offset and length table */\n\tstatic uint32_t offset_tbl[QSEED3_FILTERS][QSEED3_LUT_REGIONS][2] = {\n\t\t{{18, 0x000}, {12, 0x120}, {12, 0x1E0}, {8, 0x2A0} },\n\t\t{{6, 0x320}, {3, 0x3E0}, {3, 0x440}, {3, 0x4A0} },\n\t\t{{6, 0x380}, {3, 0x410}, {3, 0x470}, {3, 0x4d0} },\n\t\t{{6, 0x500}, {3, 0x5c0}, {3, 0x620}, {3, 0x680} },\n\t\t{{6, 0x560}, {3, 0x5f0}, {3, 0x650}, {3, 0x6b0} },\n\t};\n\n\tmdata = mdss_mdp_get_mdata();\n\n\tmutex_lock(&mdata->scaler_off->scaler_lock);\n\n\tlut_tbl = &mdata->scaler_off->lut_tbl;\n\tif ((!lut_tbl) || (!lut_tbl->valid)) {\n\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\t\tpr_err("%s:Invalid QSEED3 LUT TABLE\\n", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((scaler->lut_flag & SCALER_LUT_DIR_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_Y_CIR_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_UV_CIR_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_Y_SEP_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_UV_SEP_WR)) {\n\n\t\tif (scaler->lut_flag & SCALER_LUT_DIR_WR)\n\t\t\tlut_type[0] = lut_tbl->dir_lut;\n\t\tif (scaler->lut_flag & SCALER_LUT_Y_CIR_WR)\n\t\t\tlut_type[1] =\n\t\t\t\tlut_tbl->cir_lut + scaler->y_rgb_cir_lut_idx *\n\t\t\t\tCIR_LUT_COEFFS;\n\t\tif (scaler->lut_flag & SCALER_LUT_UV_CIR_WR)\n\t\t\tlut_type[2] = lut_tbl->cir_lut +\n\t\t\t\tscaler->uv_cir_lut_idx * CIR_LUT_COEFFS;\n\t\tif (scaler->lut_flag & SCALER_LUT_Y_SEP_WR)\n\t\t\tlut_type[3] =\n\t\t\t\tlut_tbl->sep_lut + scaler->y_rgb_sep_lut_idx *\n\t\t\t\tSEP_LUT_COEFFS;\n\t\tif (scaler->lut_flag & SCALER_LUT_UV_SEP_WR)\n\t\t\tlut_type[4] =\n\t\t\t\tlut_tbl->sep_lut + scaler->uv_sep_lut_idx *\n\t\t\t\tSEP_LUT_COEFFS;\n\n\t\t/* for each filter per plane */\n\t\tfor (filter = 0; filter < QSEED3_FILTERS; filter++) {\n\t\t\tif (!lut_type[filter])\n\t\t\t\tcontinue;\n\t\t\tlut_offset = 0;\n\t\t\t/* for each lut region */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tlut_addr = offset +\n\t\t\t\t\toffset_tbl[filter][i][1];\n\t\t\t\tlut_len =\n\t\t\t\t\toffset_tbl[filter][i][0] << 2;\n\t\t\t\tfor (j = 0; j < lut_len; j++) {\n\t\t\t\t\twritel_relaxed(\n\t\t\t\t\t\t\t(lut_type[filter])\n\t\t\t\t\t\t\t[lut_offset++],\n\t\t\t\t\t\t\t\tlut_addr);\n\t\t\t\t\t\tlut_addr += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\n\tif (scaler->lut_flag & SCALER_LUT_SWAP)\n\t\twritel_relaxed(BIT(0), MDSS_MDP_REG_SCALER_COEF_LUT_CTRL +\n\t\t\t\toffset);\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn 0;\n}'
p182
(dp183
((g178
g179
tp184
I1
tp185
(dp186
g14
(dp187
(I79
I79
tp188
(lp189
S'\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p190
as(I29
I29
tp191
(lp192
g59
as(I20
I22
tp193
(lp194
g59
aS'\tmutex_lock(&mdata->scaler_off->scaler_lock);'
p195
ag59
as(I25
I25
tp196
(lp197
S'\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p198
assg32
I2
sg12
g13
sg41
(I1
I82
tp199
ssss(S'drivers/video/fbdev/msm/mdss_mdp_overlay.c'
p200
S'mdss_mdp_scaler_lut_init'
p201
tp202
(dp203
S'static int mdss_mdp_scaler_lut_init(struct mdss_data_type *mdata,\n\t\tstruct mdp_scale_luts_info *lut_tbl)\n{\n\tstruct mdss_mdp_qseed3_lut_tbl *qseed3_lut_tbl;\n\tint ret = 0;\n\n\tif (!mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mdata->scaler_off->scaler_lock);\n\n\tqseed3_lut_tbl = &mdata->scaler_off->lut_tbl;\n\tif ((lut_tbl->dir_lut_size !=\n\t\tDIR_LUT_IDX * DIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->cir_lut_size !=\n\t\t CIR_LUT_IDX * CIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->sep_lut_size !=\n\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t))) {\n\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!qseed3_lut_tbl->dir_lut) {\n\t\tqseed3_lut_tbl->dir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->dir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->dir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->cir_lut) {\n\t\tqseed3_lut_tbl->cir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->cir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->cir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_dir_lut;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->sep_lut) {\n\t\tqseed3_lut_tbl->sep_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->sep_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->sep_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_cir_lut;\n\t\t}\n\t}\n\n\t/* Invalidate before updating */\n\tqseed3_lut_tbl->valid = false;\n\n\tif (copy_from_user(qseed3_lut_tbl->dir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->dir_lut,\n\t\t\t\tlut_tbl->dir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->cir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->cir_lut,\n\t\t\t\tlut_tbl->cir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->sep_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->sep_lut,\n\t\t\t\tlut_tbl->sep_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tqseed3_lut_tbl->valid = true;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n\nfail_free_sep_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->sep_lut);\nfail_free_cir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->cir_lut);\nfail_free_dir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->dir_lut);\nerr:\n\tqseed3_lut_tbl->dir_lut = NULL;\n\tqseed3_lut_tbl->cir_lut = NULL;\n\tqseed3_lut_tbl->sep_lut = NULL;\n\tqseed3_lut_tbl->valid = false;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n}'
p204
(dp205
((g200
g201
tp206
I1
tp207
(dp208
g12
g13
sg14
(dp209
(I82
I87
tp210
(lp211
S'fail_free_sep_lut:'
p212
aS'\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->sep_lut);'
p213
aS'fail_free_cir_lut:'
p214
aS'\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->cir_lut);'
p215
aS'fail_free_dir_lut:'
p216
aS'\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->dir_lut);'
p217
as(I29
I29
tp218
(lp219
S'\t\t\tgoto err;'
p220
as(I10
I11
tp221
(lp222
S'\tmutex_lock(&mdata->scaler_off->scaler_lock);'
p223
ag59
as(I21
I21
tp224
(lp225
S'\t}'
p226
as(I74
I74
tp227
(lp228
S'\t\tgoto fail_free_sep_lut;'
p229
as(I93
I94
tp230
(lp231
S'\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p232
ag59
as(I5
I5
tp233
(lp234
S'\tint ret = 0;'
p235
as(I60
I60
tp236
(lp237
S'\t\tgoto fail_free_sep_lut;'
p238
as(I39
I39
tp239
(lp240
S'\t\t\tgoto fail_free_dir_lut;'
p241
as(I89
I91
tp242
(lp243
S'\tqseed3_lut_tbl->dir_lut = NULL;'
p244
aS'\tqseed3_lut_tbl->cir_lut = NULL;'
p245
aS'\tqseed3_lut_tbl->sep_lut = NULL;'
p246
as(I18
I19
tp247
(lp248
S'\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t))) {'
p249
aS'\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p250
as(I78
I79
tp251
(lp252
S'\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p253
ag59
as(I49
I49
tp254
(lp255
S'\t\t\tgoto fail_free_cir_lut;'
p256
as(I67
I67
tp257
(lp258
S'\t\tgoto fail_free_sep_lut;'
p259
assg32
I2
sg33
(dp260
(I67
I67
tp261
(lp262
S'\t\tgoto err;'
p263
as(I56
I56
tp264
(lp265
g59
as(I29
I29
tp266
(lp267
S'\t\t\tgoto fail;'
p268
as(I74
I74
tp269
(lp270
S'\t\tgoto err;'
p271
as(I18
I18
tp272
(lp273
S'\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t)))'
p274
as(I82
I85
tp275
(lp276
S'fail:'
p277
aS'\tkfree(qseed3_lut_tbl->dir_lut);'
p278
aS'\tkfree(qseed3_lut_tbl->cir_lut);'
p279
aS'\tkfree(qseed3_lut_tbl->sep_lut);'
p280
as(I60
I60
tp281
(lp282
S'\t\tgoto err;'
p283
as(I49
I49
tp284
(lp285
S'\t\t\tgoto fail;'
p286
as(I39
I39
tp287
(lp288
S'\t\t\tgoto fail;'
p289
as(I5
I5
tp290
(lp291
S'\tint ret;'
p292
assg41
(I1
I96
tp293
sssS'static int mdss_mdp_scaler_lut_init(struct mdss_data_type *mdata,\n\t\tstruct mdp_scale_luts_info *lut_tbl)\n{\n\tstruct mdss_mdp_qseed3_lut_tbl *qseed3_lut_tbl;\n\tint ret;\n\n\tif (!mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mdata->scaler_off->scaler_lock);\n\n\tqseed3_lut_tbl = &mdata->scaler_off->lut_tbl;\n\tif ((lut_tbl->dir_lut_size !=\n\t\tDIR_LUT_IDX * DIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->cir_lut_size !=\n\t\t CIR_LUT_IDX * CIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->sep_lut_size !=\n\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t))) {\n\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!qseed3_lut_tbl->dir_lut) {\n\t\tqseed3_lut_tbl->dir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->dir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->dir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->cir_lut) {\n\t\tqseed3_lut_tbl->cir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->cir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->cir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_dir_lut;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->sep_lut) {\n\t\tqseed3_lut_tbl->sep_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->sep_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->sep_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_cir_lut;\n\t\t}\n\t}\n\n\t/* Invalidate before updating */\n\tqseed3_lut_tbl->valid = false;\n\n\tif (copy_from_user(qseed3_lut_tbl->dir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->dir_lut,\n\t\t\t\tlut_tbl->dir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->cir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->cir_lut,\n\t\t\t\tlut_tbl->cir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->sep_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->sep_lut,\n\t\t\t\tlut_tbl->sep_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tqseed3_lut_tbl->valid = true;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n\nfail_free_sep_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->sep_lut);\nfail_free_cir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->cir_lut);\nfail_free_dir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->dir_lut);\nerr:\n\tqseed3_lut_tbl->dir_lut = NULL;\n\tqseed3_lut_tbl->cir_lut = NULL;\n\tqseed3_lut_tbl->sep_lut = NULL;\n\tqseed3_lut_tbl->valid = false;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n}'
p294
(dp295
((g200
g201
tp296
I1
tp297
(dp298
g33
(dp299
(I67
I67
tp300
(lp301
S'\t\tgoto err;'
p302
as(I56
I56
tp303
(lp304
g59
as(I29
I29
tp305
(lp306
S'\t\t\tgoto fail;'
p307
as(I74
I74
tp308
(lp309
S'\t\tgoto err;'
p310
as(I18
I18
tp311
(lp312
S'\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t)))'
p313
as(I82
I85
tp314
(lp315
S'fail:'
p316
aS'\tkfree(qseed3_lut_tbl->dir_lut);'
p317
aS'\tkfree(qseed3_lut_tbl->cir_lut);'
p318
aS'\tkfree(qseed3_lut_tbl->sep_lut);'
p319
as(I60
I60
tp320
(lp321
S'\t\tgoto err;'
p322
as(I49
I49
tp323
(lp324
S'\t\t\tgoto fail;'
p325
as(I39
I39
tp326
(lp327
S'\t\t\tgoto fail;'
p328
assg14
(dp329
(I82
I87
tp330
(lp331
S'fail_free_sep_lut:'
p332
aS'\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->sep_lut);'
p333
aS'fail_free_cir_lut:'
p334
aS'\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->cir_lut);'
p335
aS'fail_free_dir_lut:'
p336
aS'\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->dir_lut);'
p337
as(I29
I29
tp338
(lp339
S'\t\t\tgoto err;'
p340
as(I10
I11
tp341
(lp342
S'\tmutex_lock(&mdata->scaler_off->scaler_lock);'
p343
ag59
as(I67
I67
tp344
(lp345
S'\t\tgoto fail_free_sep_lut;'
p346
as(I74
I74
tp347
(lp348
S'\t\tgoto fail_free_sep_lut;'
p349
as(I93
I94
tp350
(lp351
S'\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p352
ag59
as(I60
I60
tp353
(lp354
S'\t\tgoto fail_free_sep_lut;'
p355
as(I39
I39
tp356
(lp357
S'\t\t\tgoto fail_free_dir_lut;'
p358
as(I89
I91
tp359
(lp360
S'\tqseed3_lut_tbl->dir_lut = NULL;'
p361
aS'\tqseed3_lut_tbl->cir_lut = NULL;'
p362
aS'\tqseed3_lut_tbl->sep_lut = NULL;'
p363
as(I18
I19
tp364
(lp365
S'\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t))) {'
p366
aS'\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p367
as(I78
I79
tp368
(lp369
S'\tmutex_unlock(&mdata->scaler_off->scaler_lock);'
p370
ag59
as(I49
I49
tp371
(lp372
S'\t\t\tgoto fail_free_cir_lut;'
p373
as(I21
I21
tp374
(lp375
S'\t}'
p376
assg32
I2
sg12
g13
sg41
(I1
I96
tp377
sssssS'CVE-2019-10625'
p378
(dp379
(S'drivers/char/diag/diag_dci.c'
p380
S'extract_dci_pkt_rsp'
p381
tp382
(dp383
S'void extract_dci_pkt_rsp(unsigned char *buf, int len, int data_source,\n\t\t\t int token)\n{\n\tint tag;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tvoid *temp_buf = NULL;\n\tuint8_t dci_cmd_code, cmd_code_len, delete_flag = 0;\n\tuint32_t rsp_len = 0;\n\tstruct diag_dci_buffer_t *rsp_buf = NULL;\n\tstruct dci_pkt_req_entry_t *req_entry = NULL;\n\tunsigned char *temp = buf;\n\tint save_req_uid = 0;\n\tstruct diag_dci_pkt_rsp_header_t pkt_rsp_header;\n\tint header_len = sizeof(struct diag_dci_pkt_rsp_header_t);\n\n\tif (!buf || len <= 0) {\n\t\tpr_err("diag: Invalid pointer in %s\\n", __func__);\n\t\treturn;\n\t}\n\tdci_cmd_code = *(uint8_t *)(temp);\n\tif (dci_cmd_code == DCI_PKT_RSP_CODE) {\n\t\tcmd_code_len = sizeof(uint8_t);\n\t} else if (dci_cmd_code == DCI_DELAYED_RSP_CODE) {\n\t\tcmd_code_len = sizeof(uint32_t);\n\t} else {\n\t\tpr_err("diag: In %s, invalid command code %d\\n", __func__,\n\t\t\t\t\t\t\t\tdci_cmd_code);\n\t\treturn;\n\t}\n\tif (len < (cmd_code_len + sizeof(int)))\n\t\treturn;\n\ttemp += cmd_code_len;\n\ttag = *(int *)temp;\n\ttemp += sizeof(int);\n\n\t/*\n\t * The size of the response is (total length) - (length of the command\n\t * code, the tag (int)\n\t */\n\tif (len >= cmd_code_len + sizeof(int)) {\n\t\trsp_len = len - (cmd_code_len + sizeof(int));\n\t\tif ((rsp_len == 0) || (rsp_len > (len - 5))) {\n\t\t\tpr_err("diag: Invalid length in %s, len: %d, rsp_len: %d\\n",\n\t\t\t\t\t__func__, len, rsp_len);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tpr_err("diag:%s: Invalid length(%d) for calculating rsp_len\\n",\n\t\t\t__func__, len);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->dci_mutex);\n\treq_entry = diag_dci_get_request_entry(tag);\n\tif (!req_entry) {\n\t\tpr_err_ratelimited("diag: No matching client for DCI data\\n");\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\treturn;\n\t}\n\n\tentry = diag_dci_get_client_entry(req_entry->client_id);\n\tif (!entry) {\n\t\tpr_err("diag: In %s, couldn\'t find client entry, id:%d\\n",\n\t\t\t\t\t\t__func__, req_entry->client_id);\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\treturn;\n\t}\n\n\tsave_req_uid = req_entry->uid;\n\t/* Remove the headers and send only the response to this function */\n\tdelete_flag = diag_dci_remove_req_entry(temp, rsp_len, req_entry);\n\tif (delete_flag < 0) {\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\treturn;\n\t}\n\n\tmutex_lock(&entry->buffers[data_source].buf_mutex);\n\trsp_buf = entry->buffers[data_source].buf_cmd;\n\n\tmutex_lock(&rsp_buf->data_mutex);\n\t/*\n\t * Check if we can fit the data in the rsp buffer. The total length of\n\t * the rsp is the rsp length (write_len) + dci response packet header\n\t * length (sizeof(struct diag_dci_pkt_rsp_header_t))\n\t */\n\tif ((rsp_buf->data_len + header_len + rsp_len) > rsp_buf->capacity) {\n\t\tpr_alert("diag: create capacity for pkt rsp\\n");\n\t\ttemp_buf = vzalloc(rsp_buf->capacity + header_len + rsp_len);\n\t\tif (!temp_buf) {\n\t\t\tpr_err("diag: DCI realloc failed\\n");\n\t\t\tmutex_unlock(&rsp_buf->data_mutex);\n\t\t\tmutex_unlock(&entry->buffers[data_source].buf_mutex);\n\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\treturn;\n\t\t}\n\t\trsp_buf->capacity += header_len + rsp_len;\n\t\tif (rsp_buf->capacity > rsp_buf->data_len)\n\t\t\tmemcpy(temp_buf, rsp_buf->data, rsp_buf->data_len);\n\t\tvfree(rsp_buf->data);\n\t\trsp_buf->data = temp_buf;\n\t}\n\n\t/* Fill in packet response header information */\n\tpkt_rsp_header.type = DCI_PKT_RSP_TYPE;\n\t/* Packet Length = Response Length + Length of uid field (int) */\n\tpkt_rsp_header.length = rsp_len + sizeof(int);\n\tpkt_rsp_header.delete_flag = delete_flag;\n\tpkt_rsp_header.uid = save_req_uid;\n\tmemcpy(rsp_buf->data + rsp_buf->data_len, &pkt_rsp_header, header_len);\n\trsp_buf->data_len += header_len;\n\tmemcpy(rsp_buf->data + rsp_buf->data_len, temp, rsp_len);\n\trsp_buf->data_len += rsp_len;\n\trsp_buf->data_source = data_source;\n\n\tmutex_unlock(&rsp_buf->data_mutex);\n\n\t/*\n\t * Add directly to the list for writing responses to the\n\t * userspace as these shouldn\'t be buffered and shouldn\'t wait\n\t * for log and event buffers to be full\n\t */\n\tdci_add_buffer_to_list(entry, rsp_buf);\n\tmutex_unlock(&entry->buffers[data_source].buf_mutex);\n\tmutex_unlock(&driver->dci_mutex);\n}'
p384
(dp385
((g380
g381
tp386
I1
tp387
(dp388
g33
(dp389
(I109
I111
tp390
(lp391
S'\tmemcpy(rsp_buf->data + rsp_buf->data_len, &pkt_rsp_header,'
p392
aS'\t\tsizeof(struct diag_dci_pkt_rsp_header_t));'
p393
aS'\trsp_buf->data_len += sizeof(struct diag_dci_pkt_rsp_header_t);'
p394
as(I83
I84
tp395
(lp396
S'\t * the rsp is the rsp length (write_len) + DCI_PKT_RSP_TYPE header (int)'
p397
aS'\t * + field for length (int) + delete_flag (uint8_t)'
p398
as(I88
I90
tp399
(lp400
S'\t\trsp_buf->capacity += 9 + rsp_len;'
p401
aS'\t\ttemp_buf = krealloc(rsp_buf->data, rsp_buf->capacity,'
p402
aS'\t\t\t\t    GFP_KERNEL);'
p403
as(I86
I86
tp404
(lp405
S'\tif ((rsp_buf->data_len + 9 + rsp_len) > rsp_buf->capacity) {'
p406
assg14
(dp407
(I88
I88
tp408
(lp409
S'\t\ttemp_buf = vzalloc(rsp_buf->capacity + header_len + rsp_len);'
p410
as(I86
I86
tp411
(lp412
S'\tif ((rsp_buf->data_len + header_len + rsp_len) > rsp_buf->capacity) {'
p413
as(I109
I110
tp414
(lp415
S'\tmemcpy(rsp_buf->data + rsp_buf->data_len, &pkt_rsp_header, header_len);'
p416
aS'\trsp_buf->data_len += header_len;'
p417
as(I96
I99
tp418
(lp419
S'\t\trsp_buf->capacity += header_len + rsp_len;'
p420
aS'\t\tif (rsp_buf->capacity > rsp_buf->data_len)'
p421
aS'\t\t\tmemcpy(temp_buf, rsp_buf->data, rsp_buf->data_len);'
p422
aS'\t\tvfree(rsp_buf->data);'
p423
as(I14
I14
tp424
(lp425
S'\tint header_len = sizeof(struct diag_dci_pkt_rsp_header_t);'
p426
as(I83
I84
tp427
(lp428
S'\t * the rsp is the rsp length (write_len) + dci response packet header'
p429
aS'\t * length (sizeof(struct diag_dci_pkt_rsp_header_t))'
p430
assg32
I4
sg12
g13
sg41
(I1
I125
tp431
sssssS'CVE-2019-14104'
p432
(dp433
(S'drivers/media/platform/msm/camera/cam_core/cam_context.c'
p434
S'cam_context_handle_start_dev'
p435
tp436
(dp437
S'int cam_context_handle_start_dev(struct cam_context *ctx,\n\tstruct cam_start_stop_dev_cmd *cmd)\n{\n\tint rc = 0;\n\n\tif (!ctx || !ctx->state_machine) {\n\t\tCAM_ERR(CAM_CORE, "Context is not ready");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cmd) {\n\t\tCAM_ERR(CAM_CORE, "Invalid start device command payload");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ctx->ctx_mutex);\n\tif (ctx->state_machine[ctx->state].ioctl_ops.start_dev)\n\t\trc = ctx->state_machine[ctx->state].ioctl_ops.start_dev(\n\t\t\tctx, cmd);\n\telse\n\t\t/* start device can be optional for some driver */\n\t\tCAM_DBG(CAM_CORE, "No start device in dev %d, state %d",\n\t\t\tctx->dev_hdl, ctx->state);\n\n\tmutex_unlock(&ctx->ctx_mutex);\n\n\treturn rc;\n}'
p438
(dp439
((g434
g435
tp440
I1
tp441
(dp442
g12
g13
sg14
(dp443
(I6
I6
tp444
(lp445
S'\tif (!ctx || !ctx->state_machine) {'
p446
assg32
I2
sg33
(dp447
(I6
I6
tp448
(lp449
S'\tif (!ctx->state_machine) {'
p450
assg41
(I1
I28
tp451
ssss(g434
S'cam_context_handle_stop_dev'
p452
tp453
(dp454
S'int cam_context_handle_stop_dev(struct cam_context *ctx,\n\tstruct cam_start_stop_dev_cmd *cmd)\n{\n\tint rc = 0;\n\n\tif (!ctx || !ctx->state_machine) {\n\t\tCAM_ERR(CAM_CORE, "Context is not ready");\n\t\treturn -EINVAL;\n\t}\n\n\tif (!cmd) {\n\t\tCAM_ERR(CAM_CORE, "Invalid stop device command payload");\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ctx->ctx_mutex);\n\tif (ctx->state_machine[ctx->state].ioctl_ops.stop_dev)\n\t\trc = ctx->state_machine[ctx->state].ioctl_ops.stop_dev(\n\t\t\tctx, cmd);\n\telse\n\t\t/* stop device can be optional for some driver */\n\t\tCAM_WARN(CAM_CORE, "No stop device in dev %d, name %s state %d",\n\t\t\tctx->dev_hdl, ctx->dev_name, ctx->state);\n\tmutex_unlock(&ctx->ctx_mutex);\n\n\treturn rc;\n}'
p455
(dp456
((g434
g452
tp457
I1
tp458
(dp459
g12
g13
sg14
(dp460
(I6
I6
tp461
(lp462
S'\tif (!ctx || !ctx->state_machine) {'
p463
assg32
I2
sg33
(dp464
(I6
I6
tp465
(lp466
S'\tif (!ctx->state_machine) {'
p467
assg41
(I1
I27
tp468
sssssS'CVE-2019-2182'
p469
(dp470
(S'arch/arm64/mm/mmu.c'
p471
S'pmd_set_huge'
p472
tp473
(dp474
S"int pmd_set_huge(pmd_t *pmd, phys_addr_t phys, pgprot_t prot)\n{\n\t/* ioremap_page_range doesn't honour BBM */\n\tif (pmd_present(READ_ONCE(*pmd)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmd, __pmd(phys | PMD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));\n\treturn 1;\n}"
p475
(dp476
((g471
g472
tp477
I1
tp478
(dp479
g14
(dp480
(I3
I6
tp481
(lp482
S"\t/* ioremap_page_range doesn't honour BBM */"
p483
aS'\tif (pmd_present(READ_ONCE(*pmd)))'
p484
aS'\t\treturn 0;'
p485
ag59
assg32
I3
sg12
g13
sg41
(I1
I10
tp486
sssS'int pmd_set_huge(pmd_t *pmd, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmd)),\n\t\t\t\t   pmd_val(new_pmd)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmd, new_pmd);\n\treturn 1;\n}'
p487
(dp488
((g471
g472
tp489
I1
tp490
(dp491
g33
(dp492
(I13
I13
tp493
(lp494
S'\tset_pmd(pmd, __pmd(phys | PMD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));'
p495
assg14
(dp496
(I3
I11
tp497
(lp498
S'\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |'
p499
aS'\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));'
p500
aS'\tpmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);'
p501
ag59
aS'\t/* Only allow permission changes for now */'
p502
aS'\tif (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmd)),'
p503
aS'\t\t\t\t   pmd_val(new_pmd)))'
p504
aS'\t\treturn 0;'
p505
ag59
as(I13
I13
tp506
(lp507
S'\tset_pmd(pmd, new_pmd);'
p508
assg32
I3
sg12
g13
sg41
(I1
I15
tp509
sssS'int pmd_set_huge(pmd_t *pmdp, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmdp)),\n\t\t\t\t   pmd_val(new_pmd)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmdp, new_pmd);\n\treturn 1;\n}'
p510
(dp511
((g471
g472
tp512
I1
tp513
(dp514
g12
g13
sg14
(dp515
(I13
I13
tp516
(lp517
S'\tset_pmd(pmdp, new_pmd);'
p518
as(I1
I1
tp519
(lp520
S'int pmd_set_huge(pmd_t *pmdp, phys_addr_t phys, pgprot_t prot)'
p521
as(I3
I11
tp522
(lp523
S'\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |'
p524
aS'\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));'
p525
aS'\tpmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);'
p526
ag59
aS'\t/* Only allow permission changes for now */'
p527
aS'\tif (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmdp)),'
p528
aS'\t\t\t\t   pmd_val(new_pmd)))'
p529
aS'\t\treturn 0;'
p530
ag59
assg32
I3
sg33
(dp531
(I1
I1
tp532
(lp533
S'int pmd_set_huge(pmd_t *pmd, phys_addr_t phys, pgprot_t prot)'
p534
as(I13
I13
tp535
(lp536
S'\tset_pmd(pmd, __pmd(phys | PMD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));'
p537
assg41
(I1
I15
tp538
ssss(g471
S'pud_set_huge'
p539
tp540
(dp541
S"int pud_set_huge(pud_t *pud, phys_addr_t phys, pgprot_t prot)\n{\n\t/* ioremap_page_range doesn't honour BBM */\n\tif (pud_present(READ_ONCE(*pud)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PUD_MASK);\n\tset_pud(pud, __pud(phys | PUD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));\n\treturn 1;\n}"
p542
(dp543
((g471
g539
tp544
I1
tp545
(dp546
g14
(dp547
(I3
I6
tp548
(lp549
S"\t/* ioremap_page_range doesn't honour BBM */"
p550
aS'\tif (pud_present(READ_ONCE(*pud)))'
p551
aS'\t\treturn 0;'
p552
ag59
assg32
I3
sg12
g13
sg41
(I1
I10
tp553
sssS'int pud_set_huge(pud_t *pud, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PUD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpud_t new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pud_val(*pud)),\n\t\t\t\t   pud_val(new_pud)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PUD_MASK);\n\tset_pud(pud, new_pud);\n\treturn 1;\n}'
p554
(dp555
((g471
g539
tp556
I1
tp557
(dp558
g33
(dp559
(I13
I13
tp560
(lp561
S'\tset_pud(pud, __pud(phys | PUD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));'
p562
assg14
(dp563
(I3
I11
tp564
(lp565
S'\tpgprot_t sect_prot = __pgprot(PUD_TYPE_SECT |'
p566
aS'\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));'
p567
aS'\tpud_t new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);'
p568
ag59
aS'\t/* Only allow permission changes for now */'
p569
aS'\tif (!pgattr_change_is_safe(READ_ONCE(pud_val(*pud)),'
p570
aS'\t\t\t\t   pud_val(new_pud)))'
p571
aS'\t\treturn 0;'
p572
ag59
as(I13
I13
tp573
(lp574
S'\tset_pud(pud, new_pud);'
p575
assg32
I3
sg12
g13
sg41
(I1
I15
tp576
sssS'int pud_set_huge(pud_t *pudp, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PUD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpud_t new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pud_val(*pudp)),\n\t\t\t\t   pud_val(new_pud)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PUD_MASK);\n\tset_pud(pudp, new_pud);\n\treturn 1;\n}'
p577
(dp578
((g471
g539
tp579
I1
tp580
(dp581
g12
g13
sg14
(dp582
(I13
I13
tp583
(lp584
S'\tset_pud(pudp, new_pud);'
p585
as(I1
I1
tp586
(lp587
S'int pud_set_huge(pud_t *pudp, phys_addr_t phys, pgprot_t prot)'
p588
as(I3
I11
tp589
(lp590
S'\tpgprot_t sect_prot = __pgprot(PUD_TYPE_SECT |'
p591
aS'\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));'
p592
aS'\tpud_t new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);'
p593
ag59
aS'\t/* Only allow permission changes for now */'
p594
aS'\tif (!pgattr_change_is_safe(READ_ONCE(pud_val(*pudp)),'
p595
aS'\t\t\t\t   pud_val(new_pud)))'
p596
aS'\t\treturn 0;'
p597
ag59
assg32
I3
sg33
(dp598
(I1
I1
tp599
(lp600
S'int pud_set_huge(pud_t *pud, phys_addr_t phys, pgprot_t prot)'
p601
as(I13
I13
tp602
(lp603
S'\tset_pud(pud, __pud(phys | PUD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));'
p604
assg41
(I1
I15
tp605
sssssS'CVE-2019-2263'
p606
(dp607
(S'drivers/char/diag/diagchar_core.c'
p608
S'check_data_ready'
p609
tp610
(dp611
s(g608
S'diagchar_read'
p612
tp613
(dp614
S'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q, (check_data_ready(index)) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p615
(dp616
((g608
g612
tp617
I1
tp618
(dp619
g33
(dp620
(I216
I217
tp621
(lp622
S'\t\tmutex_lock(&driver->dci_mutex);'
p623
aS'\t\t/* Copy the type of data being passed */'
p624
as(I27
I27
tp625
(lp626
S'\twait_event_interruptible(driver->wait_q, driver->data_ready[index]);'
p627
as(I215
I215
tp628
(lp629
S'\tmutex_unlock(&driver->diagchar_mutex);'
p630
assg14
(dp631
(I251
I251
tp632
(lp633
S'\tmutex_unlock(&driver->diagchar_mutex);'
p634
as(I27
I27
tp635
(lp636
S'\twait_event_interruptible(driver->wait_q, (check_data_ready(index)) > 0);'
p637
as(I217
I219
tp638
(lp639
S'\t\tmutex_unlock(&driver->diagchar_mutex);'
p640
aS'\t\t/* Copy the type of data being passed */'
p641
aS'\t\tmutex_lock(&driver->dci_mutex);'
p642
as(I13
I13
tp643
(lp644
S'\tmutex_lock(&driver->diagchar_mutex);'
p645
as(I17
I17
tp646
(lp647
S'\tmutex_unlock(&driver->diagchar_mutex);'
p648
assg32
I4
sg12
g13
sg41
(I1
I263
tp649
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p650
(dp651
((g608
g612
tp652
I1
tp653
(dp654
g33
(dp655
(I232
I233
tp656
(lp657
S'\t\tmutex_lock(&driver->dci_mutex);'
p658
aS'\t\t/* Copy the type of data being passed */'
p659
as(I27
I27
tp660
(lp661
S'\twait_event_interruptible(driver->wait_q, driver->data_ready[index]);'
p662
as(I231
I231
tp663
(lp664
S'\tmutex_unlock(&driver->diagchar_mutex);'
p665
assg14
(dp666
(I13
I13
tp667
(lp668
S'\tmutex_lock(&driver->diagchar_mutex);'
p669
as(I268
I268
tp670
(lp671
S'\tmutex_unlock(&driver->diagchar_mutex);'
p672
as(I226
I226
tp673
(lp674
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p675
as(I67
I67
tp676
(lp677
S'\t\tmutex_lock(&driver->md_session_lock);'
p678
as(I69
I69
tp679
(lp680
S'\t\tmutex_unlock(&driver->md_session_lock);'
p681
as(I166
I166
tp682
(lp683
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p684
as(I184
I184
tp685
(lp686
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p687
as(I132
I132
tp688
(lp689
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p690
as(I39
I39
tp691
(lp692
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p693
as(I47
I47
tp694
(lp695
S'\t\tmutex_unlock(&driver->md_session_lock);'
p696
as(I258
I258
tp697
(lp698
S'\t\t\tatomic_dec(&driver->data_ready_notif[index]);'
p699
as(I56
I56
tp700
(lp701
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p702
as(I149
I149
tp703
(lp704
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p705
as(I233
I235
tp706
(lp707
S'\t\tmutex_unlock(&driver->diagchar_mutex);'
p708
aS'\t\t/* Copy the type of data being passed */'
p709
aS'\t\tmutex_lock(&driver->dci_mutex);'
p710
as(I62
I62
tp711
(lp712
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p713
as(I206
I206
tp714
(lp715
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p716
as(I87
I87
tp717
(lp718
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p719
as(I27
I28
tp720
(lp721
S'\twait_event_interruptible(driver->wait_q,'
p722
aS'\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);'
p723
as(I17
I17
tp724
(lp725
S'\tmutex_unlock(&driver->diagchar_mutex);'
p726
as(I105
I105
tp727
(lp728
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p729
as(I45
I45
tp730
(lp731
S'\t\tmutex_lock(&driver->md_session_lock);'
p732
assg32
I4
sg12
g13
sg41
(I1
I280
tp733
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client)\n\t\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p734
(dp735
((g608
g612
tp736
I1
tp737
(dp738
g33
(dp739
(I132
I132
tp740
(lp741
S'\t\t\tif (ret == -EFAULT)'
p742
as(I157
I157
tp743
(lp744
S'\t\tif (ret == -EFAULT)'
p745
as(I29
I29
tp746
(lp747
S'\twait_event_interruptible(driver->wait_q, driver->data_ready[index]);'
p748
as(I250
I250
tp749
(lp750
S'\tmutex_unlock(&driver->diagchar_mutex);'
p751
as(I140
I140
tp752
(lp753
S'\t\t\tif (ret == -EFAULT)'
p754
as(I123
I123
tp755
(lp756
S'\t\tif (ret == -EFAULT)'
p757
as(I103
I103
tp758
(lp759
S'\t\tif (ret == -EFAULT)'
p760
as(I258
I258
tp761
(lp762
S'\t\t\tif (entry->client->tgid != current->tgid)'
p763
as(I126
I126
tp764
(lp765
g59
as(I251
I252
tp766
(lp767
S'\t\tmutex_lock(&driver->dci_mutex);'
p768
aS'\t\t/* Copy the type of data being passed */'
p769
as(I75
I75
tp770
(lp771
S'\t\t\tif (ret == -EFAULT)'
p772
assg14
(dp773
(I157
I158
tp774
(lp775
S'\t\tif (ret == -EFAULT) {'
p776
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p777
as(I245
I245
tp778
(lp779
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p780
as(I154
I154
tp781
(lp782
S'\t\tmutex_lock(&driver->md_session_lock);'
p783
as(I64
I64
tp784
(lp785
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p786
as(I109
I109
tp787
(lp788
S'\t\tmutex_unlock(&driver->md_session_lock);'
p789
as(I58
I58
tp790
(lp791
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p792
as(I29
I30
tp793
(lp794
S'\twait_event_interruptible(driver->wait_q,'
p795
aS'\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);'
p796
as(I126
I126
tp797
(lp798
S'\t\t}'
p799
as(I203
I203
tp800
(lp801
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p802
as(I135
I135
tp803
(lp804
S'\t\t\t}'
p805
as(I168
I168
tp806
(lp807
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p808
as(I185
I185
tp809
(lp810
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p811
as(I120
I120
tp812
(lp813
S'\t\tmutex_lock(&driver->md_session_lock);'
p814
as(I288
I288
tp815
(lp816
S'\t\t\tatomic_dec(&driver->data_ready_notif[index]);'
p817
as(I267
I270
tp818
(lp819
S'\t\t\t}'
p820
aS'\t\t\tif (task_s == entry->client)'
p821
aS'\t\t\t\tif (entry->client->tgid != current->tgid)'
p822
aS'\t\t\t\t\tcontinue;'
p823
as(I258
I265
tp824
(lp825
S'\t\t\tpid_struct = find_get_pid(entry->tgid);'
p826
aS'\t\t\tif (!pid_struct)'
p827
aS'\t\t\t\tcontinue;'
p828
aS'\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p829
aS'\t\t\tif (!task_s) {'
p830
aS'\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p831
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p832
aS'\t\t\t\tentry->tgid);'
p833
as(I160
I160
tp834
(lp835
S'\t\t}'
p836
as(I145
I145
tp837
(lp838
S'\t\tmutex_unlock(&driver->md_session_lock);'
p839
as(I75
I76
tp840
(lp841
S'\t\t\tif (ret == -EFAULT) {'
p842
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p843
as(I19
I19
tp844
(lp845
S'\tmutex_unlock(&driver->diagchar_mutex);'
p846
as(I143
I143
tp847
(lp848
S'\t\t\t}'
p849
as(I147
I147
tp850
(lp851
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p852
as(I91
I91
tp853
(lp854
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p855
as(I69
I69
tp856
(lp857
S'\t\tmutex_lock(&driver->md_session_lock);'
p858
as(I106
I106
tp859
(lp860
S'\t\t}'
p861
as(I12
I13
tp862
(lp863
S'\tstruct pid *pid_struct = NULL;'
p864
aS'\tstruct task_struct *task_s = NULL;'
p865
as(I123
I124
tp866
(lp867
S'\t\tif (ret == -EFAULT) {'
p868
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p869
as(I252
I254
tp870
(lp871
S'\t\tmutex_unlock(&driver->diagchar_mutex);'
p872
aS'\t\t/* Copy the type of data being passed */'
p873
aS'\t\tmutex_lock(&driver->dci_mutex);'
p874
as(I100
I100
tp875
(lp876
S'\t\tmutex_lock(&driver->md_session_lock);'
p877
as(I80
I80
tp878
(lp879
S'\t\tmutex_unlock(&driver->md_session_lock);'
p880
as(I41
I41
tp881
(lp882
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p883
as(I113
I113
tp884
(lp885
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p886
as(I132
I133
tp887
(lp888
S'\t\t\tif (ret == -EFAULT) {'
p889
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p890
as(I164
I164
tp891
(lp892
S'\t\tmutex_unlock(&driver->md_session_lock);'
p893
as(I140
I141
tp894
(lp895
S'\t\t\tif (ret == -EFAULT) {'
p896
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p897
as(I298
I298
tp898
(lp899
S'\tmutex_unlock(&driver->diagchar_mutex);'
p900
as(I78
I78
tp901
(lp902
S'\t\t\t}'
p903
as(I51
I51
tp904
(lp905
S'\t\tmutex_unlock(&driver->md_session_lock);'
p906
as(I103
I104
tp907
(lp908
S'\t\tif (ret == -EFAULT) {'
p909
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p910
as(I15
I15
tp911
(lp912
S'\tmutex_lock(&driver->diagchar_mutex);'
p913
as(I225
I225
tp914
(lp915
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p916
as(I47
I47
tp917
(lp918
S'\t\tmutex_lock(&driver->md_session_lock);'
p919
assg32
I4
sg12
g13
sg41
(I1
I310
tp920
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client) {\n\t\t\t\tif (entry->client->tgid != current->tgid) {\n\t\t\t\t\tput_task_struct(task_s);\n\t\t\t\t\tput_pid(pid_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!entry->in_service) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tput_task_struct(task_s);\n\t\t\tput_pid(pid_struct);\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p921
(dp922
((g608
g612
tp923
I1
tp924
(dp925
g33
(dp926
(I132
I132
tp927
(lp928
S'\t\t\tif (ret == -EFAULT)'
p929
as(I157
I157
tp930
(lp931
S'\t\tif (ret == -EFAULT)'
p932
as(I29
I29
tp933
(lp934
S'\twait_event_interruptible(driver->wait_q, driver->data_ready[index]);'
p935
as(I250
I250
tp936
(lp937
S'\tmutex_unlock(&driver->diagchar_mutex);'
p938
as(I140
I140
tp939
(lp940
S'\t\t\tif (ret == -EFAULT)'
p941
as(I123
I123
tp942
(lp943
S'\t\tif (ret == -EFAULT)'
p944
as(I103
I103
tp945
(lp946
S'\t\tif (ret == -EFAULT)'
p947
as(I258
I258
tp948
(lp949
S'\t\t\tif (entry->client->tgid != current->tgid)'
p950
as(I126
I126
tp951
(lp952
g59
as(I251
I252
tp953
(lp954
S'\t\tmutex_lock(&driver->dci_mutex);'
p955
aS'\t\t/* Copy the type of data being passed */'
p956
as(I261
I261
tp957
(lp958
S'\t\t\tif (!entry->in_service)'
p959
as(I75
I75
tp960
(lp961
S'\t\t\tif (ret == -EFAULT)'
p962
assg14
(dp963
(I160
I160
tp964
(lp965
S'\t\t}'
p966
as(I245
I245
tp967
(lp968
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p969
as(I58
I58
tp970
(lp971
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p972
as(I51
I51
tp973
(lp974
S'\t\tmutex_unlock(&driver->md_session_lock);'
p975
as(I300
I300
tp976
(lp977
S'\t\t\tatomic_dec(&driver->data_ready_notif[index]);'
p978
as(I203
I203
tp979
(lp980
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p981
as(I135
I135
tp982
(lp983
S'\t\t\t}'
p984
as(I120
I120
tp985
(lp986
S'\t\tmutex_lock(&driver->md_session_lock);'
p987
as(I290
I291
tp988
(lp989
S'\t\t\t\tput_task_struct(task_s);'
p990
aS'\t\t\t\tput_pid(pid_struct);'
p991
as(I164
I164
tp992
(lp993
S'\t\tmutex_unlock(&driver->md_session_lock);'
p994
as(I109
I109
tp995
(lp996
S'\t\tmutex_unlock(&driver->md_session_lock);'
p997
as(I132
I133
tp998
(lp999
S'\t\t\tif (ret == -EFAULT) {'
p1000
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p1001
as(I147
I147
tp1002
(lp1003
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1004
as(I69
I69
tp1005
(lp1006
S'\t\tmutex_lock(&driver->md_session_lock);'
p1007
as(I308
I309
tp1008
(lp1009
S'\t\t\tput_task_struct(task_s);'
p1010
aS'\t\t\tput_pid(pid_struct);'
p1011
as(I12
I13
tp1012
(lp1013
S'\tstruct pid *pid_struct = NULL;'
p1014
aS'\tstruct task_struct *task_s = NULL;'
p1015
as(I314
I314
tp1016
(lp1017
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1018
as(I268
I280
tp1019
(lp1020
S'\t\t\t}'
p1021
aS'\t\t\tif (task_s == entry->client) {'
p1022
aS'\t\t\t\tif (entry->client->tgid != current->tgid) {'
p1023
aS'\t\t\t\t\tput_task_struct(task_s);'
p1024
aS'\t\t\t\t\tput_pid(pid_struct);'
p1025
aS'\t\t\t\t\tcontinue;'
p1026
aS'\t\t\t\t}'
p1027
aS'\t\t\t}'
p1028
aS'\t\t\tif (!entry->in_service) {'
p1029
aS'\t\t\t\tput_task_struct(task_s);'
p1030
aS'\t\t\t\tput_pid(pid_struct);'
p1031
aS'\t\t\t\tcontinue;'
p1032
aS'\t\t\t}'
p1033
as(I29
I30
tp1034
(lp1035
S'\twait_event_interruptible(driver->wait_q,'
p1036
aS'\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);'
p1037
as(I303
I304
tp1038
(lp1039
S'\t\t\t\tput_task_struct(task_s);'
p1040
aS'\t\t\t\tput_pid(pid_struct);'
p1041
as(I126
I126
tp1042
(lp1043
S'\t\t}'
p1044
as(I15
I15
tp1045
(lp1046
S'\tmutex_lock(&driver->diagchar_mutex);'
p1047
as(I19
I19
tp1048
(lp1049
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1050
as(I143
I143
tp1051
(lp1052
S'\t\t\t}'
p1053
as(I225
I225
tp1054
(lp1055
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1056
as(I47
I47
tp1057
(lp1058
S'\t\tmutex_lock(&driver->md_session_lock);'
p1059
as(I64
I64
tp1060
(lp1061
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1062
as(I154
I154
tp1063
(lp1064
S'\t\tmutex_lock(&driver->md_session_lock);'
p1065
as(I157
I158
tp1066
(lp1067
S'\t\tif (ret == -EFAULT) {'
p1068
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p1069
as(I78
I78
tp1070
(lp1071
S'\t\t\t}'
p1072
as(I185
I185
tp1073
(lp1074
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1075
as(I258
I259
tp1076
(lp1077
S'\t\t\tpid_struct = find_get_pid(entry->tgid);'
p1078
aS'\t\t\tif (!pid_struct)'
p1079
as(I282
I283
tp1080
(lp1081
S'\t\t\t\tput_task_struct(task_s);'
p1082
aS'\t\t\t\tput_pid(pid_struct);'
p1083
as(I75
I76
tp1084
(lp1085
S'\t\t\tif (ret == -EFAULT) {'
p1086
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p1087
as(I252
I254
tp1088
(lp1089
S'\t\tmutex_unlock(&driver->diagchar_mutex);'
p1090
aS'\t\t/* Copy the type of data being passed */'
p1091
aS'\t\tmutex_lock(&driver->dci_mutex);'
p1092
as(I261
I266
tp1093
(lp1094
S'\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p1095
aS'\t\t\tif (!task_s) {'
p1096
aS'\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p1097
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p1098
aS'\t\t\t\tentry->tgid);'
p1099
aS'\t\t\t\tput_pid(pid_struct);'
p1100
as(I91
I91
tp1101
(lp1102
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1103
as(I106
I106
tp1104
(lp1105
S'\t\t}'
p1106
as(I103
I104
tp1107
(lp1108
S'\t\tif (ret == -EFAULT) {'
p1109
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p1110
as(I100
I100
tp1111
(lp1112
S'\t\tmutex_lock(&driver->md_session_lock);'
p1113
as(I80
I80
tp1114
(lp1115
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1116
as(I41
I41
tp1117
(lp1118
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1119
as(I113
I113
tp1120
(lp1121
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1122
as(I140
I141
tp1123
(lp1124
S'\t\t\tif (ret == -EFAULT) {'
p1125
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p1126
as(I168
I168
tp1127
(lp1128
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1129
as(I123
I124
tp1130
(lp1131
S'\t\tif (ret == -EFAULT) {'
p1132
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p1133
as(I145
I145
tp1134
(lp1135
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1136
assg32
I4
sg12
g13
sg41
(I1
I326
tp1137
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q, (check_data_ready(index)) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p1138
(dp1139
((g608
g612
tp1140
I1
tp1141
(dp1142
g33
(dp1143
(I220
I221
tp1144
(lp1145
S'\t\tmutex_lock(&driver->dci_mutex);'
p1146
aS'\t\t/* Copy the type of data being passed */'
p1147
as(I27
I27
tp1148
(lp1149
S'\twait_event_interruptible(driver->wait_q, driver->data_ready[index]);'
p1150
as(I219
I219
tp1151
(lp1152
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1153
assg14
(dp1154
(I13
I13
tp1155
(lp1156
S'\tmutex_lock(&driver->diagchar_mutex);'
p1157
as(I63
I63
tp1158
(lp1159
S'\t\tmutex_lock(&driver->md_session_lock);'
p1160
as(I43
I43
tp1161
(lp1162
S'\t\tmutex_lock(&driver->md_session_lock);'
p1163
as(I255
I255
tp1164
(lp1165
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1166
as(I221
I223
tp1167
(lp1168
S'\t\tmutex_unlock(&driver->diagchar_mutex);'
p1169
aS'\t\t/* Copy the type of data being passed */'
p1170
aS'\t\tmutex_lock(&driver->dci_mutex);'
p1171
as(I65
I65
tp1172
(lp1173
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1174
as(I45
I45
tp1175
(lp1176
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1177
as(I17
I17
tp1178
(lp1179
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1180
as(I27
I27
tp1181
(lp1182
S'\twait_event_interruptible(driver->wait_q, (check_data_ready(index)) > 0);'
p1183
assg32
I4
sg12
g13
sg41
(I1
I267
tp1184
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p1185
(dp1186
((g608
g612
tp1187
I1
tp1188
(dp1189
g33
(dp1190
(I130
I130
tp1191
(lp1192
S'\t\t\tif (ret == -EFAULT)'
p1193
as(I249
I250
tp1194
(lp1195
S'\t\tmutex_lock(&driver->dci_mutex);'
p1196
aS'\t\t/* Copy the type of data being passed */'
p1197
as(I248
I248
tp1198
(lp1199
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1200
as(I138
I138
tp1201
(lp1202
S'\t\t\tif (ret == -EFAULT)'
p1203
as(I101
I101
tp1204
(lp1205
S'\t\tif (ret == -EFAULT)'
p1206
as(I73
I73
tp1207
(lp1208
S'\t\t\tif (ret == -EFAULT)'
p1209
as(I155
I155
tp1210
(lp1211
S'\t\tif (ret == -EFAULT)'
p1212
as(I124
I124
tp1213
(lp1214
g59
as(I121
I121
tp1215
(lp1216
S'\t\tif (ret == -EFAULT)'
p1217
as(I27
I27
tp1218
(lp1219
S'\twait_event_interruptible(driver->wait_q, driver->data_ready[index]);'
p1220
assg14
(dp1221
(I162
I162
tp1222
(lp1223
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1224
as(I138
I139
tp1225
(lp1226
S'\t\t\tif (ret == -EFAULT) {'
p1227
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p1228
as(I13
I13
tp1229
(lp1230
S'\tmutex_lock(&driver->diagchar_mutex);'
p1231
as(I166
I166
tp1232
(lp1233
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1234
as(I101
I102
tp1235
(lp1236
S'\t\tif (ret == -EFAULT) {'
p1237
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p1238
as(I223
I223
tp1239
(lp1240
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1241
as(I243
I243
tp1242
(lp1243
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1244
as(I76
I76
tp1245
(lp1246
S'\t\t\t}'
p1247
as(I275
I275
tp1248
(lp1249
S'\t\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1250
as(I39
I39
tp1251
(lp1252
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1253
as(I89
I89
tp1254
(lp1255
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1256
as(I73
I74
tp1257
(lp1258
S'\t\t\tif (ret == -EFAULT) {'
p1259
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p1260
as(I78
I78
tp1261
(lp1262
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1263
as(I56
I56
tp1264
(lp1265
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1266
as(I130
I131
tp1267
(lp1268
S'\t\t\tif (ret == -EFAULT) {'
p1269
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p1270
as(I201
I201
tp1271
(lp1272
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1273
as(I152
I152
tp1274
(lp1275
S'\t\tmutex_lock(&driver->md_session_lock);'
p1276
as(I145
I145
tp1277
(lp1278
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1279
as(I133
I133
tp1280
(lp1281
S'\t\t\t}'
p1282
as(I107
I107
tp1283
(lp1284
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1285
as(I141
I141
tp1286
(lp1287
S'\t\t\t}'
p1288
as(I143
I143
tp1289
(lp1290
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1291
as(I67
I67
tp1292
(lp1293
S'\t\tmutex_lock(&driver->md_session_lock);'
p1294
as(I118
I118
tp1295
(lp1296
S'\t\tmutex_lock(&driver->md_session_lock);'
p1297
as(I155
I156
tp1298
(lp1299
S'\t\tif (ret == -EFAULT) {'
p1300
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p1301
as(I124
I124
tp1302
(lp1303
S'\t\t}'
p1304
as(I45
I45
tp1305
(lp1306
S'\t\tmutex_lock(&driver->md_session_lock);'
p1307
as(I183
I183
tp1308
(lp1309
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1310
as(I17
I17
tp1311
(lp1312
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1313
as(I49
I49
tp1314
(lp1315
S'\t\tmutex_unlock(&driver->md_session_lock);'
p1316
as(I121
I122
tp1317
(lp1318
S'\t\tif (ret == -EFAULT) {'
p1319
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p1320
as(I62
I62
tp1321
(lp1322
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1323
as(I104
I104
tp1324
(lp1325
S'\t\t}'
p1326
as(I285
I285
tp1327
(lp1328
S'\tmutex_unlock(&driver->diagchar_mutex);'
p1329
as(I98
I98
tp1330
(lp1331
S'\t\tmutex_lock(&driver->md_session_lock);'
p1332
as(I158
I158
tp1333
(lp1334
S'\t\t}'
p1335
as(I27
I28
tp1336
(lp1337
S'\twait_event_interruptible(driver->wait_q,'
p1338
aS'\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);'
p1339
as(I111
I111
tp1340
(lp1341
S'\t\tatomic_dec(&driver->data_ready_notif[index]);'
p1342
as(I250
I252
tp1343
(lp1344
S'\t\tmutex_unlock(&driver->diagchar_mutex);'
p1345
aS'\t\t/* Copy the type of data being passed */'
p1346
aS'\t\tmutex_lock(&driver->dci_mutex);'
p1347
assg32
I4
sg12
g13
sg41
(I1
I297
tp1348
sssssS'CVE-2019-10620'
p1349
(dp1350
(S'drivers/gpu/drm/msm/sde_dbg.c'
p1351
S'sde_evtlog_dump_read'
p1352
tp1353
(dp1354
S'static ssize_t sde_evtlog_dump_read(struct file *file, char __user *buff,\n\t\tsize_t count, loff_t *ppos)\n{\n\tssize_t len = 0;\n\tchar evtlog_buf[SDE_EVTLOG_BUF_MAX];\n\n\tif (!buff || !ppos)\n\t\treturn -EINVAL;\n\n\tlen = sde_evtlog_dump_to_buffer(sde_dbg_base.evtlog, evtlog_buf,\n\t\t\tSDE_EVTLOG_BUF_MAX, true);\n\tif (len < 0 || len > count) {\n\t\tpr_err("len is more than user buffer size");\n\t\treturn 0;\n\t}\n\n\tif (copy_to_user(buff, evtlog_buf, len))\n\t\treturn -EFAULT;\n\t*ppos += len;\n\n\treturn len;\n}'
p1355
(dp1356
((g1351
g1352
tp1357
I1
tp1358
(dp1359
g14
(dp1360
(I12
I16
tp1361
(lp1362
S'\tif (len < 0 || len > count) {'
p1363
aS'\t\tpr_err("len is more than user buffer size");'
p1364
aS'\t\treturn 0;'
p1365
aS'\t}'
p1366
ag59
assg32
I4
sg12
g13
sg41
(I1
I22
tp1367
sssssS'CVE-2019-14072'
p1368
(dp1369
(S'drivers/gpu/msm/kgsl.c'
p1370
S'kgsl_ioctl_sparse_phys_alloc'
p1371
tp1372
(dp1373
S"long kgsl_ioctl_sparse_phys_alloc(struct kgsl_device_private *dev_priv,\n\tunsigned int cmd, void *data)\n{\n\tstruct kgsl_process_private *process = dev_priv->process_priv;\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct kgsl_sparse_phys_alloc *param = data;\n\tstruct kgsl_mem_entry *entry;\n\tuint64_t flags;\n\tint ret;\n\tint id;\n\n\tif (!(device->flags & KGSL_FLAG_SPARSE))\n\t\treturn -ENOTSUPP;\n\n\tret = _sparse_alloc_param_sanity_check(param->size, param->pagesize);\n\tif (ret)\n\t\treturn ret;\n\n\tentry = kgsl_mem_entry_create();\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tret = kgsl_process_private_get(process);\n\tif (!ret) {\n\t\tret = -EBADF;\n\t\tgoto err_free_entry;\n\t}\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock(&process->mem_lock);\n\t/* Allocate the ID but don't attach the pointer just yet */\n\tid = idr_alloc(&process->mem_idr, NULL, 1, 0, GFP_NOWAIT);\n\tspin_unlock(&process->mem_lock);\n\tidr_preload_end();\n\n\tif (id < 0) {\n\t\tret = id;\n\t\tgoto err_put_proc_priv;\n\t}\n\n\tentry->id = id;\n\tentry->priv = process;\n\n\tflags = KGSL_MEMFLAGS_SPARSE_PHYS |\n\t\t((ilog2(param->pagesize) << KGSL_MEMALIGN_SHIFT) &\n\t\t\tKGSL_MEMALIGN_MASK);\n\n\tret = kgsl_allocate_user(dev_priv->device, &entry->memdesc,\n\t\t\tparam->size, flags);\n\tif (ret)\n\t\tgoto err_remove_idr;\n\n\t/* Sanity check to verify we got correct pagesize */\n\tif (param->pagesize != PAGE_SIZE && entry->memdesc.sgt != NULL) {\n\t\tstruct scatterlist *s;\n\t\tint i;\n\n\t\tfor_each_sg(entry->memdesc.sgt->sgl, s,\n\t\t\t\tentry->memdesc.sgt->nents, i) {\n\t\t\tif (!IS_ALIGNED(s->length, param->pagesize))\n\t\t\t\tgoto err_invalid_pages;\n\t\t}\n\t}\n\n\tparam->id = entry->id;\n\tparam->flags = entry->memdesc.flags;\n\n\ttrace_sparse_phys_alloc(entry->id, param->size, param->pagesize);\n\tkgsl_mem_entry_commit_process(entry);\n\n\t/* Put the extra ref from kgsl_mem_entry_create() */\n\tkgsl_mem_entry_put(entry);\n\n\treturn 0;\n\nerr_invalid_pages:\n\tkgsl_sharedmem_free(&entry->memdesc);\nerr_remove_idr:\n\tspin_lock(&process->mem_lock);\n\tidr_remove(&process->mem_idr, entry->id);\n\tspin_unlock(&process->mem_lock);\nerr_put_proc_priv:\n\tkgsl_process_private_put(process);\nerr_free_entry:\n\tkfree(entry);\n\n\treturn ret;\n}"
p1374
(dp1375
((g1370
g1371
tp1376
I1
tp1377
(dp1378
g14
(dp1379
(I5
I5
tp1380
(lp1381
S'\tstruct kgsl_device *device = dev_priv->device;'
p1382
as(I12
I14
tp1383
(lp1384
S'\tif (!(device->flags & KGSL_FLAG_SPARSE))'
p1385
aS'\t\treturn -ENOTSUPP;'
p1386
ag59
assg32
I3
sg12
g13
sg41
(I1
I88
tp1387
ssss(g1370
S'kgsl_ioctl_sparse_phys_free'
p1388
tp1389
(dp1390
S'long kgsl_ioctl_sparse_phys_free(struct kgsl_device_private *dev_priv,\n\tunsigned int cmd, void *data)\n{\n\tstruct kgsl_process_private *process = dev_priv->process_priv;\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct kgsl_sparse_phys_free *param = data;\n\tstruct kgsl_mem_entry *entry;\n\n\tif (!(device->flags & KGSL_FLAG_SPARSE))\n\t\treturn -ENOTSUPP;\n\n\tentry = kgsl_sharedmem_find_id_flags(process, param->id,\n\t\t\tKGSL_MEMFLAGS_SPARSE_PHYS);\n\tif (entry == NULL)\n\t\treturn -EINVAL;\n\n\tif (!kgsl_mem_entry_set_pend(entry)) {\n\t\tkgsl_mem_entry_put(entry);\n\t\treturn -EBUSY;\n\t}\n\n\tif (entry->memdesc.cur_bindings != 0) {\n\t\tkgsl_mem_entry_unset_pend(entry);\n\t\tkgsl_mem_entry_put(entry);\n\t\treturn -EINVAL;\n\t}\n\n\ttrace_sparse_phys_free(entry->id);\n\n\t/* One put for find_id(), one put for the kgsl_mem_entry_create() */\n\tkgsl_mem_entry_put(entry);\n\tkgsl_mem_entry_put(entry);\n\n\treturn 0;\n}'
p1391
(dp1392
((g1370
g1388
tp1393
I1
tp1394
(dp1395
g14
(dp1396
(I9
I11
tp1397
(lp1398
S'\tif (!(device->flags & KGSL_FLAG_SPARSE))'
p1399
aS'\t\treturn -ENOTSUPP;'
p1400
ag59
as(I5
I5
tp1401
(lp1402
S'\tstruct kgsl_device *device = dev_priv->device;'
p1403
assg32
I3
sg12
g13
sg41
(I1
I35
tp1404
ssss(g1370
S'kgsl_device_platform_probe'
p1405
tp1406
(dp1407
S'int kgsl_device_platform_probe(struct kgsl_device *device)\n{\n\tint status = -EINVAL;\n\tstruct resource *res;\n\tint cpu;\n\n\tstatus = _register_device(device);\n\tif (status)\n\t\treturn status;\n\n\t/* Initialize logging first, so that failures below actually print. */\n\tkgsl_device_debugfs_init(device);\n\n\t/* Disable the sparse ioctl invocation as they are not used */\n\tdevice->flags &= ~KGSL_FLAG_SPARSE;\n\n\tstatus = kgsl_pwrctrl_init(device);\n\tif (status)\n\t\tgoto error;\n\n\t/*\n\t * Check if a shadermemname is defined, and then get shader memory\n\t * details including shader memory starting physical address\n\t * and shader memory length\n\t */\n\tif (device->shadermemname != NULL) {\n\t\tres = platform_get_resource_byname(device->pdev, IORESOURCE_MEM,\n\t\t\t\t\t\tdevice->shadermemname);\n\n\t\tif (res == NULL) {\n\t\t\tKGSL_DRV_WARN(device,\n\t\t\t"Shader memory: platform_get_resource_byname failed\\n");\n\t\t}\n\n\t\telse {\n\t\t\tdevice->shader_mem_phys = res->start;\n\t\t\tdevice->shader_mem_len = resource_size(res);\n\t\t}\n\n\t\tif (!devm_request_mem_region(device->dev,\n\t\t\t\t\tdevice->shader_mem_phys,\n\t\t\t\t\tdevice->shader_mem_len,\n\t\t\t\t\t\tdevice->name)) {\n\t\t\tKGSL_DRV_WARN(device, "request_mem_region_failed\\n");\n\t\t}\n\t}\n\n\tif (!devm_request_mem_region(device->dev, device->reg_phys,\n\t\t\t\tdevice->reg_len, device->name)) {\n\t\tKGSL_DRV_ERR(device, "request_mem_region failed\\n");\n\t\tstatus = -ENODEV;\n\t\tgoto error_pwrctrl_close;\n\t}\n\n\tdevice->reg_virt = devm_ioremap(device->dev, device->reg_phys,\n\t\t\t\t\tdevice->reg_len);\n\n\tif (device->reg_virt == NULL) {\n\t\tKGSL_DRV_ERR(device, "ioremap failed\\n");\n\t\tstatus = -ENODEV;\n\t\tgoto error_pwrctrl_close;\n\t}\n\t/*acquire interrupt */\n\tdevice->pwrctrl.interrupt_num =\n\t\tplatform_get_irq_byname(device->pdev, device->pwrctrl.irq_name);\n\n\tif (device->pwrctrl.interrupt_num <= 0) {\n\t\tKGSL_DRV_ERR(device, "platform_get_irq_byname failed: %d\\n",\n\t\t\t\t\t device->pwrctrl.interrupt_num);\n\t\tstatus = -EINVAL;\n\t\tgoto error_pwrctrl_close;\n\t}\n\n\tstatus = devm_request_irq(device->dev, device->pwrctrl.interrupt_num,\n\t\t\t\t  kgsl_irq_handler, IRQF_TRIGGER_HIGH,\n\t\t\t\t  device->name, device);\n\tif (status) {\n\t\tKGSL_DRV_ERR(device, "request_irq(%d) failed: %d\\n",\n\t\t\t      device->pwrctrl.interrupt_num, status);\n\t\tgoto error_pwrctrl_close;\n\t}\n\tdisable_irq(device->pwrctrl.interrupt_num);\n\n\tKGSL_DRV_INFO(device,\n\t\t"dev_id %d regs phys 0x%08lx size 0x%08x\\n",\n\t\tdevice->id, device->reg_phys, device->reg_len);\n\n\trwlock_init(&device->context_lock);\n\tspin_lock_init(&device->submit_lock);\n\n\tsetup_timer(&device->idle_timer, kgsl_timer, (unsigned long) device);\n\n\tstatus = kgsl_mmu_probe(device, kgsl_mmu_type);\n\tif (status != 0)\n\t\tgoto error_pwrctrl_close;\n\n\t/* Check to see if our device can perform DMA correctly */\n\tstatus = dma_set_coherent_mask(&device->pdev->dev, KGSL_DMA_BIT_MASK);\n\tif (status)\n\t\tgoto error_close_mmu;\n\n\t/* Initialize the memory pools */\n\tkgsl_init_page_pools(device->pdev);\n\n\tstatus = kgsl_allocate_global(device, &device->memstore,\n\t\tKGSL_MEMSTORE_SIZE, 0, KGSL_MEMDESC_CONTIG, "memstore");\n\n\tif (status != 0)\n\t\tgoto error_close_mmu;\n\n\t/*\n\t * The default request type PM_QOS_REQ_ALL_CORES is\n\t * applicable to all CPU cores that are online and\n\t * would have a power impact when there are more\n\t * number of CPUs. PM_QOS_REQ_AFFINE_IRQ request\n\t * type shall update/apply the vote only to that CPU to\n\t * which IRQ\'s affinity is set to.\n\t */\n#ifdef CONFIG_SMP\n\n\tdevice->pwrctrl.pm_qos_req_dma.type = PM_QOS_REQ_AFFINE_IRQ;\n\tdevice->pwrctrl.pm_qos_req_dma.irq = device->pwrctrl.interrupt_num;\n\n#endif\n\tpm_qos_add_request(&device->pwrctrl.pm_qos_req_dma,\n\t\t\t\tPM_QOS_CPU_DMA_LATENCY,\n\t\t\t\tPM_QOS_DEFAULT_VALUE);\n\n\tif (device->pwrctrl.l2pc_cpus_mask) {\n\n\t\tdevice->pwrctrl.l2pc_cpus_qos.type =\n\t\t\t\tPM_QOS_REQ_AFFINE_CORES;\n\t\tcpumask_empty(&device->pwrctrl.l2pc_cpus_qos.cpus_affine);\n\t\tfor_each_possible_cpu(cpu) {\n\t\t\tif ((1 << cpu) & device->pwrctrl.l2pc_cpus_mask)\n\t\t\t\tcpumask_set_cpu(cpu, &device->pwrctrl.\n\t\t\t\t\t\tl2pc_cpus_qos.cpus_affine);\n\t\t}\n\n\t\tpm_qos_add_request(&device->pwrctrl.l2pc_cpus_qos,\n\t\t\t\tPM_QOS_CPU_DMA_LATENCY,\n\t\t\t\tPM_QOS_DEFAULT_VALUE);\n\t}\n\n\tdevice->events_wq = alloc_workqueue("kgsl-events",\n\t\tWQ_UNBOUND | WQ_MEM_RECLAIM | WQ_SYSFS, 0);\n\n\t/* Initialize the snapshot engine */\n\tkgsl_device_snapshot_init(device);\n\n\t/* Initialize common sysfs entries */\n\tkgsl_pwrctrl_init_sysfs(device);\n\n\treturn 0;\n\nerror_close_mmu:\n\tkgsl_mmu_close(device);\nerror_pwrctrl_close:\n\tkgsl_pwrctrl_close(device);\nerror:\n\tkgsl_device_debugfs_close(device);\n\t_unregister_device(device);\n\treturn status;\n}'
p1408
(dp1409
((g1370
g1405
tp1410
I1
tp1411
(dp1412
g14
(dp1413
(I14
I16
tp1414
(lp1415
S'\t/* Disable the sparse ioctl invocation as they are not used */'
p1416
aS'\tdevice->flags &= ~KGSL_FLAG_SPARSE;'
p1417
ag59
assg32
I1
sg12
g13
sg41
(I1
I164
tp1418
ssss(g1370
S'kgsl_ioctl_gpu_sparse_command'
p1419
tp1420
(dp1421
S'long kgsl_ioctl_gpu_sparse_command(struct kgsl_device_private *dev_priv,\n\t\tunsigned int cmd, void *data)\n{\n\tstruct kgsl_gpu_sparse_command *param = data;\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct kgsl_context *context;\n\tstruct kgsl_drawobj *drawobj[2];\n\tstruct kgsl_drawobj_sparse *sparseobj;\n\tlong result;\n\tunsigned int i = 0;\n\n\tif (!(device->flags & KGSL_FLAG_SPARSE))\n\t\treturn -ENOTSUPP;\n\n\t/* Make sure sparse and syncpoint count isn\'t too big */\n\tif (param->numsparse > KGSL_MAX_SPARSE ||\n\t\tparam->numsyncs > KGSL_MAX_SYNCPOINTS)\n\t\treturn -EINVAL;\n\n\t/* Make sure there is atleast one sparse or sync */\n\tif (param->numsparse == 0 && param->numsyncs == 0)\n\t\treturn -EINVAL;\n\n\t/* Only Sparse commands are supported in this ioctl */\n\tif (!(param->flags & KGSL_DRAWOBJ_SPARSE) || (param->flags &\n\t\t\t(KGSL_DRAWOBJ_SUBMIT_IB_LIST | KGSL_DRAWOBJ_MARKER\n\t\t\t| KGSL_DRAWOBJ_SYNC)))\n\t\treturn -EINVAL;\n\n\tcontext = kgsl_context_get_owner(dev_priv, param->context_id);\n\tif (context == NULL)\n\t\treturn -EINVAL;\n\n\t/* Restrict bind commands to bind context */\n\tif (!(context->flags & KGSL_CONTEXT_SPARSE)) {\n\t\tkgsl_context_put(context);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param->numsyncs) {\n\t\tstruct kgsl_drawobj_sync *syncobj = kgsl_drawobj_sync_create(\n\t\t\t\tdevice, context);\n\t\tif (IS_ERR(syncobj)) {\n\t\t\tresult = PTR_ERR(syncobj);\n\t\t\tgoto done;\n\t\t}\n\n\t\tdrawobj[i++] = DRAWOBJ(syncobj);\n\t\tresult = kgsl_drawobj_sync_add_synclist(device, syncobj,\n\t\t\t\tto_user_ptr(param->synclist),\n\t\t\t\tparam->syncsize, param->numsyncs);\n\t\tif (result)\n\t\t\tgoto done;\n\t}\n\n\tif (param->numsparse) {\n\t\tsparseobj = kgsl_drawobj_sparse_create(device, context,\n\t\t\t\t\tparam->flags);\n\t\tif (IS_ERR(sparseobj)) {\n\t\t\tresult = PTR_ERR(sparseobj);\n\t\t\tgoto done;\n\t\t}\n\n\t\tsparseobj->id = param->id;\n\t\tdrawobj[i++] = DRAWOBJ(sparseobj);\n\t\tresult = kgsl_drawobj_sparse_add_sparselist(device, sparseobj,\n\t\t\t\tparam->id, to_user_ptr(param->sparselist),\n\t\t\t\tparam->sparsesize, param->numsparse);\n\t\tif (result)\n\t\t\tgoto done;\n\t}\n\n\tresult = dev_priv->device->ftbl->queue_cmds(dev_priv, context,\n\t\t\t\t\tdrawobj, i, &param->timestamp);\n\ndone:\n\t/*\n\t * -EPROTO is a "success" error - it just tells the user that the\n\t * context had previously faulted\n\t */\n\tif (result && result != -EPROTO)\n\t\twhile (i--)\n\t\t\tkgsl_drawobj_destroy(drawobj[i]);\n\n\tkgsl_context_put(context);\n\treturn result;\n}'
p1422
(dp1423
((g1370
g1419
tp1424
I1
tp1425
(dp1426
g14
(dp1427
(I12
I14
tp1428
(lp1429
S'\tif (!(device->flags & KGSL_FLAG_SPARSE))'
p1430
aS'\t\treturn -ENOTSUPP;'
p1431
ag59
assg32
I3
sg12
g13
sg41
(I1
I87
tp1432
ssss(g1370
S'kgsl_ioctl_sparse_virt_alloc'
p1433
tp1434
(dp1435
S'long kgsl_ioctl_sparse_virt_alloc(struct kgsl_device_private *dev_priv,\n\tunsigned int cmd, void *data)\n{\n\tstruct kgsl_process_private *private = dev_priv->process_priv;\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct kgsl_sparse_virt_alloc *param = data;\n\tstruct kgsl_mem_entry *entry;\n\tint ret;\n\n\tif (!(device->flags & KGSL_FLAG_SPARSE))\n\t\treturn -ENOTSUPP;\n\n\tret = _sparse_alloc_param_sanity_check(param->size, param->pagesize);\n\tif (ret)\n\t\treturn ret;\n\n\tentry = kgsl_mem_entry_create();\n\tif (entry == NULL)\n\t\treturn -ENOMEM;\n\n\tkgsl_memdesc_init(dev_priv->device, &entry->memdesc,\n\t\t\tKGSL_MEMFLAGS_SPARSE_VIRT);\n\tentry->memdesc.size = param->size;\n\tentry->memdesc.cur_bindings = 0;\n\tkgsl_memdesc_set_align(&entry->memdesc, ilog2(param->pagesize));\n\n\tspin_lock_init(&entry->bind_lock);\n\tentry->bind_tree = RB_ROOT;\n\n\tret = kgsl_mem_entry_attach_process(dev_priv->device, private, entry);\n\tif (ret) {\n\t\tkfree(entry);\n\t\treturn ret;\n\t}\n\n\tparam->id = entry->id;\n\tparam->gpuaddr = entry->memdesc.gpuaddr;\n\tparam->flags = entry->memdesc.flags;\n\n\ttrace_sparse_virt_alloc(entry->id, param->size, param->pagesize);\n\tkgsl_mem_entry_commit_process(entry);\n\n\t/* Put the extra ref from kgsl_mem_entry_create() */\n\tkgsl_mem_entry_put(entry);\n\n\treturn 0;\n}'
p1436
(dp1437
((g1370
g1433
tp1438
I1
tp1439
(dp1440
g14
(dp1441
(I5
I5
tp1442
(lp1443
S'\tstruct kgsl_device *device = dev_priv->device;'
p1444
as(I10
I12
tp1445
(lp1446
S'\tif (!(device->flags & KGSL_FLAG_SPARSE))'
p1447
aS'\t\treturn -ENOTSUPP;'
p1448
ag59
assg32
I3
sg12
g13
sg41
(I1
I47
tp1449
ssss(g1370
S'kgsl_ioctl_sparse_virt_free'
p1450
tp1451
(dp1452
S'long kgsl_ioctl_sparse_virt_free(struct kgsl_device_private *dev_priv,\n\tunsigned int cmd, void *data)\n{\n\tstruct kgsl_process_private *process = dev_priv->process_priv;\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct kgsl_sparse_virt_free *param = data;\n\tstruct kgsl_mem_entry *entry = NULL;\n\n\tif (!(device->flags & KGSL_FLAG_SPARSE))\n\t\treturn -ENOTSUPP;\n\n\tentry = kgsl_sharedmem_find_id_flags(process, param->id,\n\t\t\tKGSL_MEMFLAGS_SPARSE_VIRT);\n\tif (entry == NULL)\n\t\treturn -EINVAL;\n\n\tif (!kgsl_mem_entry_set_pend(entry)) {\n\t\tkgsl_mem_entry_put(entry);\n\t\treturn -EBUSY;\n\t}\n\n\tif (entry->bind_tree.rb_node != NULL) {\n\t\tkgsl_mem_entry_unset_pend(entry);\n\t\tkgsl_mem_entry_put(entry);\n\t\treturn -EINVAL;\n\t}\n\n\ttrace_sparse_virt_free(entry->id);\n\n\t/* One put for find_id(), one put for the kgsl_mem_entry_create() */\n\tkgsl_mem_entry_put(entry);\n\tkgsl_mem_entry_put(entry);\n\n\treturn 0;\n}'
p1453
(dp1454
((g1370
g1450
tp1455
I1
tp1456
(dp1457
g14
(dp1458
(I9
I11
tp1459
(lp1460
S'\tif (!(device->flags & KGSL_FLAG_SPARSE))'
p1461
aS'\t\treturn -ENOTSUPP;'
p1462
ag59
as(I5
I5
tp1463
(lp1464
S'\tstruct kgsl_device *device = dev_priv->device;'
p1465
assg32
I3
sg12
g13
sg41
(I1
I35
tp1466
ssss(g1370
S'kgsl_ioctl_sparse_bind'
p1467
tp1468
(dp1469
S'long kgsl_ioctl_sparse_bind(struct kgsl_device_private *dev_priv,\n\t\tunsigned int cmd, void *data)\n{\n\tstruct kgsl_process_private *private = dev_priv->process_priv;\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct kgsl_sparse_bind *param = data;\n\tstruct kgsl_sparse_binding_object obj;\n\tstruct kgsl_mem_entry *virt_entry;\n\tint pg_sz;\n\tvoid __user *ptr;\n\tint ret = 0;\n\tint i = 0;\n\n\tif (!(device->flags & KGSL_FLAG_SPARSE))\n\t\treturn -ENOTSUPP;\n\n\tptr = (void __user *) (uintptr_t) param->list;\n\n\tif (param->size > sizeof(struct kgsl_sparse_binding_object) ||\n\t\tparam->count == 0 || ptr == NULL)\n\t\treturn -EINVAL;\n\n\tvirt_entry = kgsl_sharedmem_find_id_flags(private, param->id,\n\t\t\tKGSL_MEMFLAGS_SPARSE_VIRT);\n\tif (virt_entry == NULL)\n\t\treturn -EINVAL;\n\n\tpg_sz = kgsl_memdesc_get_pagesize(&virt_entry->memdesc);\n\n\tfor (i = 0; i < param->count; i++) {\n\t\tmemset(&obj, 0, sizeof(obj));\n\t\tret = _copy_from_user(&obj, ptr, sizeof(obj), param->size);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\t/* Sanity check initial range */\n\t\tif (obj.size == 0 || obj.virtoffset + obj.size < obj.size ||\n\t\t\tobj.virtoffset + obj.size > virt_entry->memdesc.size ||\n\t\t\t!(IS_ALIGNED(obj.virtoffset | obj.size, pg_sz))) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (obj.flags & KGSL_SPARSE_BIND)\n\t\t\tret = sparse_bind_range(private, &obj, virt_entry);\n\t\telse if (obj.flags & KGSL_SPARSE_UNBIND)\n\t\t\tret = sparse_unbind_range(&obj, virt_entry);\n\t\telse\n\t\t\tret = -EINVAL;\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tptr += sizeof(obj);\n\t}\n\n\tkgsl_mem_entry_put(virt_entry);\n\n\treturn ret;\n}'
p1470
(dp1471
((g1370
g1467
tp1472
I1
tp1473
(dp1474
g14
(dp1475
(I5
I5
tp1476
(lp1477
S'\tstruct kgsl_device *device = dev_priv->device;'
p1478
as(I14
I16
tp1479
(lp1480
S'\tif (!(device->flags & KGSL_FLAG_SPARSE))'
p1481
aS'\t\treturn -ENOTSUPP;'
p1482
ag59
assg32
I3
sg12
g13
sg41
(I1
I59
tp1483
sssssS'CVE-2019-10584'
p1484
(dp1485
(S'drivers/media/platform/msm/vidc/venus_hfi.c'
p1486
S'__flush_debug_queue'
p1487
tp1488
(dp1489
S'static void __flush_debug_queue(struct venus_hfi_device *device, u8 *packet)\n{\n\tbool local_packet = false;\n\tenum vidc_msg_prio log_level = VIDC_FW;\n\n\tif (!device) {\n\t\tdprintk(VIDC_ERR, "%s: Invalid params\\n", __func__);\n\t\treturn;\n\t}\n\n\tif (!packet) {\n\t\tpacket = kzalloc(VIDC_IFACEQ_VAR_HUGE_PKT_SIZE, GFP_TEMPORARY);\n\t\tif (!packet) {\n\t\t\tdprintk(VIDC_ERR, "In %s() Fail to allocate mem\\n",\n\t\t\t\t__func__);\n\t\t\treturn;\n\t\t}\n\n\t\tlocal_packet = true;\n\n\t\t/*\n\t\t * Local packek is used when something FATAL occurred.\n\t\t * It is good to print these logs by default.\n\t\t */\n\n\t\tlog_level = VIDC_ERR;\n\t}\n\n#define SKIP_INVALID_PKT(pkt_size, payload_size, pkt_hdr_size) ({ \\\n\t\tif (pkt_size < pkt_hdr_size || \\\n\t\t\tpayload_size < MIN_PAYLOAD_SIZE || \\\n\t\t\tpayload_size > \\\n\t\t\t(pkt_size - pkt_hdr_size + sizeof(u8))) { \\\n\t\t\tdprintk(VIDC_ERR, \\\n\t\t\t\t"%s: invalid msg size - %d\\n", \\\n\t\t\t\t__func__, pkt->msg_size); \\\n\t\t\tcontinue; \\\n\t\t} \\\n\t})\n\n\twhile (!__iface_dbgq_read(device, packet)) {\n\t\tstruct hfi_packet_header *pkt =\n\t\t\t(struct hfi_packet_header *) packet;\n\n\t\tif (pkt->size < sizeof(struct hfi_packet_header)) {\n\t\t\tdprintk(VIDC_ERR, "Invalid pkt size - %s\\n",\n\t\t\t\t__func__);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkt->packet_type == HFI_MSG_SYS_COV) {\n\t\t\tstruct hfi_msg_sys_coverage_packet *pkt =\n\t\t\t\t(struct hfi_msg_sys_coverage_packet *) packet;\n\t\t\tint stm_size = 0;\n\n\t\t\tSKIP_INVALID_PKT(pkt->size,\n\t\t\t\tpkt->msg_size, sizeof(*pkt));\n\n\t\t\tstm_size = stm_log_inv_ts(0, 0,\n\t\t\t\tpkt->rg_msg_data, pkt->msg_size);\n\t\t\tif (stm_size == 0)\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"In %s, stm_log returned size of 0\\n",\n\t\t\t\t\t__func__);\n\n\t\t} else if (pkt->packet_type == HFI_MSG_SYS_DEBUG) {\n\t\t\tstruct hfi_msg_sys_debug_packet *pkt =\n\t\t\t\t(struct hfi_msg_sys_debug_packet *) packet;\n\n\t\t\tSKIP_INVALID_PKT(pkt->size,\n\t\t\t\tpkt->msg_size, sizeof(*pkt));\n\n\t\t\tpkt->rg_msg_data[pkt->msg_size-1] = \'\\0\';\n\t\t\tdprintk(log_level, "%s", pkt->rg_msg_data);\n\t\t}\n\t}\n#undef SKIP_INVALID_PKT\n\n\tif (local_packet)\n\t\tkfree(packet);\n}'
p1490
(dp1491
((g1486
g1487
tp1492
I1
tp1493
(dp1494
g33
(dp1495
(I42
I43
tp1496
(lp1497
S'\t\tstruct hfi_msg_sys_coverage_packet *pkt ='
p1498
aS'\t\t\t(struct hfi_msg_sys_coverage_packet *) packet;'
p1499
as(I65
I65
tp1500
(lp1501
S'\t\t} else {'
p1502
assg14
(dp1503
(I65
I66
tp1504
(lp1505
g59
aS'\t\t} else if (pkt->packet_type == HFI_MSG_SYS_DEBUG) {'
p1506
as(I69
I73
tp1507
(lp1508
g59
aS'\t\t\tSKIP_INVALID_PKT(pkt->size,'
p1509
aS'\t\t\t\tpkt->msg_size, sizeof(*pkt));'
p1510
ag59
aS"\t\t\tpkt->rg_msg_data[pkt->msg_size-1] = '\\0';"
p1511
as(I29
I40
tp1512
(lp1513
S'#define SKIP_INVALID_PKT(pkt_size, payload_size, pkt_hdr_size) ({ \\'
p1514
aS'\t\tif (pkt_size < pkt_hdr_size || \\'
p1515
aS'\t\t\tpayload_size < MIN_PAYLOAD_SIZE || \\'
p1516
aS'\t\t\tpayload_size > \\'
p1517
aS'\t\t\t(pkt_size - pkt_hdr_size + sizeof(u8))) { \\'
p1518
aS'\t\t\tdprintk(VIDC_ERR, \\'
p1519
aS'\t\t\t\t"%s: invalid msg size - %d\\n", \\'
p1520
aS'\t\t\t\t__func__, pkt->msg_size); \\'
p1521
aS'\t\t\tcontinue; \\'
p1522
aS'\t\t} \\'
p1523
aS'\t})'
p1524
ag59
as(I42
I49
tp1525
(lp1526
S'\t\tstruct hfi_packet_header *pkt ='
p1527
aS'\t\t\t(struct hfi_packet_header *) packet;'
p1528
ag59
aS'\t\tif (pkt->size < sizeof(struct hfi_packet_header)) {'
p1529
aS'\t\t\tdprintk(VIDC_ERR, "Invalid pkt size - %s\\n",'
p1530
aS'\t\t\t\t__func__);'
p1531
aS'\t\t\tcontinue;'
p1532
aS'\t\t}'
p1533
as(I52
I53
tp1534
(lp1535
S'\t\t\tstruct hfi_msg_sys_coverage_packet *pkt ='
p1536
aS'\t\t\t\t(struct hfi_msg_sys_coverage_packet *) packet;'
p1537
as(I56
I58
tp1538
(lp1539
S'\t\t\tSKIP_INVALID_PKT(pkt->size,'
p1540
aS'\t\t\t\tpkt->msg_size, sizeof(*pkt));'
p1541
ag59
as(I77
I77
tp1542
(lp1543
S'#undef SKIP_INVALID_PKT'
p1544
assg32
I2
sg12
g13
sg41
(I1
I81
tp1545
sssssS'CVE-2019-10585'
p1546
(dp1547
(S'drivers/char/adsprpc.c'
p1548
S'fastrpc_mmap_find'
p1549
tp1550
(dp1551
S'static int fastrpc_mmap_find(struct fastrpc_file *fl, int fd,\n\t\tuintptr_t va, size_t len, int mflags, int refs,\n\t\tstruct fastrpc_mmap **ppmap)\n{\n\tstruct fastrpc_apps *me = &gfa;\n\tstruct fastrpc_mmap *match = NULL, *map = NULL;\n\tstruct hlist_node *n;\n\n\tif ((va + len) < va)\n\t\treturn -EOVERFLOW;\n\tif (mflags == ADSP_MMAP_HEAP_ADDR ||\n\t\t\t\t mflags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tspin_lock(&me->hlock);\n\t\thlist_for_each_entry_safe(map, n, &me->maps, hn) {\n\t\t\tif (va >= map->va &&\n\t\t\t\tva + len <= map->va + map->len &&\n\t\t\t\tmap->fd == fd) {\n\t\t\t\tif (refs) {\n\t\t\t\t\tif (map->refs + 1 == INT_MAX) {\n\t\t\t\t\t\tspin_unlock(&me->hlock);\n\t\t\t\t\t\treturn -ETOOMANYREFS;\n\t\t\t\t\t}\n\t\t\t\t\tmap->refs++;\n\t\t\t\t}\n\t\t\t\tmatch = map;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tspin_unlock(&me->hlock);\n\t} else {\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\tif (va >= map->va &&\n\t\t\t\tva + len <= map->va + map->len &&\n\t\t\t\tmap->fd == fd) {\n\t\t\t\tif (refs) {\n\t\t\t\t\tif (map->refs + 1 == INT_MAX)\n\t\t\t\t\t\treturn -ETOOMANYREFS;\n\t\t\t\t\tmap->refs++;\n\t\t\t\t}\n\t\t\t\tmatch = map;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (match) {\n\t\t*ppmap = match;\n\t\treturn 0;\n\t}\n\treturn -ENOTTY;\n}'
p1552
(dp1553
((g1548
g1549
tp1554
I1
tp1555
(dp1556
g12
g13
sg14
(dp1557
(I24
I24
tp1558
(lp1559
S'\t\t\t\t}'
p1560
as(I18
I22
tp1561
(lp1562
S'\t\t\t\tif (refs) {'
p1563
aS'\t\t\t\t\tif (map->refs + 1 == INT_MAX) {'
p1564
aS'\t\t\t\t\t\tspin_unlock(&me->hlock);'
p1565
aS'\t\t\t\t\t\treturn -ETOOMANYREFS;'
p1566
aS'\t\t\t\t\t}'
p1567
as(I39
I39
tp1568
(lp1569
S'\t\t\t\t}'
p1570
as(I35
I37
tp1571
(lp1572
S'\t\t\t\tif (refs) {'
p1573
aS'\t\t\t\t\tif (map->refs + 1 == INT_MAX)'
p1574
aS'\t\t\t\t\t\treturn -ETOOMANYREFS;'
p1575
assg32
I7
sg33
(dp1576
(I35
I35
tp1577
(lp1578
S'\t\t\t\tif (refs)'
p1579
as(I18
I18
tp1580
(lp1581
S'\t\t\t\tif (refs)'
p1582
assg41
(I1
I50
tp1583
sssssS'CVE-2019-19527'
p1584
(dp1585
(S'drivers/hid/usbhid/hiddev.c'
p1586
S'hiddev_open'
p1587
tp1588
(dp1589
S'static int hiddev_open(struct inode *inode, struct file *file)\n{\n\tstruct hiddev_list *list;\n\tstruct usb_interface *intf;\n\tstruct hid_device *hid;\n\tstruct hiddev *hiddev;\n\tint res;\n\n\tintf = usbhid_find_interface(iminor(inode));\n\tif (!intf)\n\t\treturn -ENODEV;\n\thid = usb_get_intfdata(intf);\n\thiddev = hid->hiddev;\n\n\tif (!(list = vzalloc(sizeof(struct hiddev_list))))\n\t\treturn -ENOMEM;\n\tmutex_init(&list->thread_lock);\n\tlist->hiddev = hiddev;\n\tfile->private_data = list;\n\n\t/*\n\t * no need for locking because the USB major number\n\t * is shared which usbcore guards against disconnect\n\t */\n\tif (list->hiddev->exist) {\n\t\tif (!list->hiddev->open++) {\n\t\t\tres = usbhid_open(hiddev->hid);\n\t\t\tif (res < 0) {\n\t\t\t\tres = -EIO;\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tres = -ENODEV;\n\t\tgoto bail;\n\t}\n\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_add_tail(&list->node, &hiddev->list);\n\tspin_unlock_irq(&list->hiddev->list_lock);\n\n\tmutex_lock(&hiddev->existancelock);\n\t/*\n\t * recheck exist with existance lock held to\n\t * avoid opening a disconnected device\n\t */\n\tif (!list->hiddev->exist) {\n\t\tres = -ENODEV;\n\t\tgoto bail_unlock;\n\t}\n\tif (!list->hiddev->open++)\n\t\tif (list->hiddev->exist) {\n\t\t\tstruct hid_device *hid = hiddev->hid;\n\t\t\tres = usbhid_get_power(hid);\n\t\t\tif (res < 0) {\n\t\t\t\tres = -EIO;\n\t\t\t\tgoto bail_unlock;\n\t\t\t}\n\t\t\tusbhid_open(hid);\n\t\t}\n\tmutex_unlock(&hiddev->existancelock);\n\treturn 0;\nbail_unlock:\n\tmutex_unlock(&hiddev->existancelock);\n\n\tspin_lock_irq(&list->hiddev->list_lock);\n\tlist_del(&list->node);\n\tspin_unlock_irq(&list->hiddev->list_lock);\nbail:\n\tfile->private_data = NULL;\n\tvfree(list);\n\treturn res;\n}'
p1590
(dp1591
((g1586
g1587
tp1592
I1
tp1593
(dp1594
g14
(dp1595
(I43
I50
tp1596
(lp1597
S'\t/*'
p1598
aS'\t * recheck exist with existance lock held to'
p1599
aS'\t * avoid opening a disconnected device'
p1600
aS'\t */'
p1601
aS'\tif (!list->hiddev->exist) {'
p1602
aS'\t\tres = -ENODEV;'
p1603
aS'\t\tgoto bail_unlock;'
p1604
aS'\t}'
p1605
as(I65
I68
tp1606
(lp1607
g59
aS'\tspin_lock_irq(&list->hiddev->list_lock);'
p1608
aS'\tlist_del(&list->node);'
p1609
aS'\tspin_unlock_irq(&list->hiddev->list_lock);'
p1610
assg32
I2
sg12
g13
sg41
(I1
I73
tp1611
sssssS'CVE-2019-14815'
p1612
(dp1613
(S'drivers/net/wireless/marvell/mwifiex/ie.c'
p1614
S'mwifiex_update_vs_ie'
p1615
tp1616
(dp1617
S'static int mwifiex_update_vs_ie(const u8 *ies, int ies_len,\n\t\t\t\tstruct mwifiex_ie **ie_ptr, u16 mask,\n\t\t\t\tunsigned int oui, u8 oui_type)\n{\n\tstruct ieee_types_header *vs_ie;\n\tstruct mwifiex_ie *ie = *ie_ptr;\n\tconst u8 *vendor_ie;\n\n\tvendor_ie = cfg80211_find_vendor_ie(oui, oui_type, ies, ies_len);\n\tif (vendor_ie) {\n\t\tif (!*ie_ptr) {\n\t\t\t*ie_ptr = kzalloc(sizeof(struct mwifiex_ie),\n\t\t\t\t\t  GFP_KERNEL);\n\t\t\tif (!*ie_ptr)\n\t\t\t\treturn -ENOMEM;\n\t\t\tie = *ie_ptr;\n\t\t}\n\n\t\tvs_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >\n\t\t\tIEEE_MAX_IE_SIZE)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(ie->ie_buffer + le16_to_cpu(ie->ie_length),\n\t\t       vs_ie, vs_ie->len + 2);\n\t\tle16_add_cpu(&ie->ie_length, vs_ie->len + 2);\n\t\tie->mgmt_subtype_mask = cpu_to_le16(mask);\n\t\tie->ie_index = cpu_to_le16(MWIFIEX_AUTO_IDX_MASK);\n\t}\n\n\t*ie_ptr = ie;\n\treturn 0;\n}'
p1618
(dp1619
((g1614
g1615
tp1620
I1
tp1621
(dp1622
g14
(dp1623
(I20
I22
tp1624
(lp1625
S'\t\tif (le16_to_cpu(ie->ie_length) + vs_ie->len + 2 >'
p1626
aS'\t\t\tIEEE_MAX_IE_SIZE)'
p1627
aS'\t\t\treturn -EINVAL;'
p1628
assg32
I6
sg12
g13
sg41
(I1
I32
tp1629
ssss(S'drivers/net/wireless/marvell/mwifiex/uap_cmd.c'
p1630
S'mwifiex_set_wmm_params'
p1631
tp1632
(dp1633
S'mwifiex_set_wmm_params(struct mwifiex_private *priv,\n\t\t       struct mwifiex_uap_bss_param *bss_cfg,\n\t\t       struct cfg80211_ap_settings *params)\n{\n\tconst u8 *vendor_ie;\n\tstruct ieee_types_header *wmm_ie;\n\tu8 wmm_oui[] = {0x00, 0x50, 0xf2, 0x02};\n\n\tvendor_ie = cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WMM,\n\t\t\t\t\t    params->beacon.tail,\n\t\t\t\t\t    params->beacon.tail_len);\n\tif (vendor_ie) {\n\t\twmm_ie = (struct ieee_types_header *)vendor_ie;\n\t\tif (*(vendor_ie + 1) > sizeof(struct mwifiex_types_wmm_info))\n\t\t\treturn;\n\t\tmemcpy(&bss_cfg->wmm_info, wmm_ie + 1,\n\t\t       sizeof(bss_cfg->wmm_info));\n\t\tpriv->wmm_enabled = 1;\n\t} else {\n\t\tmemset(&bss_cfg->wmm_info, 0, sizeof(bss_cfg->wmm_info));\n\t\tmemcpy(&bss_cfg->wmm_info.oui, wmm_oui, sizeof(wmm_oui));\n\t\tbss_cfg->wmm_info.subtype = MWIFIEX_WMM_SUBTYPE;\n\t\tbss_cfg->wmm_info.version = MWIFIEX_WMM_VERSION;\n\t\tpriv->wmm_enabled = 0;\n\t}\n\n\tbss_cfg->qos_info = 0x00;\n\treturn;\n}'
p1634
(dp1635
((g1630
g1631
tp1636
I1
tp1637
(dp1638
g14
(dp1639
(I15
I16
tp1640
(lp1641
S'\t\tif (*(vendor_ie + 1) > sizeof(struct mwifiex_types_wmm_info))'
p1642
aS'\t\t\treturn;'
p1643
assg32
I3
sg12
g13
sg41
(I1
I30
tp1644
ssss(g1630
S'mwifiex_set_uap_rates'
p1645
tp1646
(dp1647
S'mwifiex_set_uap_rates(struct mwifiex_uap_bss_param *bss_cfg,\n\t\t      struct cfg80211_ap_settings *params)\n{\n\tstruct ieee_types_header *rate_ie;\n\tint var_offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);\n\tconst u8 *var_pos = params->beacon.head + var_offset;\n\tint len = params->beacon.head_len - var_offset;\n\tu8 rate_len = 0;\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_SUPP_RATES, var_pos, len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates, rate_ie + 1, rate_ie->len);\n\t\trate_len = rate_ie->len;\n\t}\n\n\trate_ie = (void *)cfg80211_find_ie(WLAN_EID_EXT_SUPP_RATES,\n\t\t\t\t\t   params->beacon.tail,\n\t\t\t\t\t   params->beacon.tail_len);\n\tif (rate_ie) {\n\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)\n\t\t\treturn;\n\t\tmemcpy(bss_cfg->rates + rate_len, rate_ie + 1, rate_ie->len);\n\t}\n\n\treturn;\n}'
p1648
(dp1649
((g1630
g1645
tp1650
I1
tp1651
(dp1652
g33
(dp1653
(I21
I21
tp1654
(lp1655
S'\tif (rate_ie)'
p1656
assg14
(dp1657
(I12
I13
tp1658
(lp1659
S'\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES)'
p1660
aS'\t\t\treturn;'
p1661
as(I21
I23
tp1662
(lp1663
S'\tif (rate_ie) {'
p1664
aS'\t\tif (rate_ie->len > MWIFIEX_SUPPORTED_RATES - rate_len)'
p1665
aS'\t\t\treturn;'
p1666
as(I25
I25
tp1667
(lp1668
S'\t}'
p1669
assg32
I2
sg12
g13
sg41
(I1
I28
tp1670
sssssS'CVE-2019-2264'
p1671
(dp1672
(S'drivers/soc/qcom/glink.c'
p1673
S'glink_open'
p1674
tp1675
(dp1676
S'void *glink_open(const struct glink_open_config *cfg)\n{\n\tstruct channel_ctx *ctx = NULL;\n\tstruct glink_core_xprt_ctx *transport_ptr;\n\tsize_t len;\n\tint ret;\n\tuint16_t best_id;\n\n\tif (!cfg->edge || !cfg->name) {\n\t\tGLINK_ERR("%s: !cfg->edge || !cfg->name\\n", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlen = strlen(cfg->edge);\n\tif (len == 0 || len >= GLINK_NAME_SIZE) {\n\t\tGLINK_ERR("%s: [EDGE] len == 0 || len >= GLINK_NAME_SIZE\\n",\n\t\t\t\t__func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tlen = strlen(cfg->name);\n\tif (len == 0 || len >= GLINK_NAME_SIZE) {\n\t\tGLINK_ERR("%s: [NAME] len == 0 || len >= GLINK_NAME_SIZE\\n",\n\t\t\t\t__func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tif (cfg->transport) {\n\t\tlen = strlen(cfg->transport);\n\t\tif (len == 0 || len >= GLINK_NAME_SIZE) {\n\t\t\tGLINK_ERR("%s: [TRANSPORT] len == 0 || %s\\n",\n\t\t\t\t__func__,\n\t\t\t\t"len >= GLINK_NAME_SIZE");\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t}\n\n\t/* confirm required notification parameters */\n\tif (!(cfg->notify_rx || cfg->notify_rxv) || !cfg->notify_tx_done\n\t\t|| !cfg->notify_state\n\t\t|| ((cfg->options & GLINK_OPT_RX_INTENT_NOTIF)\n\t\t\t&& !cfg->notify_remote_rx_intent)) {\n\t\tGLINK_ERR("%s: Incorrect notification parameters\\n", __func__);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* find transport */\n\ttransport_ptr = find_open_transport(cfg->edge, cfg->transport,\n\t\t\t\t\tcfg->options & GLINK_OPT_INITIAL_XPORT,\n\t\t\t\t\t&best_id);\n\tif (IS_ERR_OR_NULL(transport_ptr)) {\n\t\tGLINK_ERR("%s:%s %s: Error %d - unable to find transport\\n",\n\t\t\t\tcfg->transport, cfg->edge, __func__,\n\t\t\t\t(unsigned int)PTR_ERR(transport_ptr));\n\t\treturn ERR_PTR(-ENODEV);\n\t}\n\n\t/*\n\t * look for an existing port structure which can occur in\n\t * reopen and remote-open-first cases\n\t */\n\tctx = ch_name_to_ch_ctx_create(transport_ptr, cfg->name, true);\n\tif (ctx == NULL) {\n\t\tGLINK_ERR("%s:%s %s: Error - unable to allocate new channel\\n",\n\t\t\t\tcfg->transport, cfg->edge, __func__);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* initialize port structure */\n\tctx->user_priv = cfg->priv;\n\tctx->rx_intent_req_timeout_jiffies =\n\t\tmsecs_to_jiffies(cfg->rx_intent_req_timeout_ms);\n\tctx->notify_rx = cfg->notify_rx;\n\tctx->notify_tx_done = cfg->notify_tx_done;\n\tctx->notify_state = cfg->notify_state;\n\tctx->notify_rx_intent_req = cfg->notify_rx_intent_req;\n\tctx->notify_rxv = cfg->notify_rxv;\n\tctx->notify_rx_sigs = cfg->notify_rx_sigs;\n\tctx->notify_rx_abort = cfg->notify_rx_abort;\n\tctx->notify_tx_abort = cfg->notify_tx_abort;\n\tctx->notify_rx_tracer_pkt = cfg->notify_rx_tracer_pkt;\n\tctx->notify_remote_rx_intent = cfg->notify_remote_rx_intent;\n\n\tif (!ctx->notify_rx_intent_req)\n\t\tctx->notify_rx_intent_req = glink_dummy_notify_rx_intent_req;\n\tif (!ctx->notify_rx_sigs)\n\t\tctx->notify_rx_sigs = glink_dummy_notify_rx_sigs;\n\tif (!ctx->notify_rx_abort)\n\t\tctx->notify_rx_abort = glink_dummy_notify_rx_abort;\n\tif (!ctx->notify_tx_abort)\n\t\tctx->notify_tx_abort = glink_dummy_notify_tx_abort;\n\n\tif (!ctx->rx_intent_req_timeout_jiffies)\n\t\tctx->rx_intent_req_timeout_jiffies = MAX_SCHEDULE_TIMEOUT;\n\n\tctx->local_xprt_req = best_id;\n\tctx->no_migrate = cfg->transport &&\n\t\t\t\t!(cfg->options & GLINK_OPT_INITIAL_XPORT);\n\tGLINK_INFO_PERF_CH(ctx,\n\t\t"%s: local:GLINK_CHANNEL_CLOSED->GLINK_CHANNEL_OPENING\\n",\n\t\t__func__);\n\n\t/* start local-open sequence */\n\tret = ctx->transport_ptr->ops->tx_cmd_ch_open(ctx->transport_ptr->ops,\n\t\tctx->lcid, cfg->name, best_id);\n\tif (ret) {\n\t\t/* failure to send open command (transport failure) */\n\t\tctx->local_open_state = GLINK_CHANNEL_CLOSED;\n\t\tGLINK_ERR_CH(ctx, "%s: Unable to send open command %d\\n",\n\t\t\t__func__, ret);\n\t\trwref_put(&ctx->ch_state_lhb2);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tGLINK_INFO_CH(ctx, "%s: Created channel, sent OPEN command. ctx %p\\n",\n\t\t\t__func__, ctx);\n\trwref_put(&ctx->ch_state_lhb2);\n\treturn ctx;\n}'
p1677
(dp1678
((g1673
g1674
tp1679
I1
tp1680
(dp1681
g12
g13
sg14
(dp1682
(I62
I62
tp1683
(lp1684
S'\tctx = ch_name_to_ch_ctx_create(transport_ptr, cfg->name, true);'
p1685
assg32
I1
sg33
(dp1686
(I69
I78
tp1687
(lp1688
S'\t/* port already exists */'
p1689
aS'\tif (ctx->local_open_state != GLINK_CHANNEL_CLOSED) {'
p1690
aS'\t\t/* not ready to be re-opened */'
p1691
aS'\t\tGLINK_INFO_CH_XPRT(ctx, transport_ptr,'
p1692
aS'\t\t"%s: Channel not ready to be re-opened. State: %u\\n",'
p1693
aS'\t\t__func__, ctx->local_open_state);'
p1694
aS'\t\trwref_put(&ctx->ch_state_lhb2);'
p1695
aS'\t\treturn ERR_PTR(-EBUSY);'
p1696
aS'\t}'
p1697
ag59
as(I99
I99
tp1698
(lp1699
S'\tctx->local_open_state = GLINK_CHANNEL_OPENING;'
p1700
as(I62
I62
tp1701
(lp1702
S'\tctx = ch_name_to_ch_ctx_create(transport_ptr, cfg->name);'
p1703
assg41
(I1
I119
tp1704
ssss(g1673
S'ch_name_to_ch_ctx_create'
p1705
tp1706
(dp1707
S'static struct channel_ctx *ch_name_to_ch_ctx_create(\n\t\t\t\t\tstruct glink_core_xprt_ctx *xprt_ctx,\n\t\t\t\t\tconst char *name, bool local)\n{\n\tstruct channel_ctx *entry;\n\tstruct channel_ctx *ctx;\n\tstruct channel_ctx *temp;\n\tunsigned long flags;\n\tstruct channel_lcid *flcid;\n\n\tctx = kzalloc(sizeof(struct channel_ctx), GFP_KERNEL);\n\tif (!ctx) {\n\t\tGLINK_ERR_XPRT(xprt_ctx, "%s: Failed to allocated ctx, %s",\n\t\t\t"checking if there is one existing\\n",\n\t\t\t__func__);\n\t\tgoto check_ctx;\n\t}\n\n\tctx->local_open_state = GLINK_CHANNEL_CLOSED;\n\tstrlcpy(ctx->name, name, GLINK_NAME_SIZE);\n\trwref_lock_init(&ctx->ch_state_lhb2, glink_ch_ctx_release);\n\tINIT_LIST_HEAD(&ctx->tx_ready_list_node);\n\tinit_completion(&ctx->int_req_ack_complete);\n\tinit_completion(&ctx->int_req_complete);\n\tINIT_LIST_HEAD(&ctx->local_rx_intent_list);\n\tINIT_LIST_HEAD(&ctx->local_rx_intent_ntfy_list);\n\tINIT_LIST_HEAD(&ctx->local_rx_intent_free_list);\n\tspin_lock_init(&ctx->local_rx_intent_lst_lock_lhc1);\n\tINIT_LIST_HEAD(&ctx->rmt_rx_intent_list);\n\tspin_lock_init(&ctx->rmt_rx_intent_lst_lock_lhc2);\n\tINIT_LIST_HEAD(&ctx->tx_active);\n\tspin_lock_init(&ctx->tx_pending_rmt_done_lock_lhc4);\n\tINIT_LIST_HEAD(&ctx->tx_pending_remote_done);\n\tspin_lock_init(&ctx->tx_lists_lock_lhc3);\n\ncheck_ctx:\n\trwref_write_get(&xprt_ctx->xprt_state_lhb0);\n\tif (xprt_ctx->local_state != GLINK_XPRT_OPENED) {\n\t\tkfree(ctx);\n\t\trwref_write_put(&xprt_ctx->xprt_state_lhb0);\n\t\treturn NULL;\n\t}\n\tspin_lock_irqsave(&xprt_ctx->xprt_ctx_lock_lhb1, flags);\n\tlist_for_each_entry_safe(entry, temp, &xprt_ctx->channels,\n\t\t    port_list_node)\n\t\tif (!strcmp(entry->name, name) && !entry->pending_delete) {\n\t\t\trwref_get(&entry->ch_state_lhb2);\n\t\t\t/* port already exists */\n\t\t\tif (entry->local_open_state != GLINK_CHANNEL_CLOSED\n\t\t\t\t\t\t\t\t&& local) {\n\t\t\t\t/* not ready to be re-opened */\n\t\t\t\tGLINK_INFO_CH_XPRT(entry, xprt_ctx,\n\t\t\t\t\t"%s: Ch not ready. State: %u\\n",\n\t\t\t\t\t__func__, entry->local_open_state);\n\t\t\t\trwref_put(&entry->ch_state_lhb2);\n\t\t\t\tentry = NULL;\n\t\t\t} else if (local) {\n\t\t\t\tentry->local_open_state =\n\t\t\t\t\t\tGLINK_CHANNEL_OPENING;\n\t\t\t}\n\t\t\tspin_unlock_irqrestore(&xprt_ctx->xprt_ctx_lock_lhb1,\n\t\t\t\t\tflags);\n\t\t\tkfree(ctx);\n\t\t\trwref_write_put(&xprt_ctx->xprt_state_lhb0);\n\t\t\treturn entry;\n\t\t}\n\n\tif (ctx) {\n\t\tif (list_empty(&xprt_ctx->free_lcid_list)) {\n\t\t\tif (xprt_ctx->next_lcid > xprt_ctx->max_cid) {\n\t\t\t\t/* no more channels available */\n\t\t\t\tGLINK_ERR_XPRT(xprt_ctx,\n\t\t\t\t\t"%s: unable to exceed %u channels\\n",\n\t\t\t\t\t__func__, xprt_ctx->max_cid);\n\t\t\t\tspin_unlock_irqrestore(\n\t\t\t\t\t\t&xprt_ctx->xprt_ctx_lock_lhb1,\n\t\t\t\t\t\tflags);\n\t\t\t\tkfree(ctx);\n\t\t\t\trwref_write_put(&xprt_ctx->xprt_state_lhb0);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tctx->lcid = xprt_ctx->next_lcid++;\n\t\t} else {\n\t\t\tflcid = list_first_entry(&xprt_ctx->free_lcid_list,\n\t\t\t\t\t\tstruct channel_lcid, list_node);\n\t\t\tctx->lcid = flcid->lcid;\n\t\t\tlist_del(&flcid->list_node);\n\t\t\tkfree(flcid);\n\t\t}\n\n\t\tctx->transport_ptr = xprt_ctx;\n\t\trwref_get(&ctx->ch_state_lhb2);\n\t\tif (local)\n\t\t\tctx->local_open_state = GLINK_CHANNEL_OPENING;\n\t\tlist_add_tail(&ctx->port_list_node, &xprt_ctx->channels);\n\n\t\tGLINK_INFO_PERF_CH_XPRT(ctx, xprt_ctx,\n\t\t\t"%s: local:GLINK_CHANNEL_CLOSED\\n",\n\t\t\t__func__);\n\t}\n\tspin_unlock_irqrestore(&xprt_ctx->xprt_ctx_lock_lhb1, flags);\n\trwref_write_put(&xprt_ctx->xprt_state_lhb0);\n\tmutex_lock(&xprt_ctx->xprt_dbgfs_lock_lhb4);\n\tif (ctx != NULL)\n\t\tglink_debugfs_add_channel(ctx, xprt_ctx);\n\tmutex_unlock(&xprt_ctx->xprt_dbgfs_lock_lhb4);\n\treturn ctx;\n}'
p1708
(dp1709
((g1673
g1705
tp1710
I1
tp1711
(dp1712
g12
g13
sg14
(dp1713
(I47
I60
tp1714
(lp1715
S'\t\t\trwref_get(&entry->ch_state_lhb2);'
p1716
aS'\t\t\t/* port already exists */'
p1717
aS'\t\t\tif (entry->local_open_state != GLINK_CHANNEL_CLOSED'
p1718
aS'\t\t\t\t\t\t\t\t&& local) {'
p1719
aS'\t\t\t\t/* not ready to be re-opened */'
p1720
aS'\t\t\t\tGLINK_INFO_CH_XPRT(entry, xprt_ctx,'
p1721
aS'\t\t\t\t\t"%s: Ch not ready. State: %u\\n",'
p1722
aS'\t\t\t\t\t__func__, entry->local_open_state);'
p1723
aS'\t\t\t\trwref_put(&entry->ch_state_lhb2);'
p1724
aS'\t\t\t\tentry = NULL;'
p1725
aS'\t\t\t} else if (local) {'
p1726
aS'\t\t\t\tentry->local_open_state ='
p1727
aS'\t\t\t\t\t\tGLINK_CHANNEL_OPENING;'
p1728
aS'\t\t\t}'
p1729
as(I93
I94
tp1730
(lp1731
S'\t\tif (local)'
p1732
aS'\t\t\tctx->local_open_state = GLINK_CHANNEL_OPENING;'
p1733
as(I3
I3
tp1734
(lp1735
S'\t\t\t\t\tconst char *name, bool local)'
p1736
assg32
I3
sg33
(dp1737
(I64
I64
tp1738
(lp1739
S'\t\t\trwref_get(&entry->ch_state_lhb2);'
p1740
as(I3
I3
tp1741
(lp1742
S'\t\t\t\t\tconst char *name)'
p1743
assg41
(I1
I108
tp1744
ssss(g1673
S'glink_core_rx_cmd_ch_remote_close'
p1745
tp1746
(dp1747
S'static void glink_core_rx_cmd_ch_remote_close(\n\t\tstruct glink_transport_if *if_ptr, uint32_t rcid)\n{\n\tstruct channel_ctx *ctx;\n\tbool is_ch_fully_closed;\n\tstruct glink_core_xprt_ctx *xprt_ptr = if_ptr->glink_core_priv;\n\tunsigned long flags;\n\n\tctx = xprt_rcid_to_ch_ctx_get(if_ptr->glink_core_priv, rcid);\n\tif (!ctx) {\n\t\t/* unknown LCID received - this shouldn\'t happen */\n\t\tGLINK_ERR_XPRT(if_ptr->glink_core_priv,\n\t\t\t\t"%s: invalid rcid %u received\\n", __func__,\n\t\t\t\t(unsigned int)rcid);\n\t\treturn;\n\t}\n\n\tif (!ctx->remote_opened) {\n\t\tGLINK_ERR_CH(ctx,\n\t\t\t"%s: unexpected remote close receive for rcid %u\\n",\n\t\t\t__func__, (unsigned int)rcid);\n\t\trwref_put(&ctx->ch_state_lhb2);\n\t\treturn;\n\t}\n\tspin_lock_irqsave(&ctx->transport_ptr->xprt_ctx_lock_lhb1, flags);\n\tctx->pending_delete = true;\n\tspin_unlock_irqrestore(&ctx->transport_ptr->xprt_ctx_lock_lhb1, flags);\n\tGLINK_INFO_CH(ctx, "%s: remote: OPENED->CLOSED\\n", __func__);\n\n\tis_ch_fully_closed = glink_core_remote_close_common(ctx, false);\n\n\tif_ptr->tx_cmd_ch_remote_close_ack(if_ptr, rcid);\n\n\tif (is_ch_fully_closed) {\n\t\tglink_delete_ch_from_list(ctx, true);\n\t\tkthread_flush_worker(&xprt_ptr->tx_wq);\n\t}\n\trwref_put(&ctx->ch_state_lhb2);\n}'
p1748
(dp1749
((g1673
g1745
tp1750
I1
tp1751
(dp1752
g33
(dp1753
(I32
I32
tp1754
(lp1755
S'\tctx->pending_delete = true;'
p1756
assg14
(dp1757
(I25
I27
tp1758
(lp1759
S'\tspin_lock_irqsave(&ctx->transport_ptr->xprt_ctx_lock_lhb1, flags);'
p1760
aS'\tctx->pending_delete = true;'
p1761
aS'\tspin_unlock_irqrestore(&ctx->transport_ptr->xprt_ctx_lock_lhb1, flags);'
p1762
as(I7
I7
tp1763
(lp1764
S'\tunsigned long flags;'
p1765
assg32
I2
sg12
g13
sg41
(I1
I39
tp1766
ssss(g1673
S'glink_core_rx_cmd_ch_remote_open'
p1767
tp1768
(dp1769
S'static void glink_core_rx_cmd_ch_remote_open(struct glink_transport_if *if_ptr,\n\tuint32_t rcid, const char *name, uint16_t req_xprt)\n{\n\tstruct channel_ctx *ctx;\n\tuint16_t xprt_resp;\n\tbool do_migrate;\n\n\tglink_core_migration_edge_lock(if_ptr->glink_core_priv);\n\tctx = ch_name_to_ch_ctx_create(if_ptr->glink_core_priv, name, false);\n\tif (ctx == NULL) {\n\t\tGLINK_ERR_XPRT(if_ptr->glink_core_priv,\n\t\t       "%s: invalid rcid %u received, name \'%s\'\\n",\n\t\t       __func__, rcid, name);\n\t\tglink_core_migration_edge_unlock(if_ptr->glink_core_priv);\n\t\treturn;\n\t}\n\n\t/* port already exists */\n\tif (ctx->remote_opened) {\n\t\tGLINK_ERR_CH(ctx,\n\t\t       "%s: Duplicate remote open for rcid %u, name \'%s\'\\n",\n\t\t       __func__, rcid, name);\n\t\trwref_put(&ctx->ch_state_lhb2);\n\t\tglink_core_migration_edge_unlock(if_ptr->glink_core_priv);\n\t\treturn;\n\t}\n\n\tctx->remote_opened = true;\n\tch_add_rcid(if_ptr->glink_core_priv, ctx, rcid);\n\tctx->transport_ptr = if_ptr->glink_core_priv;\n\n\tctx->remote_xprt_req = req_xprt;\n\txprt_resp = calculate_xprt_resp(ctx);\n\n\tdo_migrate = will_migrate(NULL, ctx);\n\tGLINK_INFO_CH(ctx, "%s: remote: CLOSED->OPENED ; xprt req:resp %u:%u\\n",\n\t\t\t__func__, req_xprt, xprt_resp);\n\n\tif_ptr->tx_cmd_ch_remote_open_ack(if_ptr, rcid, xprt_resp);\n\tif (!do_migrate && ch_is_fully_opened(ctx))\n\t\tctx->notify_state(ctx, ctx->user_priv, GLINK_CONNECTED);\n\n\n\tif (do_migrate)\n\t\tch_migrate(NULL, ctx);\n\trwref_put(&ctx->ch_state_lhb2);\n\tglink_core_migration_edge_unlock(if_ptr->glink_core_priv);\n}'
p1770
(dp1771
((g1673
g1767
tp1772
I1
tp1773
(dp1774
g12
g13
sg14
(dp1775
(I9
I9
tp1776
(lp1777
S'\tctx = ch_name_to_ch_ctx_create(if_ptr->glink_core_priv, name, false);'
p1778
assg32
I4
sg33
(dp1779
(I9
I9
tp1780
(lp1781
S'\tctx = ch_name_to_ch_ctx_create(if_ptr->glink_core_priv, name);'
p1782
assg41
(I1
I48
tp1783
sssssS'CVE-2019-13631'
p1784
(dp1785
(S'drivers/input/tablet/gtco.c'
p1786
S'parse_hid_report_descriptor'
p1787
tp1788
(dp1789
S'static void parse_hid_report_descriptor(struct gtco *device, char * report,\n\t\t\t\t\tint length)\n{\n\tstruct device *ddev = &device->intf->dev;\n\tint   x, i = 0;\n\n\t/* Tag primitive vars */\n\t__u8   prefix;\n\t__u8   size;\n\t__u8   tag;\n\t__u8   type;\n\t__u8   data   = 0;\n\t__u16  data16 = 0;\n\t__u32  data32 = 0;\n\n\t/* For parsing logic */\n\tint   inputnum = 0;\n\t__u32 usage = 0;\n\n\t/* Global Values, indexed by TAG */\n\t__u32 globalval[TAG_GLOB_MAX];\n\t__u32 oldval[TAG_GLOB_MAX];\n\n\t/* Debug stuff */\n\tchar  maintype = \'x\';\n\tchar  globtype[12];\n\tint   indent = 0;\n\tchar  indentstr[MAX_COLLECTION_LEVELS + 1] = { 0 };\n\n\tdev_dbg(ddev, "======>>>>>>PARSE<<<<<<======\\n");\n\n\t/* Walk  this report and pull out the info we need */\n\twhile (i < length) {\n\t\tprefix = report[i++];\n\n\t\t/* Determine data size and save the data in the proper variable */\n\t\tsize = (1U << PREF_SIZE(prefix)) >> 1;\n\t\tif (i + size > length) {\n\t\t\tdev_err(ddev,\n\t\t\t\t"Not enough data (need %d, have %d)\\n",\n\t\t\t\ti + size, length);\n\t\t\tbreak;\n\t\t}\n\n\t\tswitch (size) {\n\t\tcase 1:\n\t\t\tdata = report[i];\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tdata16 = get_unaligned_le16(&report[i]);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tdata32 = get_unaligned_le32(&report[i]);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Skip size of data */\n\t\ti += size;\n\n\t\t/* What we do depends on the tag type */\n\t\ttag  = PREF_TAG(prefix);\n\t\ttype = PREF_TYPE(prefix);\n\t\tswitch (type) {\n\t\tcase TYPE_MAIN:\n\t\t\tstrcpy(globtype, "");\n\t\t\tswitch (tag) {\n\n\t\t\tcase TAG_MAIN_INPUT:\n\t\t\t\t/*\n\t\t\t\t * The INPUT MAIN tag signifies this is\n\t\t\t\t * information from a report.  We need to\n\t\t\t\t * figure out what it is and store the\n\t\t\t\t * min/max values\n\t\t\t\t */\n\n\t\t\t\tmaintype = \'I\';\n\t\t\t\tif (data == 2)\n\t\t\t\t\tstrcpy(globtype, "Variable");\n\t\t\t\telse if (data == 3)\n\t\t\t\t\tstrcpy(globtype, "Var|Const");\n\n\t\t\t\tdev_dbg(ddev, "::::: Saving Report: %d input #%d Max: 0x%X(%d) Min:0x%X(%d) of %d bits\\n",\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_ID], inputnum,\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MAX], globalval[TAG_GLOB_LOG_MAX],\n\t\t\t\t\tglobalval[TAG_GLOB_LOG_MIN], globalval[TAG_GLOB_LOG_MIN],\n\t\t\t\t\tglobalval[TAG_GLOB_REPORT_SZ] * globalval[TAG_GLOB_REPORT_CNT]);\n\n\n\t\t\t\t/*\n\t\t\t\t  We can assume that the first two input items\n\t\t\t\t  are always the X and Y coordinates.  After\n\t\t\t\t  that, we look for everything else by\n\t\t\t\t  local usage value\n\t\t\t\t */\n\t\t\t\tswitch (inputnum) {\n\t\t\t\tcase 0:  /* X coord */\n\t\t\t\t\tdev_dbg(ddev, "GER: X Usage: 0x%x\\n", usage);\n\t\t\t\t\tif (device->max_X == 0) {\n\t\t\t\t\t\tdevice->max_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 1:  /* Y coord */\n\t\t\t\t\tdev_dbg(ddev, "GER: Y Usage: 0x%x\\n", usage);\n\t\t\t\t\tif (device->max_Y == 0) {\n\t\t\t\t\t\tdevice->max_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\tdevice->min_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t/* Tilt X */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_X) {\n\t\t\t\t\t\tif (device->maxtilt_X == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_X = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_X = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Tilt Y */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TILT_Y) {\n\t\t\t\t\t\tif (device->maxtilt_Y == 0) {\n\t\t\t\t\t\t\tdevice->maxtilt_Y = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->mintilt_Y = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Pressure */\n\t\t\t\t\tif (usage == DIGITIZER_USAGE_TIP_PRESSURE) {\n\t\t\t\t\t\tif (device->maxpressure == 0) {\n\t\t\t\t\t\t\tdevice->maxpressure = globalval[TAG_GLOB_LOG_MAX];\n\t\t\t\t\t\t\tdevice->minpressure = globalval[TAG_GLOB_LOG_MIN];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tinputnum++;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_OUTPUT:\n\t\t\t\tmaintype = \'O\';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_FEATURE:\n\t\t\t\tmaintype = \'F\';\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_START:\n\t\t\t\tmaintype = \'S\';\n\n\t\t\t\tif (indent == MAX_COLLECTION_LEVELS) {\n\t\t\t\t\tdev_err(ddev, "Collection level %d would exceed limit of %d\\n",\n\t\t\t\t\t\tindent + 1,\n\t\t\t\t\t\tMAX_COLLECTION_LEVELS);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (data == 0) {\n\t\t\t\t\tdev_dbg(ddev, "======>>>>>> Physical\\n");\n\t\t\t\t\tstrcpy(globtype, "Physical");\n\t\t\t\t} else\n\t\t\t\t\tdev_dbg(ddev, "======>>>>>>\\n");\n\n\t\t\t\t/* Indent the debug output */\n\t\t\t\tindent++;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = \'-\';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Save global tags */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\toldval[x] = globalval[x];\n\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_MAIN_COL_END:\n\t\t\t\tmaintype = \'E\';\n\n\t\t\t\tif (indent == 0) {\n\t\t\t\t\tdev_err(ddev, "Collection level already at zero\\n");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tdev_dbg(ddev, "<<<<<<======\\n");\n\n\t\t\t\tindent--;\n\t\t\t\tfor (x = 0; x < indent; x++)\n\t\t\t\t\tindentstr[x] = \'-\';\n\t\t\t\tindentstr[x] = 0;\n\n\t\t\t\t/* Copy global tags back */\n\t\t\t\tfor (x = 0; x < TAG_GLOB_MAX; x++)\n\t\t\t\t\tglobalval[x] = oldval[x];\n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, "%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, "%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, "%sMAINTAG:(%d) %c SIZE: %d Data: %s 0x%x\\n",\n\t\t\t\t\tindentstr, tag, maintype, size, globtype, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_GLOBAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\t/*\n\t\t\t\t * First time we hit the global usage tag,\n\t\t\t\t * it should tell us the type of device\n\t\t\t\t */\n\t\t\t\tif (device->usage == 0)\n\t\t\t\t\tdevice->usage = data;\n\n\t\t\t\tstrcpy(globtype, "USAGE");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, "LOG_MIN");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, "LOG_MAX");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MIN:\n\t\t\t\tstrcpy(globtype, "PHYS_MIN");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PHYS_MAX:\n\t\t\t\tstrcpy(globtype, "PHYS_MAX");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT_EXP:\n\t\t\t\tstrcpy(globtype, "EXP");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_UNIT:\n\t\t\t\tstrcpy(globtype, "UNIT");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_SZ:\n\t\t\t\tstrcpy(globtype, "REPORT_SZ");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_ID:\n\t\t\t\tstrcpy(globtype, "REPORT_ID");\n\t\t\t\t/* New report, restart numbering */\n\t\t\t\tinputnum = 0;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_REPORT_CNT:\n\t\t\t\tstrcpy(globtype, "REPORT_CNT");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_PUSH:\n\t\t\t\tstrcpy(globtype, "PUSH");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_POP:\n\t\t\t\tstrcpy(globtype, "POP");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Check to make sure we have a good tag number\n\t\t\t   so we don\'t overflow array */\n\t\t\tif (tag < TAG_GLOB_MAX) {\n\t\t\t\tswitch (size) {\n\t\t\t\tcase 1:\n\t\t\t\t\tdev_dbg(ddev, "%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data);\n\t\t\t\t\tglobalval[tag] = data;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 2:\n\t\t\t\t\tdev_dbg(ddev, "%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data16);\n\t\t\t\t\tglobalval[tag] = data16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 4:\n\t\t\t\t\tdev_dbg(ddev, "%sGLOBALTAG:%s(%d) SIZE: %d Data: 0x%x\\n",\n\t\t\t\t\t\tindentstr, globtype, tag, size, data32);\n\t\t\t\t\tglobalval[tag] = data32;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdev_dbg(ddev, "%sGLOBALTAG: ILLEGAL TAG:%d SIZE: %d\\n",\n\t\t\t\t\tindentstr, tag, size);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TYPE_LOCAL:\n\t\t\tswitch (tag) {\n\t\t\tcase TAG_GLOB_USAGE:\n\t\t\t\tstrcpy(globtype, "USAGE");\n\t\t\t\t/* Always 1 byte */\n\t\t\t\tusage = data;\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MIN:\n\t\t\t\tstrcpy(globtype, "MIN");\n\t\t\t\tbreak;\n\n\t\t\tcase TAG_GLOB_LOG_MAX:\n\t\t\t\tstrcpy(globtype, "MAX");\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tstrcpy(globtype, "UNKNOWN");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch (size) {\n\t\t\tcase 1:\n\t\t\t\tdev_dbg(ddev, "%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n",\n\t\t\t\t\tindentstr, tag, globtype, size, data);\n\t\t\t\tbreak;\n\n\t\t\tcase 2:\n\t\t\t\tdev_dbg(ddev, "%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n",\n\t\t\t\t\tindentstr, tag, globtype, size, data16);\n\t\t\t\tbreak;\n\n\t\t\tcase 4:\n\t\t\t\tdev_dbg(ddev, "%sLOCALTAG:(%d) %s SIZE: %d Data: 0x%x\\n",\n\t\t\t\t\tindentstr, tag, globtype, size, data32);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n}'
p1790
(dp1791
((g1786
g1787
tp1792
I1
tp1793
(dp1794
g12
g13
sg14
(dp1795
(I154
I160
tp1796
(lp1797
S'\t\t\t\tif (indent == MAX_COLLECTION_LEVELS) {'
p1798
aS'\t\t\t\t\tdev_err(ddev, "Collection level %d would exceed limit of %d\\n",'
p1799
aS'\t\t\t\t\t\tindent + 1,'
p1800
aS'\t\t\t\t\t\tMAX_COLLECTION_LEVELS);'
p1801
aS'\t\t\t\t\tbreak;'
p1802
aS'\t\t\t\t}'
p1803
ag59
as(I181
I188
tp1804
(lp1805
g59
aS'\t\t\t\tif (indent == 0) {'
p1806
aS'\t\t\t\t\tdev_err(ddev, "Collection level already at zero\\n");'
p1807
aS'\t\t\t\t\tbreak;'
p1808
aS'\t\t\t\t}'
p1809
ag59
aS'\t\t\t\tdev_dbg(ddev, "<<<<<<======\\n");'
p1810
ag59
as(I28
I28
tp1811
(lp1812
S'\tchar  indentstr[MAX_COLLECTION_LEVELS + 1] = { 0 };'
p1813
assg32
I3
sg33
(dp1814
(I28
I29
tp1815
(lp1816
S'\tchar  indentstr[10] = "";'
p1817
ag59
as(I180
I180
tp1818
(lp1819
S'\t\t\t\tdev_dbg(ddev, "<<<<<<======\\n");'
p1820
assg41
(I1
I348
tp1821
sssssS'CVE-2017-16939'
p1822
(dp1823
(S'net/xfrm/xfrm_user.c'
p1824
S'xfrm_user_rcv_msg'
p1825
tp1826
(dp1827
S'static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}'
p1828
(dp1829
((g1824
g1825
tp1830
I1
tp1831
(dp1832
g14
(dp1833
(I32
I32
tp1834
(lp1835
S'\t\t\t\t.start = link->start,'
p1836
assg32
I2
sg12
g13
sg41
(I1
I50
tp1837
sssS'static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}'
p1838
(dp1839
((g1824
g1825
tp1840
I1
tp1841
(dp1842
g12
g13
sg14
(dp1843
(I27
I27
tp1844
(lp1845
S'\t\t\t\t.start = link->start,'
p1846
assg32
I2
sg33
(dp1847
(I8
I12
tp1848
(lp1849
S'#ifdef CONFIG_COMPAT'
p1850
aS'\tif (in_compat_syscall())'
p1851
aS'\t\treturn -EOPNOTSUPP;'
p1852
aS'#endif'
p1853
ag59
assg41
(I1
I45
tp1854
ssss(g1824
S'xfrm_dump_policy'
p1855
tp1856
(dp1857
S'static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct xfrm_dump_info info;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}'
p1858
(dp1859
((g1824
g1855
tp1860
I1
tp1861
(dp1862
g12
g13
sg14
(dp1863
(I4
I4
tp1864
(lp1865
S'\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;'
p1866
assg32
I2
sg33
(dp1867
(I4
I4
tp1868
(lp1869
S'\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];'
p1870
as(I12
I16
tp1871
(lp1872
S'\tif (!cb->args[0]) {'
p1873
aS'\t\tcb->args[0] = 1;'
p1874
aS'\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);'
p1875
aS'\t}'
p1876
ag59
as(I7
I9
tp1877
(lp1878
S'\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >'
p1879
aS'\t\t     sizeof(cb->args) - sizeof(cb->args[0]));'
p1880
ag59
assg41
(I1
I15
tp1881
ssss(g1824
S'xfrm_dump_policy_start'
p1882
tp1883
(dp1884
s(g1824
S'xfrm_dump_policy_done'
p1885
tp1886
(dp1887
S'static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}'
p1888
(dp1889
((g1824
g1885
tp1890
I1
tp1891
(dp1892
g12
g13
sg14
(dp1893
(I3
I3
tp1894
(lp1895
S'\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;'
p1896
assg32
I1
sg33
(dp1897
(I3
I3
tp1898
(lp1899
S'\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];'
p1900
assg41
(I1
I8
tp1901
sssssS'CVE-2019-9457'
p1902
(dp1903
(S'fs/exec.c'
p1904
S'get_arg_page'
p1905
tp1906
(dp1907
S"static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\n\tif (write)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We are doing an exec().  'current' is the process\n\t * doing the exec and bprm->mm is the new process's mm.\n\t */\n\tret = get_user_pages_remote(current, bprm->mm, pos, 1, gup_flags,\n\t\t\t&page, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tunsigned long ptr_size, limit;\n\n\t\t/*\n\t\t * Since the stack will hold pointers to the strings, we\n\t\t * must account for them as well.\n\t\t *\n\t\t * The size calculation is the entire vma while each arg page is\n\t\t * built, so each time we get here it's calculating how far it\n\t\t * is currently (rather than each call being just the newly\n\t\t * added size from the arg page).  As a result, we need to\n\t\t * always add the entire size of the pointers, so that on the\n\t\t * last call to get_arg_page() we'll actually have the entire\n\t\t * correct size.\n\t\t */\n\t\tptr_size = (bprm->argc + bprm->envc) * sizeof(void *);\n\t\tif (ptr_size > ULONG_MAX - size)\n\t\t\tgoto fail;\n\t\tsize += ptr_size;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4 of the max stack size or 3/4 of _STK_LIM\n\t\t * (whichever is smaller) for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\tlimit = _STK_LIM / 4 * 3;\n\t\tlimit = min(limit, rlimit(RLIMIT_STACK) / 4);\n\t\tif (size > limit)\n\t\t\tgoto fail;\n\t}\n\n\treturn page;\n\nfail:\n\tput_page(page);\n\treturn NULL;\n}"
p1908
(dp1909
((g1904
g1905
tp1910
I1
tp1911
(dp1912
g12
g13
sg14
(dp1913
(I59
I60
tp1914
(lp1915
S'\t\t * Limit to 1/4 of the max stack size or 3/4 of _STK_LIM'
p1916
aS'\t\t * (whichever is smaller) for the argv+env strings.'
p1917
as(I66
I68
tp1918
(lp1919
S'\t\tlimit = _STK_LIM / 4 * 3;'
p1920
aS'\t\tlimit = min(limit, rlimit(RLIMIT_STACK) / 4);'
p1921
aS'\t\tif (size > limit)'
p1922
as(I30
I30
tp1923
(lp1924
S'\t\tunsigned long ptr_size, limit;'
p1925
assg32
I3
sg33
(dp1926
(I66
I67
tp1927
(lp1928
S'\t\trlim = current->signal->rlim;'
p1929
aS'\t\tif (size > READ_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4)'
p1930
as(I30
I31
tp1931
(lp1932
S'\t\tunsigned long ptr_size;'
p1933
aS'\t\tstruct rlimit *rlim;'
p1934
as(I59
I59
tp1935
(lp1936
S'\t\t * Limit to 1/4-th the stack size for the argv+env strings.'
p1937
assg41
(I1
I77
tp1938
sssssS'CVE-2019-9456'
p1939
(dp1940
(S'drivers/usb/mon/mon_text.c'
p1941
S'mon_text_read_u'
p1942
tp1943
(dp1944
S'static ssize_t mon_text_read_u(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_u(rp, &ptr, ep);\n\t\tif (ep->type == \'E\') {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tmon_text_read_isostat(rp, &ptr, ep);\n\t\t\tmon_text_read_isodesc(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\t\tmon_text_read_intstat(rp, &ptr, ep);\n\t\t} else {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t}\n\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    " %d", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}'
p1945
(dp1946
((g1941
g1942
tp1947
I1
tp1948
(dp1949
g12
g13
sg14
(dp1950
(I11
I40
tp1951
(lp1952
S'\tif (rp->printf_togo == 0) {'
p1953
ag59
aS'\t\tep = mon_text_read_wait(rp, file);'
p1954
aS'\t\tif (IS_ERR(ep)) {'
p1955
aS'\t\t\tmutex_unlock(&rp->printf_lock);'
p1956
aS'\t\t\treturn PTR_ERR(ep);'
p1957
aS'\t\t}'
p1958
aS'\t\tptr.cnt = 0;'
p1959
aS'\t\tptr.pbuf = rp->printf_buf;'
p1960
aS'\t\tptr.limit = rp->printf_size;'
p1961
ag59
aS'\t\tmon_text_read_head_u(rp, &ptr, ep);'
p1962
aS"\t\tif (ep->type == 'E') {"
p1963
aS'\t\t\tmon_text_read_statset(rp, &ptr, ep);'
p1964
aS'\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {'
p1965
aS'\t\t\tmon_text_read_isostat(rp, &ptr, ep);'
p1966
aS'\t\t\tmon_text_read_isodesc(rp, &ptr, ep);'
p1967
aS'\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {'
p1968
aS'\t\t\tmon_text_read_intstat(rp, &ptr, ep);'
p1969
aS'\t\t} else {'
p1970
aS'\t\t\tmon_text_read_statset(rp, &ptr, ep);'
p1971
aS'\t\t}'
p1972
aS'\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,'
p1973
aS'\t\t    " %d", ep->length);'
p1974
aS'\t\tmon_text_read_data(rp, &ptr, ep);'
p1975
ag59
aS'\t\trp->printf_togo = ptr.cnt;'
p1976
aS'\t\trp->printf_offset = 0;'
p1977
ag59
aS'\t\tkmem_cache_free(rp->e_slab, ep);'
p1978
as(I43
I43
tp1979
(lp1980
S'\tret = mon_text_copy_to_user(rp, buf, nbytes);'
p1981
as(I45
I45
tp1982
(lp1983
S'\treturn ret;'
p1984
as(I7
I7
tp1985
(lp1986
S'\tssize_t ret;'
p1987
as(I2
I2
tp1988
(lp1989
S'    size_t nbytes, loff_t *ppos)'
p1990
assg32
I4
sg33
(dp1991
(I9
I11
tp1992
(lp1993
S'\tep = mon_text_read_wait(rp, file);'
p1994
aS'\tif (IS_ERR(ep))'
p1995
aS'\t\treturn PTR_ERR(ep);'
p1996
as(I11
I20
tp1997
(lp1998
S'\tmon_text_read_head_u(rp, &ptr, ep);'
p1999
aS"\tif (ep->type == 'E') {"
p2000
aS'\t\tmon_text_read_statset(rp, &ptr, ep);'
p2001
aS'\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {'
p2002
aS'\t\tmon_text_read_isostat(rp, &ptr, ep);'
p2003
aS'\t\tmon_text_read_isodesc(rp, &ptr, ep);'
p2004
aS'\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {'
p2005
aS'\t\tmon_text_read_intstat(rp, &ptr, ep);'
p2006
aS'\t} else {'
p2007
aS'\t\tmon_text_read_statset(rp, &ptr, ep);'
p2008
as(I2
I2
tp2009
(lp2010
S'\t\t\t\tsize_t nbytes, loff_t *ppos)'
p2011
as(I45
I46
tp2012
(lp2013
S'\tkmem_cache_free(rp->e_slab, ep);'
p2014
aS'\treturn ptr.cnt;'
p2015
as(I43
I44
tp2016
(lp2017
S'\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))'
p2018
aS'\t\tptr.cnt = -EFAULT;'
p2019
as(I42
I44
tp2020
(lp2021
S'\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,'
p2022
aS'\t    " %d", ep->length);'
p2023
aS'\tmon_text_read_data(rp, &ptr, ep);'
p2024
as(I10
I12
tp2025
(lp2026
S'\tptr.cnt = 0;'
p2027
aS'\tptr.pbuf = rp->printf_buf;'
p2028
aS'\tptr.limit = rp->printf_size;'
p2029
assg41
(I1
I46
tp2030
ssss(g1941
S'mon_text_copy_to_user'
p2031
tp2032
(dp2033
s(g1941
S'mon_text_read_t'
p2034
tp2035
(dp2036
S'static ssize_t mon_text_read_t(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_t(rp, &ptr, ep);\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    " %d", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}'
p2037
(dp2038
((g1941
g2034
tp2039
I1
tp2040
(dp2041
g12
g13
sg14
(dp2042
(I13
I34
tp2043
(lp2044
S'\t\tep = mon_text_read_wait(rp, file);'
p2045
aS'\t\tif (IS_ERR(ep)) {'
p2046
aS'\t\t\tmutex_unlock(&rp->printf_lock);'
p2047
aS'\t\t\treturn PTR_ERR(ep);'
p2048
aS'\t\t}'
p2049
aS'\t\tptr.cnt = 0;'
p2050
aS'\t\tptr.pbuf = rp->printf_buf;'
p2051
aS'\t\tptr.limit = rp->printf_size;'
p2052
ag59
aS'\t\tmon_text_read_head_t(rp, &ptr, ep);'
p2053
aS'\t\tmon_text_read_statset(rp, &ptr, ep);'
p2054
aS'\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,'
p2055
aS'\t\t    " %d", ep->length);'
p2056
aS'\t\tmon_text_read_data(rp, &ptr, ep);'
p2057
ag59
aS'\t\trp->printf_togo = ptr.cnt;'
p2058
aS'\t\trp->printf_offset = 0;'
p2059
ag59
aS'\t\tkmem_cache_free(rp->e_slab, ep);'
p2060
aS'\t}'
p2061
ag59
aS'\tret = mon_text_copy_to_user(rp, buf, nbytes);'
p2062
as(I36
I36
tp2063
(lp2064
S'\treturn ret;'
p2065
as(I11
I11
tp2066
(lp2067
S'\tif (rp->printf_togo == 0) {'
p2068
as(I7
I7
tp2069
(lp2070
S'\tssize_t ret;'
p2071
as(I2
I2
tp2072
(lp2073
S'    size_t nbytes, loff_t *ppos)'
p2074
assg32
I4
sg33
(dp2075
(I36
I37
tp2076
(lp2077
S'\tkmem_cache_free(rp->e_slab, ep);'
p2078
aS'\treturn ptr.cnt;'
p2079
as(I9
I11
tp2080
(lp2081
S'\tep = mon_text_read_wait(rp, file);'
p2082
aS'\tif (IS_ERR(ep))'
p2083
aS'\t\treturn PTR_ERR(ep);'
p2084
as(I2
I2
tp2085
(lp2086
S'\t\t\t\tsize_t nbytes, loff_t *ppos)'
p2087
as(I13
I14
tp2088
(lp2089
S'\tif (copy_to_user(buf, rp->printf_buf, ptr.cnt))'
p2090
aS'\t\tptr.cnt = -EFAULT;'
p2091
as(I11
I15
tp2092
(lp2093
S'\tmon_text_read_head_t(rp, &ptr, ep);'
p2094
aS'\tmon_text_read_statset(rp, &ptr, ep);'
p2095
aS'\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,'
p2096
aS'\t    " %d", ep->length);'
p2097
aS'\tmon_text_read_data(rp, &ptr, ep);'
p2098
as(I10
I12
tp2099
(lp2100
S'\tptr.cnt = 0;'
p2101
aS'\tptr.pbuf = rp->printf_buf;'
p2102
aS'\tptr.limit = rp->printf_size;'
p2103
assg41
(I1
I37
tp2104
sssssS'CVE-2019-9453'
p2105
(dp2106
(S'fs/f2fs/xattr.c'
p2107
S'__f2fs_setxattr'
p2108
tp2109
(dp2110
S'static int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\n\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(xnid, inode);\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, last_base_addr, index, len, name);\n\tif (!here) {\n\t\terror = -EFAULT;\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto exit;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tinode->i_ctime = current_time(inode);\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (!error && S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\nexit:\n\tkvfree(base_addr);\n\treturn error;\n}'
p2111
(dp2112
((g2107
g2108
tp2113
I1
tp2114
(dp2115
g12
g13
sg14
(dp2116
(I31
I32
tp2117
(lp2118
S'\tlast_base_addr = (void *)base_addr + XATTR_SIZE(xnid, inode);'
p2119
ag59
as(I34
I38
tp2120
(lp2121
S'\there = __find_xattr(base_addr, last_base_addr, index, len, name);'
p2122
aS'\tif (!here) {'
p2123
aS'\t\terror = -EFAULT;'
p2124
aS'\t\tgoto exit;'
p2125
aS'\t}'
p2126
as(I6
I7
tp2127
(lp2128
S'\tvoid *base_addr, *last_base_addr;'
p2129
aS'\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;'
p2130
as(I126
I126
tp2131
(lp2132
S'\tkvfree(base_addr);'
p2133
assg32
I7
sg33
(dp2134
(I34
I34
tp2135
(lp2136
S'\there = __find_xattr(base_addr, index, len, name);'
p2137
as(I126
I126
tp2138
(lp2139
S'\tkzfree(base_addr);'
p2140
as(I6
I6
tp2141
(lp2142
S'\tvoid *base_addr;'
p2143
assg41
(I1
I128
tp2144
sssS'static int __f2fs_setxattr(struct inode *inode, int index,\n\t\t\tconst char *name, const void *value, size_t size,\n\t\t\tstruct page *ipage, int flags)\n{\n\tstruct f2fs_xattr_entry *here, *last;\n\tvoid *base_addr, *last_base_addr;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tint found, newsize;\n\tsize_t len;\n\t__u32 new_hsize;\n\tint error = 0;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tif (value == NULL)\n\t\tsize = 0;\n\n\tlen = strlen(name);\n\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tif (size > MAX_VALUE_LEN(inode))\n\t\treturn -E2BIG;\n\n\terror = read_all_xattrs(inode, ipage, &base_addr);\n\tif (error)\n\t\treturn error;\n\n\tlast_base_addr = (void *)base_addr + XATTR_SIZE(xnid, inode);\n\n\t/* find entry with wanted name. */\n\there = __find_xattr(base_addr, last_base_addr, index, len, name);\n\tif (!here) {\n\t\tf2fs_err(F2FS_I_SB(inode), "inode (%lu) has corrupted xattr",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terror = -EFSCORRUPTED;\n\t\tgoto exit;\n\t}\n\n\tfound = IS_XATTR_LAST_ENTRY(here) ? 0 : 1;\n\n\tif (found) {\n\t\tif ((flags & XATTR_CREATE)) {\n\t\t\terror = -EEXIST;\n\t\t\tgoto exit;\n\t\t}\n\n\t\tif (value && f2fs_xattr_value_same(here, value, size))\n\t\t\tgoto exit;\n\t} else if ((flags & XATTR_REPLACE)) {\n\t\terror = -ENODATA;\n\t\tgoto exit;\n\t}\n\n\tlast = here;\n\twhile (!IS_XATTR_LAST_ENTRY(last))\n\t\tlast = XATTR_NEXT_ENTRY(last);\n\n\tnewsize = XATTR_ALIGN(sizeof(struct f2fs_xattr_entry) + len + size);\n\n\t/* 1. Check space */\n\tif (value) {\n\t\tint free;\n\t\t/*\n\t\t * If value is NULL, it is remove operation.\n\t\t * In case of update operation, we calculate free.\n\t\t */\n\t\tfree = MIN_OFFSET(inode) - ((char *)last - (char *)base_addr);\n\t\tif (found)\n\t\t\tfree = free + ENTRY_SIZE(here);\n\n\t\tif (unlikely(free < newsize)) {\n\t\t\terror = -E2BIG;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* 2. Remove old entry */\n\tif (found) {\n\t\t/*\n\t\t * If entry is found, remove old entry.\n\t\t * If not found, remove operation is not needed.\n\t\t */\n\t\tstruct f2fs_xattr_entry *next = XATTR_NEXT_ENTRY(here);\n\t\tint oldsize = ENTRY_SIZE(here);\n\n\t\tmemmove(here, next, (char *)last - (char *)next);\n\t\tlast = (struct f2fs_xattr_entry *)((char *)last - oldsize);\n\t\tmemset(last, 0, oldsize);\n\t}\n\n\tnew_hsize = (char *)last - (char *)base_addr;\n\n\t/* 3. Write new entry */\n\tif (value) {\n\t\tchar *pval;\n\t\t/*\n\t\t * Before we come here, old entry is removed.\n\t\t * We just write new entry.\n\t\t */\n\t\tlast->e_name_index = index;\n\t\tlast->e_name_len = len;\n\t\tmemcpy(last->e_name, name, len);\n\t\tpval = last->e_name + len;\n\t\tmemcpy(pval, value, size);\n\t\tlast->e_value_size = cpu_to_le16(size);\n\t\tnew_hsize += newsize;\n\t}\n\n\terror = write_all_xattrs(inode, new_hsize, base_addr, ipage);\n\tif (error)\n\t\tgoto exit;\n\n\tif (is_inode_flag_set(inode, FI_ACL_MODE)) {\n\t\tinode->i_mode = F2FS_I(inode)->i_acl_mode;\n\t\tinode->i_ctime = current_time(inode);\n\t\tclear_inode_flag(inode, FI_ACL_MODE);\n\t}\n\tif (index == F2FS_XATTR_INDEX_ENCRYPTION &&\n\t\t\t!strcmp(name, F2FS_XATTR_NAME_ENCRYPTION_CONTEXT))\n\t\tf2fs_set_encrypted_inode(inode);\n\tf2fs_mark_inode_dirty_sync(inode, true);\n\tif (!error && S_ISDIR(inode->i_mode))\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_CP);\nexit:\n\tkvfree(base_addr);\n\treturn error;\n}'
p2145
(dp2146
((g2107
g2108
tp2147
I1
tp2148
(dp2149
g12
g13
sg14
(dp2150
(I31
I32
tp2151
(lp2152
S'\tlast_base_addr = (void *)base_addr + XATTR_SIZE(xnid, inode);'
p2153
ag59
as(I6
I7
tp2154
(lp2155
S'\tvoid *base_addr, *last_base_addr;'
p2156
aS'\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;'
p2157
as(I129
I129
tp2158
(lp2159
S'\tkvfree(base_addr);'
p2160
as(I34
I41
tp2161
(lp2162
S'\there = __find_xattr(base_addr, last_base_addr, index, len, name);'
p2163
aS'\tif (!here) {'
p2164
aS'\t\tf2fs_err(F2FS_I_SB(inode), "inode (%lu) has corrupted xattr",'
p2165
aS'\t\t\t\t\t\t\t\tinode->i_ino);'
p2166
aS'\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);'
p2167
aS'\t\terror = -EFSCORRUPTED;'
p2168
aS'\t\tgoto exit;'
p2169
aS'\t}'
p2170
assg32
I7
sg33
(dp2171
(I34
I34
tp2172
(lp2173
S'\there = __find_xattr(base_addr, index, len, name);'
p2174
as(I129
I129
tp2175
(lp2176
S'\tkzfree(base_addr);'
p2177
as(I6
I6
tp2178
(lp2179
S'\tvoid *base_addr;'
p2180
assg41
(I1
I131
tp2181
ssss(g2107
S'lookup_all_xattrs'
p2182
tp2183
(dp2184
S'static int lookup_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\tunsigned int index, unsigned int len,\n\t\t\t\tconst char *name, struct f2fs_xattr_entry **xe,\n\t\t\t\tvoid **base_addr, int *base_size)\n{\n\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;\n\tvoid *last_addr = NULL;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tint err = 0;\n\n\tif (!xnid && !inline_size)\n\t\treturn -ENODATA;\n\n\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;\n\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t*xe = __find_inline_xattr(inode, txattr_addr, &last_addr,\n\t\t\t\t\t\tindex, len, name);\n\t\tif (*xe) {\n\t\t\t*base_size = inline_size;\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\t/* read from xattr node block */\n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (last_addr)\n\t\tcur_addr = XATTR_HDR(last_addr) - 1;\n\telse\n\t\tcur_addr = txattr_addr;\n\n\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);\n\tif (!*xe) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\ncheck:\n\tif (IS_XATTR_LAST_ENTRY(*xe)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t*base_addr = txattr_addr;\n\treturn 0;\nout:\n\tkvfree(txattr_addr);\n\treturn err;\n}'
p2185
(dp2186
((g2107
g2182
tp2187
I1
tp2188
(dp2189
g12
g13
sg14
(dp2190
(I62
I62
tp2191
(lp2192
S'\tkvfree(txattr_addr);'
p2193
as(I6
I7
tp2194
(lp2195
S'\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;'
p2196
aS'\tvoid *last_addr = NULL;'
p2197
as(I48
I52
tp2198
(lp2199
S'\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);'
p2200
aS'\tif (!*xe) {'
p2201
aS'\t\terr = -EFAULT;'
p2202
aS'\t\tgoto out;'
p2203
aS'\t}'
p2204
as(I20
I21
tp2205
(lp2206
S'\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);'
p2207
ag59
as(I12
I12
tp2208
(lp2209
S'\tif (!xnid && !inline_size)'
p2210
as(I15
I15
tp2211
(lp2212
S'\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;'
p2213
assg32
I8
sg33
(dp2214
(I62
I62
tp2215
(lp2216
S'\tkzfree(txattr_addr);'
p2217
as(I48
I48
tp2218
(lp2219
S'\t*xe = __find_xattr(cur_addr, index, len, name);'
p2220
as(I6
I6
tp2221
(lp2222
S'\tvoid *cur_addr, *txattr_addr, *last_addr = NULL;'
p2223
as(I12
I12
tp2224
(lp2225
S'\tif (!size && !inline_size)'
p2226
as(I15
I15
tp2227
(lp2228
S'\t*base_size = inline_size + size + XATTR_PADDING_SIZE;'
p2229
as(I9
I9
tp2230
(lp2231
S'\tunsigned int size = xnid ? VALID_XATTR_BLOCK_SIZE : 0;'
p2232
assg41
(I1
I64
tp2233
sssS'static int lookup_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\tunsigned int index, unsigned int len,\n\t\t\t\tconst char *name, struct f2fs_xattr_entry **xe,\n\t\t\t\tvoid **base_addr, int *base_size)\n{\n\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;\n\tvoid *last_addr = NULL;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tint err = 0;\n\n\tif (!xnid && !inline_size)\n\t\treturn -ENODATA;\n\n\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;\n\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t*xe = __find_inline_xattr(inode, txattr_addr, &last_addr,\n\t\t\t\t\t\tindex, len, name);\n\t\tif (*xe) {\n\t\t\t*base_size = inline_size;\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\t/* read from xattr node block */\n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (last_addr)\n\t\tcur_addr = XATTR_HDR(last_addr) - 1;\n\telse\n\t\tcur_addr = txattr_addr;\n\n\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);\n\tif (!*xe) {\n\t\tf2fs_err(F2FS_I_SB(inode), "inode (%lu) has corrupted xattr",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\ncheck:\n\tif (IS_XATTR_LAST_ENTRY(*xe)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t*base_addr = txattr_addr;\n\treturn 0;\nout:\n\tkvfree(txattr_addr);\n\treturn err;\n}'
p2234
(dp2235
((g2107
g2182
tp2236
I1
tp2237
(dp2238
g12
g13
sg14
(dp2239
(I6
I7
tp2240
(lp2241
S'\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;'
p2242
aS'\tvoid *last_addr = NULL;'
p2243
as(I20
I21
tp2244
(lp2245
S'\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);'
p2246
ag59
as(I12
I12
tp2247
(lp2248
S'\tif (!xnid && !inline_size)'
p2249
as(I15
I15
tp2250
(lp2251
S'\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;'
p2252
as(I48
I55
tp2253
(lp2254
S'\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);'
p2255
aS'\tif (!*xe) {'
p2256
aS'\t\tf2fs_err(F2FS_I_SB(inode), "inode (%lu) has corrupted xattr",'
p2257
aS'\t\t\t\t\t\t\t\tinode->i_ino);'
p2258
aS'\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);'
p2259
aS'\t\terr = -EFSCORRUPTED;'
p2260
aS'\t\tgoto out;'
p2261
aS'\t}'
p2262
as(I65
I65
tp2263
(lp2264
S'\tkvfree(txattr_addr);'
p2265
assg32
I8
sg33
(dp2266
(I48
I48
tp2267
(lp2268
S'\t*xe = __find_xattr(cur_addr, index, len, name);'
p2269
as(I65
I65
tp2270
(lp2271
S'\tkzfree(txattr_addr);'
p2272
as(I6
I6
tp2273
(lp2274
S'\tvoid *cur_addr, *txattr_addr, *last_addr = NULL;'
p2275
as(I12
I12
tp2276
(lp2277
S'\tif (!size && !inline_size)'
p2278
as(I15
I15
tp2279
(lp2280
S'\t*base_size = inline_size + size + XATTR_PADDING_SIZE;'
p2281
as(I9
I9
tp2282
(lp2283
S'\tunsigned int size = xnid ? VALID_XATTR_BLOCK_SIZE : 0;'
p2284
assg41
(I1
I67
tp2285
ssss(g2107
S'__find_xattr'
p2286
tp2287
(dp2288
S'static struct f2fs_xattr_entry *__find_xattr(void *base_addr,\n\t\t\t\tvoid *last_base_addr, int index,\n\t\t\t\tsize_t len, const char *name)\n{\n\tstruct f2fs_xattr_entry *entry;\n\n\tlist_for_each_xattr(entry, base_addr) {\n\t\tif ((void *)(entry) + sizeof(__u32) > last_base_addr ||\n\t\t\t(void *)XATTR_NEXT_ENTRY(entry) > last_base_addr)\n\t\t\treturn NULL;\n\n\t\tif (entry->e_name_index != index)\n\t\t\tcontinue;\n\t\tif (entry->e_name_len != len)\n\t\t\tcontinue;\n\t\tif (!memcmp(entry->e_name, name, len))\n\t\t\tbreak;\n\t}\n\treturn entry;\n}'
p2289
(dp2290
((g2107
g2286
tp2291
I1
tp2292
(dp2293
g12
g13
sg14
(dp2294
(I8
I11
tp2295
(lp2296
S'\t\tif ((void *)(entry) + sizeof(__u32) > last_base_addr ||'
p2297
aS'\t\t\t(void *)XATTR_NEXT_ENTRY(entry) > last_base_addr)'
p2298
aS'\t\t\treturn NULL;'
p2299
ag59
as(I1
I3
tp2300
(lp2301
S'static struct f2fs_xattr_entry *__find_xattr(void *base_addr,'
p2302
aS'\t\t\t\tvoid *last_base_addr, int index,'
p2303
aS'\t\t\t\tsize_t len, const char *name)'
p2304
assg32
I5
sg33
(dp2305
(I1
I2
tp2306
(lp2307
S'static struct f2fs_xattr_entry *__find_xattr(void *base_addr, int index,'
p2308
aS'\t\t\t\t\tsize_t len, const char *name)'
p2309
assg41
(I1
I20
tp2310
sssssS'CVE-2019-10515'
p2311
(dp2312
(S'drivers/char/diag/diag_dci.c'
p2313
S'dci_lookup_client_entry_pid'
p2314
tp2315
(dp2316
S'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client)\n\t\t\tif (entry->client->tgid == tgid)\n\t\t\t\treturn entry;\n\t}\n\treturn NULL;\n}'
p2317
(dp2318
((g2313
g2314
tp2319
I1
tp2320
(dp2321
g12
g13
sg14
(dp2322
(I13
I14
tp2323
(lp2324
S'\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",'
p2325
aS'\t\t\ttgid, entry->tgid);'
p2326
assg32
I1
sg33
(dp2327
(I13
I14
tp2328
(lp2329
S'\t\t\t\t"diag: valid pid doesn\'t exist for pid = %d\\n",'
p2330
aS'\t\t\t\tentry->tgid);'
p2331
assg41
(I1
I29
tp2332
sssS'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tput_pid(pid_struct);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client) {\n\t\t\tif (entry->client->tgid == tgid) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\tput_task_struct(task_s);\n\t\tput_pid(pid_struct);\n\t}\n\treturn NULL;\n}'
p2333
(dp2334
((g2313
g2314
tp2335
I1
tp2336
(dp2337
g12
g13
sg14
(dp2338
(I13
I14
tp2339
(lp2340
S'\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",'
p2341
aS'\t\t\ttgid, entry->tgid);'
p2342
as(I30
I33
tp2343
(lp2344
S'\t\t\t}'
p2345
aS'\t\t}'
p2346
aS'\t\tput_task_struct(task_s);'
p2347
aS'\t\tput_pid(pid_struct);'
p2348
as(I25
I28
tp2349
(lp2350
S'\t\tif (task_s == entry->client) {'
p2351
aS'\t\t\tif (entry->client->tgid == tgid) {'
p2352
aS'\t\t\t\tput_task_struct(task_s);'
p2353
aS'\t\t\t\tput_pid(pid_struct);'
p2354
as(I22
I22
tp2355
(lp2356
S'\t\t\tput_pid(pid_struct);'
p2357
assg32
I1
sg33
(dp2358
(I13
I14
tp2359
(lp2360
S'\t\t\t\t"diag: valid pid doesn\'t exist for pid = %d\\n",'
p2361
aS'\t\t\t\tentry->tgid);'
p2362
as(I25
I26
tp2363
(lp2364
S'\t\tif (task_s == entry->client)'
p2365
aS'\t\t\tif (entry->client->tgid == tgid)'
p2366
assg41
(I1
I36
tp2367
ssss(S'drivers/char/diag/diagchar_core.c'
p2368
S'diagchar_read'
p2369
tp2370
(dp2371
S'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client)\n\t\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p2372
(dp2373
((g2368
g2369
tp2374
I1
tp2375
(dp2376
g33
(dp2377
(I258
I258
tp2378
(lp2379
S'\t\t\tif (entry->client->tgid != current->tgid)'
p2380
assg14
(dp2381
(I12
I13
tp2382
(lp2383
S'\tstruct pid *pid_struct = NULL;'
p2384
aS'\tstruct task_struct *task_s = NULL;'
p2385
as(I261
I270
tp2386
(lp2387
S'\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p2388
aS'\t\t\tif (!task_s) {'
p2389
aS'\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p2390
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p2391
aS'\t\t\t\tentry->tgid);'
p2392
aS'\t\t\t\tcontinue;'
p2393
aS'\t\t\t}'
p2394
aS'\t\t\tif (task_s == entry->client)'
p2395
aS'\t\t\t\tif (entry->client->tgid != current->tgid)'
p2396
aS'\t\t\t\t\tcontinue;'
p2397
as(I258
I259
tp2398
(lp2399
S'\t\t\tpid_struct = find_get_pid(entry->tgid);'
p2400
aS'\t\t\tif (!pid_struct)'
p2401
assg32
I4
sg12
g13
sg41
(I1
I310
tp2402
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client) {\n\t\t\t\tif (entry->client->tgid != current->tgid) {\n\t\t\t\t\tput_task_struct(task_s);\n\t\t\t\t\tput_pid(pid_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!entry->in_service) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tput_task_struct(task_s);\n\t\t\tput_pid(pid_struct);\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p2403
(dp2404
((g2368
g2369
tp2405
I1
tp2406
(dp2407
g33
(dp2408
(I261
I261
tp2409
(lp2410
S'\t\t\tif (!entry->in_service)'
p2411
as(I258
I258
tp2412
(lp2413
S'\t\t\tif (entry->client->tgid != current->tgid)'
p2414
assg14
(dp2415
(I308
I309
tp2416
(lp2417
S'\t\t\tput_task_struct(task_s);'
p2418
aS'\t\t\tput_pid(pid_struct);'
p2419
as(I261
I266
tp2420
(lp2421
S'\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p2422
aS'\t\t\tif (!task_s) {'
p2423
aS'\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p2424
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p2425
aS'\t\t\t\tentry->tgid);'
p2426
aS'\t\t\t\tput_pid(pid_struct);'
p2427
as(I12
I13
tp2428
(lp2429
S'\tstruct pid *pid_struct = NULL;'
p2430
aS'\tstruct task_struct *task_s = NULL;'
p2431
as(I258
I259
tp2432
(lp2433
S'\t\t\tpid_struct = find_get_pid(entry->tgid);'
p2434
aS'\t\t\tif (!pid_struct)'
p2435
as(I303
I304
tp2436
(lp2437
S'\t\t\t\tput_task_struct(task_s);'
p2438
aS'\t\t\t\tput_pid(pid_struct);'
p2439
as(I282
I283
tp2440
(lp2441
S'\t\t\t\tput_task_struct(task_s);'
p2442
aS'\t\t\t\tput_pid(pid_struct);'
p2443
as(I290
I291
tp2444
(lp2445
S'\t\t\t\tput_task_struct(task_s);'
p2446
aS'\t\t\t\tput_pid(pid_struct);'
p2447
as(I268
I280
tp2448
(lp2449
S'\t\t\t}'
p2450
aS'\t\t\tif (task_s == entry->client) {'
p2451
aS'\t\t\t\tif (entry->client->tgid != current->tgid) {'
p2452
aS'\t\t\t\t\tput_task_struct(task_s);'
p2453
aS'\t\t\t\t\tput_pid(pid_struct);'
p2454
aS'\t\t\t\t\tcontinue;'
p2455
aS'\t\t\t\t}'
p2456
aS'\t\t\t}'
p2457
aS'\t\t\tif (!entry->in_service) {'
p2458
aS'\t\t\t\tput_task_struct(task_s);'
p2459
aS'\t\t\t\tput_pid(pid_struct);'
p2460
aS'\t\t\t\tcontinue;'
p2461
aS'\t\t\t}'
p2462
assg32
I4
sg12
g13
sg41
(I1
I326
tp2463
ssss(g2368
S'diagchar_close'
p2464
tp2465
(dp2466
S'static int diagchar_close(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "diag: %s process exit with pid = %d\\n",\n\t\tcurrent->comm, current->tgid);\n\tret = diag_remove_client_entry(file);\n\n\treturn ret;\n}'
p2467
(dp2468
((g2368
g2464
tp2469
I1
tp2470
(dp2471
g12
g13
sg14
(dp2472
(I5
I6
tp2473
(lp2474
S'\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "diag: %s process exit with pid = %d\\n",'
p2475
aS'\t\tcurrent->comm, current->tgid);'
p2476
assg32
I2
sg33
(dp2477
(I5
I6
tp2478
(lp2479
S'\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "diag: process exit %s\\n",'
p2480
aS'\t\tcurrent->comm);'
p2481
assg41
(I1
I10
tp2482
sssssS'CVE-2019-9458'
p2483
(dp2484
(S'drivers/media/v4l2-core/v4l2-event.c'
p2485
S'v4l2_event_subscribe'
p2486
tp2487
(dp2488
S'int v4l2_event_subscribe(struct v4l2_fh *fh,\n\t\t\t const struct v4l2_event_subscription *sub, unsigned elems,\n\t\t\t const struct v4l2_subscribed_event_ops *ops)\n{\n\tstruct v4l2_subscribed_event *sev, *found_ev;\n\tunsigned long flags;\n\tunsigned i;\n\tint ret = 0;\n\n\tif (sub->type == V4L2_EVENT_ALL)\n\t\treturn -EINVAL;\n\n\tif (elems < 1)\n\t\telems = 1;\n\n\tsev = kzalloc(sizeof(*sev) + sizeof(struct v4l2_kevent) * elems, GFP_KERNEL);\n\tif (!sev)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < elems; i++)\n\t\tsev->events[i].sev = sev;\n\tsev->type = sub->type;\n\tsev->id = sub->id;\n\tsev->flags = sub->flags;\n\tsev->fh = fh;\n\tsev->ops = ops;\n\tsev->elems = elems;\n\n\tmutex_lock(&fh->subscribe_lock);\n\n\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);\n\tfound_ev = v4l2_event_subscribed(fh, sub->type, sub->id);\n\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);\n\n\tif (found_ev) {\n\t\t/* Already listening */\n\t\tkfree(sev);\n\t\tgoto out_unlock;\n\t}\n\n\tif (sev->ops && sev->ops->add) {\n\t\tret = sev->ops->add(sev, elems);\n\t\tif (ret) {\n\t\t\tkfree(sev);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);\n\tlist_add(&sev->list, &fh->subscribed);\n\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);\n\nout_unlock:\n\tmutex_unlock(&fh->subscribe_lock);\n\n\treturn ret;\n}'
p2489
(dp2490
((g2485
g2486
tp2491
I1
tp2492
(dp2493
g33
(dp2494
(I32
I33
tp2495
(lp2496
S'\tif (!found_ev)'
p2497
aS'\t\tlist_add(&sev->list, &fh->subscribed);'
p2498
as(I48
I49
tp2499
(lp2500
S'\t/* Mark as ready for use */'
p2501
aS'\tsev->elems = elems;'
p2502
as(I37
I37
tp2503
(lp2504
S'\t\treturn 0; /* Already listening */'
p2505
as(I55
I55
tp2506
(lp2507
S'\treturn 0;'
p2508
as(I41
I41
tp2509
(lp2510
S'\t\tint ret = sev->ops->add(sev, elems);'
p2511
as(I43
I45
tp2512
(lp2513
S'\t\t\tsev->ops = NULL;'
p2514
aS'\t\t\tv4l2_event_unsubscribe(fh, sub);'
p2515
aS'\t\t\treturn ret;'
p2516
assg14
(dp2517
(I35
I35
tp2518
(lp2519
S'\t\t/* Already listening */'
p2520
as(I8
I8
tp2521
(lp2522
S'\tint ret = 0;'
p2523
as(I48
I53
tp2524
(lp2525
S'\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);'
p2526
aS'\tlist_add(&sev->list, &fh->subscribed);'
p2527
aS'\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);'
p2528
ag59
aS'out_unlock:'
p2529
aS'\tmutex_unlock(&fh->subscribe_lock);'
p2530
as(I37
I37
tp2531
(lp2532
S'\t\tgoto out_unlock;'
p2533
as(I55
I55
tp2534
(lp2535
S'\treturn ret;'
p2536
as(I43
I44
tp2537
(lp2538
S'\t\t\tkfree(sev);'
p2539
aS'\t\t\tgoto out_unlock;'
p2540
as(I41
I41
tp2541
(lp2542
S'\t\tret = sev->ops->add(sev, elems);'
p2543
as(I26
I28
tp2544
(lp2545
S'\tsev->elems = elems;'
p2546
ag59
aS'\tmutex_lock(&fh->subscribe_lock);'
p2547
assg32
I4
sg12
g13
sg41
(I1
I56
tp2548
sssS'int v4l2_event_subscribe(struct v4l2_fh *fh,\n\t\t\t const struct v4l2_event_subscription *sub, unsigned elems,\n\t\t\t const struct v4l2_subscribed_event_ops *ops)\n{\n\tstruct v4l2_subscribed_event *sev, *found_ev;\n\tunsigned long flags;\n\tunsigned i;\n\tint ret = 0;\n\n\tif (sub->type == V4L2_EVENT_ALL)\n\t\treturn -EINVAL;\n\n\tif (elems < 1)\n\t\telems = 1;\n\n\tsev = kzalloc(sizeof(*sev) + sizeof(struct v4l2_kevent) * elems, GFP_KERNEL);\n\tif (!sev)\n\t\treturn -ENOMEM;\n\tfor (i = 0; i < elems; i++)\n\t\tsev->events[i].sev = sev;\n\tsev->type = sub->type;\n\tsev->id = sub->id;\n\tsev->flags = sub->flags;\n\tsev->fh = fh;\n\tsev->ops = ops;\n\tsev->elems = elems;\n\n\tmutex_lock(&fh->subscribe_lock);\n\n\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);\n\tfound_ev = v4l2_event_subscribed(fh, sub->type, sub->id);\n\tif (!found_ev)\n\t\tlist_add(&sev->list, &fh->subscribed);\n\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);\n\n\tif (found_ev) {\n\t\t/* Already listening */\n\t\tkfree(sev);\n\t} else if (sev->ops && sev->ops->add) {\n\t\tret = sev->ops->add(sev, elems);\n\t\tif (ret) {\n\t\t\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);\n\t\t\t__v4l2_event_unsubscribe(sev);\n\t\t\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);\n\t\t\tkfree(sev);\n\t\t}\n\t}\n\n\tmutex_unlock(&fh->subscribe_lock);\n\n\treturn ret;\n}'
p2549
(dp2550
((g2485
g2486
tp2551
I1
tp2552
(dp2553
g33
(dp2554
(I49
I50
tp2555
(lp2556
S'\t/* Mark as ready for use */'
p2557
aS'\tsev->elems = elems;'
p2558
as(I39
I43
tp2559
(lp2560
S'\t\treturn 0; /* Already listening */'
p2561
aS'\t}'
p2562
ag59
aS'\tif (sev->ops && sev->ops->add) {'
p2563
aS'\t\tint ret = sev->ops->add(sev, elems);'
p2564
as(I42
I44
tp2565
(lp2566
S'\t\t\tsev->ops = NULL;'
p2567
aS'\t\t\tv4l2_event_unsubscribe(fh, sub);'
p2568
aS'\t\t\treturn ret;'
p2569
as(I51
I51
tp2570
(lp2571
S'\treturn 0;'
p2572
assg14
(dp2573
(I8
I8
tp2574
(lp2575
S'\tint ret = 0;'
p2576
as(I37
I37
tp2577
(lp2578
S'\t\t/* Already listening */'
p2579
as(I51
I51
tp2580
(lp2581
S'\treturn ret;'
p2582
as(I42
I45
tp2583
(lp2584
S'\t\t\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);'
p2585
aS'\t\t\t__v4l2_event_unsubscribe(sev);'
p2586
aS'\t\t\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);'
p2587
aS'\t\t\tkfree(sev);'
p2588
as(I39
I40
tp2589
(lp2590
S'\t} else if (sev->ops && sev->ops->add) {'
p2591
aS'\t\tret = sev->ops->add(sev, elems);'
p2592
as(I26
I28
tp2593
(lp2594
S'\tsev->elems = elems;'
p2595
ag59
aS'\tmutex_lock(&fh->subscribe_lock);'
p2596
as(I49
I49
tp2597
(lp2598
S'\tmutex_unlock(&fh->subscribe_lock);'
p2599
assg32
I4
sg12
g13
sg41
(I1
I52
tp2600
ssss(g2485
S'v4l2_event_unsubscribe'
p2601
tp2602
(dp2603
S'int v4l2_event_unsubscribe(struct v4l2_fh *fh,\n\t\t\t   const struct v4l2_event_subscription *sub)\n{\n\tstruct v4l2_subscribed_event *sev;\n\tunsigned long flags;\n\tint i;\n\n\tif (sub->type == V4L2_EVENT_ALL) {\n\t\tv4l2_event_unsubscribe_all(fh);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&fh->subscribe_lock);\n\n\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);\n\n\tsev = v4l2_event_subscribed(fh, sub->type, sub->id);\n\tif (sev != NULL) {\n\t\t/* Remove any pending events for this subscription */\n\t\tfor (i = 0; i < sev->in_use; i++) {\n\t\t\tlist_del(&sev->events[sev_pos(sev, i)].list);\n\t\t\tfh->navailable--;\n\t\t}\n\t\tlist_del(&sev->list);\n\t}\n\n\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);\n\n\tif (sev && sev->ops && sev->ops->del)\n\t\tsev->ops->del(sev);\n\n\tmutex_unlock(&fh->subscribe_lock);\n\n\tkfree(sev);\n\n\treturn 0;\n}'
p2604
(dp2605
((g2485
g2601
tp2606
I1
tp2607
(dp2608
g14
(dp2609
(I13
I14
tp2610
(lp2611
S'\tmutex_lock(&fh->subscribe_lock);'
p2612
ag59
as(I32
I33
tp2613
(lp2614
S'\tmutex_unlock(&fh->subscribe_lock);'
p2615
ag59
assg32
I2
sg12
g13
sg41
(I1
I37
tp2616
sssS'int v4l2_event_unsubscribe(struct v4l2_fh *fh,\n\t\t\t   const struct v4l2_event_subscription *sub)\n{\n\tstruct v4l2_subscribed_event *sev;\n\tunsigned long flags;\n\n\tif (sub->type == V4L2_EVENT_ALL) {\n\t\tv4l2_event_unsubscribe_all(fh);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&fh->subscribe_lock);\n\n\tspin_lock_irqsave(&fh->vdev->fh_lock, flags);\n\n\tsev = v4l2_event_subscribed(fh, sub->type, sub->id);\n\tif (sev != NULL)\n\t\t__v4l2_event_unsubscribe(sev);\n\n\tspin_unlock_irqrestore(&fh->vdev->fh_lock, flags);\n\n\tif (sev && sev->ops && sev->ops->del)\n\t\tsev->ops->del(sev);\n\n\tmutex_unlock(&fh->subscribe_lock);\n\n\tkfree(sev);\n\n\treturn 0;\n}'
p2617
(dp2618
((g2485
g2601
tp2619
I1
tp2620
(dp2621
g12
g13
sg14
(dp2622
(I12
I13
tp2623
(lp2624
S'\tmutex_lock(&fh->subscribe_lock);'
p2625
ag59
as(I17
I18
tp2626
(lp2627
S'\tif (sev != NULL)'
p2628
aS'\t\t__v4l2_event_unsubscribe(sev);'
p2629
as(I25
I26
tp2630
(lp2631
S'\tmutex_unlock(&fh->subscribe_lock);'
p2632
ag59
assg32
I2
sg33
(dp2633
(I17
I24
tp2634
(lp2635
S'\tif (sev != NULL) {'
p2636
aS'\t\t/* Remove any pending events for this subscription */'
p2637
aS'\t\tfor (i = 0; i < sev->in_use; i++) {'
p2638
aS'\t\t\tlist_del(&sev->events[sev_pos(sev, i)].list);'
p2639
aS'\t\t\tfh->navailable--;'
p2640
aS'\t\t}'
p2641
aS'\t\tlist_del(&sev->list);'
p2642
aS'\t}'
p2643
as(I6
I6
tp2644
(lp2645
S'\tint i;'
p2646
assg41
(I1
I30
tp2647
ssss(S'drivers/media/v4l2-core/v4l2-fh.c'
p2648
S'v4l2_fh_exit'
p2649
tp2650
(dp2651
S'void v4l2_fh_exit(struct v4l2_fh *fh)\n{\n\tif (fh->vdev == NULL)\n\t\treturn;\n\tv4l_disable_media_source(fh->vdev);\n\tv4l2_event_unsubscribe_all(fh);\n\tmutex_destroy(&fh->subscribe_lock);\n\tfh->vdev = NULL;\n}'
p2652
(dp2653
((g2648
g2649
tp2654
I1
tp2655
(dp2656
g14
(dp2657
(I7
I7
tp2658
(lp2659
S'\tmutex_destroy(&fh->subscribe_lock);'
p2660
assg32
I1
sg12
g13
sg41
(I1
I9
tp2661
ssss(g2648
S'v4l2_fh_init'
p2662
tp2663
(dp2664
S'void v4l2_fh_init(struct v4l2_fh *fh, struct video_device *vdev)\n{\n\tfh->vdev = vdev;\n\t/* Inherit from video_device. May be overridden by the driver. */\n\tfh->ctrl_handler = vdev->ctrl_handler;\n\tINIT_LIST_HEAD(&fh->list);\n\tset_bit(V4L2_FL_USES_V4L2_FH, &fh->vdev->flags);\n\t/*\n\t * determine_valid_ioctls() does not know if struct v4l2_fh\n\t * is used by this driver, but here we do. So enable the\n\t * prio ioctls here.\n\t */\n\tset_bit(_IOC_NR(VIDIOC_G_PRIORITY), vdev->valid_ioctls);\n\tset_bit(_IOC_NR(VIDIOC_S_PRIORITY), vdev->valid_ioctls);\n\tfh->prio = V4L2_PRIORITY_UNSET;\n\tinit_waitqueue_head(&fh->wait);\n\tINIT_LIST_HEAD(&fh->available);\n\tINIT_LIST_HEAD(&fh->subscribed);\n\tfh->sequence = -1;\n\tmutex_init(&fh->subscribe_lock);\n}'
p2665
(dp2666
((g2648
g2662
tp2667
I1
tp2668
(dp2669
g14
(dp2670
(I20
I20
tp2671
(lp2672
S'\tmutex_init(&fh->subscribe_lock);'
p2673
assg32
I2
sg12
g13
sg41
(I1
I21
tp2674
ssss(g2485
S'__v4l2_event_queue_fh'
p2675
tp2676
(dp2677
S'static void __v4l2_event_queue_fh(struct v4l2_fh *fh, const struct v4l2_event *ev,\n\t\tconst struct timespec *ts)\n{\n\tstruct v4l2_subscribed_event *sev;\n\tstruct v4l2_kevent *kev;\n\tbool copy_payload = true;\n\n\t/* Are we subscribed? */\n\tsev = v4l2_event_subscribed(fh, ev->type, ev->id);\n\tif (sev == NULL)\n\t\treturn;\n\n\t/* Increase event sequence number on fh. */\n\tfh->sequence++;\n\n\t/* Do we have any free events? */\n\tif (sev->in_use == sev->elems) {\n\t\t/* no, remove the oldest one */\n\t\tkev = sev->events + sev_pos(sev, 0);\n\t\tlist_del(&kev->list);\n\t\tsev->in_use--;\n\t\tsev->first = sev_pos(sev, 1);\n\t\tfh->navailable--;\n\t\tif (sev->elems == 1) {\n\t\t\tif (sev->ops && sev->ops->replace) {\n\t\t\t\tsev->ops->replace(&kev->event, ev);\n\t\t\t\tcopy_payload = false;\n\t\t\t}\n\t\t} else if (sev->ops && sev->ops->merge) {\n\t\t\tstruct v4l2_kevent *second_oldest =\n\t\t\t\tsev->events + sev_pos(sev, 0);\n\t\t\tsev->ops->merge(&kev->event, &second_oldest->event);\n\t\t}\n\t}\n\n\t/* Take one and fill it. */\n\tkev = sev->events + sev_pos(sev, sev->in_use);\n\tkev->event.type = ev->type;\n\tif (copy_payload)\n\t\tkev->event.u = ev->u;\n\tkev->event.id = ev->id;\n\tkev->event.timestamp = *ts;\n\tkev->event.sequence = fh->sequence;\n\tsev->in_use++;\n\tlist_add_tail(&kev->list, &fh->available);\n\n\tfh->navailable++;\n\n\twake_up_all(&fh->wait);\n}'
p2678
(dp2679
((g2485
g2675
tp2680
I1
tp2681
(dp2682
g12
g13
sg41
(I1
I50
tp2683
sg32
I3
sg33
(dp2684
(I13
I20
tp2685
(lp2686
S'\t/*'
p2687
aS'\t * If the event has been added to the fh->subscribed list, but its'
p2688
aS'\t * add op has not completed yet elems will be 0, treat this as'
p2689
aS'\t * not being subscribed.'
p2690
aS'\t */'
p2691
aS'\tif (!sev->elems)'
p2692
aS'\t\treturn;'
p2693
ag59
assssssS'CVE-2019-2279'
p2694
(dp2695
(S'drivers/media/platform/msm/vidc/venus_hfi.c'
p2696
S'__write_queue'
p2697
tp2698
(dp2699
S'static int __write_queue(struct vidc_iface_q_info *qinfo, u8 *packet,\n\t\tbool *rx_req_is_set)\n{\n\tstruct hfi_queue_header *queue;\n\tu32 packet_size_in_words, new_write_idx;\n\tu32 empty_space, read_idx, write_idx;\n\tu32 *write_ptr;\n\n\tif (!qinfo || !packet) {\n\t\tdprintk(VIDC_ERR, "Invalid Params\\n");\n\t\treturn -EINVAL;\n\t} else if (!qinfo->q_array.align_virtual_addr) {\n\t\tdprintk(VIDC_WARN, "Queues have already been freed\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tqueue = (struct hfi_queue_header *) qinfo->q_hdr;\n\tif (!queue) {\n\t\tdprintk(VIDC_ERR, "queue not present\\n");\n\t\treturn -ENOENT;\n\t}\n\n\tif (msm_vidc_debug & VIDC_PKT) {\n\t\tdprintk(VIDC_PKT, "%s: %pK\\n", __func__, qinfo);\n\t\t__dump_packet(packet, VIDC_PKT);\n\t}\n\n\tpacket_size_in_words = (*(u32 *)packet) >> 2;\n\tif (!packet_size_in_words || packet_size_in_words >\n\t\tqinfo->q_array.mem_size>>2) {\n\t\tdprintk(VIDC_ERR, "Invalid packet size\\n");\n\t\treturn -ENODATA;\n\t}\n\n\tread_idx = queue->qhdr_read_idx;\n\twrite_idx = queue->qhdr_write_idx;\n\n\tempty_space = (write_idx >=  read_idx) ?\n\t\t((qinfo->q_array.mem_size>>2) - (write_idx -  read_idx)) :\n\t\t(read_idx - write_idx);\n\tif (empty_space <= packet_size_in_words) {\n\t\tqueue->qhdr_tx_req =  1;\n\t\tdprintk(VIDC_ERR, "Insufficient size (%d) to write (%d)\\n",\n\t\t\t\t\t  empty_space, packet_size_in_words);\n\t\treturn -ENOTEMPTY;\n\t}\n\n\tqueue->qhdr_tx_req =  0;\n\n\tnew_write_idx = write_idx + packet_size_in_words;\n\twrite_ptr = (u32 *)((qinfo->q_array.align_virtual_addr) +\n\t\t\t(write_idx << 2));\n\tif (write_ptr < (u32 *)qinfo->q_array.align_virtual_addr ||\n\t    write_ptr > (u32 *)(qinfo->q_array.align_virtual_addr +\n\t    qinfo->q_array.mem_size)) {\n\t\tdprintk(VIDC_ERR, "Invalid write index");\n\t\treturn -ENODATA;\n\t}\n\n\tif (new_write_idx < (qinfo->q_array.mem_size >> 2)) {\n\t\tmemcpy(write_ptr, packet, packet_size_in_words << 2);\n\t} else {\n\t\tnew_write_idx -= qinfo->q_array.mem_size >> 2;\n\t\tmemcpy(write_ptr, packet, (packet_size_in_words -\n\t\t\tnew_write_idx) << 2);\n\t\tmemcpy((void *)qinfo->q_array.align_virtual_addr,\n\t\t\tpacket + ((packet_size_in_words - new_write_idx) << 2),\n\t\t\tnew_write_idx  << 2);\n\t}\n\n\t/*\n\t * Memory barrier to make sure packet is written before updating the\n\t * write index\n\t */\n\tmb();\n\tqueue->qhdr_write_idx = new_write_idx;\n\tif (rx_req_is_set)\n\t\t*rx_req_is_set = queue->qhdr_rx_req == 1;\n\t/*\n\t * Memory barrier to make sure write index is updated before an\n\t * interrupt is raised on venus.\n\t */\n\tmb();\n\treturn 0;\n}'
p2700
(dp2701
((g2696
g2697
tp2702
I1
tp2703
(dp2704
g12
g13
sg14
(dp2705
(I29
I31
tp2706
(lp2707
S'\tif (!packet_size_in_words || packet_size_in_words >'
p2708
aS'\t\tqinfo->q_array.mem_size>>2) {'
p2709
aS'\t\tdprintk(VIDC_ERR, "Invalid packet size\\n");'
p2710
as(I6
I6
tp2711
(lp2712
S'\tu32 empty_space, read_idx, write_idx;'
p2713
as(I38
I40
tp2714
(lp2715
S'\tempty_space = (write_idx >=  read_idx) ?'
p2716
aS'\t\t((qinfo->q_array.mem_size>>2) - (write_idx -  read_idx)) :'
p2717
aS'\t\t(read_idx - write_idx);'
p2718
as(I50
I50
tp2719
(lp2720
S'\tnew_write_idx = write_idx + packet_size_in_words;'
p2721
as(I36
I36
tp2722
(lp2723
S'\twrite_idx = queue->qhdr_write_idx;'
p2724
as(I63
I63
tp2725
(lp2726
S'\t\tnew_write_idx -= qinfo->q_array.mem_size >> 2;'
p2727
as(I52
I60
tp2728
(lp2729
S'\t\t\t(write_idx << 2));'
p2730
aS'\tif (write_ptr < (u32 *)qinfo->q_array.align_virtual_addr ||'
p2731
aS'\t    write_ptr > (u32 *)(qinfo->q_array.align_virtual_addr +'
p2732
aS'\t    qinfo->q_array.mem_size)) {'
p2733
aS'\t\tdprintk(VIDC_ERR, "Invalid write index");'
p2734
aS'\t\treturn -ENODATA;'
p2735
aS'\t}'
p2736
ag59
aS'\tif (new_write_idx < (qinfo->q_array.mem_size >> 2)) {'
p2737
assg32
I3
sg33
(dp2738
(I52
I53
tp2739
(lp2740
S'\t\t(queue->qhdr_write_idx << 2));'
p2741
aS'\tif (new_write_idx < queue->qhdr_q_size) {'
p2742
as(I38
I40
tp2743
(lp2744
S'\tempty_space = (queue->qhdr_write_idx >=  read_idx) ?'
p2745
aS'\t\t(queue->qhdr_q_size - (queue->qhdr_write_idx -  read_idx)) :'
p2746
aS'\t\t(read_idx - queue->qhdr_write_idx);'
p2747
as(I50
I50
tp2748
(lp2749
S'\tnew_write_idx = (queue->qhdr_write_idx + packet_size_in_words);'
p2750
as(I29
I30
tp2751
(lp2752
S'\tif (!packet_size_in_words) {'
p2753
aS'\t\tdprintk(VIDC_ERR, "Zero packet size\\n");'
p2754
as(I6
I6
tp2755
(lp2756
S'\tu32 empty_space, read_idx;'
p2757
as(I63
I63
tp2758
(lp2759
S'\t\tnew_write_idx -= queue->qhdr_q_size;'
p2760
assg41
(I1
I85
tp2761
ssss(g2696
S'__read_queue'
p2762
tp2763
(dp2764
S'static int __read_queue(struct vidc_iface_q_info *qinfo, u8 *packet,\n\t\tu32 *pb_tx_req_is_set)\n{\n\tstruct hfi_queue_header *queue;\n\tu32 packet_size_in_words, new_read_idx;\n\tu32 *read_ptr;\n\tu32 receive_request = 0;\n\tu32 read_idx, write_idx;\n\tint rc = 0;\n\n\tif (!qinfo || !packet || !pb_tx_req_is_set) {\n\t\tdprintk(VIDC_ERR, "Invalid Params\\n");\n\t\treturn -EINVAL;\n\t} else if (!qinfo->q_array.align_virtual_addr) {\n\t\tdprintk(VIDC_WARN, "Queues have already been freed\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Memory barrier to make sure data is valid before\n\t *reading it\n\t */\n\tmb();\n\tqueue = (struct hfi_queue_header *) qinfo->q_hdr;\n\n\tif (!queue) {\n\t\tdprintk(VIDC_ERR, "Queue memory is not allocated\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Do not set receive request for debug queue, if set,\n\t * Venus generates interrupt for debug messages even\n\t * when there is no response message available.\n\t * In general debug queue will not become full as it\n\t * is being emptied out for every interrupt from Venus.\n\t * Venus will anyway generates interrupt if it is full.\n\t */\n\tif (queue->qhdr_type & HFI_Q_ID_CTRL_TO_HOST_MSG_Q)\n\t\treceive_request = 1;\n\n\tread_idx = queue->qhdr_read_idx;\n\twrite_idx = queue->qhdr_write_idx;\n\n\tif (read_idx == write_idx) {\n\t\tqueue->qhdr_rx_req = receive_request;\n\t\t/*\n\t\t * mb() to ensure qhdr is updated in main memory\n\t\t * so that venus reads the updated header values\n\t\t */\n\t\tmb();\n\t\t*pb_tx_req_is_set = 0;\n\t\tdprintk(VIDC_DBG,\n\t\t\t"%s queue is empty, rx_req = %u, tx_req = %u, read_idx = %u\\n",\n\t\t\treceive_request ? "message" : "debug",\n\t\t\tqueue->qhdr_rx_req, queue->qhdr_tx_req,\n\t\t\tqueue->qhdr_read_idx);\n\t\treturn -ENODATA;\n\t}\n\n\tread_ptr = (u32 *)((qinfo->q_array.align_virtual_addr) +\n\t\t\t\t(read_idx << 2));\n\tif (read_ptr < (u32 *)qinfo->q_array.align_virtual_addr ||\n\t    read_ptr > (u32 *)(qinfo->q_array.align_virtual_addr +\n\t    qinfo->q_array.mem_size - sizeof(*read_ptr))) {\n\t\tdprintk(VIDC_ERR, "Invalid read index\\n");\n\t\treturn -ENODATA;\n\t}\n\n\tpacket_size_in_words = (*read_ptr) >> 2;\n\tif (!packet_size_in_words) {\n\t\tdprintk(VIDC_ERR, "Zero packet size\\n");\n\t\treturn -ENODATA;\n\t}\n\n\tnew_read_idx = read_idx + packet_size_in_words;\n\tif (((packet_size_in_words << 2) <= VIDC_IFACEQ_VAR_HUGE_PKT_SIZE) &&\n\t\tread_idx <= (qinfo->q_array.mem_size >> 2)) {\n\t\tif (new_read_idx < (qinfo->q_array.mem_size >> 2)) {\n\t\t\tmemcpy(packet, read_ptr,\n\t\t\t\t\tpacket_size_in_words << 2);\n\t\t} else {\n\t\t\tnew_read_idx -= (qinfo->q_array.mem_size >> 2);\n\t\t\tmemcpy(packet, read_ptr,\n\t\t\t(packet_size_in_words - new_read_idx) << 2);\n\t\t\tmemcpy(packet + ((packet_size_in_words -\n\t\t\t\t\tnew_read_idx) << 2),\n\t\t\t\t\t(u8 *)qinfo->q_array.align_virtual_addr,\n\t\t\t\t\tnew_read_idx << 2);\n\t\t}\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"BAD packet received, read_idx: %#x, pkt_size: %d\\n",\n\t\t\tread_idx, packet_size_in_words << 2);\n\t\tdprintk(VIDC_WARN, "Dropping this packet\\n");\n\t\tnew_read_idx = write_idx;\n\t\trc = -ENODATA;\n\t}\n\n\tif (new_read_idx != write_idx)\n\t\tqueue->qhdr_rx_req = 0;\n\telse\n\t\tqueue->qhdr_rx_req = receive_request;\n\n\tqueue->qhdr_read_idx = new_read_idx;\n\t/*\n\t * mb() to ensure qhdr is updated in main memory\n\t * so that venus reads the updated header values\n\t */\n\tmb();\n\n\t*pb_tx_req_is_set = (queue->qhdr_tx_req == 1) ? 1 : 0;\n\n\tif ((msm_vidc_debug & VIDC_PKT) &&\n\t\t!(queue->qhdr_type & HFI_Q_ID_CTRL_TO_HOST_DEBUG_Q)) {\n\t\tdprintk(VIDC_PKT, "%s: %pK\\n", __func__, qinfo);\n\t\t__dump_packet(packet, VIDC_PKT);\n\t}\n\n\treturn rc;\n}'
p2765
(dp2766
((g2696
g2762
tp2767
I1
tp2768
(dp2769
g12
g13
sg14
(dp2770
(I8
I9
tp2771
(lp2772
S'\tu32 read_idx, write_idx;'
p2773
aS'\tint rc = 0;'
p2774
as(I104
I105
tp2775
(lp2776
g59
aS'\tqueue->qhdr_read_idx = new_read_idx;'
p2777
as(I76
I79
tp2778
(lp2779
S'\tnew_read_idx = read_idx + packet_size_in_words;'
p2780
aS'\tif (((packet_size_in_words << 2) <= VIDC_IFACEQ_VAR_HUGE_PKT_SIZE) &&'
p2781
aS'\t\tread_idx <= (qinfo->q_array.mem_size >> 2)) {'
p2782
aS'\t\tif (new_read_idx < (qinfo->q_array.mem_size >> 2)) {'
p2783
as(I96
I96
tp2784
(lp2785
S'\t\tnew_read_idx = write_idx;'
p2786
as(I83
I83
tp2787
(lp2788
S'\t\t\tnew_read_idx -= (qinfo->q_array.mem_size >> 2);'
p2789
as(I62
I69
tp2790
(lp2791
S'\t\t\t\t(read_idx << 2));'
p2792
aS'\tif (read_ptr < (u32 *)qinfo->q_array.align_virtual_addr ||'
p2793
aS'\t    read_ptr > (u32 *)(qinfo->q_array.align_virtual_addr +'
p2794
aS'\t    qinfo->q_array.mem_size - sizeof(*read_ptr))) {'
p2795
aS'\t\tdprintk(VIDC_ERR, "Invalid read index\\n");'
p2796
aS'\t\treturn -ENODATA;'
p2797
aS'\t}'
p2798
ag59
as(I94
I94
tp2799
(lp2800
S'\t\t\tread_idx, packet_size_in_words << 2);'
p2801
as(I42
I45
tp2802
(lp2803
S'\tread_idx = queue->qhdr_read_idx;'
p2804
aS'\twrite_idx = queue->qhdr_write_idx;'
p2805
ag59
aS'\tif (read_idx == write_idx) {'
p2806
as(I100
I100
tp2807
(lp2808
S'\tif (new_read_idx != write_idx)'
p2809
assg32
I3
sg33
(dp2810
(I96
I96
tp2811
(lp2812
S'\t\tnew_read_idx = queue->qhdr_write_idx;'
p2813
as(I76
I79
tp2814
(lp2815
S'\tnew_read_idx = queue->qhdr_read_idx + packet_size_in_words;'
p2816
aS'\tif (((packet_size_in_words << 2) <= VIDC_IFACEQ_VAR_HUGE_PKT_SIZE)'
p2817
aS'\t\t\t&& queue->qhdr_read_idx <= queue->qhdr_q_size) {'
p2818
aS'\t\tif (new_read_idx < queue->qhdr_q_size) {'
p2819
as(I8
I8
tp2820
(lp2821
S'\t\tint rc = 0;'
p2822
as(I83
I83
tp2823
(lp2824
S'\t\t\tnew_read_idx -= queue->qhdr_q_size;'
p2825
as(I62
I62
tp2826
(lp2827
S'\t\t\t\t(queue->qhdr_read_idx << 2));'
p2828
as(I42
I42
tp2829
(lp2830
S'\tif (queue->qhdr_read_idx == queue->qhdr_write_idx) {'
p2831
as(I94
I94
tp2832
(lp2833
S'\t\t\tqueue->qhdr_read_idx, packet_size_in_words << 2);'
p2834
as(I100
I102
tp2835
(lp2836
S'\tqueue->qhdr_read_idx = new_read_idx;'
p2837
ag59
aS'\tif (queue->qhdr_read_idx != queue->qhdr_write_idx)'
p2838
assg41
(I1
I121
tp2839
sssssS'CVE-2018-5803'
p2840
(dp2841
(S'net/sctp/sm_make_chunk.c'
p2842
S'_sctp_make_chunk'
p2843
tp2844
(dp2845
S'static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_chunkhdr_t *chunk_hdr;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tint chunklen;\n\n\tchunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);\n\tif (chunklen > SCTP_MAX_CHUNK_LEN)\n\t\tgoto nodata;\n\n\t/* No need to allocate LL here, as this is only a chunk. */\n\tskb = alloc_skb(chunklen, gfp);\n\tif (!skb)\n\t\tgoto nodata;\n\n\t/* Make room for the chunk header.  */\n\tchunk_hdr = (sctp_chunkhdr_t *)skb_put(skb, sizeof(sctp_chunkhdr_t));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(sctp_chunkhdr_t));\n\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk, gfp);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(struct sctp_chunkhdr);\n\n\t/* Determine if the chunk needs to be authenticated */\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\n\treturn retval;\nnodata:\n\treturn NULL;\n}'
p2846
(dp2847
((g2842
g2843
tp2848
I1
tp2849
(dp2850
g33
(dp2851
(I16
I16
tp2852
(lp2853
S'\tskb = alloc_skb(SCTP_PAD4(sizeof(sctp_chunkhdr_t) + paylen), gfp);'
p2854
assg14
(dp2855
(I9
I13
tp2856
(lp2857
S'\tint chunklen;'
p2858
ag59
aS'\tchunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);'
p2859
aS'\tif (chunklen > SCTP_MAX_CHUNK_LEN)'
p2860
aS'\t\tgoto nodata;'
p2861
as(I16
I16
tp2862
(lp2863
S'\tskb = alloc_skb(chunklen, gfp);'
p2864
assg32
I5
sg12
g13
sg41
(I1
I43
tp2865
sssssS'CVE-2019-13272'
p2866
(dp2867
(S'kernel/ptrace.c'
p2868
S'ptrace_link'
p2869
tp2870
(dp2871
S'static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n\t__ptrace_link(child, new_parent, current_cred());\n}'
p2872
(dp2873
((g2868
g2869
tp2874
I1
tp2875
(dp2876
g12
g13
sg14
(dp2877
(I3
I3
tp2878
(lp2879
S'\t__ptrace_link(child, new_parent, current_cred());'
p2880
assg32
I2
sg33
(dp2881
(I3
I5
tp2882
(lp2883
S'\trcu_read_lock();'
p2884
aS'\t__ptrace_link(child, new_parent, __task_cred(new_parent));'
p2885
aS'\trcu_read_unlock();'
p2886
assg41
(I1
I4
tp2887
sssssS'CVE-2018-12011'
p2888
(dp2889
(S'net/ipc_router/ipc_router_socket.c'
p2890
S'msm_ipc_router_extract_msg'
p2891
tp2892
(dp2893
S'static int msm_ipc_router_extract_msg(struct msghdr *m,\n\t\t\t\t      struct rr_packet *pkt)\n{\n\tstruct sockaddr_msm_ipc *addr;\n\tstruct rr_header_v1 *hdr;\n\tstruct sk_buff *temp;\n\tunion rr_control_msg *ctl_msg;\n\tint offset = 0, data_len = 0, copy_len, copied_len;\n\n\tif (!m || !pkt) {\n\t\tIPC_RTR_ERR("%s: Invalid pointers passed\\n", __func__);\n\t\treturn -EINVAL;\n\t}\n\taddr = (struct sockaddr_msm_ipc *)m->msg_name;\n\n\thdr = &pkt->hdr;\n\tif (addr && (hdr->type == IPC_ROUTER_CTRL_CMD_RESUME_TX)) {\n\t\ttemp = skb_peek(pkt->pkt_fragment_q);\n\t\tif (!temp || !temp->data) {\n\t\t\tIPC_RTR_ERR("%s: Invalid skb\\n", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctl_msg = (union rr_control_msg *)(temp->data);\n\t\tmemset(addr, 0x0, sizeof(*addr));\n\t\taddr->family = AF_MSM_IPC;\n\t\taddr->address.addrtype = MSM_IPC_ADDR_ID;\n\t\taddr->address.addr.port_addr.node_id = ctl_msg->cli.node_id;\n\t\taddr->address.addr.port_addr.port_id = ctl_msg->cli.port_id;\n\t\tm->msg_namelen = sizeof(struct sockaddr_msm_ipc);\n\t\treturn offset;\n\t}\n\tif (addr && (hdr->type == IPC_ROUTER_CTRL_CMD_DATA)) {\n\t\tmemset(addr, 0x0, sizeof(*addr));\n\t\taddr->family = AF_MSM_IPC;\n\t\taddr->address.addrtype = MSM_IPC_ADDR_ID;\n\t\taddr->address.addr.port_addr.node_id = hdr->src_node_id;\n\t\taddr->address.addr.port_addr.port_id = hdr->src_port_id;\n\t\tm->msg_namelen = sizeof(struct sockaddr_msm_ipc);\n\t}\n\n\tdata_len = hdr->size;\n\tskb_queue_walk(pkt->pkt_fragment_q, temp) {\n\t\tcopy_len = data_len < temp->len ? data_len : temp->len;\n\t\tcopied_len = copy_to_iter(temp->data, copy_len, &m->msg_iter);\n\t\tif (copy_len != copied_len) {\n\t\t\tIPC_RTR_ERR("%s: Copy to user failed\\n", __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\toffset += copy_len;\n\t\tdata_len -= copy_len;\n\t}\n\treturn offset;\n}'
p2894
(dp2895
((g2890
g2891
tp2896
I1
tp2897
(dp2898
g14
(dp2899
(I24
I24
tp2900
(lp2901
S'\t\tmemset(addr, 0x0, sizeof(*addr));'
p2902
as(I33
I33
tp2903
(lp2904
S'\t\tmemset(addr, 0x0, sizeof(*addr));'
p2905
assg32
I2
sg12
g13
sg41
(I1
I53
tp2906
sssssS'CVE-2019-14088'
p2907
(dp2908
(S'drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c'
p2909
S'__cam_req_mgr_reserve_link'
p2910
tp2911
(dp2912
S'static struct cam_req_mgr_core_link *__cam_req_mgr_reserve_link(\n\tstruct cam_req_mgr_core_session *session)\n{\n\tstruct cam_req_mgr_core_link *link;\n\tstruct cam_req_mgr_req_queue *in_q;\n\tint i;\n\n\tif (!session || !g_crm_core_dev) {\n\t\tCAM_ERR(CAM_CRM, "NULL session/core_dev ptr");\n\t\treturn NULL;\n\t}\n\n\tif (session->num_links >= MAXIMUM_LINKS_PER_SESSION) {\n\t\tCAM_ERR(CAM_CRM, "Reached max links %d per session limit %d",\n\t\t\tsession->num_links, MAXIMUM_LINKS_PER_SESSION);\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < MAXIMUM_LINKS_PER_SESSION; i++) {\n\t\tif (!atomic_cmpxchg(&g_links[i].is_used, 0, 1)) {\n\t\t\tlink = &g_links[i];\n\t\t\tCAM_DBG(CAM_CRM, "alloc link index %d", i);\n\t\t\tcam_req_mgr_core_link_reset(link);\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (i == MAXIMUM_LINKS_PER_SESSION)\n\t\treturn NULL;\n\n\tin_q = (struct cam_req_mgr_req_queue *)\n\t\tkzalloc(sizeof(struct cam_req_mgr_req_queue), GFP_KERNEL);\n\tif (!in_q) {\n\t\tCAM_ERR(CAM_CRM, "failed to create input queue, no mem");\n\t\treturn NULL;\n\t}\n\n\tmutex_lock(&link->lock);\n\tlink->num_devs = 0;\n\tlink->max_delay = 0;\n\tmemset(in_q->slot, 0,\n\t\tsizeof(struct cam_req_mgr_slot) * MAX_REQ_SLOTS);\n\tlink->req.in_q = in_q;\n\tin_q->num_slots = 0;\n\tlink->state = CAM_CRM_LINK_STATE_IDLE;\n\tlink->parent = (void *)session;\n\tlink->sync_link = NULL;\n\tmutex_unlock(&link->lock);\n\n\tmutex_lock(&session->lock);\n\t/*  Loop through and find a free index */\n\tfor (i = 0; i < MAXIMUM_LINKS_PER_SESSION; i++) {\n\t\tif (!session->links[i]) {\n\t\t\tCAM_DBG(CAM_CRM,\n\t\t\t\t"Free link index %d found, num_links=%d",\n\t\t\t\ti, session->num_links);\n\t\t\tsession->links[i] = link;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (i == MAXIMUM_LINKS_PER_SESSION) {\n\t\tCAM_ERR(CAM_CRM, "Free link index not found");\n\t\tgoto error;\n\t}\n\n\tsession->num_links++;\n\tCAM_DBG(CAM_CRM, "Active session links (%d)",\n\t\tsession->num_links);\n\tmutex_unlock(&session->lock);\n\n\treturn link;\nerror:\n\tmutex_unlock(&session->lock);\n\tkfree(in_q);\n\treturn NULL;\n}'
p2913
(dp2914
((g2909
g2910
tp2915
I1
tp2916
(dp2917
g12
g13
sg14
(dp2918
(I18
I24
tp2919
(lp2920
S'\tfor (i = 0; i < MAXIMUM_LINKS_PER_SESSION; i++) {'
p2921
aS'\t\tif (!atomic_cmpxchg(&g_links[i].is_used, 0, 1)) {'
p2922
aS'\t\t\tlink = &g_links[i];'
p2923
aS'\t\t\tCAM_DBG(CAM_CRM, "alloc link index %d", i);'
p2924
aS'\t\t\tcam_req_mgr_core_link_reset(link);'
p2925
aS'\t\t\tbreak;'
p2926
aS'\t\t}'
p2927
as(I26
I28
tp2928
(lp2929
S'\tif (i == MAXIMUM_LINKS_PER_SESSION)'
p2930
aS'\t\treturn NULL;'
p2931
ag59
assg32
I1
sg33
(dp2932
(I18
I23
tp2933
(lp2934
g59
aS'\tlink = (struct cam_req_mgr_core_link *)'
p2935
aS'\t\tkzalloc(sizeof(struct cam_req_mgr_core_link), GFP_KERNEL);'
p2936
aS'\tif (!link) {'
p2937
aS'\t\tCAM_ERR(CAM_CRM, "failed to create link, no mem");'
p2938
aS'\t\treturn NULL;'
p2939
as(I73
I73
tp2940
(lp2941
S'\tkfree(link);'
p2942
as(I35
I36
tp2943
(lp2944
S'\tmutex_init(&link->lock);'
p2945
aS'\tspin_lock_init(&link->link_state_spin_lock);'
p2946
as(I33
I33
tp2947
(lp2948
S'\t\tkfree(link);'
p2949
as(I37
I37
tp2950
(lp2951
S'\tlink->state = CAM_CRM_LINK_STATE_AVAILABLE;'
p2952
assg41
(I1
I75
tp2953
sssssS'CVE-2019-14034'
p2954
(dp2955
(S'drivers/media/platform/msm/camera/cam_sensor_module/cam_eeprom/cam_eeprom_core.c'
p2956
S'cam_eeprom_driver_cmd'
p2957
tp2958
(dp2959
S'int32_t cam_eeprom_driver_cmd(struct cam_eeprom_ctrl_t *e_ctrl, void *arg)\n{\n\tint                            rc = 0;\n\tstruct cam_eeprom_query_cap_t  eeprom_cap = {0};\n\tstruct cam_control            *cmd = (struct cam_control *)arg;\n\n\tif (!e_ctrl || !cmd) {\n\t\tCAM_ERR(CAM_EEPROM, "Invalid Arguments");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\tCAM_ERR(CAM_EEPROM, "Invalid handle type: %d",\n\t\t\tcmd->handle_type);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&(e_ctrl->eeprom_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_QUERY_CAP:\n\t\teeprom_cap.slot_info = e_ctrl->soc_info.index;\n\t\tif (e_ctrl->userspace_probe == false)\n\t\t\teeprom_cap.eeprom_kernel_probe = true;\n\t\telse\n\t\t\teeprom_cap.eeprom_kernel_probe = false;\n\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&eeprom_cap,\n\t\t\tsizeof(struct cam_eeprom_query_cap_t))) {\n\t\t\tCAM_ERR(CAM_EEPROM, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tCAM_DBG(CAM_EEPROM, "eeprom_cap: ID: %d", eeprom_cap.slot_info);\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV:\n\t\trc = cam_eeprom_get_dev_handle(e_ctrl, arg);\n\t\tif (rc) {\n\t\t\tCAM_ERR(CAM_EEPROM, "Failed to acquire dev");\n\t\t\tgoto release_mutex;\n\t\t}\n\t\te_ctrl->cam_eeprom_state = CAM_EEPROM_ACQUIRE;\n\t\tbreak;\n\tcase CAM_RELEASE_DEV:\n\t\tif (e_ctrl->cam_eeprom_state != CAM_EEPROM_ACQUIRE) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_EEPROM,\n\t\t\t"Not in right state to release : %d",\n\t\t\te_ctrl->cam_eeprom_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (e_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_EEPROM,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\te_ctrl->bridge_intf.device_hdl,\n\t\t\t\te_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(e_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_EEPROM,\n\t\t\t\t"failed in destroying the device hdl");\n\t\te_ctrl->bridge_intf.device_hdl = -1;\n\t\te_ctrl->bridge_intf.link_hdl = -1;\n\t\te_ctrl->bridge_intf.session_hdl = -1;\n\t\te_ctrl->cam_eeprom_state = CAM_EEPROM_INIT;\n\t\tbreak;\n\tcase CAM_CONFIG_DEV:\n\t\trc = cam_eeprom_pkt_parse(e_ctrl, arg);\n\t\tif (rc) {\n\t\t\tCAM_ERR(CAM_EEPROM, "Failed in eeprom pkt Parsing");\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_DBG(CAM_EEPROM, "invalid opcode");\n\t\tbreak;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(e_ctrl->eeprom_mutex));\n\n\treturn rc;\n}'
p2960
(dp2961
((g2956
g2957
tp2962
I1
tp2963
(dp2964
g12
g13
sg14
(dp2965
(I31
I31
tp2966
(lp2967
S'\t\t\trc = -EFAULT;'
p2968
assg32
I2
sg33
(dp2969
(I31
I31
tp2970
(lp2971
S'\t\t\treturn -EFAULT;'
p2972
assg41
(I1
I86
tp2973
sssssS'CVE-2019-11477'
p2974
(dp2975
(S'net/ipv4/tcp_input.c'
p2976
S'tcp_shift_skb_data'
p2977
tp2978
(dp2979
S"static struct sk_buff *tcp_shift_skb_data(struct sock *sk, struct sk_buff *skb,\n\t\t\t\t\t  struct tcp_sacktag_state *state,\n\t\t\t\t\t  u32 start_seq, u32 end_seq,\n\t\t\t\t\t  bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev;\n\tint mss;\n\tint next_pcount;\n\tint pcount = 0;\n\tint len;\n\tint in_sack;\n\n\tif (!sk_can_gso(sk))\n\t\tgoto fallback;\n\n\t/* Normally R but no L won't result in plain S */\n\tif (!dup_sack &&\n\t    (TCP_SKB_CB(skb)->sacked & (TCPCB_LOST|TCPCB_SACKED_RETRANS)) == TCPCB_SACKED_RETRANS)\n\t\tgoto fallback;\n\tif (!skb_can_shift(skb))\n\t\tgoto fallback;\n\t/* This frame is about to be dropped (was ACKed). */\n\tif (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una))\n\t\tgoto fallback;\n\n\t/* Can only happen with delayed DSACK + discard craziness */\n\tif (unlikely(skb == tcp_write_queue_head(sk)))\n\t\tgoto fallback;\n\tprev = tcp_write_queue_prev(sk, skb);\n\n\tif ((TCP_SKB_CB(prev)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED)\n\t\tgoto fallback;\n\n\tif (!tcp_skb_can_collapse_to(prev))\n\t\tgoto fallback;\n\n\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq) &&\n\t\t  !before(end_seq, TCP_SKB_CB(skb)->end_seq);\n\n\tif (in_sack) {\n\t\tlen = skb->len;\n\t\tpcount = tcp_skb_pcount(skb);\n\t\tmss = tcp_skb_seglen(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\t} else {\n\t\tif (!after(TCP_SKB_CB(skb)->end_seq, start_seq))\n\t\t\tgoto noop;\n\t\t/* CHECKME: This is non-MSS split case only?, this will\n\t\t * cause skipped skbs due to advancing loop btw, original\n\t\t * has that feature too\n\t\t */\n\t\tif (tcp_skb_pcount(skb) <= 1)\n\t\t\tgoto noop;\n\n\t\tin_sack = !after(start_seq, TCP_SKB_CB(skb)->seq);\n\t\tif (!in_sack) {\n\t\t\t/* TODO: head merge to next could be attempted here\n\t\t\t * if (!after(TCP_SKB_CB(skb)->end_seq, end_seq)),\n\t\t\t * though it might not be worth of the additional hassle\n\t\t\t *\n\t\t\t * ...we can probably just fallback to what was done\n\t\t\t * previously. We could try merging non-SACKed ones\n\t\t\t * as well but it probably isn't going to buy off\n\t\t\t * because later SACKs might again split them, and\n\t\t\t * it would make skb timestamp tracking considerably\n\t\t\t * harder problem.\n\t\t\t */\n\t\t\tgoto fallback;\n\t\t}\n\n\t\tlen = end_seq - TCP_SKB_CB(skb)->seq;\n\t\tBUG_ON(len < 0);\n\t\tBUG_ON(len > skb->len);\n\n\t\t/* MSS boundaries should be honoured or else pcount will\n\t\t * severely break even though it makes things bit trickier.\n\t\t * Optimize common case to avoid most of the divides\n\t\t */\n\t\tmss = tcp_skb_mss(skb);\n\n\t\t/* TODO: Fix DSACKs to not fragment already SACKed and we can\n\t\t * drop this restriction as unnecessary\n\t\t */\n\t\tif (mss != tcp_skb_seglen(prev))\n\t\t\tgoto fallback;\n\n\t\tif (len == mss) {\n\t\t\tpcount = 1;\n\t\t} else if (len < mss) {\n\t\t\tgoto noop;\n\t\t} else {\n\t\t\tpcount = len / mss;\n\t\t\tlen = pcount * mss;\n\t\t}\n\t}\n\n\t/* tcp_sacktag_one() won't SACK-tag ranges below snd_una */\n\tif (!after(TCP_SKB_CB(skb)->seq + len, tp->snd_una))\n\t\tgoto fallback;\n\n\tif (!tcp_skb_shift(prev, skb, pcount, len))\n\t\tgoto fallback;\n\tif (!tcp_shifted_skb(sk, skb, state, pcount, len, mss, dup_sack))\n\t\tgoto out;\n\n\t/* Hole filled allows collapsing with the next as well, this is very\n\t * useful when hole on every nth skb pattern happens\n\t */\n\tif (prev == tcp_write_queue_tail(sk))\n\t\tgoto out;\n\tskb = tcp_write_queue_next(sk, prev);\n\n\tif (!skb_can_shift(skb) ||\n\t    (skb == tcp_send_head(sk)) ||\n\t    ((TCP_SKB_CB(skb)->sacked & TCPCB_TAGBITS) != TCPCB_SACKED_ACKED) ||\n\t    (mss != tcp_skb_seglen(skb)))\n\t\tgoto out;\n\n\tlen = skb->len;\n\tnext_pcount = tcp_skb_pcount(skb);\n\tif (tcp_skb_shift(prev, skb, next_pcount, len)) {\n\t\tpcount += next_pcount;\n\t\ttcp_shifted_skb(sk, skb, state, next_pcount, len, mss, 0);\n\t}\nout:\n\tstate->fack_count += pcount;\n\treturn prev;\n\nnoop:\n\treturn skb;\n\nfallback:\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTFALLBACK);\n\treturn NULL;\n}"
p2980
(dp2981
((g2976
g2977
tp2982
I1
tp2983
(dp2984
g33
(dp2985
(I131
I131
tp2986
(lp2987
g59
as(I107
I107
tp2988
(lp2989
S'\tif (!skb_shift(prev, skb, len))'
p2990
as(I126
I128
tp2991
(lp2992
S'\tif (skb_shift(prev, skb, len)) {'
p2993
aS'\t\tpcount += tcp_skb_pcount(skb);'
p2994
aS'\t\ttcp_shifted_skb(sk, skb, state, tcp_skb_pcount(skb), len, mss, 0);'
p2995
assg14
(dp2996
(I126
I129
tp2997
(lp2998
S'\tnext_pcount = tcp_skb_pcount(skb);'
p2999
aS'\tif (tcp_skb_shift(prev, skb, next_pcount, len)) {'
p3000
aS'\t\tpcount += next_pcount;'
p3001
aS'\t\ttcp_shifted_skb(sk, skb, state, next_pcount, len, mss, 0);'
p3002
as(I9
I9
tp3003
(lp3004
S'\tint next_pcount;'
p3005
as(I107
I107
tp3006
(lp3007
S'\tif (!tcp_skb_shift(prev, skb, pcount, len))'
p3008
assg32
I6
sg12
g13
sg41
(I1
I141
tp3009
ssss(S'net/ipv4/tcp.c'
p3010
S'tcp_init'
p3011
tp3012
(dp3013
S'void __init tcp_init(void)\n{\n\tint max_rshare, max_wshare, cnt;\n\tunsigned long limit;\n\tunsigned int i;\n\n\tBUILD_BUG_ON(TCP_MIN_SND_MSS <= MAX_TCP_OPTION_SPACE);\n\tBUILD_BUG_ON(sizeof(struct tcp_skb_cb) >\n\t\t     FIELD_SIZEOF(struct sk_buff, cb));\n\n\tpercpu_counter_init(&tcp_sockets_allocated, 0, GFP_KERNEL);\n\tpercpu_counter_init(&tcp_orphan_count, 0, GFP_KERNEL);\n\ttcp_hashinfo.bind_bucket_cachep =\n\t\tkmem_cache_create("tcp_bind_bucket",\n\t\t\t\t  sizeof(struct inet_bind_bucket), 0,\n\t\t\t\t  SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL);\n\n\t/* Size and allocate the main established and bind bucket\n\t * hash tables.\n\t *\n\t * The methodology is similar to that of the buffer cache.\n\t */\n\ttcp_hashinfo.ehash =\n\t\talloc_large_system_hash("TCP established",\n\t\t\t\t\tsizeof(struct inet_ehash_bucket),\n\t\t\t\t\tthash_entries,\n\t\t\t\t\t17, /* one slot per 128 KB of memory */\n\t\t\t\t\t0,\n\t\t\t\t\tNULL,\n\t\t\t\t\t&tcp_hashinfo.ehash_mask,\n\t\t\t\t\t0,\n\t\t\t\t\tthash_entries ? 0 : 512 * 1024);\n\tfor (i = 0; i <= tcp_hashinfo.ehash_mask; i++)\n\t\tINIT_HLIST_NULLS_HEAD(&tcp_hashinfo.ehash[i].chain, i);\n\n\tif (inet_ehash_locks_alloc(&tcp_hashinfo))\n\t\tpanic("TCP: failed to alloc ehash_locks");\n\ttcp_hashinfo.bhash =\n\t\talloc_large_system_hash("TCP bind",\n\t\t\t\t\tsizeof(struct inet_bind_hashbucket),\n\t\t\t\t\ttcp_hashinfo.ehash_mask + 1,\n\t\t\t\t\t17, /* one slot per 128 KB of memory */\n\t\t\t\t\t0,\n\t\t\t\t\t&tcp_hashinfo.bhash_size,\n\t\t\t\t\tNULL,\n\t\t\t\t\t0,\n\t\t\t\t\t64 * 1024);\n\ttcp_hashinfo.bhash_size = 1U << tcp_hashinfo.bhash_size;\n\tfor (i = 0; i < tcp_hashinfo.bhash_size; i++) {\n\t\tspin_lock_init(&tcp_hashinfo.bhash[i].lock);\n\t\tINIT_HLIST_HEAD(&tcp_hashinfo.bhash[i].chain);\n\t}\n\n\n\tcnt = tcp_hashinfo.ehash_mask + 1;\n\n\ttcp_death_row.sysctl_max_tw_buckets = cnt / 2;\n\tsysctl_tcp_max_orphans = cnt / 2;\n\tsysctl_max_syn_backlog = max(128, cnt / 256);\n\n\ttcp_init_mem();\n\t/* Set per-socket limits to no more than 1/128 the pressure threshold */\n\tlimit = nr_free_buffer_pages() << (PAGE_SHIFT - 7);\n\tmax_wshare = min(4UL*1024*1024, limit);\n\tmax_rshare = min(6UL*1024*1024, limit);\n\n\tsysctl_tcp_wmem[0] = SK_MEM_QUANTUM;\n\tsysctl_tcp_wmem[1] = 16*1024;\n\tsysctl_tcp_wmem[2] = max(64*1024, max_wshare);\n\n\tsysctl_tcp_rmem[0] = SK_MEM_QUANTUM;\n\tsysctl_tcp_rmem[1] = 87380;\n\tsysctl_tcp_rmem[2] = max(87380, max_rshare);\n\n\tpr_info("Hash tables configured (established %u bind %u)\\n",\n\t\ttcp_hashinfo.ehash_mask + 1, tcp_hashinfo.bhash_size);\n\n\ttcp_metrics_init();\n\tBUG_ON(tcp_register_congestion_control(&tcp_reno) != 0);\n\ttcp_tasklet_init();\n}'
p3014
(dp3015
((g3010
g3011
tp3016
I1
tp3017
(dp3018
g14
(dp3019
(I7
I7
tp3020
(lp3021
S'\tBUILD_BUG_ON(TCP_MIN_SND_MSS <= MAX_TCP_OPTION_SPACE);'
p3022
assg32
I1
sg12
g13
sg41
(I1
I81
tp3023
ssss(S'net/ipv4/tcp_output.c'
p3024
S'tcp_collapse_retrans'
p3025
tp3026
(dp3027
s(g3024
S'__tcp_mtu_to_mss'
p3028
tp3029
(dp3030
S'static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint mss_now;\n\n\t/* Calculate base mss without TCP options:\n\t   It is MMS_S - sizeof(tcphdr) of rfc1122\n\t */\n\tmss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);\n\n\t/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */\n\tif (icsk->icsk_af_ops->net_frag_header_len) {\n\t\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\t\tif (dst && dst_allfrag(dst))\n\t\t\tmss_now -= icsk->icsk_af_ops->net_frag_header_len;\n\t}\n\n\t/* Clamp it (mss_clamp does not include tcp options) */\n\tif (mss_now > tp->rx_opt.mss_clamp)\n\t\tmss_now = tp->rx_opt.mss_clamp;\n\n\t/* Now subtract optional transport overhead */\n\tmss_now -= icsk->icsk_ext_hdr_len;\n\n\t/* Then reserve room for full set of TCP options and 8 bytes of data */\n\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);\n\treturn mss_now;\n}'
p3031
(dp3032
((g3024
g3028
tp3033
I1
tp3034
(dp3035
g12
g13
sg14
(dp3036
(I28
I28
tp3037
(lp3038
S'\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);'
p3039
assg32
I2
sg33
(dp3040
(I28
I29
tp3041
(lp3042
S'\tif (mss_now < 48)'
p3043
aS'\t\tmss_now = 48;'
p3044
assg41
(I1
I30
tp3045
ssss(g2976
S'tcp_shifted_skb'
p3046
tp3047
(dp3048
S"static bool tcp_shifted_skb(struct sock *sk, struct sk_buff *skb,\n\t\t\t    struct tcp_sacktag_state *state,\n\t\t\t    unsigned int pcount, int shifted, int mss,\n\t\t\t    bool dup_sack)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *prev = tcp_write_queue_prev(sk, skb);\n\tu32 start_seq = TCP_SKB_CB(skb)->seq;\t/* start of newly-SACKed */\n\tu32 end_seq = start_seq + shifted;\t/* end of newly-SACKed */\n\n\tBUG_ON(!pcount);\n\n\t/* Adjust counters and hints for the newly sacked sequence\n\t * range but discard the return value since prev is already\n\t * marked. We must tag the range first because the seq\n\t * advancement below implicitly advances\n\t * tcp_highest_sack_seq() when skb is highest_sack.\n\t */\n\ttcp_sacktag_one(sk, state, TCP_SKB_CB(skb)->sacked,\n\t\t\tstart_seq, end_seq, dup_sack, pcount,\n\t\t\t&skb->skb_mstamp);\n\ttcp_rate_skb_delivered(sk, skb, state->rate);\n\n\tif (skb == tp->lost_skb_hint)\n\t\ttp->lost_cnt_hint += pcount;\n\n\tTCP_SKB_CB(prev)->end_seq += shifted;\n\tTCP_SKB_CB(skb)->seq += shifted;\n\n\ttcp_skb_pcount_add(prev, pcount);\n\tWARN_ON_ONCE(tcp_skb_pcount(skb) < pcount);\n\ttcp_skb_pcount_add(skb, -pcount);\n\n\t/* When we're adding to gso_segs == 1, gso_size will be zero,\n\t * in theory this shouldn't be necessary but as long as DSACK\n\t * code can come after this skb later on it's better to keep\n\t * setting gso_size to something.\n\t */\n\tif (!TCP_SKB_CB(prev)->tcp_gso_size)\n\t\tTCP_SKB_CB(prev)->tcp_gso_size = mss;\n\n\t/* CHECKME: To clear or not to clear? Mimics normal skb currently */\n\tif (tcp_skb_pcount(skb) <= 1)\n\t\tTCP_SKB_CB(skb)->tcp_gso_size = 0;\n\n\t/* Difference in this won't matter, both ACKed by the same cumul. ACK */\n\tTCP_SKB_CB(prev)->sacked |= (TCP_SKB_CB(skb)->sacked & TCPCB_EVER_RETRANS);\n\n\tif (skb->len > 0) {\n\t\tBUG_ON(!tcp_skb_pcount(skb));\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKSHIFTED);\n\t\treturn false;\n\t}\n\n\t/* Whole SKB was eaten :-) */\n\n\tif (skb == tp->retransmit_skb_hint)\n\t\ttp->retransmit_skb_hint = prev;\n\tif (skb == tp->lost_skb_hint) {\n\t\ttp->lost_skb_hint = prev;\n\t\ttp->lost_cnt_hint -= tcp_skb_pcount(prev);\n\t}\n\n\tTCP_SKB_CB(prev)->tcp_flags |= TCP_SKB_CB(skb)->tcp_flags;\n\tTCP_SKB_CB(prev)->eor = TCP_SKB_CB(skb)->eor;\n\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_FIN)\n\t\tTCP_SKB_CB(prev)->end_seq++;\n\n\tif (skb == tcp_highest_sack(sk))\n\t\ttcp_advance_highest_sack(sk, skb);\n\n\ttcp_skb_collapse_tstamp(prev, skb);\n\tif (unlikely(TCP_SKB_CB(prev)->tx.delivered_mstamp.v64))\n\t\tTCP_SKB_CB(prev)->tx.delivered_mstamp.v64 = 0;\n\n\ttcp_unlink_write_queue(skb, sk);\n\tsk_wmem_free_skb(sk, skb);\n\n\tNET_INC_STATS(sock_net(sk), LINUX_MIB_SACKMERGED);\n\n\treturn true;\n}"
p3049
(dp3050
((g2976
g3046
tp3051
I1
tp3052
(dp3053
g12
g13
sg14
(dp3054
(I31
I31
tp3055
(lp3056
S'\tWARN_ON_ONCE(tcp_skb_pcount(skb) < pcount);'
p3057
assg32
I7
sg33
(dp3058
(I31
I31
tp3059
(lp3060
S'\tBUG_ON(tcp_skb_pcount(skb) < pcount);'
p3061
assg41
(I1
I82
tp3062
ssss(g2976
S'tcp_skb_shift'
p3063
tp3064
(dp3065
ssS'CVE-2019-10607'
p3066
(dp3067
(S'security/selinux/ss/services.c'
p3068
S'security_context_to_sid_core'
p3069
tp3070
(dp3071
S'static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\t/* Copy the string to allow changes and ensure a NUL terminator */\n\tscontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext2)) {\n\t\t\t\t*sid = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\tgoto out;\n\t}\n\t*sid = SECSID_NULL;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = strlen(str) + 1;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}'
p3072
(dp3073
((g3068
g3069
tp3074
I1
tp3075
(dp3076
g12
g13
sg14
(dp3077
(I45
I45
tp3078
(lp3079
S'\t\tcontext.len = strlen(str) + 1;'
p3080
assg32
I6
sg33
(dp3081
(I45
I45
tp3082
(lp3083
S'\t\tcontext.len = scontext_len;'
p3084
assg41
(I1
I57
tp3085
sssssS'CVE-2019-10606'
p3086
(dp3087
(S'drivers/usb/gadget/function/uvc_configfs.c'
p3088
S'__uvcg_cnt_strm'
p3089
tp3090
(dp3091
S'static int __uvcg_cnt_strm(void *priv1, void *priv2, void *priv3, int n,\n\t\t\t   enum uvcg_strm_type type)\n{\n\tsize_t *size = priv2;\n\tsize_t *count = priv3;\n\n\tswitch (type) {\n\tcase UVCG_HEADER: {\n\t\tstruct uvcg_streaming_header *h = priv1;\n\n\t\t*size += sizeof(h->desc);\n\t\t/* bmaControls */\n\t\t*size += h->num_fmt * UVCG_STREAMING_CONTROL_SIZE;\n\t}\n\tbreak;\n\tcase UVCG_FORMAT: {\n\t\tstruct uvcg_format *fmt = priv1;\n\n\t\tif (fmt->type == UVCG_UNCOMPRESSED) {\n\t\t\tstruct uvcg_uncompressed *u =\n\t\t\t\tcontainer_of(fmt, struct uvcg_uncompressed,\n\t\t\t\t\t     fmt);\n\n\t\t\t*size += sizeof(u->desc);\n\t\t} else if (fmt->type == UVCG_MJPEG) {\n\t\t\tstruct uvcg_mjpeg *m =\n\t\t\t\tcontainer_of(fmt, struct uvcg_mjpeg, fmt);\n\n\t\t\t*size += sizeof(m->desc);\n\t\t} else if (fmt->type == UVCG_H264) {\n\t\t\tstruct uvcg_h264 *h =\n\t\t\t\tcontainer_of(fmt, struct uvcg_h264, fmt);\n\n\t\t\t*size += sizeof(h->desc);\n\t\t} else {\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tbreak;\n\tcase UVCG_FRAME: {\n\t\tstruct uvcg_frame *frm = priv1;\n\n\t\tif (frm->fmt_type == UVCG_UNCOMPRESSED) {\n\t\t\tstruct uvc_frame_uncompressed uf =\n\t\t\t\tfrm->frame.uf;\n\t\t\t*size +=\n\t\t\tUVC_DT_FRAME_UNCOMPRESSED_SIZE(uf.bFrameIntervalType);\n\t\t} else if (frm->fmt_type == UVCG_MJPEG) {\n\t\t\tstruct uvc_frame_mjpeg mf =\n\t\t\t\tfrm->frame.mf;\n\t\t\t*size +=\n\t\t\tUVC_DT_FRAME_MJPEG_SIZE(mf.bFrameIntervalType);\n\t\t} else if (frm->fmt_type == UVCG_H264) {\n\t\t\tstruct uvc_frame_h264 hf =\n\t\t\t\tfrm->frame.hf;\n\t\t\t*size +=\n\t\t\tUVC_DT_FRAME_H264_SIZE(hf.bNumFrameIntervals);\n\t\t}\n\t}\n\tbreak;\n\t}\n\n\t++*count;\n\n\treturn 0;\n}'
p3092
(dp3093
((g3088
g3089
tp3094
I1
tp3095
(dp3096
g12
g13
sg14
(dp3097
(I52
I52
tp3098
(lp3099
S'\t\t\tUVC_DT_FRAME_MJPEG_SIZE(mf.bFrameIntervalType);'
p3100
as(I57
I57
tp3101
(lp3102
S'\t\t\tUVC_DT_FRAME_H264_SIZE(hf.bNumFrameIntervals);'
p3103
assg32
I5
sg33
(dp3104
(I52
I52
tp3105
(lp3106
S'\t\t\tUVC_DT_FRAME_UNCOMPRESSED_SIZE(mf.bFrameIntervalType);'
p3107
as(I57
I57
tp3108
(lp3109
S'\t\t\tUVC_DT_FRAME_UNCOMPRESSED_SIZE(hf.bNumFrameIntervals);'
p3110
assg41
(I1
I66
tp3111
sssssS'CVE-2019-11479'
p3112
(dp3113
(S'net/ipv4/tcp_ipv4.c'
p3114
S'tcp_sk_init'
p3115
tp3116
(dp3117
S'static int __net_init tcp_sk_init(struct net *net)\n{\n\tint res, cpu;\n\n\tnet->ipv4.tcp_sk = alloc_percpu(struct sock *);\n\tif (!net->ipv4.tcp_sk)\n\t\treturn -ENOMEM;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct sock *sk;\n\n\t\tres = inet_ctl_sock_create(&sk, PF_INET, SOCK_RAW,\n\t\t\t\t\t   IPPROTO_TCP, net);\n\t\tif (res)\n\t\t\tgoto fail;\n\t\tsock_set_flag(sk, SOCK_USE_WRITE_QUEUE);\n\n\t\t/* Please enforce IP_DF and IPID==0 for RST and\n\t\t * ACK sent in SYN-RECV and TIME-WAIT state.\n\t\t */\n\t\tinet_sk(sk)->pmtudisc = IP_PMTUDISC_DO;\n\n\t\t*per_cpu_ptr(net->ipv4.tcp_sk, cpu) = sk;\n\t}\n\n\tnet->ipv4.sysctl_tcp_ecn = 2;\n\tnet->ipv4.sysctl_tcp_ecn_fallback = 1;\n\n\tnet->ipv4.sysctl_tcp_base_mss = TCP_BASE_MSS;\n\tnet->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;\n\tnet->ipv4.sysctl_tcp_probe_threshold = TCP_PROBE_THRESHOLD;\n\tnet->ipv4.sysctl_tcp_probe_interval = TCP_PROBE_INTERVAL;\n\n\tnet->ipv4.sysctl_tcp_keepalive_time = TCP_KEEPALIVE_TIME;\n\tnet->ipv4.sysctl_tcp_keepalive_probes = TCP_KEEPALIVE_PROBES;\n\tnet->ipv4.sysctl_tcp_keepalive_intvl = TCP_KEEPALIVE_INTVL;\n\n\tnet->ipv4.sysctl_tcp_syn_retries = TCP_SYN_RETRIES;\n\tnet->ipv4.sysctl_tcp_synack_retries = TCP_SYNACK_RETRIES;\n\tnet->ipv4.sysctl_tcp_syncookies = 1;\n\tnet->ipv4.sysctl_tcp_reordering = TCP_FASTRETRANS_THRESH;\n\tnet->ipv4.sysctl_tcp_retries1 = TCP_RETR1;\n\tnet->ipv4.sysctl_tcp_retries2 = TCP_RETR2;\n\tnet->ipv4.sysctl_tcp_orphan_retries = 0;\n\tnet->ipv4.sysctl_tcp_fin_timeout = TCP_FIN_TIMEOUT;\n\tnet->ipv4.sysctl_tcp_notsent_lowat = UINT_MAX;\n\n\treturn 0;\nfail:\n\ttcp_sk_exit(net);\n\n\treturn res;\n}'
p3118
(dp3119
((g3114
g3115
tp3120
I1
tp3121
(dp3122
g14
(dp3123
(I30
I30
tp3124
(lp3125
S'\tnet->ipv4.sysctl_tcp_min_snd_mss = TCP_MIN_SND_MSS;'
p3126
assg32
I1
sg12
g13
sg41
(I1
I53
tp3127
ssss(S'net/ipv4/tcp_output.c'
p3128
S'__tcp_mtu_to_mss'
p3129
tp3130
(dp3131
S'static inline int __tcp_mtu_to_mss(struct sock *sk, int pmtu)\n{\n\tconst struct tcp_sock *tp = tcp_sk(sk);\n\tconst struct inet_connection_sock *icsk = inet_csk(sk);\n\tint mss_now;\n\n\t/* Calculate base mss without TCP options:\n\t   It is MMS_S - sizeof(tcphdr) of rfc1122\n\t */\n\tmss_now = pmtu - icsk->icsk_af_ops->net_header_len - sizeof(struct tcphdr);\n\n\t/* IPv6 adds a frag_hdr in case RTAX_FEATURE_ALLFRAG is set */\n\tif (icsk->icsk_af_ops->net_frag_header_len) {\n\t\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\n\t\tif (dst && dst_allfrag(dst))\n\t\t\tmss_now -= icsk->icsk_af_ops->net_frag_header_len;\n\t}\n\n\t/* Clamp it (mss_clamp does not include tcp options) */\n\tif (mss_now > tp->rx_opt.mss_clamp)\n\t\tmss_now = tp->rx_opt.mss_clamp;\n\n\t/* Now subtract optional transport overhead */\n\tmss_now -= icsk->icsk_ext_hdr_len;\n\n\t/* Then reserve room for full set of TCP options and 8 bytes of data */\n\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);\n\treturn mss_now;\n}'
p3132
(dp3133
((g3128
g3129
tp3134
I1
tp3135
(dp3136
g12
g13
sg14
(dp3137
(I28
I28
tp3138
(lp3139
S'\tmss_now = max(mss_now, sock_net(sk)->ipv4.sysctl_tcp_min_snd_mss);'
p3140
assg32
I2
sg33
(dp3141
(I28
I29
tp3142
(lp3143
S'\tif (mss_now < 48)'
p3144
aS'\t\tmss_now = 48;'
p3145
assg41
(I1
I30
tp3146
sssssS'CVE-2019-11478'
p3147
(dp3148
(S'net/ipv4/tcp_output.c'
p3149
S'tcp_fragment'
p3150
tp3151
(dp3152
S"int tcp_fragment(struct sock *sk, struct sk_buff *skb, u32 len,\n\t\t unsigned int mss_now, gfp_t gfp)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *buff;\n\tint nsize, old_factor;\n\tint nlen;\n\tu8 flags;\n\n\tif (WARN_ON(len > skb->len))\n\t\treturn -EINVAL;\n\n\tnsize = skb_headlen(skb) - len;\n\tif (nsize < 0)\n\t\tnsize = 0;\n\n\tif (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf + 0x20000)) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (skb_unclone(skb, gfp))\n\t\treturn -ENOMEM;\n\n\t/* Get a new skb... force flag on. */\n\tbuff = sk_stream_alloc_skb(sk, nsize, gfp, true);\n\tif (!buff)\n\t\treturn -ENOMEM; /* We'll just try again later. */\n\n\tsk->sk_wmem_queued += buff->truesize;\n\tsk_mem_charge(sk, buff->truesize);\n\tnlen = skb->len - len - nsize;\n\tbuff->truesize += nlen;\n\tskb->truesize -= nlen;\n\n\t/* Correct the sequence numbers. */\n\tTCP_SKB_CB(buff)->seq = TCP_SKB_CB(skb)->seq + len;\n\tTCP_SKB_CB(buff)->end_seq = TCP_SKB_CB(skb)->end_seq;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(buff)->seq;\n\n\t/* PSH and FIN should only be set in the second packet. */\n\tflags = TCP_SKB_CB(skb)->tcp_flags;\n\tTCP_SKB_CB(skb)->tcp_flags = flags & ~(TCPHDR_FIN | TCPHDR_PSH);\n\tTCP_SKB_CB(buff)->tcp_flags = flags;\n\tTCP_SKB_CB(buff)->sacked = TCP_SKB_CB(skb)->sacked;\n\ttcp_skb_fragment_eor(skb, buff);\n\n\tif (!skb_shinfo(skb)->nr_frags && skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\t/* Copy and checksum data tail into the new buffer. */\n\t\tbuff->csum = csum_partial_copy_nocheck(skb->data + len,\n\t\t\t\t\t\t       skb_put(buff, nsize),\n\t\t\t\t\t\t       nsize, 0);\n\n\t\tskb_trim(skb, len);\n\n\t\tskb->csum = csum_block_sub(skb->csum, buff->csum, len);\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb_split(skb, buff, len);\n\t}\n\n\tbuff->ip_summed = skb->ip_summed;\n\n\tbuff->tstamp = skb->tstamp;\n\ttcp_fragment_tstamp(skb, buff);\n\n\told_factor = tcp_skb_pcount(skb);\n\n\t/* Fix up tso_factor for both original and new SKB.  */\n\ttcp_set_skb_tso_segs(skb, mss_now);\n\ttcp_set_skb_tso_segs(buff, mss_now);\n\n\t/* Update delivered info for the new segment */\n\tTCP_SKB_CB(buff)->tx = TCP_SKB_CB(skb)->tx;\n\n\t/* If this packet has been sent out already, we must\n\t * adjust the various packet counters.\n\t */\n\tif (!before(tp->snd_nxt, TCP_SKB_CB(buff)->end_seq)) {\n\t\tint diff = old_factor - tcp_skb_pcount(skb) -\n\t\t\ttcp_skb_pcount(buff);\n\n\t\tif (diff)\n\t\t\ttcp_adjust_pcount(sk, skb, diff);\n\t}\n\n\t/* Link BUFF into the send queue. */\n\t__skb_header_release(buff);\n\ttcp_insert_write_queue_after(skb, buff, sk);\n\n\treturn 0;\n}"
p3153
(dp3154
((g3149
g3150
tp3155
I1
tp3156
(dp3157
g14
(dp3158
(I17
I21
tp3159
(lp3160
S'\tif (unlikely((sk->sk_wmem_queued >> 1) > sk->sk_sndbuf + 0x20000)) {'
p3161
aS'\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);'
p3162
aS'\t\treturn -ENOMEM;'
p3163
aS'\t}'
p3164
ag59
assg32
I5
sg12
g13
sg41
(I1
I92
tp3165
sssS"int tcp_fragment(struct sock *sk, struct sk_buff *skb, u32 len,\n\t\t unsigned int mss_now, gfp_t gfp)\n{\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tstruct sk_buff *buff;\n\tint nsize, old_factor;\n\tlong limit;\n\tint nlen;\n\tu8 flags;\n\n\tif (WARN_ON(len > skb->len))\n\t\treturn -EINVAL;\n\n\tnsize = skb_headlen(skb) - len;\n\tif (nsize < 0)\n\t\tnsize = 0;\n\n\t/* tcp_sendmsg() can overshoot sk_wmem_queued by one full size skb.\n\t * We need some allowance to not penalize applications setting small\n\t * SO_SNDBUF values.\n\t * Also allow first and last skb in retransmit queue to be split.\n\t */\n\tlimit = sk->sk_sndbuf + 2 * SKB_TRUESIZE(GSO_MAX_SIZE);\n\tif (unlikely((sk->sk_wmem_queued >> 1) > limit &&\n\t\t     skb != tcp_rtx_queue_head(sk) &&\n\t\t     skb != tcp_rtx_queue_tail(sk))) {\n\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);\n\t\treturn -ENOMEM;\n\t}\n\n\tif (skb_unclone(skb, gfp))\n\t\treturn -ENOMEM;\n\n\t/* Get a new skb... force flag on. */\n\tbuff = sk_stream_alloc_skb(sk, nsize, gfp, true);\n\tif (!buff)\n\t\treturn -ENOMEM; /* We'll just try again later. */\n\n\tsk->sk_wmem_queued += buff->truesize;\n\tsk_mem_charge(sk, buff->truesize);\n\tnlen = skb->len - len - nsize;\n\tbuff->truesize += nlen;\n\tskb->truesize -= nlen;\n\n\t/* Correct the sequence numbers. */\n\tTCP_SKB_CB(buff)->seq = TCP_SKB_CB(skb)->seq + len;\n\tTCP_SKB_CB(buff)->end_seq = TCP_SKB_CB(skb)->end_seq;\n\tTCP_SKB_CB(skb)->end_seq = TCP_SKB_CB(buff)->seq;\n\n\t/* PSH and FIN should only be set in the second packet. */\n\tflags = TCP_SKB_CB(skb)->tcp_flags;\n\tTCP_SKB_CB(skb)->tcp_flags = flags & ~(TCPHDR_FIN | TCPHDR_PSH);\n\tTCP_SKB_CB(buff)->tcp_flags = flags;\n\tTCP_SKB_CB(buff)->sacked = TCP_SKB_CB(skb)->sacked;\n\ttcp_skb_fragment_eor(skb, buff);\n\n\tif (!skb_shinfo(skb)->nr_frags && skb->ip_summed != CHECKSUM_PARTIAL) {\n\t\t/* Copy and checksum data tail into the new buffer. */\n\t\tbuff->csum = csum_partial_copy_nocheck(skb->data + len,\n\t\t\t\t\t\t       skb_put(buff, nsize),\n\t\t\t\t\t\t       nsize, 0);\n\n\t\tskb_trim(skb, len);\n\n\t\tskb->csum = csum_block_sub(skb->csum, buff->csum, len);\n\t} else {\n\t\tskb->ip_summed = CHECKSUM_PARTIAL;\n\t\tskb_split(skb, buff, len);\n\t}\n\n\tbuff->ip_summed = skb->ip_summed;\n\n\tbuff->tstamp = skb->tstamp;\n\ttcp_fragment_tstamp(skb, buff);\n\n\told_factor = tcp_skb_pcount(skb);\n\n\t/* Fix up tso_factor for both original and new SKB.  */\n\ttcp_set_skb_tso_segs(skb, mss_now);\n\ttcp_set_skb_tso_segs(buff, mss_now);\n\n\t/* Update delivered info for the new segment */\n\tTCP_SKB_CB(buff)->tx = TCP_SKB_CB(skb)->tx;\n\n\t/* If this packet has been sent out already, we must\n\t * adjust the various packet counters.\n\t */\n\tif (!before(tp->snd_nxt, TCP_SKB_CB(buff)->end_seq)) {\n\t\tint diff = old_factor - tcp_skb_pcount(skb) -\n\t\t\ttcp_skb_pcount(buff);\n\n\t\tif (diff)\n\t\t\ttcp_adjust_pcount(sk, skb, diff);\n\t}\n\n\t/* Link BUFF into the send queue. */\n\t__skb_header_release(buff);\n\ttcp_insert_write_queue_after(skb, buff, sk);\n\n\treturn 0;\n}"
p3166
(dp3167
((g3149
g3150
tp3168
I1
tp3169
(dp3170
g14
(dp3171
(I18
I30
tp3172
(lp3173
S'\t/* tcp_sendmsg() can overshoot sk_wmem_queued by one full size skb.'
p3174
aS'\t * We need some allowance to not penalize applications setting small'
p3175
aS'\t * SO_SNDBUF values.'
p3176
aS'\t * Also allow first and last skb in retransmit queue to be split.'
p3177
aS'\t */'
p3178
aS'\tlimit = sk->sk_sndbuf + 2 * SKB_TRUESIZE(GSO_MAX_SIZE);'
p3179
aS'\tif (unlikely((sk->sk_wmem_queued >> 1) > limit &&'
p3180
aS'\t\t     skb != tcp_rtx_queue_head(sk) &&'
p3181
aS'\t\t     skb != tcp_rtx_queue_tail(sk))) {'
p3182
aS'\t\tNET_INC_STATS(sock_net(sk), LINUX_MIB_TCPWQUEUETOOBIG);'
p3183
aS'\t\treturn -ENOMEM;'
p3184
aS'\t}'
p3185
ag59
as(I7
I7
tp3186
(lp3187
S'\tlong limit;'
p3188
assg32
I5
sg12
g13
sg41
(I1
I101
tp3189
sssssS'CVE-2019-10567'
p3190
(dp3191
(S'drivers/gpu/msm/adreno_ringbuffer.c'
p3192
S'_adreno_ringbuffer_probe'
p3193
tp3194
(dp3195
S'static int _adreno_ringbuffer_probe(struct adreno_device *adreno_dev,\n\t\tint id)\n{\n\tstruct adreno_ringbuffer *rb = &adreno_dev->ringbuffers[id];\n\tint ret;\n\tchar name[64];\n\n\trb->id = id;\n\n\tsnprintf(name, sizeof(name), "rb_events-%d", id);\n\tkgsl_add_event_group(&rb->events, NULL, name,\n\t\t_rb_readtimestamp, rb);\n\trb->timestamp = 0;\n\tinit_waitqueue_head(&rb->ts_expire_waitq);\n\n\tspin_lock_init(&rb->preempt_lock);\n\n\t/*\n\t * Allocate mem for storing RB pagetables and commands to\n\t * switch pagetable\n\t */\n\tret = kgsl_allocate_global(KGSL_DEVICE(adreno_dev), &rb->pagetable_desc,\n\t\tPAGE_SIZE, 0, KGSL_MEMDESC_PRIVILEGED, "pagetable_desc");\n\tif (ret)\n\t\treturn ret;\n\n\t/* allocate a chunk of memory to create user profiling IB1s */\n\tkgsl_allocate_global(KGSL_DEVICE(adreno_dev), &rb->profile_desc,\n\t\tPAGE_SIZE, KGSL_MEMFLAGS_GPUREADONLY, 0, "profile_desc");\n\n\treturn kgsl_allocate_global(KGSL_DEVICE(adreno_dev), &rb->buffer_desc,\n\t\t\tKGSL_RB_SIZE, KGSL_MEMFLAGS_GPUREADONLY,\n\t\t\t0, "ringbuffer");\n}'
p3196
(dp3197
((g3192
g3193
tp3198
I1
tp3199
(dp3200
g14
(dp3201
(I26
I30
tp3202
(lp3203
g59
aS'\t/* allocate a chunk of memory to create user profiling IB1s */'
p3204
aS'\tkgsl_allocate_global(KGSL_DEVICE(adreno_dev), &rb->profile_desc,'
p3205
aS'\t\tPAGE_SIZE, KGSL_MEMFLAGS_GPUREADONLY, 0, "profile_desc");'
p3206
ag59
assg32
I2
sg12
g13
sg41
(I1
I34
tp3207
ssss(g3192
S'_adreno_ringbuffer_close'
p3208
tp3209
(dp3210
S'static void _adreno_ringbuffer_close(struct adreno_device *adreno_dev,\n\t\tstruct adreno_ringbuffer *rb)\n{\n\tstruct kgsl_device *device = KGSL_DEVICE(adreno_dev);\n\n\tkgsl_free_global(device, &rb->pagetable_desc);\n\tkgsl_free_global(device, &rb->preemption_desc);\n\tkgsl_free_global(device, &rb->profile_desc);\n\tkgsl_free_global(device, &rb->buffer_desc);\n\tkgsl_del_event_group(&rb->events);\n\tmemset(rb, 0, sizeof(struct adreno_ringbuffer));\n}'
p3211
(dp3212
((g3192
g3208
tp3213
I1
tp3214
(dp3215
g12
g13
sg14
(dp3216
(I8
I8
tp3217
(lp3218
S'\tkgsl_free_global(device, &rb->profile_desc);'
p3219
assg32
I2
sg33
(dp3220
(I8
I8
tp3221
(lp3222
g59
assg41
(I1
I12
tp3223
ssss(g3192
S'set_user_profiling'
p3224
tp3225
(dp3226
s(g3192
S'adreno_ringbuffer_submitcmd'
p3227
tp3228
(dp3229
S'int adreno_ringbuffer_submitcmd(struct adreno_device *adreno_dev,\n\t\tstruct kgsl_drawobj_cmd *cmdobj,\n\t\tstruct adreno_submit_time *time)\n{\n\tstruct kgsl_device *device = KGSL_DEVICE(adreno_dev);\n\tstruct adreno_gpudev *gpudev = ADRENO_GPU_DEVICE(adreno_dev);\n\tstruct kgsl_drawobj *drawobj = DRAWOBJ(cmdobj);\n\tstruct kgsl_memobj_node *ib;\n\tunsigned int numibs = 0;\n\tunsigned int *link;\n\tunsigned int *cmds;\n\tstruct kgsl_context *context;\n\tstruct adreno_context *drawctxt;\n\tbool use_preamble = true;\n\tbool user_profiling = false;\n\tbool kernel_profiling = false;\n\tint flags = KGSL_CMD_FLAGS_NONE;\n\tint ret;\n\tstruct adreno_ringbuffer *rb;\n\tunsigned int dwords = 0;\n\tstruct adreno_submit_time local;\n\tstruct adreno_firmware *fw = ADRENO_FW(adreno_dev, ADRENO_FW_SQE);\n\tbool set_ib1list_marker = false;\n\n\tmemset(&local, 0x0, sizeof(local));\n\n\tcontext = drawobj->context;\n\tdrawctxt = ADRENO_CONTEXT(context);\n\n\t/* Get the total IBs in the list */\n\tlist_for_each_entry(ib, &cmdobj->cmdlist, node)\n\t\tnumibs++;\n\n\trb = drawctxt->rb;\n\n\t/* process any profiling results that are available into the log_buf */\n\tadreno_profile_process_results(adreno_dev);\n\n\t/*\n\t * If SKIP CMD flag is set for current context\n\t * a) set SKIPCMD as fault_recovery for current commandbatch\n\t * b) store context\'s commandbatch fault_policy in current\n\t *    commandbatch fault_policy and clear context\'s commandbatch\n\t *    fault_policy\n\t * c) force preamble for commandbatch\n\t */\n\tif (test_bit(ADRENO_CONTEXT_SKIP_CMD, &drawctxt->base.priv) &&\n\t\t(!test_bit(CMDOBJ_SKIP, &cmdobj->priv))) {\n\n\t\tset_bit(KGSL_FT_SKIPCMD, &cmdobj->fault_recovery);\n\t\tcmdobj->fault_policy = drawctxt->fault_policy;\n\t\tset_bit(CMDOBJ_FORCE_PREAMBLE, &cmdobj->priv);\n\n\t\t/* if context is detached print fault recovery */\n\t\tadreno_fault_skipcmd_detached(adreno_dev, drawctxt, drawobj);\n\n\t\t/* clear the drawctxt flags */\n\t\tclear_bit(ADRENO_CONTEXT_SKIP_CMD, &drawctxt->base.priv);\n\t\tdrawctxt->fault_policy = 0;\n\t}\n\n\t/*\n\t * When preamble is enabled, the preamble buffer with state restoration\n\t * commands are stored in the first node of the IB chain.\n\t * We can skip that if a context switch hasn\'t occurred.\n\t */\n\n\tif ((drawctxt->base.flags & KGSL_CONTEXT_PREAMBLE) &&\n\t\t!test_bit(CMDOBJ_FORCE_PREAMBLE, &cmdobj->priv) &&\n\t\t(rb->drawctxt_active == drawctxt))\n\t\tuse_preamble = false;\n\n\t/*\n\t * In skip mode don\'t issue the draw IBs but keep all the other\n\t * accoutrements of a submision (including the interrupt) to keep\n\t * the accounting sane. Set start_index and numibs to 0 to just\n\t * generate the start and end markers and skip everything else\n\t */\n\tif (test_bit(CMDOBJ_SKIP, &cmdobj->priv)) {\n\t\tuse_preamble = false;\n\t\tnumibs = 0;\n\t}\n\n\t/*\n\t * a5xx uses 64 bit memory address. pm4 commands that involve read/write\n\t * from memory take 4 bytes more than a4xx because of 64 bit addressing.\n\t * This function is shared between gpucores, so reserve the max size\n\t * required and adjust the number of commands before calling addcmds.\n\t * Each submission needs 7 dwords max for wrappers and other red tape.\n\t */\n\tdwords = 7;\n\n\t/* Each IB takes up 30 dwords in worst case */\n\tdwords += (numibs * 30);\n\n\tif (drawobj->flags & KGSL_DRAWOBJ_PROFILING &&\n\t\t!adreno_is_a3xx(adreno_dev) &&\n\t\t(cmdobj->profiling_buf_entry != NULL)) {\n\t\tuser_profiling = true;\n\n\t\t/*\n\t\t * User side profiling uses two IB1s, one before with 4 dwords\n\t\t * per INDIRECT_BUFFER_PFE call\n\t\t */\n\t\tdwords += 8;\n\n\t\t/*\n\t\t * we want to use an adreno_submit_time struct to get the\n\t\t * precise moment when the command is submitted to the\n\t\t * ringbuffer.  If an upstream caller already passed down a\n\t\t * pointer piggyback on that otherwise use a local struct\n\t\t */\n\n\t\tif (time == NULL)\n\t\t\ttime = &local;\n\n\t\ttime->drawobj = drawobj;\n\t}\n\n\tif (test_bit(CMDOBJ_PROFILE, &cmdobj->priv)) {\n\t\tkernel_profiling = true;\n\t\tdwords += 6;\n\t\tif (!ADRENO_LEGACY_PM4(adreno_dev))\n\t\t\tdwords += 2;\n\t}\n\n\tif (adreno_is_preemption_enabled(adreno_dev))\n\t\tif (gpudev->preemption_yield_enable)\n\t\t\tdwords += 8;\n\n\t/*\n\t * Prior to SQE FW version 1.49, there was only one marker for\n\t * both preemption and IFPC. Only include the IB1LIST markers if\n\t * we are using a firmware that supports them.\n\t */\n\tif (gpudev->set_marker && numibs && adreno_is_a6xx(adreno_dev) &&\n\t\t\t((fw->version & 0xFFF) >= 0x149)) {\n\t\tset_ib1list_marker = true;\n\t\tdwords += 4;\n\t}\n\n\tif (gpudev->ccu_invalidate)\n\t\tdwords += 4;\n\n\tlink = kcalloc(dwords, sizeof(unsigned int), GFP_KERNEL);\n\tif (!link) {\n\t\tret = -ENOMEM;\n\t\tgoto done;\n\t}\n\n\tcmds = link;\n\n\t*cmds++ = cp_packet(adreno_dev, CP_NOP, 1);\n\t*cmds++ = KGSL_START_OF_IB_IDENTIFIER;\n\n\tif (kernel_profiling) {\n\t\tcmds += _get_alwayson_counter(adreno_dev, cmds,\n\t\t\tadreno_dev->profile_buffer.gpuaddr +\n\t\t\tADRENO_DRAWOBJ_PROFILE_OFFSET(cmdobj->profile_index,\n\t\t\t\tstarted));\n\t}\n\n\t/*\n\t * Add IB1 to read the GPU ticks at the start of command obj and\n\t * write it into the appropriate command obj profiling buffer offset\n\t */\n\tif (user_profiling) {\n\t\tcmds += set_user_profiling(adreno_dev, rb, cmds,\n\t\t\tcmdobj->profiling_buffer_gpuaddr +\n\t\t\toffsetof(struct kgsl_drawobj_profiling_buffer,\n\t\t\tgpu_ticks_submitted));\n\t}\n\n\tif (numibs) {\n\t\tif (set_ib1list_marker)\n\t\t\tcmds += gpudev->set_marker(cmds, IB1LIST_START);\n\n\t\tlist_for_each_entry(ib, &cmdobj->cmdlist, node) {\n\t\t\t/*\n\t\t\t * Skip 0 sized IBs - these are presumed to have been\n\t\t\t * removed from consideration by the FT policy\n\t\t\t */\n\t\t\tif (ib->priv & MEMOBJ_SKIP ||\n\t\t\t\t(ib->priv & MEMOBJ_PREAMBLE &&\n\t\t\t\tuse_preamble == false))\n\t\t\t\t*cmds++ = cp_mem_packet(adreno_dev, CP_NOP,\n\t\t\t\t\t\t3, 1);\n\n\t\t\t*cmds++ = cp_mem_packet(adreno_dev,\n\t\t\t\t\tCP_INDIRECT_BUFFER_PFE, 2, 1);\n\t\t\tcmds += cp_gpuaddr(adreno_dev, cmds, ib->gpuaddr);\n\t\t\t*cmds++ = (unsigned int) ib->size >> 2;\n\t\t\t/* preamble is required on only for first command */\n\t\t\tuse_preamble = false;\n\t\t}\n\n\t\tif (set_ib1list_marker)\n\t\t\tcmds += gpudev->set_marker(cmds, IB1LIST_END);\n\t}\n\n\tif (gpudev->ccu_invalidate)\n\t\tcmds += gpudev->ccu_invalidate(adreno_dev, cmds);\n\n\tif (adreno_is_preemption_enabled(adreno_dev))\n\t\tif (gpudev->preemption_yield_enable)\n\t\t\tcmds += gpudev->preemption_yield_enable(cmds);\n\n\tif (kernel_profiling) {\n\t\tcmds += _get_alwayson_counter(adreno_dev, cmds,\n\t\t\tadreno_dev->profile_buffer.gpuaddr +\n\t\t\tADRENO_DRAWOBJ_PROFILE_OFFSET(cmdobj->profile_index,\n\t\t\t\tretired));\n\t}\n\n\t/*\n\t * Add IB1 to read the GPU ticks at the end of command obj and\n\t * write it into the appropriate command obj profiling buffer offset\n\t */\n\tif (user_profiling) {\n\t\tcmds += set_user_profiling(adreno_dev, rb, cmds,\n\t\t\tcmdobj->profiling_buffer_gpuaddr +\n\t\t\toffsetof(struct kgsl_drawobj_profiling_buffer,\n\t\t\tgpu_ticks_retired));\n\t}\n\n\t*cmds++ = cp_packet(adreno_dev, CP_NOP, 1);\n\t*cmds++ = KGSL_END_OF_IB_IDENTIFIER;\n\n\t/* Context switches commands should *always* be on the GPU */\n\tret = adreno_drawctxt_switch(adreno_dev, rb, drawctxt,\n\t\tADRENO_CONTEXT_SWITCH_FORCE_GPU);\n\n\t/*\n\t * In the unlikely event of an error in the drawctxt switch,\n\t * treat it like a hang\n\t */\n\tif (ret) {\n\t\t/*\n\t\t * It is "normal" to get a -ENOSPC or a -ENOENT. Don\'t log it,\n\t\t * the upper layers know how to handle it\n\t\t */\n\t\tif (ret != -ENOSPC && ret != -ENOENT)\n\t\t\tKGSL_DRV_ERR(device,\n\t\t\t\t"Unable to switch draw context: %d\\n", ret);\n\t\tgoto done;\n\t}\n\n\tif (test_bit(CMDOBJ_WFI, &cmdobj->priv))\n\t\tflags = KGSL_CMD_FLAGS_WFI;\n\n\t/*\n\t * For some targets, we need to execute a dummy shader operation after a\n\t * power collapse\n\t */\n\n\tif (test_and_clear_bit(ADRENO_DEVICE_PWRON, &adreno_dev->priv) &&\n\t\ttest_bit(ADRENO_DEVICE_PWRON_FIXUP, &adreno_dev->priv))\n\t\tflags |= KGSL_CMD_FLAGS_PWRON_FIXUP;\n\n\t/* Set the constraints before adding to ringbuffer */\n\tadreno_ringbuffer_set_constraint(device, drawobj);\n\n\tret = adreno_ringbuffer_addcmds(rb, flags,\n\t\t\t\t\t&link[0], (cmds - link),\n\t\t\t\t\tdrawobj->timestamp, time);\n\n\tif (!ret) {\n\t\tset_bit(KGSL_CONTEXT_PRIV_SUBMITTED, &context->priv);\n\t\tcmdobj->global_ts = drawctxt->internal_timestamp;\n\t}\n\ndone:\n\ttrace_kgsl_issueibcmds(device, context->id, numibs, drawobj->timestamp,\n\t\t\tdrawobj->flags, ret, drawctxt->type);\n\n\tkfree(link);\n\treturn ret;\n}'
p3230
(dp3231
((g3192
g3227
tp3232
I1
tp3233
(dp3234
g12
g13
sg14
(dp3235
(I216
I216
tp3236
(lp3237
S'\t * Add IB1 to read the GPU ticks at the end of command obj and'
p3238
as(I102
I103
tp3239
(lp3240
S'\t\t * User side profiling uses two IB1s, one before with 4 dwords'
p3241
aS'\t\t * per INDIRECT_BUFFER_PFE call'
p3242
as(I164
I164
tp3243
(lp3244
S'\t * Add IB1 to read the GPU ticks at the start of command obj and'
p3245
as(I105
I105
tp3246
(lp3247
S'\t\tdwords += 8;'
p3248
as(I168
I168
tp3249
(lp3250
S'\t\tcmds += set_user_profiling(adreno_dev, rb, cmds,'
p3251
as(I220
I220
tp3252
(lp3253
S'\t\tcmds += set_user_profiling(adreno_dev, rb, cmds,'
p3254
assg32
I3
sg33
(dp3255
(I105
I106
tp3256
(lp3257
S'\t\tif (!ADRENO_LEGACY_PM4(adreno_dev))'
p3258
aS'\t\t\tdwords += 2;'
p3259
as(I216
I216
tp3260
(lp3261
S'\t * Add cmds to read the GPU ticks at the end of command obj and'
p3262
as(I100
I100
tp3263
(lp3264
S'\t\tdwords += 6;'
p3265
as(I102
I103
tp3266
(lp3267
S'\t\t * REG_TO_MEM packet on A5xx and above needs another ordinal.'
p3268
aS'\t\t * Add 2 more dwords since we do profiling before and after.'
p3269
as(I164
I164
tp3270
(lp3271
S'\t * Add cmds to read the GPU ticks at the start of command obj and'
p3272
as(I168
I168
tp3273
(lp3274
S'\t\tcmds += _get_alwayson_counter(adreno_dev, cmds,'
p3275
as(I220
I220
tp3276
(lp3277
S'\t\tcmds += _get_alwayson_counter(adreno_dev, cmds,'
p3278
assg41
(I1
I278
tp3279
sssssS'CVE-2019-10565'
p3280
(dp3281
(S'drivers/media/platform/msm/camera/cam_sensor_module/cam_sensor/cam_sensor_core.c'
p3282
S'cam_sensor_driver_cmd'
p3283
tp3284
(dp3285
S'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif ((s_ctrl->is_probe_succeed == 0) ||\n\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t\t"Not in right state to aquire %d",\n\t\t\t\ts_ctrl->sensor_state);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,\n\t\t\tsizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p3286
(dp3287
((g3282
g3283
tp3288
I1
tp3289
(dp3290
g12
g13
sg14
(dp3291
(I40
I41
tp3292
(lp3293
S'\t\t\trc = -EINVAL;'
p3294
aS'\t\t\tgoto release_mutex;'
p3295
as(I72
I72
tp3296
(lp3297
S'\t\t\tgoto free_power_settings;'
p3298
as(I323
I332
tp3299
(lp3300
g59
aS'free_power_settings:'
p3301
aS'\tkfree(power_info->power_setting);'
p3302
aS'\tkfree(power_info->power_down_setting);'
p3303
aS'\tpower_info->power_setting = NULL;'
p3304
aS'\tpower_info->power_down_setting = NULL;'
p3305
aS'\tpower_info->power_down_setting_size = 0;'
p3306
aS'\tpower_info->power_setting_size = 0;'
p3307
aS'\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));'
p3308
aS'\treturn rc;'
p3309
as(I53
I53
tp3310
(lp3311
S'\t\t\tgoto free_power_settings;'
p3312
as(I92
I92
tp3313
(lp3314
S'\t\t\tgoto free_power_settings;'
p3315
as(I84
I84
tp3316
(lp3317
S'\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3318
as(I80
I80
tp3319
(lp3320
S'\t\t\tgoto free_power_settings;'
p3321
as(I65
I65
tp3322
(lp3323
S'\t\t\tgoto free_power_settings;'
p3324
as(I106
I114
tp3325
(lp3326
S'\t\tif ((s_ctrl->is_probe_succeed == 0) ||'
p3327
aS'\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {'
p3328
aS'\t\t\tCAM_WARN(CAM_SENSOR,'
p3329
aS'\t\t\t\t"Not in right state to aquire %d",'
p3330
aS'\t\t\t\ts_ctrl->sensor_state);'
p3331
aS'\t\t\trc = -EINVAL;'
p3332
aS'\t\t\tgoto release_mutex;'
p3333
aS'\t\t}'
p3334
ag59
assg32
I2
sg33
(dp3335
(I65
I67
tp3336
(lp3337
S'\t\t\tkfree(pu);'
p3338
aS'\t\t\tkfree(pd);'
p3339
aS'\t\t\tgoto release_mutex;'
p3340
as(I40
I40
tp3341
(lp3342
S'\t\t\treturn -EINVAL;'
p3343
as(I6
I7
tp3344
(lp3345
S'\tstruct cam_sensor_power_setting *pu = NULL;'
p3346
aS'\tstruct cam_sensor_power_setting *pd = NULL;'
p3347
as(I92
I94
tp3348
(lp3349
S'\t\t\tkfree(pu);'
p3350
aS'\t\t\tkfree(pd);'
p3351
aS'\t\t\tgoto release_mutex;'
p3352
as(I84
I84
tp3353
(lp3354
S'\t\t\t"Probe Succees,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3355
as(I29
I46
tp3356
(lp3357
S'\t\t/* Allocate memory for power up setting */'
p3358
aS'\t\tpu = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3359
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3360
aS'\t\tif (!pu) {'
p3361
aS'\t\t\trc = -ENOMEM;'
p3362
aS'\t\t\tgoto release_mutex;'
p3363
aS'\t\t}'
p3364
ag59
aS'\t\tpd = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3365
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3366
aS'\t\tif (!pd) {'
p3367
aS'\t\t\tkfree(pu);'
p3368
aS'\t\t\trc = -ENOMEM;'
p3369
aS'\t\t\tgoto release_mutex;'
p3370
aS'\t\t}'
p3371
ag59
aS'\t\tpower_info->power_setting = pu;'
p3372
aS'\t\tpower_info->power_down_setting = pd;'
p3373
as(I53
I55
tp3374
(lp3375
S'\t\t\tkfree(pu);'
p3376
aS'\t\t\tkfree(pd);'
p3377
aS'\t\t\tgoto release_mutex;'
p3378
as(I35
I36
tp3379
(lp3380
S'\t\t\t\tkfree(pu);'
p3381
aS'\t\t\t\tkfree(pd);'
p3382
as(I72
I74
tp3383
(lp3384
S'\t\t\tkfree(pu);'
p3385
aS'\t\t\tkfree(pd);'
p3386
aS'\t\t\tgoto release_mutex;'
p3387
as(I80
I82
tp3388
(lp3389
S'\t\t\tkfree(pu);'
p3390
aS'\t\t\tkfree(pd);'
p3391
aS'\t\t\tgoto release_mutex;'
p3392
assg41
(I1
I333
tp3393
sssS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_setting *pu = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tkfree(pu);\n\t\t\t\tkfree(pd);\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tpu = power_info->power_setting;\n\t\tpd = power_info->power_down_setting;\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,\n\t\t\tsizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p3394
(dp3395
((g3282
g3283
tp3396
I1
tp3397
(dp3398
g12
g13
sg14
(dp3399
(I44
I45
tp3400
(lp3401
S'\t\t\trc = -EINVAL;'
p3402
aS'\t\t\tgoto release_mutex;'
p3403
as(I48
I50
tp3404
(lp3405
S'\t\tpu = power_info->power_setting;'
p3406
aS'\t\tpd = power_info->power_down_setting;'
p3407
ag59
as(I99
I99
tp3408
(lp3409
S'\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3410
assg32
I2
sg33
(dp3411
(I44
I44
tp3412
(lp3413
S'\t\t\treturn -EINVAL;'
p3414
as(I31
I48
tp3415
(lp3416
S'\t\t/* Allocate memory for power up setting */'
p3417
aS'\t\tpu = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3418
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3419
aS'\t\tif (!pu) {'
p3420
aS'\t\t\trc = -ENOMEM;'
p3421
aS'\t\t\tgoto release_mutex;'
p3422
aS'\t\t}'
p3423
ag59
aS'\t\tpd = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3424
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3425
aS'\t\tif (!pd) {'
p3426
aS'\t\t\tkfree(pu);'
p3427
aS'\t\t\trc = -ENOMEM;'
p3428
aS'\t\t\tgoto release_mutex;'
p3429
aS'\t\t}'
p3430
ag59
aS'\t\tpower_info->power_setting = pu;'
p3431
aS'\t\tpower_info->power_down_setting = pd;'
p3432
as(I99
I99
tp3433
(lp3434
S'\t\t\t"Probe Succees,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3435
assg41
(I1
I331
tp3436
sssS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_setting *pu = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tkfree(pu);\n\t\t\t\tkfree(pd);\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpu = power_info->power_setting;\n\t\tpd = power_info->power_down_setting;\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe Succees,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,\n\t\t\tsizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p3437
(dp3438
((g3282
g3283
tp3439
I1
tp3440
(dp3441
g12
g13
sg14
(dp3442
(I47
I49
tp3443
(lp3444
S'\t\tpu = power_info->power_setting;'
p3445
aS'\t\tpd = power_info->power_down_setting;'
p3446
ag59
assg32
I2
sg33
(dp3447
(I31
I48
tp3448
(lp3449
S'\t\t/* Allocate memory for power up setting */'
p3450
aS'\t\tpu = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3451
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3452
aS'\t\tif (!pu) {'
p3453
aS'\t\t\trc = -ENOMEM;'
p3454
aS'\t\t\tgoto release_mutex;'
p3455
aS'\t\t}'
p3456
ag59
aS'\t\tpd = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3457
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3458
aS'\t\tif (!pd) {'
p3459
aS'\t\t\tkfree(pu);'
p3460
aS'\t\t\trc = -ENOMEM;'
p3461
aS'\t\t\tgoto release_mutex;'
p3462
aS'\t\t}'
p3463
ag59
aS'\t\tpower_info->power_setting = pu;'
p3464
aS'\t\tpower_info->power_down_setting = pd;'
p3465
assg41
(I1
I330
tp3466
sssS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif ((s_ctrl->is_probe_succeed == 0) ||\n\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t\t"Not in right state to aquire %d",\n\t\t\t\ts_ctrl->sensor_state);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\tu64_to_user_ptr(cmd->handle),\n\t\t\tsizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p3467
(dp3468
((g3282
g3283
tp3469
I1
tp3470
(dp3471
g12
g13
sg14
(dp3472
(I209
I210
tp3473
(lp3474
S'\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),'
p3475
aS'\t\t\t&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {'
p3476
as(I121
I122
tp3477
(lp3478
S'\t\t\tu64_to_user_ptr(cmd->handle),'
p3479
aS'\t\t\tsizeof(sensor_acq_dev));'
p3480
as(I84
I84
tp3481
(lp3482
S'\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3483
as(I53
I53
tp3484
(lp3485
S'\t\t\tgoto free_power_settings;'
p3486
as(I141
I142
tp3487
(lp3488
S'\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),'
p3489
aS'\t\t\t&sensor_acq_dev,'
p3490
as(I92
I92
tp3491
(lp3492
S'\t\t\tgoto free_power_settings;'
p3493
as(I80
I80
tp3494
(lp3495
S'\t\t\tgoto free_power_settings;'
p3496
as(I263
I263
tp3497
(lp3498
S'\t\tcam_sensor_release_per_frame_resource(s_ctrl);'
p3499
as(I106
I114
tp3500
(lp3501
S'\t\tif ((s_ctrl->is_probe_succeed == 0) ||'
p3502
aS'\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {'
p3503
aS'\t\t\tCAM_WARN(CAM_SENSOR,'
p3504
aS'\t\t\t\t"Not in right state to aquire %d",'
p3505
aS'\t\t\t\ts_ctrl->sensor_state);'
p3506
aS'\t\t\trc = -EINVAL;'
p3507
aS'\t\t\tgoto release_mutex;'
p3508
aS'\t\t}'
p3509
ag59
as(I40
I41
tp3510
(lp3511
S'\t\t\trc = -EINVAL;'
p3512
aS'\t\t\tgoto release_mutex;'
p3513
as(I325
I334
tp3514
(lp3515
g59
aS'free_power_settings:'
p3516
aS'\tkfree(power_info->power_setting);'
p3517
aS'\tkfree(power_info->power_down_setting);'
p3518
aS'\tpower_info->power_setting = NULL;'
p3519
aS'\tpower_info->power_down_setting = NULL;'
p3520
aS'\tpower_info->power_down_setting_size = 0;'
p3521
aS'\tpower_info->power_setting_size = 0;'
p3522
aS'\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));'
p3523
aS'\treturn rc;'
p3524
as(I72
I72
tp3525
(lp3526
S'\t\t\tgoto free_power_settings;'
p3527
as(I178
I178
tp3528
(lp3529
S'\t\tcam_sensor_release_per_frame_resource(s_ctrl);'
p3530
as(I65
I65
tp3531
(lp3532
S'\t\t\tgoto free_power_settings;'
p3533
assg32
I2
sg33
(dp3534
(I209
I210
tp3535
(lp3536
S'\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,'
p3537
aS'\t\t\tsizeof(struct  cam_sensor_query_cap))) {'
p3538
as(I65
I67
tp3539
(lp3540
S'\t\t\tkfree(pu);'
p3541
aS'\t\t\tkfree(pd);'
p3542
aS'\t\t\tgoto release_mutex;'
p3543
as(I6
I7
tp3544
(lp3545
S'\tstruct cam_sensor_power_setting *pu = NULL;'
p3546
aS'\tstruct cam_sensor_power_setting *pd = NULL;'
p3547
as(I92
I94
tp3548
(lp3549
S'\t\t\tkfree(pu);'
p3550
aS'\t\t\tkfree(pd);'
p3551
aS'\t\t\tgoto release_mutex;'
p3552
as(I53
I55
tp3553
(lp3554
S'\t\t\tkfree(pu);'
p3555
aS'\t\t\tkfree(pd);'
p3556
aS'\t\t\tgoto release_mutex;'
p3557
as(I263
I263
tp3558
(lp3559
S'\t\tcam_sensor_release_resource(s_ctrl);'
p3560
as(I84
I84
tp3561
(lp3562
S'\t\t\t"Probe Succees,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3563
as(I72
I74
tp3564
(lp3565
S'\t\t\tkfree(pu);'
p3566
aS'\t\t\tkfree(pd);'
p3567
aS'\t\t\tgoto release_mutex;'
p3568
as(I121
I121
tp3569
(lp3570
S'\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));'
p3571
as(I40
I40
tp3572
(lp3573
S'\t\t\treturn -EINVAL;'
p3574
as(I178
I178
tp3575
(lp3576
S'\t\tcam_sensor_release_resource(s_ctrl);'
p3577
as(I29
I46
tp3578
(lp3579
S'\t\t/* Allocate memory for power up setting */'
p3580
aS'\t\tpu = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3581
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3582
aS'\t\tif (!pu) {'
p3583
aS'\t\t\trc = -ENOMEM;'
p3584
aS'\t\t\tgoto release_mutex;'
p3585
aS'\t\t}'
p3586
ag59
aS'\t\tpd = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3587
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3588
aS'\t\tif (!pd) {'
p3589
aS'\t\t\tkfree(pu);'
p3590
aS'\t\t\trc = -ENOMEM;'
p3591
aS'\t\t\tgoto release_mutex;'
p3592
aS'\t\t}'
p3593
ag59
aS'\t\tpower_info->power_setting = pu;'
p3594
aS'\t\tpower_info->power_down_setting = pd;'
p3595
as(I35
I36
tp3596
(lp3597
S'\t\t\t\tkfree(pu);'
p3598
aS'\t\t\t\tkfree(pd);'
p3599
as(I80
I82
tp3600
(lp3601
S'\t\t\tkfree(pu);'
p3602
aS'\t\t\tkfree(pd);'
p3603
aS'\t\t\tgoto release_mutex;'
p3604
as(I141
I141
tp3605
(lp3606
S'\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,'
p3607
assg41
(I1
I335
tp3608
sssS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif ((s_ctrl->is_probe_succeed == 0) ||\n\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t\t"Not in right state to aquire %d",\n\t\t\t\ts_ctrl->sensor_state);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\tu64_to_user_ptr(cmd->handle),\n\t\t\tsizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.link_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Device [%d] still active on link 0x%x",\n\t\t\t\ts_ctrl->sensor_state,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EAGAIN;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p3609
(dp3610
((g3282
g3283
tp3611
I1
tp3612
(dp3613
g12
g13
sg14
(dp3614
(I121
I122
tp3615
(lp3616
S'\t\t\tu64_to_user_ptr(cmd->handle),'
p3617
aS'\t\t\tsizeof(sensor_acq_dev));'
p3618
as(I187
I187
tp3619
(lp3620
S'\t\tcam_sensor_release_per_frame_resource(s_ctrl);'
p3621
as(I84
I84
tp3622
(lp3623
S'\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3624
as(I218
I219
tp3625
(lp3626
S'\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),'
p3627
aS'\t\t\t&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {'
p3628
as(I53
I53
tp3629
(lp3630
S'\t\t\tgoto free_power_settings;'
p3631
as(I141
I142
tp3632
(lp3633
S'\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),'
p3634
aS'\t\t\t&sensor_acq_dev,'
p3635
as(I92
I92
tp3636
(lp3637
S'\t\t\tgoto free_power_settings;'
p3638
as(I80
I80
tp3639
(lp3640
S'\t\t\tgoto free_power_settings;'
p3641
as(I106
I114
tp3642
(lp3643
S'\t\tif ((s_ctrl->is_probe_succeed == 0) ||'
p3644
aS'\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {'
p3645
aS'\t\t\tCAM_WARN(CAM_SENSOR,'
p3646
aS'\t\t\t\t"Not in right state to aquire %d",'
p3647
aS'\t\t\t\ts_ctrl->sensor_state);'
p3648
aS'\t\t\trc = -EINVAL;'
p3649
aS'\t\t\tgoto release_mutex;'
p3650
aS'\t\t}'
p3651
ag59
as(I40
I41
tp3652
(lp3653
S'\t\t\trc = -EINVAL;'
p3654
aS'\t\t\tgoto release_mutex;'
p3655
as(I72
I72
tp3656
(lp3657
S'\t\t\tgoto free_power_settings;'
p3658
as(I272
I272
tp3659
(lp3660
S'\t\tcam_sensor_release_per_frame_resource(s_ctrl);'
p3661
as(I334
I343
tp3662
(lp3663
g59
aS'free_power_settings:'
p3664
aS'\tkfree(power_info->power_setting);'
p3665
aS'\tkfree(power_info->power_down_setting);'
p3666
aS'\tpower_info->power_setting = NULL;'
p3667
aS'\tpower_info->power_down_setting = NULL;'
p3668
aS'\tpower_info->power_down_setting_size = 0;'
p3669
aS'\tpower_info->power_setting_size = 0;'
p3670
aS'\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));'
p3671
aS'\treturn rc;'
p3672
as(I65
I65
tp3673
(lp3674
S'\t\t\tgoto free_power_settings;'
p3675
as(I172
I180
tp3676
(lp3677
S'\t\tif (s_ctrl->bridge_intf.link_hdl != -1) {'
p3678
aS'\t\t\tCAM_ERR(CAM_SENSOR,'
p3679
aS'\t\t\t\t"Device [%d] still active on link 0x%x",'
p3680
aS'\t\t\t\ts_ctrl->sensor_state,'
p3681
aS'\t\t\t\ts_ctrl->bridge_intf.link_hdl);'
p3682
aS'\t\t\trc = -EAGAIN;'
p3683
aS'\t\t\tgoto release_mutex;'
p3684
aS'\t\t}'
p3685
ag59
assg32
I2
sg33
(dp3686
(I187
I187
tp3687
(lp3688
S'\t\tcam_sensor_release_resource(s_ctrl);'
p3689
as(I65
I67
tp3690
(lp3691
S'\t\t\tkfree(pu);'
p3692
aS'\t\t\tkfree(pd);'
p3693
aS'\t\t\tgoto release_mutex;'
p3694
as(I6
I7
tp3695
(lp3696
S'\tstruct cam_sensor_power_setting *pu = NULL;'
p3697
aS'\tstruct cam_sensor_power_setting *pd = NULL;'
p3698
as(I92
I94
tp3699
(lp3700
S'\t\t\tkfree(pu);'
p3701
aS'\t\t\tkfree(pd);'
p3702
aS'\t\t\tgoto release_mutex;'
p3703
as(I53
I55
tp3704
(lp3705
S'\t\t\tkfree(pu);'
p3706
aS'\t\t\tkfree(pd);'
p3707
aS'\t\t\tgoto release_mutex;'
p3708
as(I84
I84
tp3709
(lp3710
S'\t\t\t"Probe Succees,slot:%d,slave_addr:0x%x,sensor_id:0x%x",'
p3711
as(I72
I74
tp3712
(lp3713
S'\t\t\tkfree(pu);'
p3714
aS'\t\t\tkfree(pd);'
p3715
aS'\t\t\tgoto release_mutex;'
p3716
as(I121
I121
tp3717
(lp3718
S'\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));'
p3719
as(I40
I40
tp3720
(lp3721
S'\t\t\treturn -EINVAL;'
p3722
as(I272
I272
tp3723
(lp3724
S'\t\tcam_sensor_release_resource(s_ctrl);'
p3725
as(I29
I46
tp3726
(lp3727
S'\t\t/* Allocate memory for power up setting */'
p3728
aS'\t\tpu = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3729
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3730
aS'\t\tif (!pu) {'
p3731
aS'\t\t\trc = -ENOMEM;'
p3732
aS'\t\t\tgoto release_mutex;'
p3733
aS'\t\t}'
p3734
ag59
aS'\t\tpd = kzalloc(sizeof(struct cam_sensor_power_setting) *'
p3735
aS'\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);'
p3736
aS'\t\tif (!pd) {'
p3737
aS'\t\t\tkfree(pu);'
p3738
aS'\t\t\trc = -ENOMEM;'
p3739
aS'\t\t\tgoto release_mutex;'
p3740
aS'\t\t}'
p3741
ag59
aS'\t\tpower_info->power_setting = pu;'
p3742
aS'\t\tpower_info->power_down_setting = pd;'
p3743
as(I218
I219
tp3744
(lp3745
S'\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,'
p3746
aS'\t\t\tsizeof(struct  cam_sensor_query_cap))) {'
p3747
as(I35
I36
tp3748
(lp3749
S'\t\t\t\tkfree(pu);'
p3750
aS'\t\t\t\tkfree(pd);'
p3751
as(I80
I82
tp3752
(lp3753
S'\t\t\tkfree(pu);'
p3754
aS'\t\t\tkfree(pd);'
p3755
aS'\t\t\tgoto release_mutex;'
p3756
as(I141
I141
tp3757
(lp3758
S'\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,'
p3759
assg41
(I1
I344
tp3760
ssss(S'drivers/media/platform/msm/camera/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c'
p3761
S'cam_sensor_core_power_up'
p3762
tp3763
(dp3764
S'int cam_sensor_core_power_up(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint rc = 0, index = 0, no_gpio = 0, ret = 0, num_vreg, j = 0, i = 0;\n\tint32_t vreg_idx = -1;\n\tstruct cam_sensor_power_setting *power_setting = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid ctrl handle");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(true);\n\n\tret = msm_camera_pinctrl_init(&(ctrl->pinctrl_info), ctrl->dev);\n\tif (ret < 0) {\n\t\t/* Some sensor subdev no pinctrl. */\n\t\tCAM_DBG(CAM_SENSOR, "Initialization of pinctrl failed");\n\t\tctrl->cam_pinctrl_status = 0;\n\t} else {\n\t\tctrl->cam_pinctrl_status = 1;\n\t}\n\n\tif (cam_res_mgr_shared_pinctrl_init()) {\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to init shared pinctrl");\n\t\treturn -EINVAL;\n\t}\n\n\trc = cam_sensor_util_request_gpio_table(soc_info, 1);\n\tif (rc < 0)\n\t\tno_gpio = rc;\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\tctrl->pinctrl_info.gpio_state_active);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to active state");\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_select_state(true);\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Cannot set shared pin to active state");\n\n\tCAM_DBG(CAM_SENSOR, "power setting size: %d", ctrl->power_setting_size);\n\n\tfor (index = 0; index < ctrl->power_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "index: %d", index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tif (!power_setting) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power up settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tCAM_DBG(CAM_SENSOR, "seq_type %d", power_setting->seq_type);\n\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tif (power_setting->seq_val >= soc_info->num_clk) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk index %d >= max %u",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tsoc_info->num_clk);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tfor (j = 0; j < num_vreg; j++) {\n\t\t\t\tif (!strcmp(soc_info->rgltr_name[j],\n\t\t\t\t\t"cam_clk")) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Enable cam_clk: %d", j);\n\n\t\t\t\t\tsoc_info->rgltr[j] =\n\t\t\t\t\tregulator_get(\n\t\t\t\t\t\tsoc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[j]);\n\n\t\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\t\tsoc_info->rgltr[j])) {\n\t\t\t\t\t\trc = PTR_ERR(\n\t\t\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\t\t\trc = rc ? rc : -EINVAL;\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t\t"vreg %s %d",\n\t\t\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\t\t\trc);\n\t\t\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t\t}\n\n\t\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t\t"Reg enable failed");\n\t\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t\t}\n\t\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (power_setting->config_val)\n\t\t\t\tsoc_info->clk_rate[0][power_setting->seq_val] =\n\t\t\t\t\tpower_setting->config_val;\n\n\t\t\tfor (j = 0; j < soc_info->num_clk; j++) {\n\t\t\t\trc = cam_soc_util_clk_enable(soc_info->clk[j],\n\t\t\t\t\tsoc_info->clk_name[j],\n\t\t\t\t\tsoc_info->clk_rate[0][j]);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk enable failed");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (no_gpio) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "request gpio failed");\n\t\t\t\treturn no_gpio;\n\t\t\t}\n\t\t\tif (!gpio_num_info) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid gpio_num_info");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tCAM_DBG(CAM_SENSOR, "gpio set val %d",\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type]);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info,\n\t\t\t\t(int) power_setting->config_val);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tif (power_setting->seq_val >= CAM_VREG_MAX) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "vreg index %d >= max %d",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tCAM_VREG_MAX);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Enable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\tsoc_info->rgltr[vreg_idx] =\n\t\t\t\t\tregulator_get(soc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx])) {\n\t\t\t\t\trc = PTR_ERR(soc_info->rgltr[vreg_idx]);\n\t\t\t\t\trc = rc ? rc : -EINVAL;\n\n\t\t\t\t\tCAM_ERR(CAM_SENSOR, "%s get failed %d",\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\t\trc);\n\n\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t}\n\n\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\t\t\t\tif (rc) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Reg Enable failed for %s",\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t}\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "usr_idx:%d dts_idx:%d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20)\n\t\t\tmsleep(power_setting->delay);\n\t\telse if (power_setting->delay)\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_post_init();\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to post init shared pinctrl");\n\n\treturn 0;\npower_up_failed:\n\tCAM_ERR(CAM_SENSOR, "failed");\n\tfor (index--; index >= 0; index--) {\n\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tCAM_DBG(CAM_SENSOR, "type %d",\n\t\t\tpower_setting->seq_type);\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {\n\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],\n\t\t\t\t\tsoc_info->clk_name[i]);\n\t\t\t}\n\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);\n\t\t\tif (ret < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"config clk reg failed rc: %d", ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (!gpio_num_info)\n\t\t\t\tcontinue;\n\t\t\tif (!gpio_num_info->valid\n\t\t\t\t[power_setting->seq_type])\n\t\t\t\tcontinue;\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type], GPIOF_OUT_INIT_LOW);\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\trc =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail to disalbe reg: %s",\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t\t\tmsm_cam_sensor_handle_reg_gpio(\n\t\t\t\t\t\tpower_setting->seq_type,\n\t\t\t\t\t\tgpio_num_info,\n\t\t\t\t\t\tGPIOF_OUT_INIT_LOW);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\n\t\t\t\tregulator_put(soc_info->rgltr[vreg_idx]);\n\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "seq_val:%d > num_vreg: %d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\tmsm_cam_sensor_handle_reg_gpio(power_setting->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20) {\n\t\t\tmsleep(power_setting->delay);\n\t\t} else if (power_setting->delay) {\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t\t}\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn rc;\n}'
p3765
(dp3766
((g3761
g3762
tp3767
I1
tp3768
(dp3769
g12
g13
sg14
(dp3770
(I4
I4
tp3771
(lp3772
S'\tint rc = 0, index = 0, no_gpio = 0, ret = 0, num_vreg, j = 0, i = 0;'
p3773
as(I101
I101
tp3774
(lp3775
S'\t\t\t\t\t\tgoto power_up_failed;'
p3776
as(I206
I211
tp3777
(lp3778
S'\t\t\t\tif (rc) {'
p3779
aS'\t\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3780
aS'\t\t\t\t\t\t"Reg Enable failed for %s",'
p3781
aS'\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);'
p3782
aS'\t\t\t\t\tgoto power_up_failed;'
p3783
aS'\t\t\t\t}'
p3784
as(I254
I265
tp3785
(lp3786
S'\t\tcase SENSOR_MCLK:'
p3787
aS'\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {'
p3788
aS'\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],'
p3789
aS'\t\t\t\t\tsoc_info->clk_name[i]);'
p3790
aS'\t\t\t}'
p3791
aS'\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);'
p3792
aS'\t\t\tif (ret < 0) {'
p3793
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3794
aS'\t\t\t\t\t"config clk reg failed rc: %d", ret);'
p3795
aS'\t\t\t\tcontinue;'
p3796
aS'\t\t\t}'
p3797
aS'\t\t\tbreak;'
p3798
as(I196
I196
tp3799
(lp3800
S'\t\t\t\t\tgoto power_up_failed;'
p3801
as(I343
I343
tp3802
(lp3803
S'\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3804
as(I312
I312
tp3805
(lp3806
S'\t\t\t\tregulator_put(soc_info->rgltr[vreg_idx]);'
p3807
as(I338
I339
tp3808
(lp3809
S'\t\t\tctrl->pinctrl_info.pinctrl,'
p3810
aS'\t\t\tctrl->pinctrl_info.gpio_state_suspend);'
p3811
as(I298
I308
tp3812
(lp3813
S'\t\t\t\tif (rc) {'
p3814
aS'\t\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3815
aS'\t\t\t\t\t"Fail to disalbe reg: %s",'
p3816
aS'\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);'
p3817
aS'\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;'
p3818
aS'\t\t\t\t\tmsm_cam_sensor_handle_reg_gpio('
p3819
aS'\t\t\t\t\t\tpower_setting->seq_type,'
p3820
aS'\t\t\t\t\t\tgpio_num_info,'
p3821
aS'\t\t\t\t\t\tGPIOF_OUT_INIT_LOW);'
p3822
aS'\t\t\t\t\tcontinue;'
p3823
aS'\t\t\t\t}'
p3824
as(I111
I115
tp3825
(lp3826
S'\t\t\t\t\tif (rc) {'
p3827
aS'\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3828
aS'\t\t\t\t\t\t\t"Reg enable failed");'
p3829
aS'\t\t\t\t\t\tgoto power_up_failed;'
p3830
aS'\t\t\t\t\t}'
p3831
as(I64
I66
tp3832
(lp3833
S'\t\t\tCAM_ERR(CAM_SENSOR,'
p3834
aS'\t\t\t\t"Invalid power up settings for index %d",'
p3835
aS'\t\t\t\tindex);'
p3836
assg32
I2
sg33
(dp3837
(I312
I313
tp3838
(lp3839
S'\t\t\t\tregulator_put('
p3840
aS'\t\t\t\t\tsoc_info->rgltr[vreg_idx]);'
p3841
as(I64
I64
tp3842
(lp3843
S'\t\t\tCAM_ERR(CAM_SENSOR, "Invalid power up settings");'
p3844
as(I338
I339
tp3845
(lp3846
S'\t\t\t\tctrl->pinctrl_info.pinctrl,'
p3847
aS'\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);'
p3848
as(I206
I206
tp3849
(lp3850
g59
as(I4
I4
tp3851
(lp3852
S'\tint rc = 0, index = 0, no_gpio = 0, ret = 0, num_vreg, j = 0;'
p3853
as(I111
I111
tp3854
(lp3855
g59
as(I343
I343
tp3856
(lp3857
S'\t\tpinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3858
assg41
(I1
I355
tp3859
sssS'int cam_sensor_core_power_up(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint rc = 0, index = 0, no_gpio = 0, ret = 0, num_vreg, j = 0;\n\tint32_t vreg_idx = -1;\n\tstruct cam_sensor_power_setting *power_setting = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid ctrl handle");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(true);\n\n\tret = msm_camera_pinctrl_init(&(ctrl->pinctrl_info), ctrl->dev);\n\tif (ret < 0) {\n\t\t/* Some sensor subdev no pinctrl. */\n\t\tCAM_DBG(CAM_SENSOR, "Initialization of pinctrl failed");\n\t\tctrl->cam_pinctrl_status = 0;\n\t} else {\n\t\tctrl->cam_pinctrl_status = 1;\n\t}\n\n\tif (cam_res_mgr_shared_pinctrl_init()) {\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to init shared pinctrl");\n\t\treturn -EINVAL;\n\t}\n\n\trc = cam_sensor_util_request_gpio_table(soc_info, 1);\n\tif (rc < 0)\n\t\tno_gpio = rc;\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\tctrl->pinctrl_info.gpio_state_active);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to active state");\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_select_state(true);\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Cannot set shared pin to active state");\n\n\tCAM_DBG(CAM_SENSOR, "power setting size: %d", ctrl->power_setting_size);\n\n\tfor (index = 0; index < ctrl->power_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "index: %d", index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tif (!power_setting) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power up settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tCAM_DBG(CAM_SENSOR, "seq_type %d", power_setting->seq_type);\n\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tif (power_setting->seq_val >= soc_info->num_clk) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk index %d >= max %u",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tsoc_info->num_clk);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tfor (j = 0; j < num_vreg; j++) {\n\t\t\t\tif (!strcmp(soc_info->rgltr_name[j],\n\t\t\t\t\t"cam_clk")) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Enable cam_clk: %d", j);\n\n\t\t\t\t\tsoc_info->rgltr[j] =\n\t\t\t\t\tregulator_get(\n\t\t\t\t\t\tsoc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[j]);\n\n\t\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\t\tsoc_info->rgltr[j])) {\n\t\t\t\t\t\trc = PTR_ERR(\n\t\t\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\t\t\trc = rc ? rc : -EINVAL;\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t\t"vreg %s %d",\n\t\t\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\t\t\trc);\n\t\t\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\n\t\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (power_setting->config_val)\n\t\t\t\tsoc_info->clk_rate[0][power_setting->seq_val] =\n\t\t\t\t\tpower_setting->config_val;\n\n\t\t\tfor (j = 0; j < soc_info->num_clk; j++) {\n\t\t\t\trc = cam_soc_util_clk_enable(soc_info->clk[j],\n\t\t\t\t\tsoc_info->clk_name[j],\n\t\t\t\t\tsoc_info->clk_rate[0][j]);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk enable failed");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (no_gpio) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "request gpio failed");\n\t\t\t\treturn no_gpio;\n\t\t\t}\n\t\t\tif (!gpio_num_info) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid gpio_num_info");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tCAM_DBG(CAM_SENSOR, "gpio set val %d",\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type]);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info,\n\t\t\t\t(int) power_setting->config_val);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tif (power_setting->seq_val >= CAM_VREG_MAX) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "vreg index %d >= max %d",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tCAM_VREG_MAX);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Enable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\tsoc_info->rgltr[vreg_idx] =\n\t\t\t\t\tregulator_get(soc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx])) {\n\t\t\t\t\trc = PTR_ERR(soc_info->rgltr[vreg_idx]);\n\t\t\t\t\trc = rc ? rc : -EINVAL;\n\n\t\t\t\t\tCAM_ERR(CAM_SENSOR, "%s get failed %d",\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\t\trc);\n\n\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t\t}\n\n\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "usr_idx:%d dts_idx:%d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20)\n\t\t\tmsleep(power_setting->delay);\n\t\telse if (power_setting->delay)\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_post_init();\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to post init shared pinctrl");\n\n\treturn 0;\npower_up_failed:\n\tCAM_ERR(CAM_SENSOR, "failed");\n\tfor (index--; index >= 0; index--) {\n\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tCAM_DBG(CAM_SENSOR, "type %d",\n\t\t\tpower_setting->seq_type);\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (!gpio_num_info)\n\t\t\t\tcontinue;\n\t\t\tif (!gpio_num_info->valid\n\t\t\t\t[power_setting->seq_type])\n\t\t\t\tcontinue;\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type], GPIOF_OUT_INIT_LOW);\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\trc =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\n\t\t\t\tregulator_put(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx]);\n\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "seq_val:%d > num_vreg: %d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\tmsm_cam_sensor_handle_reg_gpio(power_setting->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20) {\n\t\t\tmsleep(power_setting->delay);\n\t\t} else if (power_setting->delay) {\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t\t}\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn rc;\n}'
p3860
(dp3861
((g3761
g3762
tp3862
I1
tp3863
(dp3864
g12
g13
sg14
(dp3865
(I64
I66
tp3866
(lp3867
S'\t\t\tCAM_ERR(CAM_SENSOR,'
p3868
aS'\t\t\t\t"Invalid power up settings for index %d",'
p3869
aS'\t\t\t\tindex);'
p3870
as(I310
I310
tp3871
(lp3872
S'\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3873
assg32
I2
sg33
(dp3874
(I64
I64
tp3875
(lp3876
S'\t\t\tCAM_ERR(CAM_SENSOR, "Invalid power up settings");'
p3877
as(I310
I310
tp3878
(lp3879
S'\t\tpinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3880
assg41
(I1
I322
tp3881
ssss(g3761
S'msm_camera_power_down'
p3882
tp3883
(dp3884
S'int msm_camera_power_down(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint index = 0, ret = 0, num_vreg = 0, i;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl || !soc_info) {\n\t\tCAM_ERR(CAM_SENSOR, "failed ctrl %pK",  ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctrl->power_down_setting_size > MAX_POWER_CONFIG) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid: power setting size %d",\n\t\t\tctrl->power_setting_size);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (index = 0; index < ctrl->power_down_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "power_down_index %d",  index);\n\t\tpd = &ctrl->power_down_setting[index];\n\t\tif (!pd) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power down settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tps = NULL;\n\t\tCAM_DBG(CAM_SENSOR, "seq_type %d",  pd->seq_type);\n\t\tswitch (pd->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {\n\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],\n\t\t\t\t\tsoc_info->clk_name[i]);\n\t\t\t}\n\n\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);\n\t\t\tif (ret < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"config clk reg failed rc: %d", ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\n\t\t\tif (!gpio_num_info->valid[pd->seq_type])\n\t\t\t\tcontinue;\n\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[pd->seq_type],\n\t\t\t\t(int) pd->config_val);\n\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (pd->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tps = msm_camera_get_power_settings(\n\t\t\t\tctrl, pd->seq_type,\n\t\t\t\tpd->seq_val);\n\t\t\tif (ps) {\n\t\t\t\tif (pd->seq_val < num_vreg) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Disable Regulator");\n\t\t\t\t\tret =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_name[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_min_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_max_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_op_mode[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_delay[ps->seq_val]);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Reg: %s disable failed",\n\t\t\t\t\t\tsoc_info->rgltr_name[\n\t\t\t\t\t\t\tps->seq_val]);\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val] =\n\t\t\t\t\t\t\tNULL;\n\t\t\t\t\t\tmsm_cam_sensor_handle_reg_gpio(\n\t\t\t\t\t\t\tpd->seq_type,\n\t\t\t\t\t\t\tgpio_num_info,\n\t\t\t\t\t\t\tGPIOF_OUT_INIT_LOW);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tps->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val];\n\n\t\t\t\t\tregulator_put(\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val]);\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val] = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"seq_val:%d > num_vreg: %d",\n\t\t\t\t\t\t pd->seq_val,\n\t\t\t\t\t\tnum_vreg);\n\t\t\t} else\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"error in power up/down seq");\n\n\t\t\tret = msm_cam_sensor_handle_reg_gpio(pd->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tif (ret < 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error disabling VREG GPIO");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpd->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (pd->delay > 20)\n\t\t\tmsleep(pd->delay);\n\t\telse if (pd->delay)\n\t\t\tusleep_range(pd->delay * 1000,\n\t\t\t\t(pd->delay * 1000) + 1000);\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn 0;\n}'
p3885
(dp3886
((g3761
g3882
tp3887
I1
tp3888
(dp3889
g12
g13
sg14
(dp3890
(I32
I38
tp3891
(lp3892
S'\t\tif (!pd) {'
p3893
aS'\t\t\tCAM_ERR(CAM_SENSOR,'
p3894
aS'\t\t\t\t"Invalid power down settings for index %d",'
p3895
aS'\t\t\t\tindex);'
p3896
aS'\t\t\treturn -EINVAL;'
p3897
aS'\t\t}'
p3898
ag59
as(I40
I40
tp3899
(lp3900
S'\t\tCAM_DBG(CAM_SENSOR, "seq_type %d",  pd->seq_type);'
p3901
as(I48
I53
tp3902
(lp3903
S'\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);'
p3904
aS'\t\t\tif (ret < 0) {'
p3905
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3906
aS'\t\t\t\t\t"config clk reg failed rc: %d", ret);'
p3907
aS'\t\t\t\tcontinue;'
p3908
aS'\t\t\t}'
p3909
as(I149
I149
tp3910
(lp3911
S'\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3912
as(I30
I30
tp3913
(lp3914
S'\t\tCAM_DBG(CAM_SENSOR, "power_down_index %d",  index);'
p3915
as(I23
I28
tp3916
(lp3917
S'\tif (ctrl->power_down_setting_size > MAX_POWER_CONFIG) {'
p3918
aS'\t\tCAM_ERR(CAM_SENSOR, "Invalid: power setting size %d",'
p3919
aS'\t\t\tctrl->power_setting_size);'
p3920
aS'\t\treturn -EINVAL;'
p3921
aS'\t}'
p3922
ag59
as(I93
I105
tp3923
(lp3924
S'\t\t\t\t\tif (ret) {'
p3925
aS'\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3926
aS'\t\t\t\t\t\t"Reg: %s disable failed",'
p3927
aS'\t\t\t\t\t\tsoc_info->rgltr_name['
p3928
aS'\t\t\t\t\t\t\tps->seq_val]);'
p3929
aS'\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val] ='
p3930
aS'\t\t\t\t\t\t\tNULL;'
p3931
aS'\t\t\t\t\t\tmsm_cam_sensor_handle_reg_gpio('
p3932
aS'\t\t\t\t\t\t\tpd->seq_type,'
p3933
aS'\t\t\t\t\t\t\tgpio_num_info,'
p3934
aS'\t\t\t\t\t\t\tGPIOF_OUT_INIT_LOW);'
p3935
aS'\t\t\t\t\t\tcontinue;'
p3936
aS'\t\t\t\t\t}'
p3937
as(I6
I6
tp3938
(lp3939
S'\tstruct cam_sensor_power_setting *ps = NULL;'
p3940
assg32
I2
sg33
(dp3941
(I43
I49
tp3942
(lp3943
S'\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);'
p3944
aS'\t\t\tif (ret < 0) {'
p3945
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p3946
aS'\t\t\t\t\t"config clk reg failed rc: %d", ret);'
p3947
aS'\t\t\t\treturn ret;'
p3948
aS'\t\t\t}'
p3949
aS'\t\t\t//cam_soc_util_clk_disable_default(soc_info);'
p3950
as(I6
I6
tp3951
(lp3952
S'\tstruct cam_sensor_power_setting *ps;'
p3953
as(I93
I93
tp3954
(lp3955
g59
as(I30
I30
tp3956
(lp3957
S'\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);'
p3958
as(I40
I40
tp3959
(lp3960
S'\t\tCAM_DBG(CAM_SENSOR, "type %d",  pd->seq_type);'
p3961
as(I149
I149
tp3962
(lp3963
S'\t\tpinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3964
assg41
(I1
I161
tp3965
sssS'int msm_camera_power_down(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint index = 0, ret = 0, num_vreg = 0, i;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl || !soc_info) {\n\t\tCAM_ERR(CAM_SENSOR, "failed ctrl %pK",  ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (index = 0; index < ctrl->power_down_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);\n\t\tpd = &ctrl->power_down_setting[index];\n\t\tif (!pd) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power down settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tps = NULL;\n\t\tCAM_DBG(CAM_SENSOR, "type %d",  pd->seq_type);\n\t\tswitch (pd->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);\n\t\t\tif (ret < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"config clk reg failed rc: %d", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t//cam_soc_util_clk_disable_default(soc_info);\n\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {\n\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],\n\t\t\t\t\tsoc_info->clk_name[i]);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\n\t\t\tif (!gpio_num_info->valid[pd->seq_type])\n\t\t\t\tcontinue;\n\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[pd->seq_type],\n\t\t\t\t(int) pd->config_val);\n\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (pd->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tps = msm_camera_get_power_settings(\n\t\t\t\tctrl, pd->seq_type,\n\t\t\t\tpd->seq_val);\n\t\t\tif (ps) {\n\t\t\t\tif (pd->seq_val < num_vreg) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Disable Regulator");\n\t\t\t\t\tret =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_name[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_min_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_max_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_op_mode[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_delay[ps->seq_val]);\n\n\t\t\t\t\tps->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val];\n\n\t\t\t\t\tregulator_put(\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val]);\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val] = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"seq_val:%d > num_vreg: %d",\n\t\t\t\t\t\t pd->seq_val,\n\t\t\t\t\t\tnum_vreg);\n\t\t\t} else\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"error in power up/down seq");\n\n\t\t\tret = msm_cam_sensor_handle_reg_gpio(pd->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tif (ret < 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error disabling VREG GPIO");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpd->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (pd->delay > 20)\n\t\t\tmsleep(pd->delay);\n\t\telse if (pd->delay)\n\t\t\tusleep_range(pd->delay * 1000,\n\t\t\t\t(pd->delay * 1000) + 1000);\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn 0;\n}'
p3966
(dp3967
((g3761
g3882
tp3968
I1
tp3969
(dp3970
g12
g13
sg14
(dp3971
(I26
I32
tp3972
(lp3973
S'\t\tif (!pd) {'
p3974
aS'\t\t\tCAM_ERR(CAM_SENSOR,'
p3975
aS'\t\t\t\t"Invalid power down settings for index %d",'
p3976
aS'\t\t\t\tindex);'
p3977
aS'\t\t\treturn -EINVAL;'
p3978
aS'\t\t}'
p3979
ag59
as(I132
I132
tp3980
(lp3981
S'\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3982
as(I6
I6
tp3983
(lp3984
S'\tstruct cam_sensor_power_setting *ps = NULL;'
p3985
assg32
I2
sg33
(dp3986
(I132
I132
tp3987
(lp3988
S'\t\tpinctrl_put(ctrl->pinctrl_info.pinctrl);'
p3989
as(I6
I6
tp3990
(lp3991
S'\tstruct cam_sensor_power_setting *ps;'
p3992
assg41
(I1
I144
tp3993
ssss(g3282
S'cam_sensor_shutdown'
p3994
tp3995
(dp3996
S'void cam_sensor_shutdown(struct cam_sensor_ctrl_t *s_ctrl)\n{\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tint rc = 0;\n\n\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&\n\t\t(s_ctrl->is_probe_succeed == 0))\n\t\treturn;\n\n\tcam_sensor_release_stream_rsc(s_ctrl);\n\tcam_sensor_release_per_frame_resource(s_ctrl);\n\tcam_sensor_power_down(s_ctrl);\n\n\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\tif (rc < 0)\n\t\tCAM_ERR(CAM_SENSOR, " failed destroying dhdl");\n\ts_ctrl->bridge_intf.device_hdl = -1;\n\ts_ctrl->bridge_intf.link_hdl = -1;\n\ts_ctrl->bridge_intf.session_hdl = -1;\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_down_setting_size = 0;\n\ts_ctrl->streamon_count = 0;\n\ts_ctrl->streamoff_count = 0;\n\ts_ctrl->is_probe_succeed = 0;\n\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n}'
p3997
(dp3998
((g3282
g3994
tp3999
I1
tp4000
(dp4001
g12
g13
sg14
(dp4002
(I12
I13
tp4003
(lp4004
S'\tcam_sensor_release_per_frame_resource(s_ctrl);'
p4005
aS'\tcam_sensor_power_down(s_ctrl);'
p4006
as(I7
I8
tp4007
(lp4008
S'\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&'
p4009
aS'\t\t(s_ctrl->is_probe_succeed == 0))'
p4010
as(I29
I29
tp4011
(lp4012
S'\ts_ctrl->is_probe_succeed = 0;'
p4013
as(I23
I26
tp4014
(lp4015
S'\tpower_info->power_setting = NULL;'
p4016
aS'\tpower_info->power_down_setting = NULL;'
p4017
aS'\tpower_info->power_setting_size = 0;'
p4018
aS'\tpower_info->power_down_setting_size = 0;'
p4019
assg32
I1
sg33
(dp4020
(I12
I13
tp4021
(lp4022
S'\tif (s_ctrl->sensor_state >= CAM_SENSOR_ACQUIRE)'
p4023
aS'\t\tcam_sensor_power_down(s_ctrl);'
p4024
as(I23
I23
tp4025
(lp4026
g59
as(I7
I8
tp4027
(lp4028
S'\ts_ctrl->is_probe_succeed = 0;'
p4029
aS'\tif (s_ctrl->sensor_state == CAM_SENSOR_INIT)'
p4030
as(I11
I11
tp4031
(lp4032
S'\tcam_sensor_release_resource(s_ctrl);'
p4033
as(I21
I21
tp4034
(lp4035
g59
assg41
(I1
I31
tp4036
sssS'void cam_sensor_shutdown(struct cam_sensor_ctrl_t *s_ctrl)\n{\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tint rc = 0;\n\n\ts_ctrl->is_probe_succeed = 0;\n\tif (s_ctrl->sensor_state == CAM_SENSOR_INIT)\n\t\treturn;\n\n\tcam_sensor_release_resource(s_ctrl);\n\tcam_sensor_release_stream_rsc(s_ctrl);\n\tif (s_ctrl->sensor_state >= CAM_SENSOR_ACQUIRE)\n\t\tcam_sensor_power_down(s_ctrl);\n\n\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\tif (rc < 0)\n\t\tCAM_ERR(CAM_SENSOR, " failed destroying dhdl");\n\ts_ctrl->bridge_intf.device_hdl = -1;\n\ts_ctrl->bridge_intf.link_hdl = -1;\n\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\n\ts_ctrl->streamon_count = 0;\n\ts_ctrl->streamoff_count = 0;\n\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n}'
p4037
(dp4038
((g3282
g3994
tp4039
I1
tp4040
(dp4041
g14
(dp4042
(I25
I26
tp4043
(lp4044
S'\tpower_info->power_setting = NULL;'
p4045
aS'\tpower_info->power_down_setting = NULL;'
p4046
assg32
I1
sg12
g13
sg41
(I1
I31
tp4047
sssS'void cam_sensor_shutdown(struct cam_sensor_ctrl_t *s_ctrl)\n{\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tint rc = 0;\n\n\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&\n\t\t(s_ctrl->is_probe_succeed == 0))\n\t\treturn;\n\n\tcam_sensor_release_resource(s_ctrl);\n\tcam_sensor_release_stream_rsc(s_ctrl);\n\tif (s_ctrl->sensor_state >= CAM_SENSOR_ACQUIRE)\n\t\tcam_sensor_power_down(s_ctrl);\n\n\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\tif (rc < 0)\n\t\tCAM_ERR(CAM_SENSOR, " failed destroying dhdl");\n\ts_ctrl->bridge_intf.device_hdl = -1;\n\ts_ctrl->bridge_intf.link_hdl = -1;\n\ts_ctrl->bridge_intf.session_hdl = -1;\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_down_setting_size = 0;\n\ts_ctrl->streamon_count = 0;\n\ts_ctrl->streamoff_count = 0;\n\ts_ctrl->is_probe_succeed = 0;\n\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n}'
p4048
(dp4049
((g3282
g3994
tp4050
I1
tp4051
(dp4052
g12
g13
sg14
(dp4053
(I24
I27
tp4054
(lp4055
S'\tpower_info->power_setting = NULL;'
p4056
aS'\tpower_info->power_down_setting = NULL;'
p4057
aS'\tpower_info->power_setting_size = 0;'
p4058
aS'\tpower_info->power_down_setting_size = 0;'
p4059
as(I7
I8
tp4060
(lp4061
S'\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&'
p4062
aS'\t\t(s_ctrl->is_probe_succeed == 0))'
p4063
as(I30
I30
tp4064
(lp4065
S'\ts_ctrl->is_probe_succeed = 0;'
p4066
assg32
I1
sg33
(dp4067
(I24
I24
tp4068
(lp4069
g59
as(I7
I8
tp4070
(lp4071
S'\ts_ctrl->is_probe_succeed = 0;'
p4072
aS'\tif (s_ctrl->sensor_state == CAM_SENSOR_INIT)'
p4073
as(I22
I22
tp4074
(lp4075
g59
assg41
(I1
I32
tp4076
ssss(g3761
S'cam_sensor_update_power_settings'
p4077
tp4078
(dp4079
S'int32_t cam_sensor_update_power_settings(void *cmd_buf,\n\tint cmd_length, struct cam_sensor_power_ctrl_t *power_info)\n{\n\tint32_t rc = 0, tot_size = 0, last_cmd_type = 0;\n\tint32_t i = 0, pwr_up = 0, pwr_down = 0;\n\tstruct cam_sensor_power_setting *pwr_settings;\n\tvoid *ptr = cmd_buf, *scr;\n\tstruct cam_cmd_power *pwr_cmd = (struct cam_cmd_power *)cmd_buf;\n\tstruct common_header *cmm_hdr = (struct common_header *)cmd_buf;\n\n\tif (!pwr_cmd || !cmd_length) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Args: pwr_cmd %pK, cmd_length: %d",\n\t\t\tpwr_cmd, cmd_length);\n\t\treturn -EINVAL;\n\t}\n\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_setting)\n\t\treturn -ENOMEM;\n\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_down_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_down_setting) {\n\t\trc = -ENOMEM;\n\t\tgoto free_power_settings;\n\t}\n\n\twhile (tot_size < cmd_length) {\n\t\tif (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tpower_info->power_setting_size += pwr_cmd->count;\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_WARN(CAM_SENSOR, "Un expected Command");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_up++) {\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpower_info->power_setting[pwr_up].config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_setting[pwr_up].delay = 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size = tot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Error: Cmd Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_down_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t"Seq Type[%d]: %d Config_val: %ld", pwr_up,\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type,\n\t\t\t\tpower_info->power_setting[pwr_up].config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_UP;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type == CAMERA_SENSOR_CMD_TYPE_WAIT) {\n\t\t\tstruct cam_cmd_unconditional_wait *wait_cmd =\n\t\t\t\t(struct cam_cmd_unconditional_wait *)ptr;\n\t\t\tif ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP)) {\n\t\t\t\tif (pwr_up > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_setting[pwr_up - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else if ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN)) {\n\t\t\t\tif (pwr_down > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_down_setting[\n\t\t\t\t\t\tpwr_down - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Invalid op code: %d",\n\t\t\t\t\twait_cmd->op_code);\n\t\t\t}\n\n\t\t\ttot_size = tot_size +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait);\n\t\t\tif (tot_size > cmd_length) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Command Buffer is wrong");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscr = (void *) (wait_cmd);\n\t\t\tptr = (void *)\n\t\t\t\t(scr +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait));\n\t\t\tCAM_DBG(CAM_SENSOR, "ptr: %pK sizeof: %d Next: %pK",\n\t\t\t\tscr, (int32_t)sizeof(\n\t\t\t\tstruct cam_cmd_unconditional_wait), ptr);\n\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\t\t\tpower_info->power_down_setting_size += pwr_cmd->count;\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_down++) {\n\t\t\t\tpwr_settings =\n\t\t\t\t&power_info->power_down_setting[pwr_down];\n\t\t\t\tpwr_settings->seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpwr_settings->config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_down_setting[pwr_down].delay\n\t\t\t\t\t= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size =\n\t\t\t\t\t\ttot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Command Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_down_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t"Seq Type[%d]: %d Config_val: %ld",\n\t\t\t\t\tpwr_down, pwr_settings->seq_type,\n\t\t\t\t\tpwr_settings->config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_DOWN;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Error: Un expected Header Type: %d",\n\t\t\t\tcmm_hdr->cmd_type);\n\t\t}\n\t}\n\n\treturn rc;\nfree_power_down_settings:\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_down_setting = NULL;\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tpower_info->power_setting = NULL;\n\treturn rc;\n}'
p4080
(dp4081
((g3761
g4077
tp4082
I1
tp4083
(dp4084
g14
(dp4085
(I180
I180
tp4086
(lp4087
S'\tpower_info->power_down_setting = NULL;'
p4088
as(I183
I183
tp4089
(lp4090
S'\tpower_info->power_setting = NULL;'
p4091
assg32
I3
sg12
g13
sg41
(I1
I185
tp4092
sssS'int32_t cam_sensor_update_power_settings(void *cmd_buf,\n\tint cmd_length, struct cam_sensor_power_ctrl_t *power_info)\n{\n\tint32_t rc = 0, tot_size = 0, last_cmd_type = 0;\n\tint32_t i = 0, pwr_up = 0, pwr_down = 0;\n\tstruct cam_sensor_power_setting *pwr_settings;\n\tvoid *ptr = cmd_buf, *scr;\n\tstruct cam_cmd_power *pwr_cmd = (struct cam_cmd_power *)cmd_buf;\n\tstruct common_header *cmm_hdr = (struct common_header *)cmd_buf;\n\n\tif (!pwr_cmd || !cmd_length) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Args: pwr_cmd %pK, cmd_length: %d",\n\t\t\tpwr_cmd, cmd_length);\n\t\treturn -EINVAL;\n\t}\n\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_setting)\n\t\treturn -ENOMEM;\n\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_down_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_down_setting) {\n\t\tkfree(power_info->power_setting);\n\t\tpower_info->power_setting = NULL;\n\t\tpower_info->power_setting_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (tot_size < cmd_length) {\n\t\tif (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tpower_info->power_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_setting_size > MAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power up setting size %d",\n\t\t\t\t\tpower_info->power_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_WARN(CAM_SENSOR, "pwr_up_size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_up++) {\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpower_info->power_setting[pwr_up].config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_setting[pwr_up].delay = 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size = tot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Error: Cmd Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t"Seq Type[%d]: %d Config_val: %ld", pwr_up,\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type,\n\t\t\t\tpower_info->power_setting[pwr_up].config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_UP;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type == CAMERA_SENSOR_CMD_TYPE_WAIT) {\n\t\t\tstruct cam_cmd_unconditional_wait *wait_cmd =\n\t\t\t\t(struct cam_cmd_unconditional_wait *)ptr;\n\t\t\tif ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP)) {\n\t\t\t\tif (pwr_up > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_setting[pwr_up - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else if ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN)) {\n\t\t\t\tif (pwr_down > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_down_setting[\n\t\t\t\t\t\tpwr_down - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Invalid op code: %d",\n\t\t\t\t\twait_cmd->op_code);\n\t\t\t}\n\n\t\t\ttot_size = tot_size +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait);\n\t\t\tif (tot_size > cmd_length) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Command Buffer is wrong");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscr = (void *) (wait_cmd);\n\t\t\tptr = (void *)\n\t\t\t\t(scr +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait));\n\t\t\tCAM_DBG(CAM_SENSOR, "ptr: %pK sizeof: %d Next: %pK",\n\t\t\t\tscr, (int32_t)sizeof(\n\t\t\t\tstruct cam_cmd_unconditional_wait), ptr);\n\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\t\t\tpower_info->power_down_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_down_setting_size >\n\t\t\t\tMAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power down setting size %d",\n\t\t\t\t\tpower_info->power_down_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR, "pwr_down size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_down++) {\n\t\t\t\tpwr_settings =\n\t\t\t\t&power_info->power_down_setting[pwr_down];\n\t\t\t\tpwr_settings->seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpwr_settings->config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_down_setting[pwr_down].delay\n\t\t\t\t\t= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size =\n\t\t\t\t\t\ttot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Command Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t"Seq Type[%d]: %d Config_val: %ld",\n\t\t\t\t\tpwr_down, pwr_settings->seq_type,\n\t\t\t\t\tpwr_settings->config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_DOWN;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Error: Un expected Header Type: %d",\n\t\t\t\tcmm_hdr->cmd_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_power_settings;\n\t\t}\n\t}\n\n\treturn rc;\nfree_power_settings:\n\tkfree(power_info->power_down_setting);\n\tkfree(power_info->power_setting);\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\treturn rc;\n}'
p4093
(dp4094
((g3761
g4077
tp4095
I1
tp4096
(dp4097
g12
g13
sg14
(dp4098
(I44
I50
tp4099
(lp4100
S'\t\t\tif (power_info->power_setting_size > MAX_POWER_CONFIG) {'
p4101
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p4102
aS'\t\t\t\t\t"Invalid: power up setting size %d",'
p4103
aS'\t\t\t\t\tpower_info->power_setting_size);'
p4104
aS'\t\t\t\trc = -EINVAL;'
p4105
aS'\t\t\t\tgoto free_power_settings;'
p4106
aS'\t\t\t}'
p4107
as(I143
I150
tp4108
(lp4109
S'\t\t\tif (power_info->power_down_setting_size >'
p4110
aS'\t\t\t\tMAX_POWER_CONFIG) {'
p4111
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p4112
aS'\t\t\t\t\t"Invalid: power down setting size %d",'
p4113
aS'\t\t\t\t\tpower_info->power_down_setting_size);'
p4114
aS'\t\t\t\trc = -EINVAL;'
p4115
aS'\t\t\t\tgoto free_power_settings;'
p4116
aS'\t\t\t}'
p4117
as(I75
I75
tp4118
(lp4119
S'\t\t\t\t\tgoto free_power_settings;'
p4120
as(I31
I34
tp4121
(lp4122
S'\t\tkfree(power_info->power_setting);'
p4123
aS'\t\tpower_info->power_setting = NULL;'
p4124
aS'\t\tpower_info->power_setting_size = 0;'
p4125
aS'\t\treturn -ENOMEM;'
p4126
as(I198
I198
tp4127
(lp4128
S'\tkfree(power_info->power_down_setting);'
p4129
as(I200
I203
tp4130
(lp4131
S'\tpower_info->power_down_setting = NULL;'
p4132
aS'\tpower_info->power_setting = NULL;'
p4133
aS'\tpower_info->power_down_setting_size = 0;'
p4134
aS'\tpower_info->power_setting_size = 0;'
p4135
as(I177
I177
tp4136
(lp4137
S'\t\t\t\t\tgoto free_power_settings;'
p4138
as(I191
I192
tp4139
(lp4140
S'\t\t\trc = -EINVAL;'
p4141
aS'\t\t\tgoto free_power_settings;'
p4142
as(I55
I55
tp4143
(lp4144
S'\t\t\t\tCAM_WARN(CAM_SENSOR, "pwr_up_size is zero");'
p4145
as(I153
I153
tp4146
(lp4147
S'\t\t\t\tCAM_ERR(CAM_SENSOR, "pwr_down size is zero");'
p4148
assg32
I3
sg33
(dp4149
(I75
I75
tp4150
(lp4151
S'\t\t\t\t\tgoto free_power_down_settings;'
p4152
as(I55
I55
tp4153
(lp4154
S'\t\t\t\tCAM_WARN(CAM_SENSOR, "Un expected Command");'
p4155
as(I197
I198
tp4156
(lp4157
S'free_power_down_settings:'
p4158
aS'\tkfree(power_info->power_down_setting);'
p4159
as(I31
I32
tp4160
(lp4161
S'\t\trc = -ENOMEM;'
p4162
aS'\t\tgoto free_power_settings;'
p4163
as(I177
I177
tp4164
(lp4165
S'\t\t\t\t\tgoto free_power_down_settings;'
p4166
as(I153
I153
tp4167
(lp4168
S'\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command");'
p4169
assg41
(I1
I205
tp4170
sssS'int32_t cam_sensor_update_power_settings(void *cmd_buf,\n\tuint32_t cmd_length, struct cam_sensor_power_ctrl_t *power_info,\n\tsize_t cmd_buf_len)\n{\n\tint32_t rc = 0, tot_size = 0, last_cmd_type = 0;\n\tint32_t i = 0, pwr_up = 0, pwr_down = 0;\n\tstruct cam_sensor_power_setting *pwr_settings;\n\tvoid *ptr = cmd_buf, *scr;\n\tstruct cam_cmd_power *pwr_cmd = (struct cam_cmd_power *)cmd_buf;\n\tstruct common_header *cmm_hdr = (struct common_header *)cmd_buf;\n\n\tif (!pwr_cmd || !cmd_length || cmd_buf_len < (size_t)cmd_length ||\n\t\tcam_sensor_validate(cmd_buf, cmd_buf_len)) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Args: pwr_cmd %pK, cmd_length: %d",\n\t\t\tpwr_cmd, cmd_length);\n\t\treturn -EINVAL;\n\t}\n\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_setting)\n\t\treturn -ENOMEM;\n\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_down_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_down_setting) {\n\t\tkfree(power_info->power_setting);\n\t\tpower_info->power_setting = NULL;\n\t\tpower_info->power_setting_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (tot_size < cmd_length) {\n\t\tif (cam_sensor_validate(ptr, (cmd_length - tot_size))) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\tif (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tpower_info->power_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_setting_size > MAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power up setting size %d",\n\t\t\t\t\tpower_info->power_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_WARN(CAM_SENSOR, "pwr_up_size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_up++) {\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpower_info->power_setting[pwr_up].config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_setting[pwr_up].delay = 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size = tot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Error: Cmd Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t"Seq Type[%d]: %d Config_val: %ld", pwr_up,\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type,\n\t\t\t\tpower_info->power_setting[pwr_up].config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_UP;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type == CAMERA_SENSOR_CMD_TYPE_WAIT) {\n\t\t\tstruct cam_cmd_unconditional_wait *wait_cmd =\n\t\t\t\t(struct cam_cmd_unconditional_wait *)ptr;\n\t\t\tif ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP)) {\n\t\t\t\tif (pwr_up > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_setting[pwr_up - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else if ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN)) {\n\t\t\t\tif (pwr_down > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_down_setting[\n\t\t\t\t\t\tpwr_down - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Invalid op code: %d",\n\t\t\t\t\twait_cmd->op_code);\n\t\t\t}\n\n\t\t\ttot_size = tot_size +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait);\n\t\t\tif (tot_size > cmd_length) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Command Buffer is wrong");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscr = (void *) (wait_cmd);\n\t\t\tptr = (void *)\n\t\t\t\t(scr +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait));\n\t\t\tCAM_DBG(CAM_SENSOR, "ptr: %pK sizeof: %d Next: %pK",\n\t\t\t\tscr, (int32_t)sizeof(\n\t\t\t\tstruct cam_cmd_unconditional_wait), ptr);\n\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\t\t\tpower_info->power_down_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_down_setting_size >\n\t\t\t\tMAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power down setting size %d",\n\t\t\t\t\tpower_info->power_down_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR, "pwr_down size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_down++) {\n\t\t\t\tpwr_settings =\n\t\t\t\t&power_info->power_down_setting[pwr_down];\n\t\t\t\tpwr_settings->seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpwr_settings->config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_down_setting[pwr_down].delay\n\t\t\t\t\t= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size =\n\t\t\t\t\t\ttot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Command Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t"Seq Type[%d]: %d Config_val: %ld",\n\t\t\t\t\tpwr_down, pwr_settings->seq_type,\n\t\t\t\t\tpwr_settings->config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_DOWN;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Error: Un expected Header Type: %d",\n\t\t\t\tcmm_hdr->cmd_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_power_settings;\n\t\t}\n\t}\n\n\treturn rc;\nfree_power_settings:\n\tkfree(power_info->power_down_setting);\n\tkfree(power_info->power_setting);\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\treturn rc;\n}'
p4171
(dp4172
((g3761
g4077
tp4173
I1
tp4174
(dp4175
g12
g13
sg14
(dp4176
(I159
I159
tp4177
(lp4178
S'\t\t\t\tCAM_ERR(CAM_SENSOR, "pwr_down size is zero");'
p4179
as(I206
I209
tp4180
(lp4181
S'\tpower_info->power_down_setting = NULL;'
p4182
aS'\tpower_info->power_setting = NULL;'
p4183
aS'\tpower_info->power_down_setting_size = 0;'
p4184
aS'\tpower_info->power_setting_size = 0;'
p4185
as(I61
I61
tp4186
(lp4187
S'\t\t\t\tCAM_WARN(CAM_SENSOR, "pwr_up_size is zero");'
p4188
as(I12
I13
tp4189
(lp4190
S'\tif (!pwr_cmd || !cmd_length || cmd_buf_len < (size_t)cmd_length ||'
p4191
aS'\t\tcam_sensor_validate(cmd_buf, cmd_buf_len)) {'
p4192
as(I50
I56
tp4193
(lp4194
S'\t\t\tif (power_info->power_setting_size > MAX_POWER_CONFIG) {'
p4195
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p4196
aS'\t\t\t\t\t"Invalid: power up setting size %d",'
p4197
aS'\t\t\t\t\tpower_info->power_setting_size);'
p4198
aS'\t\t\t\trc = -EINVAL;'
p4199
aS'\t\t\t\tgoto free_power_settings;'
p4200
aS'\t\t\t}'
p4201
as(I149
I156
tp4202
(lp4203
S'\t\t\tif (power_info->power_down_setting_size >'
p4204
aS'\t\t\t\tMAX_POWER_CONFIG) {'
p4205
aS'\t\t\t\tCAM_ERR(CAM_SENSOR,'
p4206
aS'\t\t\t\t\t"Invalid: power down setting size %d",'
p4207
aS'\t\t\t\t\tpower_info->power_down_setting_size);'
p4208
aS'\t\t\t\trc = -EINVAL;'
p4209
aS'\t\t\t\tgoto free_power_settings;'
p4210
aS'\t\t\t}'
p4211
as(I204
I204
tp4212
(lp4213
S'\tkfree(power_info->power_down_setting);'
p4214
as(I183
I183
tp4215
(lp4216
S'\t\t\t\t\tgoto free_power_settings;'
p4217
as(I33
I36
tp4218
(lp4219
S'\t\tkfree(power_info->power_setting);'
p4220
aS'\t\tpower_info->power_setting = NULL;'
p4221
aS'\t\tpower_info->power_setting_size = 0;'
p4222
aS'\t\treturn -ENOMEM;'
p4223
as(I81
I81
tp4224
(lp4225
S'\t\t\t\t\tgoto free_power_settings;'
p4226
as(I197
I198
tp4227
(lp4228
S'\t\t\trc = -EINVAL;'
p4229
aS'\t\t\tgoto free_power_settings;'
p4230
as(I2
I3
tp4231
(lp4232
S'\tuint32_t cmd_length, struct cam_sensor_power_ctrl_t *power_info,'
p4233
aS'\tsize_t cmd_buf_len)'
p4234
as(I40
I43
tp4235
(lp4236
S'\t\tif (cam_sensor_validate(ptr, (cmd_length - tot_size))) {'
p4237
aS'\t\t\trc = -EINVAL;'
p4238
aS'\t\t\tgoto free_power_settings;'
p4239
aS'\t\t}'
p4240
assg32
I4
sg33
(dp4241
(I33
I34
tp4242
(lp4243
S'\t\trc = -ENOMEM;'
p4244
aS'\t\tgoto free_power_settings;'
p4245
as(I183
I183
tp4246
(lp4247
S'\t\t\t\t\tgoto free_power_down_settings;'
p4248
as(I61
I61
tp4249
(lp4250
S'\t\t\t\tCAM_WARN(CAM_SENSOR, "Un expected Command");'
p4251
as(I2
I2
tp4252
(lp4253
S'\tint cmd_length, struct cam_sensor_power_ctrl_t *power_info)'
p4254
as(I12
I12
tp4255
(lp4256
S'\tif (!pwr_cmd || !cmd_length) {'
p4257
as(I203
I204
tp4258
(lp4259
S'free_power_down_settings:'
p4260
aS'\tkfree(power_info->power_down_setting);'
p4261
as(I81
I81
tp4262
(lp4263
S'\t\t\t\t\tgoto free_power_down_settings;'
p4264
as(I159
I159
tp4265
(lp4266
S'\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command");'
p4267
assg41
(I1
I211
tp4268
ssss(g3761
S'cam_config_mclk_reg'
p4269
tp4270
(dp4271
S'static int cam_config_mclk_reg(struct cam_sensor_power_ctrl_t *ctrl,\n\tstruct cam_hw_soc_info *soc_info, int32_t index)\n{\n\tint32_t num_vreg = 0, j = 0, rc = 0, idx = 0;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\n\tnum_vreg = soc_info->num_rgltr;\n\n\tpd = &ctrl->power_down_setting[index];\n\n\tfor (j = 0; j < num_vreg; j++) {\n\t\tif (!strcmp(soc_info->rgltr_name[j], "cam_clk")) {\n\n\t\t\tps = NULL;\n\t\t\tfor (idx = 0; idx <\n\t\t\t\tctrl->power_setting_size; idx++) {\n\t\t\t\tif (ctrl->power_setting[idx].\n\t\t\t\t\tseq_type == pd->seq_type) {\n\t\t\t\t\tps = &ctrl->power_setting[idx];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps != NULL) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");\n\n\t\t\t\trc = cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\n\t\t\t\tps->data[0] =\n\t\t\t\t\tsoc_info->rgltr[j];\n\n\t\t\t\tregulator_put(\n\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}'
p4272
(dp4273
((g3761
g4269
tp4274
I1
tp4275
(dp4276
g12
g13
sg41
(I1
I47
tp4277
sg32
I3
sg33
(dp4278
(I12
I16
tp4279
(lp4280
S'\tif (!pd) {'
p4281
aS'\t\tCAM_ERR(CAM_SENSOR, "Invalid power down setting");'
p4282
aS'\t\treturn -EINVAL;'
p4283
aS'\t}'
p4284
ag59
assssS'static int cam_config_mclk_reg(struct cam_sensor_power_ctrl_t *ctrl,\n\tstruct cam_hw_soc_info *soc_info, int32_t index)\n{\n\tint32_t num_vreg = 0, j = 0, rc = 0, idx = 0;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\n\tnum_vreg = soc_info->num_rgltr;\n\n\tpd = &ctrl->power_down_setting[index];\n\n\tfor (j = 0; j < num_vreg; j++) {\n\t\tif (!strcmp(soc_info->rgltr_name[j], "cam_clk")) {\n\t\t\tps = NULL;\n\t\t\tfor (idx = 0; idx < ctrl->power_setting_size; idx++) {\n\t\t\t\tif (ctrl->power_setting[idx].seq_type ==\n\t\t\t\t\tpd->seq_type) {\n\t\t\t\t\tps = &ctrl->power_setting[idx];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps != NULL) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable MCLK Regulator");\n\t\t\t\trc = cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"MCLK REG DISALBE FAILED: %d",\n\t\t\t\t\t\trc);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\tps->data[0] =\n\t\t\t\t\tsoc_info->rgltr[j];\n\n\t\t\t\tregulator_put(\n\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}'
p4285
(dp4286
((g3761
g4269
tp4287
I1
tp4288
(dp4289
g12
g13
sg14
(dp4290
(I33
I39
tp4291
(lp4292
S'\t\t\t\tif (rc) {'
p4293
aS'\t\t\t\t\tCAM_ERR(CAM_SENSOR,'
p4294
aS'\t\t\t\t\t\t"MCLK REG DISALBE FAILED: %d",'
p4295
aS'\t\t\t\t\t\trc);'
p4296
aS'\t\t\t\t\treturn rc;'
p4297
aS'\t\t\t\t}'
p4298
ag59
as(I24
I24
tp4299
(lp4300
S'\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable MCLK Regulator");'
p4301
as(I15
I17
tp4302
(lp4303
S'\t\t\tfor (idx = 0; idx < ctrl->power_setting_size; idx++) {'
p4304
aS'\t\t\t\tif (ctrl->power_setting[idx].seq_type =='
p4305
aS'\t\t\t\t\tpd->seq_type) {'
p4306
assg32
I3
sg33
(dp4307
(I24
I25
tp4308
(lp4309
S'\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");'
p4310
ag59
as(I14
I14
tp4311
(lp4312
g59
as(I15
I18
tp4313
(lp4314
S'\t\t\tfor (idx = 0; idx <'
p4315
aS'\t\t\t\tctrl->power_setting_size; idx++) {'
p4316
aS'\t\t\t\tif (ctrl->power_setting[idx].'
p4317
aS'\t\t\t\t\tseq_type == pd->seq_type) {'
p4318
as(I12
I16
tp4319
(lp4320
S'\tif (!pd) {'
p4321
aS'\t\tCAM_ERR(CAM_SENSOR, "Invalid power down setting");'
p4322
aS'\t\treturn -EINVAL;'
p4323
aS'\t}'
p4324
ag59
assg41
(I1
I51
tp4325
sssssS'CVE-2018-1000199'
p4326
(dp4327
(S'kernel/events/hw_breakpoint.c'
p4328
S'modify_user_hw_breakpoint'
p4329
tp4330
(dp4331
S'int modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\t/*\n\t * modify_user_hw_breakpoint can be invoked with IRQs disabled and hence it\n\t * will not be possible to raise IPIs that invoke __perf_event_disable.\n\t * So call the function directly after making sure we are targeting the\n\t * current task.\n\t */\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\tperf_event_disable_local(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\tbp->attr.bp_addr = attr->bp_addr;\n\tbp->attr.bp_type = attr->bp_type;\n\tbp->attr.bp_len = attr->bp_len;\n\tbp->attr.disabled = 1;\n\n\tif (!attr->disabled) {\n\t\tint err = validate_hw_breakpoint(bp);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tperf_event_enable(bp);\n\t\tbp->attr.disabled = 0;\n\t}\n\n\treturn 0;\n}'
p4332
(dp4333
((g4328
g4329
tp4334
I1
tp4335
(dp4336
g12
g13
sg14
(dp4337
(I25
I26
tp4338
(lp4339
S'\t\tperf_event_enable(bp);'
p4340
aS'\t\tbp->attr.disabled = 0;'
p4341
as(I22
I23
tp4342
(lp4343
S'\t\tif (err)'
p4344
aS'\t\t\treturn err;'
p4345
as(I19
I20
tp4346
(lp4347
S'\tif (!attr->disabled) {'
p4348
aS'\t\tint err = validate_hw_breakpoint(bp);'
p4349
as(I17
I17
tp4350
(lp4351
S'\tbp->attr.disabled = 1;'
p4352
assg32
I2
sg33
(dp4353
(I19
I24
tp4354
(lp4355
S'\tif (attr->disabled)'
p4356
aS'\t\tgoto end;'
p4357
ag59
aS'\terr = validate_hw_breakpoint(bp);'
p4358
aS'\tif (!err)'
p4359
aS'\t\tperf_event_enable(bp);'
p4360
as(I3
I7
tp4361
(lp4362
S'\tu64 old_addr = bp->attr.bp_addr;'
p4363
aS'\tu64 old_len = bp->attr.bp_len;'
p4364
aS'\tint old_type = bp->attr.bp_type;'
p4365
aS'\tint err = 0;'
p4366
ag59
as(I29
I31
tp4367
(lp4368
S'end:'
p4369
aS'\tbp->attr.disabled = attr->disabled;'
p4370
ag59
as(I25
I25
tp4371
(lp4372
S'\t\treturn err;'
p4373
as(I22
I27
tp4374
(lp4375
S'\tif (err) {'
p4376
aS'\t\tbp->attr.bp_addr = old_addr;'
p4377
aS'\t\tbp->attr.bp_type = old_type;'
p4378
aS'\t\tbp->attr.bp_len = old_len;'
p4379
aS'\t\tif (!bp->attr.disabled)'
p4380
aS'\t\t\tperf_event_enable(bp);'
p4381
assg41
(I1
I30
tp4382
sssssS'CVE-2018-11266'
p4383
(dp4384
(S'drivers/char/diag/diag_dci.c'
p4385
S'dci_lookup_client_entry_pid'
p4386
tp4387
(dp4388
S'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid pid doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client)\n\t\t\tif (entry->client->tgid == tgid)\n\t\t\t\treturn entry;\n\t}\n\treturn NULL;\n}'
p4389
(dp4390
((g4385
g4386
tp4391
I1
tp4392
(dp4393
g33
(dp4394
(I10
I11
tp4395
(lp4396
S'\t\tif (entry->client->tgid == tgid)'
p4397
aS'\t\t\treturn entry;'
p4398
assg14
(dp4399
(I5
I6
tp4400
(lp4401
S'\tstruct pid *pid_struct = NULL;'
p4402
aS'\tstruct task_struct *task_s = NULL;'
p4403
as(I10
I26
tp4404
(lp4405
S'\t\tpid_struct = find_get_pid(entry->tgid);'
p4406
aS'\t\tif (!pid_struct) {'
p4407
aS'\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p4408
aS'\t\t\t\t"diag: valid pid doesn\'t exist for pid = %d\\n",'
p4409
aS'\t\t\t\tentry->tgid);'
p4410
aS'\t\t\tcontinue;'
p4411
aS'\t\t}'
p4412
aS'\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p4413
aS'\t\tif (!task_s) {'
p4414
aS'\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p4415
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p4416
aS'\t\t\t\tentry->tgid);'
p4417
aS'\t\t\tcontinue;'
p4418
aS'\t\t}'
p4419
aS'\t\tif (task_s == entry->client)'
p4420
aS'\t\t\tif (entry->client->tgid == tgid)'
p4421
aS'\t\t\t\treturn entry;'
p4422
assg32
I1
sg12
g13
sg41
(I1
I29
tp4423
sssS'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client)\n\t\t\tif (entry->client->tgid == tgid)\n\t\t\t\treturn entry;\n\t}\n\treturn NULL;\n}'
p4424
(dp4425
((g4385
g4386
tp4426
I1
tp4427
(dp4428
g33
(dp4429
(I10
I11
tp4430
(lp4431
S'\t\tif (entry->client->tgid == tgid)'
p4432
aS'\t\t\treturn entry;'
p4433
assg14
(dp4434
(I5
I6
tp4435
(lp4436
S'\tstruct pid *pid_struct = NULL;'
p4437
aS'\tstruct task_struct *task_s = NULL;'
p4438
as(I10
I26
tp4439
(lp4440
S'\t\tpid_struct = find_get_pid(entry->tgid);'
p4441
aS'\t\tif (!pid_struct) {'
p4442
aS'\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p4443
aS'\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",'
p4444
aS'\t\t\ttgid, entry->tgid);'
p4445
aS'\t\t\tcontinue;'
p4446
aS'\t\t}'
p4447
aS'\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p4448
aS'\t\tif (!task_s) {'
p4449
aS'\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p4450
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p4451
aS'\t\t\t\tentry->tgid);'
p4452
aS'\t\t\tcontinue;'
p4453
aS'\t\t}'
p4454
aS'\t\tif (task_s == entry->client)'
p4455
aS'\t\t\tif (entry->client->tgid == tgid)'
p4456
aS'\t\t\t\treturn entry;'
p4457
assg32
I1
sg12
g13
sg41
(I1
I29
tp4458
sssS'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tput_pid(pid_struct);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client) {\n\t\t\tif (entry->client->tgid == tgid) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\tput_task_struct(task_s);\n\t\tput_pid(pid_struct);\n\t}\n\treturn NULL;\n}'
p4459
(dp4460
((g4385
g4386
tp4461
I1
tp4462
(dp4463
g33
(dp4464
(I10
I11
tp4465
(lp4466
S'\t\tif (entry->client->tgid == tgid)'
p4467
aS'\t\t\treturn entry;'
p4468
assg14
(dp4469
(I5
I6
tp4470
(lp4471
S'\tstruct pid *pid_struct = NULL;'
p4472
aS'\tstruct task_struct *task_s = NULL;'
p4473
as(I10
I33
tp4474
(lp4475
S'\t\tpid_struct = find_get_pid(entry->tgid);'
p4476
aS'\t\tif (!pid_struct) {'
p4477
aS'\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p4478
aS'\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",'
p4479
aS'\t\t\ttgid, entry->tgid);'
p4480
aS'\t\t\tcontinue;'
p4481
aS'\t\t}'
p4482
aS'\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p4483
aS'\t\tif (!task_s) {'
p4484
aS'\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p4485
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p4486
aS'\t\t\t\tentry->tgid);'
p4487
aS'\t\t\tput_pid(pid_struct);'
p4488
aS'\t\t\tcontinue;'
p4489
aS'\t\t}'
p4490
aS'\t\tif (task_s == entry->client) {'
p4491
aS'\t\t\tif (entry->client->tgid == tgid) {'
p4492
aS'\t\t\t\tput_task_struct(task_s);'
p4493
aS'\t\t\t\tput_pid(pid_struct);'
p4494
aS'\t\t\t\treturn entry;'
p4495
aS'\t\t\t}'
p4496
aS'\t\t}'
p4497
aS'\t\tput_task_struct(task_s);'
p4498
aS'\t\tput_pid(pid_struct);'
p4499
assg32
I1
sg12
g13
sg41
(I1
I36
tp4500
sssssS'CVE-2018-13096'
p4501
(dp4502
(S'fs/f2fs/inode.c'
p4503
S'do_read_inode'
p4504
tp4505
(dp4506
S"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p4507
(dp4508
((g4503
g4504
tp4509
I1
tp4510
(dp4511
g33
(dp4512
(I88
I89
tp4513
(lp4514
S'\tif (__written_first_block(ri))'
p4515
aS'\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4516
assg14
(dp4517
(I79
I84
tp4518
(lp4519
S'\t/* try to recover cold bit for non-dir inode */'
p4520
aS'\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {'
p4521
aS'\t\tset_cold_node(node_page, false);'
p4522
aS'\t\tset_page_dirty(node_page);'
p4523
aS'\t}'
p4524
ag59
as(I8
I8
tp4525
(lp4526
S'\tint err;'
p4527
as(I70
I74
tp4528
(lp4529
S'\tif (!sanity_check_inode(inode, node_page)) {'
p4530
aS'\t\tf2fs_put_page(node_page, 1);'
p4531
aS'\t\treturn -EINVAL;'
p4532
aS'\t}'
p4533
ag59
as(I88
I96
tp4534
(lp4535
S'\tif (S_ISREG(inode->i_mode)) {'
p4536
aS'\t\terr = __written_first_block(sbi, ri);'
p4537
aS'\t\tif (err < 0) {'
p4538
aS'\t\t\tf2fs_put_page(node_page, 1);'
p4539
aS'\t\t\treturn err;'
p4540
aS'\t\t}'
p4541
aS'\t\tif (!err)'
p4542
aS'\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4543
aS'\t}'
p4544
assg32
I1
sg12
g13
sg41
(I1
I128
tp4545
sssS"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p4546
(dp4547
((g4503
g4504
tp4548
I1
tp4549
(dp4550
g33
(dp4551
(I88
I89
tp4552
(lp4553
S'\tif (__written_first_block(ri))'
p4554
aS'\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4555
as(I104
I104
tp4556
(lp4557
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi->sb) &&'
p4558
as(I111
I111
tp4559
(lp4560
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi->sb) &&'
p4561
as(I54
I54
tp4562
(lp4563
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)) {'
p4564
assg14
(dp4565
(I8
I8
tp4566
(lp4567
S'\tint err;'
p4568
as(I54
I54
tp4569
(lp4570
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {'
p4571
as(I88
I96
tp4572
(lp4573
S'\tif (S_ISREG(inode->i_mode)) {'
p4574
aS'\t\terr = __written_first_block(sbi, ri);'
p4575
aS'\t\tif (err < 0) {'
p4576
aS'\t\t\tf2fs_put_page(node_page, 1);'
p4577
aS'\t\t\treturn err;'
p4578
aS'\t\t}'
p4579
aS'\t\tif (!err)'
p4580
aS'\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4581
aS'\t}'
p4582
as(I79
I84
tp4583
(lp4584
S'\t/* try to recover cold bit for non-dir inode */'
p4585
aS'\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {'
p4586
aS'\t\tset_cold_node(node_page, false);'
p4587
aS'\t\tset_page_dirty(node_page);'
p4588
aS'\t}'
p4589
ag59
as(I70
I74
tp4590
(lp4591
S'\tif (!sanity_check_inode(inode, node_page)) {'
p4592
aS'\t\tf2fs_put_page(node_page, 1);'
p4593
aS'\t\treturn -EINVAL;'
p4594
aS'\t}'
p4595
ag59
as(I104
I104
tp4596
(lp4597
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&'
p4598
as(I111
I111
tp4599
(lp4600
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&'
p4601
assg32
I1
sg12
g13
sg41
(I1
I128
tp4602
sssS"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tif (S_ISREG(inode->i_mode))\n\t\tfi->i_flags &= ~F2FS_PROJINHERIT_FL;\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p4603
(dp4604
((g4503
g4504
tp4605
I1
tp4606
(dp4607
g33
(dp4608
(I56
I56
tp4609
(lp4610
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)) {'
p4611
as(I90
I91
tp4612
(lp4613
S'\tif (__written_first_block(ri))'
p4614
aS'\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4615
as(I113
I113
tp4616
(lp4617
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi->sb) &&'
p4618
as(I106
I106
tp4619
(lp4620
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi->sb) &&'
p4621
assg14
(dp4622
(I41
I42
tp4623
(lp4624
S'\tif (S_ISREG(inode->i_mode))'
p4625
aS'\t\tfi->i_flags &= ~F2FS_PROJINHERIT_FL;'
p4626
as(I106
I106
tp4627
(lp4628
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&'
p4629
as(I56
I56
tp4630
(lp4631
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {'
p4632
as(I81
I86
tp4633
(lp4634
S'\t/* try to recover cold bit for non-dir inode */'
p4635
aS'\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {'
p4636
aS'\t\tset_cold_node(node_page, false);'
p4637
aS'\t\tset_page_dirty(node_page);'
p4638
aS'\t}'
p4639
ag59
as(I72
I76
tp4640
(lp4641
S'\tif (!sanity_check_inode(inode, node_page)) {'
p4642
aS'\t\tf2fs_put_page(node_page, 1);'
p4643
aS'\t\treturn -EFSCORRUPTED;'
p4644
aS'\t}'
p4645
ag59
as(I90
I98
tp4646
(lp4647
S'\tif (S_ISREG(inode->i_mode)) {'
p4648
aS'\t\terr = __written_first_block(sbi, ri);'
p4649
aS'\t\tif (err < 0) {'
p4650
aS'\t\t\tf2fs_put_page(node_page, 1);'
p4651
aS'\t\t\treturn err;'
p4652
aS'\t\t}'
p4653
aS'\t\tif (!err)'
p4654
aS'\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4655
aS'\t}'
p4656
as(I113
I113
tp4657
(lp4658
S'\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&'
p4659
as(I8
I8
tp4660
(lp4661
S'\tint err;'
p4662
assg32
I1
sg12
g13
sg41
(I1
I130
tp4663
sssS"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p4664
(dp4665
((g4503
g4504
tp4666
I1
tp4667
(dp4668
g33
(dp4669
(I82
I83
tp4670
(lp4671
S'\tif (__written_first_block(ri))'
p4672
aS'\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4673
assg14
(dp4674
(I8
I8
tp4675
(lp4676
S'\tint err;'
p4677
as(I70
I74
tp4678
(lp4679
S'\tif (!sanity_check_inode(inode, node_page)) {'
p4680
aS'\t\tf2fs_put_page(node_page, 1);'
p4681
aS'\t\treturn -EINVAL;'
p4682
aS'\t}'
p4683
ag59
as(I82
I90
tp4684
(lp4685
S'\tif (S_ISREG(inode->i_mode)) {'
p4686
aS'\t\terr = __written_first_block(sbi, ri);'
p4687
aS'\t\tif (err < 0) {'
p4688
aS'\t\t\tf2fs_put_page(node_page, 1);'
p4689
aS'\t\t\treturn err;'
p4690
aS'\t\t}'
p4691
aS'\t\tif (!err)'
p4692
aS'\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);'
p4693
aS'\t}'
p4694
assg32
I1
sg12
g13
sg41
(I1
I122
tp4695
ssss(g4503
S'sanity_check_inode'
p4696
tp4697
(dp4698
S'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, run fsck to fix.",\n\t\t\t  __func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: corrupted inode footer i_ino=%lx, ino,nid: [%u, %u] run fsck to fix.",\n\t\t\t  __func__, inode->i_ino,\n\t\t\t  ino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) is with extra_attr, but extra_attr feature is off",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) has corrupted i_extra_isize: %d, max: %zu",\n\t\t\t  __func__, inode->i_ino, fi->i_extra_isize,\n\t\t\t  F2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\tf2fs_sb_has_flexible_inline_xattr(sbi) &&\n\t\tf2fs_has_inline_xattr(inode) &&\n\t\t(!fi->i_inline_xattr_size ||\n\t\tfi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) has corrupted i_inline_xattr_size: %d, max: %zu",\n\t\t\t  __func__, inode->i_ino, fi->i_inline_xattr_size,\n\t\t\t  MAX_INLINE_XATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) extent info [%u, %u, %u] is incorrect, run fsck to fix",\n\t\t\t\t  __func__, inode->i_ino,\n\t\t\t\t  ei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx, mode=%u) should not have inline_data, run fsck to fix",\n\t\t\t  __func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx, mode=%u) should not have inline_dentry, run fsck to fix",\n\t\t\t  __func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p4699
(dp4700
((g4503
g4696
tp4701
I1
tp4702
(dp4703
g12
g13
sg14
(dp4704
(I4
I5
tp4705
(lp4706
S'\tstruct f2fs_inode_info *fi = F2FS_I(inode);'
p4707
aS'\tunsigned long long iblocks;'
p4708
as(I47
I90
tp4709
(lp4710
g59
aS'\tif (f2fs_has_extra_attr(inode) &&'
p4711
aS'\t\tf2fs_sb_has_flexible_inline_xattr(sbi) &&'
p4712
aS'\t\tf2fs_has_inline_xattr(inode) &&'
p4713
aS'\t\t(!fi->i_inline_xattr_size ||'
p4714
aS'\t\tfi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {'
p4715
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4716
aS'\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) has corrupted i_inline_xattr_size: %d, max: %zu",'
p4717
aS'\t\t\t  __func__, inode->i_ino, fi->i_inline_xattr_size,'
p4718
aS'\t\t\t  MAX_INLINE_XATTR_SIZE);'
p4719
aS'\t\treturn false;'
p4720
aS'\t}'
p4721
ag59
aS'\tif (F2FS_I(inode)->extent_tree) {'
p4722
aS'\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;'
p4723
ag59
aS'\t\tif (ei->len &&'
p4724
aS'\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk,'
p4725
aS'\t\t\t\t\t\tDATA_GENERIC_ENHANCE) ||'
p4726
aS'\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,'
p4727
aS'\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {'
p4728
aS'\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4729
aS'\t\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) extent info [%u, %u, %u] is incorrect, run fsck to fix",'
p4730
aS'\t\t\t\t  __func__, inode->i_ino,'
p4731
aS'\t\t\t\t  ei->blk, ei->fofs, ei->len);'
p4732
aS'\t\t\treturn false;'
p4733
aS'\t\t}'
p4734
aS'\t}'
p4735
ag59
aS'\tif (f2fs_has_inline_data(inode) &&'
p4736
aS'\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {'
p4737
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4738
aS'\t\tf2fs_warn(sbi, "%s: inode (ino=%lx, mode=%u) should not have inline_data, run fsck to fix",'
p4739
aS'\t\t\t  __func__, inode->i_ino, inode->i_mode);'
p4740
aS'\t\treturn false;'
p4741
aS'\t}'
p4742
ag59
aS'\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {'
p4743
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4744
aS'\t\tf2fs_warn(sbi, "%s: inode (ino=%lx, mode=%u) should not have inline_dentry, run fsck to fix",'
p4745
aS'\t\t\t  __func__, inode->i_ino, inode->i_mode);'
p4746
aS'\t\treturn false;'
p4747
aS'\t}'
p4748
ag59
as(I1
I1
tp4749
(lp4750
S'static bool sanity_check_inode(struct inode *inode, struct page *node_page)'
p4751
as(I26
I44
tp4752
(lp4753
S'\t\tf2fs_warn(sbi, "%s: corrupted inode ino=%lx, run fsck to fix.",'
p4754
aS'\t\t\t  __func__, inode->i_ino);'
p4755
aS'\t\treturn false;'
p4756
aS'\t}'
p4757
ag59
aS'\tif (f2fs_has_extra_attr(inode) &&'
p4758
aS'\t\t\t!f2fs_sb_has_extra_attr(sbi)) {'
p4759
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4760
aS'\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) is with extra_attr, but extra_attr feature is off",'
p4761
aS'\t\t\t  __func__, inode->i_ino);'
p4762
aS'\t\treturn false;'
p4763
aS'\t}'
p4764
ag59
aS'\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||'
p4765
aS'\t\t\tfi->i_extra_isize % sizeof(__le32)) {'
p4766
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4767
aS'\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) has corrupted i_extra_isize: %d, max: %zu",'
p4768
aS'\t\t\t  __func__, inode->i_ino, fi->i_extra_isize,'
p4769
aS'\t\t\t  F2FS_TOTAL_EXTRA_ATTR_SIZE);'
p4770
as(I7
I23
tp4771
(lp4772
S'\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);'
p4773
aS'\tif (!iblocks) {'
p4774
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4775
aS'\t\tf2fs_warn(sbi, "%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, run fsck to fix.",'
p4776
aS'\t\t\t  __func__, inode->i_ino, iblocks);'
p4777
aS'\t\treturn false;'
p4778
aS'\t}'
p4779
ag59
aS'\tif (ino_of_node(node_page) != nid_of_node(node_page)) {'
p4780
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4781
aS'\t\tf2fs_warn(sbi, "%s: corrupted inode footer i_ino=%lx, ino,nid: [%u, %u] run fsck to fix.",'
p4782
aS'\t\t\t  __func__, inode->i_ino,'
p4783
aS'\t\t\t  ino_of_node(node_page), nid_of_node(node_page));'
p4784
aS'\t\treturn false;'
p4785
aS'\t}'
p4786
ag59
aS'\tif (f2fs_sb_has_flexible_inline_xattr(sbi)'
p4787
assg32
I2
sg33
(dp4788
(I26
I28
tp4789
(lp4790
S'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4791
aS'\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",'
p4792
aS'\t\t\t__func__, inode->i_ino);'
p4793
as(I1
I1
tp4794
(lp4795
S'static bool sanity_check_inode(struct inode *inode)'
p4796
as(I7
I7
tp4797
(lp4798
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)'
p4799
assg41
(I1
I92
tp4800
sssS'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "\n\t\t\t"run fsck to fix.",\n\t\t\t__func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "\n\t\t\t"[%u, %u] run fsck to fix.",\n\t\t\t__func__, inode->i_ino,\n\t\t\tino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi->sb)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) is with extra_attr, "\n\t\t\t"but extra_attr feature is off",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "\n\t\t\t"max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_extra_isize,\n\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\t\tDATA_GENERIC))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "\n\t\t\t\t"is incorrect, run fsck to fix",\n\t\t\t\t__func__, inode->i_ino,\n\t\t\t\tei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_data, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_dentry, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p4801
(dp4802
((g4503
g4696
tp4803
I1
tp4804
(dp4805
g12
g13
sg14
(dp4806
(I35
I92
tp4807
(lp4808
g59
aS'\tif (f2fs_has_extra_attr(inode) &&'
p4809
aS'\t\t\t!f2fs_sb_has_extra_attr(sbi->sb)) {'
p4810
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4811
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4812
aS'\t\t\t"%s: inode (ino=%lx) is with extra_attr, "'
p4813
aS'\t\t\t"but extra_attr feature is off",'
p4814
aS'\t\t\t__func__, inode->i_ino);'
p4815
aS'\t\treturn false;'
p4816
aS'\t}'
p4817
ag59
aS'\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||'
p4818
aS'\t\t\tfi->i_extra_isize % sizeof(__le32)) {'
p4819
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4820
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4821
aS'\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "'
p4822
aS'\t\t\t"max: %zu",'
p4823
aS'\t\t\t__func__, inode->i_ino, fi->i_extra_isize,'
p4824
aS'\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);'
p4825
aS'\t\treturn false;'
p4826
aS'\t}'
p4827
ag59
aS'\tif (F2FS_I(inode)->extent_tree) {'
p4828
aS'\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;'
p4829
ag59
aS'\t\tif (ei->len &&'
p4830
aS'\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC) ||'
p4831
aS'\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,'
p4832
aS'\t\t\t\t\t\t\tDATA_GENERIC))) {'
p4833
aS'\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4834
aS'\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4835
aS'\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "'
p4836
aS'\t\t\t\t"is incorrect, run fsck to fix",'
p4837
aS'\t\t\t\t__func__, inode->i_ino,'
p4838
aS'\t\t\t\tei->blk, ei->fofs, ei->len);'
p4839
aS'\t\t\treturn false;'
p4840
aS'\t\t}'
p4841
aS'\t}'
p4842
ag59
aS'\tif (f2fs_has_inline_data(inode) &&'
p4843
aS'\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {'
p4844
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4845
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4846
aS'\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "'
p4847
aS'\t\t\t"inline_data, run fsck to fix",'
p4848
aS'\t\t\t__func__, inode->i_ino, inode->i_mode);'
p4849
aS'\t\treturn false;'
p4850
aS'\t}'
p4851
ag59
aS'\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {'
p4852
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4853
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4854
aS'\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "'
p4855
aS'\t\t\t"inline_dentry, run fsck to fix",'
p4856
aS'\t\t\t__func__, inode->i_ino, inode->i_mode);'
p4857
aS'\t\treturn false;'
p4858
aS'\t}'
p4859
ag59
as(I4
I25
tp4860
(lp4861
S'\tstruct f2fs_inode_info *fi = F2FS_I(inode);'
p4862
aS'\tunsigned long long iblocks;'
p4863
ag59
aS'\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);'
p4864
aS'\tif (!iblocks) {'
p4865
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4866
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4867
aS'\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "'
p4868
aS'\t\t\t"run fsck to fix.",'
p4869
aS'\t\t\t__func__, inode->i_ino, iblocks);'
p4870
aS'\t\treturn false;'
p4871
aS'\t}'
p4872
ag59
aS'\tif (ino_of_node(node_page) != nid_of_node(node_page)) {'
p4873
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4874
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4875
aS'\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "'
p4876
aS'\t\t\t"[%u, %u] run fsck to fix.",'
p4877
aS'\t\t\t__func__, inode->i_ino,'
p4878
aS'\t\t\tino_of_node(node_page), nid_of_node(node_page));'
p4879
aS'\t\treturn false;'
p4880
aS'\t}'
p4881
as(I1
I1
tp4882
(lp4883
S'static bool sanity_check_inode(struct inode *inode, struct page *node_page)'
p4884
assg32
I2
sg33
(dp4885
(I1
I1
tp4886
(lp4887
S'static bool sanity_check_inode(struct inode *inode)'
p4888
assg41
(I1
I94
tp4889
sssS'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "\n\t\t\t"run fsck to fix.",\n\t\t\t__func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "\n\t\t\t"[%u, %u] run fsck to fix.",\n\t\t\t__func__, inode->i_ino,\n\t\t\tino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) is with extra_attr, "\n\t\t\t"but extra_attr feature is off",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "\n\t\t\t"max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_extra_isize,\n\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\t\tDATA_GENERIC))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "\n\t\t\t\t"is incorrect, run fsck to fix",\n\t\t\t\t__func__, inode->i_ino,\n\t\t\t\tei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_data, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_dentry, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p4890
(dp4891
((g4503
g4696
tp4892
I1
tp4893
(dp4894
g12
g13
sg14
(dp4895
(I4
I5
tp4896
(lp4897
S'\tstruct f2fs_inode_info *fi = F2FS_I(inode);'
p4898
aS'\tunsigned long long iblocks;'
p4899
as(I7
I27
tp4900
(lp4901
S'\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);'
p4902
aS'\tif (!iblocks) {'
p4903
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4904
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4905
aS'\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "'
p4906
aS'\t\t\t"run fsck to fix.",'
p4907
aS'\t\t\t__func__, inode->i_ino, iblocks);'
p4908
aS'\t\treturn false;'
p4909
aS'\t}'
p4910
ag59
aS'\tif (ino_of_node(node_page) != nid_of_node(node_page)) {'
p4911
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4912
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4913
aS'\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "'
p4914
aS'\t\t\t"[%u, %u] run fsck to fix.",'
p4915
aS'\t\t\t__func__, inode->i_ino,'
p4916
aS'\t\t\tino_of_node(node_page), nid_of_node(node_page));'
p4917
aS'\t\treturn false;'
p4918
aS'\t}'
p4919
ag59
aS'\tif (f2fs_sb_has_flexible_inline_xattr(sbi)'
p4920
as(I35
I92
tp4921
(lp4922
g59
aS'\tif (f2fs_has_extra_attr(inode) &&'
p4923
aS'\t\t\t!f2fs_sb_has_extra_attr(sbi)) {'
p4924
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4925
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4926
aS'\t\t\t"%s: inode (ino=%lx) is with extra_attr, "'
p4927
aS'\t\t\t"but extra_attr feature is off",'
p4928
aS'\t\t\t__func__, inode->i_ino);'
p4929
aS'\t\treturn false;'
p4930
aS'\t}'
p4931
ag59
aS'\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||'
p4932
aS'\t\t\tfi->i_extra_isize % sizeof(__le32)) {'
p4933
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4934
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4935
aS'\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "'
p4936
aS'\t\t\t"max: %zu",'
p4937
aS'\t\t\t__func__, inode->i_ino, fi->i_extra_isize,'
p4938
aS'\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);'
p4939
aS'\t\treturn false;'
p4940
aS'\t}'
p4941
ag59
aS'\tif (F2FS_I(inode)->extent_tree) {'
p4942
aS'\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;'
p4943
ag59
aS'\t\tif (ei->len &&'
p4944
aS'\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC) ||'
p4945
aS'\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,'
p4946
aS'\t\t\t\t\t\t\tDATA_GENERIC))) {'
p4947
aS'\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4948
aS'\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4949
aS'\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "'
p4950
aS'\t\t\t\t"is incorrect, run fsck to fix",'
p4951
aS'\t\t\t\t__func__, inode->i_ino,'
p4952
aS'\t\t\t\tei->blk, ei->fofs, ei->len);'
p4953
aS'\t\t\treturn false;'
p4954
aS'\t\t}'
p4955
aS'\t}'
p4956
ag59
aS'\tif (f2fs_has_inline_data(inode) &&'
p4957
aS'\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {'
p4958
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4959
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4960
aS'\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "'
p4961
aS'\t\t\t"inline_data, run fsck to fix",'
p4962
aS'\t\t\t__func__, inode->i_ino, inode->i_mode);'
p4963
aS'\t\treturn false;'
p4964
aS'\t}'
p4965
ag59
aS'\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {'
p4966
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4967
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p4968
aS'\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "'
p4969
aS'\t\t\t"inline_dentry, run fsck to fix",'
p4970
aS'\t\t\t__func__, inode->i_ino, inode->i_mode);'
p4971
aS'\t\treturn false;'
p4972
aS'\t}'
p4973
ag59
as(I1
I1
tp4974
(lp4975
S'static bool sanity_check_inode(struct inode *inode, struct page *node_page)'
p4976
assg32
I2
sg33
(dp4977
(I1
I1
tp4978
(lp4979
S'static bool sanity_check_inode(struct inode *inode)'
p4980
as(I7
I7
tp4981
(lp4982
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)'
p4983
assg41
(I1
I94
tp4984
sssS'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "\n\t\t\t"run fsck to fix.",\n\t\t\t__func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "\n\t\t\t"[%u, %u] run fsck to fix.",\n\t\t\t__func__, inode->i_ino,\n\t\t\tino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) is with extra_attr, "\n\t\t\t"but extra_attr feature is off",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "\n\t\t\t"max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_extra_isize,\n\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\tf2fs_sb_has_flexible_inline_xattr(sbi) &&\n\t\tf2fs_has_inline_xattr(inode) &&\n\t\t(!fi->i_inline_xattr_size ||\n\t\tfi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted "\n\t\t\t"i_inline_xattr_size: %d, max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_inline_xattr_size,\n\t\t\tMAX_INLINE_XATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "\n\t\t\t\t"is incorrect, run fsck to fix",\n\t\t\t\t__func__, inode->i_ino,\n\t\t\t\tei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_data, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_dentry, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p4985
(dp4986
((g4503
g4696
tp4987
I1
tp4988
(dp4989
g12
g13
sg14
(dp4990
(I4
I5
tp4991
(lp4992
S'\tstruct f2fs_inode_info *fi = F2FS_I(inode);'
p4993
aS'\tunsigned long long iblocks;'
p4994
as(I7
I27
tp4995
(lp4996
S'\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);'
p4997
aS'\tif (!iblocks) {'
p4998
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p4999
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5000
aS'\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "'
p5001
aS'\t\t\t"run fsck to fix.",'
p5002
aS'\t\t\t__func__, inode->i_ino, iblocks);'
p5003
aS'\t\treturn false;'
p5004
aS'\t}'
p5005
ag59
aS'\tif (ino_of_node(node_page) != nid_of_node(node_page)) {'
p5006
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5007
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5008
aS'\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "'
p5009
aS'\t\t\t"[%u, %u] run fsck to fix.",'
p5010
aS'\t\t\t__func__, inode->i_ino,'
p5011
aS'\t\t\tino_of_node(node_page), nid_of_node(node_page));'
p5012
aS'\t\treturn false;'
p5013
aS'\t}'
p5014
ag59
aS'\tif (f2fs_sb_has_flexible_inline_xattr(sbi)'
p5015
as(I1
I1
tp5016
(lp5017
S'static bool sanity_check_inode(struct inode *inode, struct page *node_page)'
p5018
as(I35
I107
tp5019
(lp5020
g59
aS'\tif (f2fs_has_extra_attr(inode) &&'
p5021
aS'\t\t\t!f2fs_sb_has_extra_attr(sbi)) {'
p5022
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5023
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5024
aS'\t\t\t"%s: inode (ino=%lx) is with extra_attr, "'
p5025
aS'\t\t\t"but extra_attr feature is off",'
p5026
aS'\t\t\t__func__, inode->i_ino);'
p5027
aS'\t\treturn false;'
p5028
aS'\t}'
p5029
ag59
aS'\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||'
p5030
aS'\t\t\tfi->i_extra_isize % sizeof(__le32)) {'
p5031
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5032
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5033
aS'\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "'
p5034
aS'\t\t\t"max: %zu",'
p5035
aS'\t\t\t__func__, inode->i_ino, fi->i_extra_isize,'
p5036
aS'\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);'
p5037
aS'\t\treturn false;'
p5038
aS'\t}'
p5039
ag59
aS'\tif (f2fs_has_extra_attr(inode) &&'
p5040
aS'\t\tf2fs_sb_has_flexible_inline_xattr(sbi) &&'
p5041
aS'\t\tf2fs_has_inline_xattr(inode) &&'
p5042
aS'\t\t(!fi->i_inline_xattr_size ||'
p5043
aS'\t\tfi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {'
p5044
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5045
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5046
aS'\t\t\t"%s: inode (ino=%lx) has corrupted "'
p5047
aS'\t\t\t"i_inline_xattr_size: %d, max: %zu",'
p5048
aS'\t\t\t__func__, inode->i_ino, fi->i_inline_xattr_size,'
p5049
aS'\t\t\tMAX_INLINE_XATTR_SIZE);'
p5050
aS'\t\treturn false;'
p5051
aS'\t}'
p5052
ag59
aS'\tif (F2FS_I(inode)->extent_tree) {'
p5053
aS'\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;'
p5054
ag59
aS'\t\tif (ei->len &&'
p5055
aS'\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk,'
p5056
aS'\t\t\t\t\t\tDATA_GENERIC_ENHANCE) ||'
p5057
aS'\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,'
p5058
aS'\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {'
p5059
aS'\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5060
aS'\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5061
aS'\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "'
p5062
aS'\t\t\t\t"is incorrect, run fsck to fix",'
p5063
aS'\t\t\t\t__func__, inode->i_ino,'
p5064
aS'\t\t\t\tei->blk, ei->fofs, ei->len);'
p5065
aS'\t\t\treturn false;'
p5066
aS'\t\t}'
p5067
aS'\t}'
p5068
ag59
aS'\tif (f2fs_has_inline_data(inode) &&'
p5069
aS'\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {'
p5070
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5071
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5072
aS'\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "'
p5073
aS'\t\t\t"inline_data, run fsck to fix",'
p5074
aS'\t\t\t__func__, inode->i_ino, inode->i_mode);'
p5075
aS'\t\treturn false;'
p5076
aS'\t}'
p5077
ag59
aS'\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {'
p5078
aS'\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);'
p5079
aS'\t\tf2fs_msg(sbi->sb, KERN_WARNING,'
p5080
aS'\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "'
p5081
aS'\t\t\t"inline_dentry, run fsck to fix",'
p5082
aS'\t\t\t__func__, inode->i_ino, inode->i_mode);'
p5083
aS'\t\treturn false;'
p5084
aS'\t}'
p5085
ag59
assg32
I2
sg33
(dp5086
(I1
I1
tp5087
(lp5088
S'static bool sanity_check_inode(struct inode *inode)'
p5089
as(I7
I7
tp5090
(lp5091
S'\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)'
p5092
assg41
(I1
I109
tp5093
sssssS'CVE-2018-11988'
p5094
(dp5095
(S'drivers/misc/qseecom.c'
p5096
S'qseecom_remove'
p5097
tp5098
(dp5099
S'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle) {\n\t\t\tlist_del(&kclient->list);\n\t\t\tkzfree(kclient);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tkthread_stop(qseecom.unload_app_kthread_task);\n\n\tkthread_stop(qseecom.unregister_lsnr_kthread_task);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p5100
(dp5101
((g5096
g5097
tp5102
I1
tp5103
(dp5104
g33
(dp5105
(I35
I39
tp5106
(lp5107
S'exit_free_kc_handle:'
p5108
aS'\tkzfree(kclient->handle);'
p5109
aS'exit_free_kclient:'
p5110
aS'\tkzfree(kclient);'
p5111
aS'exit_irqrestore:'
p5112
as(I14
I17
tp5113
(lp5114
S'\tlist_for_each_entry(kclient, &qseecom.registered_kclient_list_head,'
p5115
aS'\t\t\t\t\t\t\t\tlist) {'
p5116
aS'\t\tif (!kclient)'
p5117
aS'\t\t\tgoto exit_irqrestore;'
p5118
as(I18
I22
tp5119
(lp5120
S'\t\tif (!kclient->handle)'
p5121
aS'\t\t\tgoto exit_free_kclient;'
p5122
ag59
aS'\t\tif (list_empty(&kclient->list))'
p5123
aS'\t\t\tgoto exit_free_kc_handle;'
p5124
assg14
(dp5125
(I18
I22
tp5126
(lp5127
S'\t\tif (!kclient->handle) {'
p5128
aS'\t\t\tlist_del(&kclient->list);'
p5129
aS'\t\t\tkzfree(kclient);'
p5130
aS'\t\t\tbreak;'
p5131
aS'\t\t}'
p5132
as(I80
I83
tp5133
(lp5134
S'\tkthread_stop(qseecom.unload_app_kthread_task);'
p5135
ag59
aS'\tkthread_stop(qseecom.unregister_lsnr_kthread_task);'
p5136
ag59
as(I4
I4
tp5137
(lp5138
S'\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;'
p5139
as(I14
I15
tp5140
(lp5141
S'\tlist_for_each_entry_safe(kclient, kclient_tmp,'
p5142
aS'\t\t&qseecom.registered_kclient_list_head, list) {'
p5143
assg32
I1
sg12
g13
sg41
(I1
I93
tp5144
sssS'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle) {\n\t\t\tlist_del(&kclient->list);\n\t\t\tkzfree(kclient);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tkthread_stop(qseecom.unregister_lsnr_kthread_task);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p5145
(dp5146
((g5096
g5097
tp5147
I1
tp5148
(dp5149
g33
(dp5150
(I35
I39
tp5151
(lp5152
S'exit_free_kc_handle:'
p5153
aS'\tkzfree(kclient->handle);'
p5154
aS'exit_free_kclient:'
p5155
aS'\tkzfree(kclient);'
p5156
aS'exit_irqrestore:'
p5157
as(I14
I17
tp5158
(lp5159
S'\tlist_for_each_entry(kclient, &qseecom.registered_kclient_list_head,'
p5160
aS'\t\t\t\t\t\t\t\tlist) {'
p5161
aS'\t\tif (!kclient)'
p5162
aS'\t\t\tgoto exit_irqrestore;'
p5163
as(I18
I22
tp5164
(lp5165
S'\t\tif (!kclient->handle)'
p5166
aS'\t\t\tgoto exit_free_kclient;'
p5167
ag59
aS'\t\tif (list_empty(&kclient->list))'
p5168
aS'\t\t\tgoto exit_free_kc_handle;'
p5169
assg14
(dp5170
(I18
I22
tp5171
(lp5172
S'\t\tif (!kclient->handle) {'
p5173
aS'\t\t\tlist_del(&kclient->list);'
p5174
aS'\t\t\tkzfree(kclient);'
p5175
aS'\t\t\tbreak;'
p5176
aS'\t\t}'
p5177
as(I80
I81
tp5178
(lp5179
S'\tkthread_stop(qseecom.unregister_lsnr_kthread_task);'
p5180
ag59
as(I4
I4
tp5181
(lp5182
S'\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;'
p5183
as(I14
I15
tp5184
(lp5185
S'\tlist_for_each_entry_safe(kclient, kclient_tmp,'
p5186
aS'\t\t&qseecom.registered_kclient_list_head, list) {'
p5187
assg32
I1
sg12
g13
sg41
(I1
I91
tp5188
sssS'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle)\n\t\t\tgoto exit_free_kclient;\n\n\t\tif (list_empty(&kclient->list))\n\t\t\tgoto exit_free_kc_handle;\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\nexit_free_kc_handle:\n\tkzfree(kclient->handle);\nexit_free_kclient:\n\tkzfree(kclient);\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p5189
(dp5190
((g5096
g5097
tp5191
I1
tp5192
(dp5193
g33
(dp5194
(I14
I17
tp5195
(lp5196
S'\tlist_for_each_entry(kclient, &qseecom.registered_kclient_list_head,'
p5197
aS'\t\t\t\t\t\t\t\tlist) {'
p5198
aS'\t\tif (!kclient)'
p5199
aS'\t\t\tgoto exit_irqrestore;'
p5200
as(I39
I39
tp5201
(lp5202
S'exit_irqrestore:'
p5203
assg14
(dp5204
(I4
I4
tp5205
(lp5206
S'\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;'
p5207
as(I14
I15
tp5208
(lp5209
S'\tlist_for_each_entry_safe(kclient, kclient_tmp,'
p5210
aS'\t\t&qseecom.registered_kclient_list_head, list) {'
p5211
as(I39
I39
tp5212
(lp5213
g59
assg32
I1
sg12
g13
sg41
(I1
I94
tp5214
sssS'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle) {\n\t\t\tlist_del(&kclient->list);\n\t\t\tkzfree(kclient);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p5215
(dp5216
((g5096
g5097
tp5217
I1
tp5218
(dp5219
g33
(dp5220
(I35
I39
tp5221
(lp5222
S'exit_free_kc_handle:'
p5223
aS'\tkzfree(kclient->handle);'
p5224
aS'exit_free_kclient:'
p5225
aS'\tkzfree(kclient);'
p5226
aS'exit_irqrestore:'
p5227
as(I14
I17
tp5228
(lp5229
S'\tlist_for_each_entry(kclient, &qseecom.registered_kclient_list_head,'
p5230
aS'\t\t\t\t\t\t\t\tlist) {'
p5231
aS'\t\tif (!kclient)'
p5232
aS'\t\t\tgoto exit_irqrestore;'
p5233
as(I18
I22
tp5234
(lp5235
S'\t\tif (!kclient->handle)'
p5236
aS'\t\t\tgoto exit_free_kclient;'
p5237
ag59
aS'\t\tif (list_empty(&kclient->list))'
p5238
aS'\t\t\tgoto exit_free_kc_handle;'
p5239
assg14
(dp5240
(I18
I22
tp5241
(lp5242
S'\t\tif (!kclient->handle) {'
p5243
aS'\t\t\tlist_del(&kclient->list);'
p5244
aS'\t\t\tkzfree(kclient);'
p5245
aS'\t\t\tbreak;'
p5246
aS'\t\t}'
p5247
as(I4
I4
tp5248
(lp5249
S'\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;'
p5250
as(I14
I15
tp5251
(lp5252
S'\tlist_for_each_entry_safe(kclient, kclient_tmp,'
p5253
aS'\t\t&qseecom.registered_kclient_list_head, list) {'
p5254
assg32
I1
sg12
g13
sg41
(I1
I89
tp5255
sssssS'CVE-2018-11983'
p5256
(dp5257
(S'drivers/char/diag/diagfwd_cntl.c'
p5258
S'process_ssid_range_report'
p5259
tp5260
(dp5261
S'static void process_ssid_range_report(uint8_t *buf, uint32_t len,\n\t\t\t\t      uint8_t peripheral)\n{\n\tint i;\n\tint j;\n\tint read_len = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tint err = 0;\n\tstruct diag_ctrl_ssid_range_report *header = NULL;\n\tstruct diag_ssid_range_t *ssid_range = NULL;\n\tint header_len = sizeof(struct diag_ctrl_ssid_range_report);\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tuint8_t *ptr = buf;\n\tuint8_t *temp = NULL;\n\tuint32_t min_len = header_len - sizeof(struct diag_ctrl_pkt_header_t);\n\n\tif (!buf || peripheral >= NUM_PERIPHERALS || len < min_len) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid parameters:(!buf) = %d, peripheral = %d, len = %d, min_len = %d\\n",\n\t\t!buf, peripheral, len, min_len);\n\t\treturn;\n\t}\n\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: started processing ssid range for peripheral (%d)\\n",\n\t\tperipheral);\n\n\theader = (struct diag_ctrl_ssid_range_report *)ptr;\n\tptr += header_len;\n\t/* Don\'t account for pkt_id and length */\n\tread_len += header_len - (2 * sizeof(uint32_t));\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tdriver->max_ssid_count[peripheral] = header->count;\n\tfor (i = 0; i < header->count && read_len < len; i++) {\n\t\tssid_range = (struct diag_ssid_range_t *)ptr;\n\t\tptr += sizeof(struct diag_ssid_range_t);\n\t\tread_len += sizeof(struct diag_ssid_range_t);\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\tfound = 0;\n\t\tfor (j = 0; j < driver->msg_mask_tbl_count; j++, mask_ptr++) {\n\t\t\tif (!mask_ptr->ptr || !ssid_range) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mask_ptr->ssid_first != ssid_range->ssid_first)\n\t\t\t\tcontinue;\n\t\t\tmutex_lock(&mask_ptr->lock);\n\t\t\terr = update_msg_mask_tbl_entry(mask_ptr, ssid_range);\n\t\t\tmutex_unlock(&mask_ptr->lock);\n\t\t\tif (err == -ENOMEM) {\n\t\t\t\tpr_err("diag: In %s, unable to increase the msg mask table range\\n",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tnew_size = (driver->msg_mask_tbl_count + 1) *\n\t\t\t   sizeof(struct diag_msg_mask_t);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"diag: receiving msg mask size more that Apps can handle\\n");\n\t\ttemp = krealloc(msg_mask.ptr, new_size, GFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tpr_err("diag: In %s, Unable to add new ssid table to msg mask, ssid first: %d, last: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last);\n\t\t\tcontinue;\n\t\t}\n\t\tmsg_mask.ptr = temp;\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\terr = diag_create_msg_mask_table_entry(mask_ptr, ssid_range);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, first: %d last: %d err: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last, err);\n\t\t\tcontinue;\n\t\t}\n\t\tdriver->msg_mask_tbl_count += 1;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: processed ssid range for peripheral(%d)\\n",\n\t\tperipheral);\n}'
p5262
(dp5263
((g5258
g5259
tp5264
I1
tp5265
(dp5266
g14
(dp5267
(I65
I66
tp5268
(lp5269
S'\t\tDIAG_LOG(DIAG_DEBUG_MASKS,'
p5270
aS'\t\t\t"diag: receiving msg mask size more that Apps can handle\\n");'
p5271
as(I75
I75
tp5272
(lp5273
S'\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;'
p5274
as(I43
I46
tp5275
(lp5276
S'\t\t\tif (!mask_ptr->ptr || !ssid_range) {'
p5277
aS'\t\t\t\tfound = 1;'
p5278
aS'\t\t\t\tbreak;'
p5279
aS'\t\t\t}'
p5280
assg32
I3
sg12
g13
sg41
(I1
I89
tp5281
sssS'static void process_ssid_range_report(uint8_t *buf, uint32_t len,\n\t\t\t\t      uint8_t peripheral)\n{\n\tint i;\n\tint j;\n\tint read_len = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tint err = 0;\n\tstruct diag_ctrl_ssid_range_report *header = NULL;\n\tstruct diag_ssid_range_t *ssid_range = NULL;\n\tint header_len = sizeof(struct diag_ctrl_ssid_range_report);\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tuint8_t *ptr = buf;\n\tuint8_t *temp = NULL;\n\tuint32_t min_len = header_len - sizeof(struct diag_ctrl_pkt_header_t);\n\n\tif (!buf || peripheral >= NUM_PERIPHERALS || len < min_len) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid parameters:(!buf) = %d, peripheral = %d, len = %d, min_len = %d\\n",\n\t\t!buf, peripheral, len, min_len);\n\t\treturn;\n\t}\n\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: started processing ssid range for peripheral (%d)\\n",\n\t\tperipheral);\n\n\theader = (struct diag_ctrl_ssid_range_report *)ptr;\n\tptr += header_len;\n\t/* Don\'t account for pkt_id and length */\n\tread_len += header_len - (2 * sizeof(uint32_t));\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tdriver->max_ssid_count[peripheral] = header->count;\n\tfor (i = 0; i < header->count && read_len < len; i++) {\n\t\tssid_range = (struct diag_ssid_range_t *)ptr;\n\t\tptr += sizeof(struct diag_ssid_range_t);\n\t\tread_len += sizeof(struct diag_ssid_range_t);\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\tfound = 0;\n\t\tfor (j = 0; j < driver->msg_mask_tbl_count; j++, mask_ptr++) {\n\t\t\tif (!mask_ptr || !ssid_range) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mask_ptr->ssid_first != ssid_range->ssid_first)\n\t\t\t\tcontinue;\n\t\t\tmutex_lock(&mask_ptr->lock);\n\t\t\terr = update_msg_mask_tbl_entry(mask_ptr, ssid_range);\n\t\t\tmutex_unlock(&mask_ptr->lock);\n\t\t\tif (err == -ENOMEM) {\n\t\t\t\tpr_err("diag: In %s, unable to increase the msg mask table range\\n",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tnew_size = (driver->msg_mask_tbl_count + 1) *\n\t\t\t   sizeof(struct diag_msg_mask_t);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"diag: receiving msg mask size more that Apps can handle\\n");\n\t\ttemp = krealloc(msg_mask.ptr, new_size, GFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tpr_err("diag: In %s, Unable to add new ssid table to msg mask, ssid first: %d, last: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last);\n\t\t\tcontinue;\n\t\t}\n\t\tmsg_mask.ptr = temp;\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\terr = diag_create_msg_mask_table_entry(mask_ptr, ssid_range);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, first: %d last: %d err: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last, err);\n\t\t\tcontinue;\n\t\t}\n\t\tdriver->msg_mask_tbl_count += 1;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: processed ssid range for peripheral(%d)\\n",\n\t\tperipheral);\n}'
p5282
(dp5283
((g5258
g5259
tp5284
I1
tp5285
(dp5286
g14
(dp5287
(I65
I66
tp5288
(lp5289
S'\t\tDIAG_LOG(DIAG_DEBUG_MASKS,'
p5290
aS'\t\t\t"diag: receiving msg mask size more that Apps can handle\\n");'
p5291
as(I75
I75
tp5292
(lp5293
S'\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;'
p5294
as(I43
I46
tp5295
(lp5296
S'\t\t\tif (!mask_ptr || !ssid_range) {'
p5297
aS'\t\t\t\tfound = 1;'
p5298
aS'\t\t\t\tbreak;'
p5299
aS'\t\t\t}'
p5300
assg32
I3
sg12
g13
sg41
(I1
I89
tp5301
ssss(S'drivers/char/diag/diag_masks.c'
p5302
S'diag_cmd_set_log_mask'
p5303
tp5304
(dp5305
S'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p5306
(dp5307
((g5302
g5303
tp5308
I1
tp5309
(dp5310
g14
(dp5311
(I60
I61
tp5312
(lp5313
S'\t\tif (!mask || !mask->ptr)'
p5314
aS'\t\t\tcontinue;'
p5315
assg32
I5
sg12
g13
sg41
(I1
I152
tp5316
sssS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0 && src_len >= read_len + mask_size)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p5317
(dp5318
((g5302
g5303
tp5319
I1
tp5320
(dp5321
g12
g13
sg14
(dp5322
(I60
I61
tp5323
(lp5324
S'\t\tif (!mask || !mask->ptr)'
p5325
aS'\t\t\tcontinue;'
p5326
as(I22
I23
tp5327
(lp5328
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p5329
aS'\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {'
p5330
as(I97
I97
tp5331
(lp5332
S'\t\tif (mask_size > 0 && src_len >= read_len + mask_size)'
p5333
assg32
I5
sg33
(dp5334
(I22
I23
tp5335
(lp5336
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p5337
aS'\t    !mask_info) {'
p5338
as(I97
I97
tp5339
(lp5340
S'\t\tif (mask_size > 0)'
p5341
assg41
(I1
I152
tp5342
ssss(g5302
S'diag_cmd_set_all_msg_mask'
p5343
tp5344
(dp5345
S'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p5346
(dp5347
((g5302
g5343
tp5348
I1
tp5349
(dp5350
g12
g13
sg14
(dp5351
(I48
I53
tp5352
(lp5353
S'\t\tif (mask && mask->ptr) {'
p5354
aS'\t\t\tmutex_lock(&mask->lock);'
p5355
aS'\t\t\tmemset(mask->ptr, req->rt_mask,'
p5356
aS'\t\t\t       mask->range * sizeof(uint32_t));'
p5357
aS'\t\t\tmutex_unlock(&mask->lock);'
p5358
aS'\t\t}'
p5359
assg32
I5
sg33
(dp5360
(I48
I51
tp5361
(lp5362
S'\t\tmutex_lock(&mask->lock);'
p5363
aS'\t\tmemset(mask->ptr, req->rt_mask,'
p5364
aS'\t\t       mask->range * sizeof(uint32_t));'
p5365
aS'\t\tmutex_unlock(&mask->lock);'
p5366
assg41
(I1
I88
tp5367
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p5368
(dp5369
((g5302
g5343
tp5370
I1
tp5371
(dp5372
g33
(dp5373
(I17
I18
tp5374
(lp5375
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p5376
aS'\t    !mask_info) {'
p5377
as(I50
I54
tp5378
(lp5379
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p5380
aS'\t\tmutex_lock(&mask->lock);'
p5381
aS'\t\tmemset(mask->ptr, req->rt_mask,'
p5382
aS'\t\t       mask->range * sizeof(uint32_t));'
p5383
aS'\t\tmutex_unlock(&mask->lock);'
p5384
assg14
(dp5385
(I17
I18
tp5386
(lp5387
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p5388
aS'\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {'
p5389
as(I50
I56
tp5390
(lp5391
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p5392
aS'\t\tif (mask && mask->ptr) {'
p5393
aS'\t\t\tmutex_lock(&mask->lock);'
p5394
aS'\t\t\tmemset(mask->ptr, req->rt_mask,'
p5395
aS'\t\t\t       mask->range * sizeof(uint32_t));'
p5396
aS'\t\t\tmutex_unlock(&mask->lock);'
p5397
aS'\t\t}'
p5398
as(I46
I47
tp5399
(lp5400
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p5401
aS'\t\t\tdriver->msg_mask_tbl_count;'
p5402
as(I11
I11
tp5403
(lp5404
S'\tuint8_t msg_mask_tbl_count = 0;'
p5405
assg32
I5
sg12
g13
sg41
(I1
I91
tp5406
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p5407
(dp5408
((g5302
g5343
tp5409
I1
tp5410
(dp5411
g33
(dp5412
(I50
I54
tp5413
(lp5414
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p5415
aS'\t\tmutex_lock(&mask->lock);'
p5416
aS'\t\tmemset(mask->ptr, req->rt_mask,'
p5417
aS'\t\t       mask->range * sizeof(uint32_t));'
p5418
aS'\t\tmutex_unlock(&mask->lock);'
p5419
assg14
(dp5420
(I50
I56
tp5421
(lp5422
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p5423
aS'\t\tif (mask && mask->ptr) {'
p5424
aS'\t\t\tmutex_lock(&mask->lock);'
p5425
aS'\t\t\tmemset(mask->ptr, req->rt_mask,'
p5426
aS'\t\t\t       mask->range * sizeof(uint32_t));'
p5427
aS'\t\t\tmutex_unlock(&mask->lock);'
p5428
aS'\t\t}'
p5429
as(I46
I47
tp5430
(lp5431
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p5432
aS'\t\t\tdriver->msg_mask_tbl_count;'
p5433
as(I11
I11
tp5434
(lp5435
S'\tuint8_t msg_mask_tbl_count = 0;'
p5436
assg32
I5
sg12
g13
sg41
(I1
I91
tp5437
ssss(g5258
S'process_last_event_report'
p5438
tp5439
(dp5440
S'static void process_last_event_report(uint8_t *buf, uint32_t len,\n\t\t\t\t      uint8_t peripheral)\n{\n\tstruct diag_ctrl_last_event_report *header = NULL;\n\tuint8_t *ptr = buf;\n\tuint8_t *temp = NULL;\n\tuint32_t pkt_len = sizeof(uint32_t) + sizeof(uint16_t);\n\tuint16_t event_size = 0;\n\n\tif (!buf || peripheral >= NUM_PERIPHERALS || len != pkt_len) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid parameters:(!buf) = %d, peripheral = %d, len = %d, pkt_len = %d\\n",\n\t\t!buf, peripheral, len, pkt_len);\n\t\treturn;\n\t}\n\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag:started processing last event report for peripheral (%d)\\n",\n\t\tperipheral);\n\n\tmutex_lock(&event_mask.lock);\n\theader = (struct diag_ctrl_last_event_report *)ptr;\n\tevent_size = ((header->event_last_id / 8) + 1);\n\tif (event_size >= driver->event_mask_size) {\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t"diag: receiving event mask size more that Apps can handle\\n");\n\t\ttemp = krealloc(driver->event_mask->ptr, event_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tpr_err("diag: In %s, unable to reallocate event mask to support events from %d\\n",\n\t\t\t       __func__, peripheral);\n\t\t\tgoto err;\n\t\t}\n\t\tdriver->event_mask->ptr = temp;\n\t\tdriver->event_mask_size = event_size;\n\t}\n\n\tdriver->num_event_id[peripheral] = header->event_last_id;\n\tif (header->event_last_id > driver->last_event_id)\n\t\tdriver->last_event_id = header->event_last_id;\nerr:\n\tmutex_unlock(&event_mask.lock);\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: last event report processed for peripheral (%d)\\n",\n\t\tperipheral);\n}'
p5441
(dp5442
((g5258
g5438
tp5443
I1
tp5444
(dp5445
g12
g13
sg14
(dp5446
(I25
I26
tp5447
(lp5448
S'\t\tDIAG_LOG(DIAG_DEBUG_MASKS,'
p5449
aS'\t\t"diag: receiving event mask size more that Apps can handle\\n");'
p5450
assg32
I3
sg33
(dp5451
(I25
I27
tp5452
(lp5453
S'\t\tDIAG_LOG(DIAG_DEBUG_CONTROL,'
p5454
aS'\t\t\t"diag: In %s, receiving event mask size more that Apps can handle\\n",'
p5455
aS'\t\t\t __func__);'
p5456
assg41
(I1
I46
tp5457
ssss(g5258
S'diag_build_time_mask_update'
p5458
tp5459
(dp5460
S'static void diag_build_time_mask_update(uint8_t *buf,\n\t\t\t\t\tstruct diag_ssid_range_t *range)\n{\n\tint i;\n\tint j;\n\tint num_items = 0;\n\tint err = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tuint8_t *temp = NULL;\n\tuint32_t *mask_ptr = (uint32_t *)buf;\n\tuint32_t *dest_ptr = NULL;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\n\tif (!range || !buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid %s\\n",\n\t\t(!range ? "range" : (!buf ? "buf" : " ")));\n\t\treturn;\n\t}\n\n\tif (range->ssid_last < range->ssid_first) {\n\t\tpr_err("diag: In %s, invalid ssid range, first: %d, last: %d\\n",\n\t\t       __func__, range->ssid_first, range->ssid_last);\n\t\treturn;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tbuild_mask = (struct diag_msg_mask_t *)(driver->build_time_mask->ptr);\n\tnum_items = range->ssid_last - range->ssid_first + 1;\n\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (build_mask->ssid_first != range->ssid_first)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tmutex_lock(&build_mask->lock);\n\t\terr = update_msg_mask_tbl_entry(build_mask, range);\n\t\tif (err == -ENOMEM) {\n\t\t\tpr_err("diag: In %s, unable to increase the msg build mask table range\\n",\n\t\t\t       __func__);\n\t\t}\n\t\tdest_ptr = build_mask->ptr;\n\t\tfor (j = 0; (j < build_mask->range) && mask_ptr && dest_ptr;\n\t\t\tj++, mask_ptr++, dest_ptr++)\n\t\t\t*(uint32_t *)dest_ptr |= *mask_ptr;\n\t\tmutex_unlock(&build_mask->lock);\n\t\tbreak;\n\t}\n\n\tif (found)\n\t\tgoto end;\n\n\tnew_size = (driver->bt_msg_mask_tbl_count + 1) *\n\t\t   sizeof(struct diag_msg_mask_t);\n\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t"diag: receiving build time mask size more that Apps can handle\\n");\n\n\ttemp = krealloc(driver->build_time_mask->ptr, new_size, GFP_KERNEL);\n\tif (!temp) {\n\t\tpr_err("diag: In %s, unable to create a new entry for build time mask\\n",\n\t\t       __func__);\n\t\tgoto end;\n\t}\n\tdriver->build_time_mask->ptr = temp;\n\tbuild_mask = (struct diag_msg_mask_t *)driver->build_time_mask->ptr;\n\terr = diag_create_msg_mask_table_entry(build_mask, range);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, err: %d\\n",\n\t\t       __func__, err);\n\t\tgoto end;\n\t}\n\tdriver->bt_msg_mask_tbl_count += 1;\nend:\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn;\n}'
p5461
(dp5462
((g5258
g5458
tp5463
I1
tp5464
(dp5465
g33
(dp5466
(I46
I46
tp5467
(lp5468
S'\t\tfor (j = 0; j < build_mask->range; j++, mask_ptr++, dest_ptr++)'
p5469
assg14
(dp5470
(I32
I35
tp5471
(lp5472
S'\t\tif (!build_mask->ptr) {'
p5473
aS'\t\t\tfound = 1;'
p5474
aS'\t\t\tbreak;'
p5475
aS'\t\t}'
p5476
as(I68
I68
tp5477
(lp5478
S'\tbuild_mask = (struct diag_msg_mask_t *)driver->build_time_mask->ptr;'
p5479
as(I46
I47
tp5480
(lp5481
S'\t\tfor (j = 0; (j < build_mask->range) && mask_ptr && dest_ptr;'
p5482
aS'\t\t\tj++, mask_ptr++, dest_ptr++)'
p5483
as(I55
I55
tp5484
(lp5485
g59
as(I58
I60
tp5486
(lp5487
S'\tDIAG_LOG(DIAG_DEBUG_MASKS,'
p5488
aS'\t\t"diag: receiving build time mask size more that Apps can handle\\n");'
p5489
ag59
assg32
I2
sg12
g13
sg41
(I1
I79
tp5490
sssS'static void diag_build_time_mask_update(uint8_t *buf,\n\t\t\t\t\tstruct diag_ssid_range_t *range)\n{\n\tint i;\n\tint j;\n\tint num_items = 0;\n\tint err = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tuint8_t *temp = NULL;\n\tuint32_t *mask_ptr = (uint32_t *)buf;\n\tuint32_t *dest_ptr = NULL;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\n\tif (!range || !buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid %s\\n",\n\t\t(!range ? "range" : (!buf ? "buf" : " ")));\n\t\treturn;\n\t}\n\n\tif (range->ssid_last < range->ssid_first) {\n\t\tpr_err("diag: In %s, invalid ssid range, first: %d, last: %d\\n",\n\t\t       __func__, range->ssid_first, range->ssid_last);\n\t\treturn;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tbuild_mask = (struct diag_msg_mask_t *)(driver->build_time_mask->ptr);\n\tnum_items = range->ssid_last - range->ssid_first + 1;\n\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (build_mask->ssid_first != range->ssid_first)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tmutex_lock(&build_mask->lock);\n\t\terr = update_msg_mask_tbl_entry(build_mask, range);\n\t\tif (err == -ENOMEM) {\n\t\t\tpr_err("diag: In %s, unable to increase the msg build mask table range\\n",\n\t\t\t       __func__);\n\t\t}\n\t\tdest_ptr = build_mask->ptr;\n\t\tfor (j = 0; (j < build_mask->range) && mask_ptr && dest_ptr;\n\t\t\tj++, mask_ptr++, dest_ptr++)\n\t\t\t*(uint32_t *)dest_ptr |= *mask_ptr;\n\t\tmutex_unlock(&build_mask->lock);\n\t\tbreak;\n\t}\n\n\tif (found)\n\t\tgoto end;\n\n\tnew_size = (driver->bt_msg_mask_tbl_count + 1) *\n\t\t   sizeof(struct diag_msg_mask_t);\n\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t"diag: receiving build time mask size more that Apps can handle\\n");\n\n\ttemp = krealloc(driver->build_time_mask->ptr, new_size, GFP_KERNEL);\n\tif (!temp) {\n\t\tpr_err("diag: In %s, unable to create a new entry for build time mask\\n",\n\t\t       __func__);\n\t\tgoto end;\n\t}\n\tdriver->build_time_mask->ptr = temp;\n\tbuild_mask = (struct diag_msg_mask_t *)driver->build_time_mask->ptr;\n\terr = diag_create_msg_mask_table_entry(build_mask, range);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, err: %d\\n",\n\t\t       __func__, err);\n\t\tgoto end;\n\t}\n\tdriver->bt_msg_mask_tbl_count += 1;\nend:\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn;\n}'
p5491
(dp5492
((g5258
g5458
tp5493
I1
tp5494
(dp5495
g33
(dp5496
(I46
I46
tp5497
(lp5498
S'\t\tfor (j = 0; j < build_mask->range; j++, mask_ptr++, dest_ptr++)'
p5499
assg14
(dp5500
(I32
I35
tp5501
(lp5502
S'\t\tif (!build_mask) {'
p5503
aS'\t\t\tfound = 1;'
p5504
aS'\t\t\tbreak;'
p5505
aS'\t\t}'
p5506
as(I68
I68
tp5507
(lp5508
S'\tbuild_mask = (struct diag_msg_mask_t *)driver->build_time_mask->ptr;'
p5509
as(I46
I47
tp5510
(lp5511
S'\t\tfor (j = 0; (j < build_mask->range) && mask_ptr && dest_ptr;'
p5512
aS'\t\t\tj++, mask_ptr++, dest_ptr++)'
p5513
as(I55
I55
tp5514
(lp5515
g59
as(I58
I60
tp5516
(lp5517
S'\tDIAG_LOG(DIAG_DEBUG_MASKS,'
p5518
aS'\t\t"diag: receiving build time mask size more that Apps can handle\\n");'
p5519
ag59
assg32
I2
sg12
g13
sg41
(I1
I79
tp5520
ssss(g5302
S'diag_cmd_disable_log_mask'
p5521
tp5522
(dp5523
S'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, 0, mask->range);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p5524
(dp5525
((g5302
g5521
tp5526
I1
tp5527
(dp5528
g12
g13
sg14
(dp5529
(I36
I40
tp5530
(lp5531
S'\t\tif (mask && mask->ptr) {'
p5532
aS'\t\t\tmutex_lock(&mask->lock);'
p5533
aS'\t\t\tmemset(mask->ptr, 0, mask->range);'
p5534
aS'\t\t\tmutex_unlock(&mask->lock);'
p5535
aS'\t\t}'
p5536
assg32
I5
sg33
(dp5537
(I36
I38
tp5538
(lp5539
S'\t\tmutex_lock(&mask->lock);'
p5540
aS'\t\tmemset(mask->ptr, 0, mask->range);'
p5541
aS'\t\tmutex_unlock(&mask->lock);'
p5542
assg41
(I1
I74
tp5543
sssssS'CVE-2018-11986'
p5544
(dp5545
(S'drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c'
p5546
S'SWAP_IDENTITY_FOR_BATCH_ON_PREVIEW'
p5547
tp5548
(dp5549
s(g5546
S'msm_cpp_empty_list'
p5550
tp5551
(dp5552
s(g5546
S'msm_cpp_irq'
p5553
tp5554
(dp5555
S'static irqreturn_t msm_cpp_irq(int irq_num, void *data)\n{\n\tunsigned long flags;\n\tuint32_t tx_level;\n\tuint32_t irq_status;\n\tuint32_t i;\n\tuint32_t tx_fifo[MSM_CPP_TX_FIFO_LEVEL];\n\tstruct cpp_device *cpp_dev = data;\n\tstruct msm_cpp_tasklet_queue_cmd *queue_cmd;\n\n\tirq_status = msm_camera_io_r(cpp_dev->base + MSM_CPP_MICRO_IRQGEN_STAT);\n\n\tif (irq_status & 0x8) {\n\t\ttx_level = msm_camera_io_r(cpp_dev->base +\n\t\t\tMSM_CPP_MICRO_FIFO_TX_STAT) >> 2;\n\t\tif (tx_level < MSM_CPP_TX_FIFO_LEVEL) {\n\t\t\tfor (i = 0; i < tx_level; i++) {\n\t\t\t\ttx_fifo[i] = msm_camera_io_r(cpp_dev->base +\n\t\t\t\t\tMSM_CPP_MICRO_FIFO_TX_DATA);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err("Fatal invalid tx level %d", tx_level);\n\t\t\tgoto err;\n\t\t}\n\t\tspin_lock_irqsave(&cpp_dev->tasklet_lock, flags);\n\t\tqueue_cmd = &cpp_dev->tasklet_queue_cmd[cpp_dev->taskletq_idx];\n\t\tif (queue_cmd->cmd_used) {\n\t\t\tpr_err("%s:%d] cpp tasklet queue overflow tx %d rc %x",\n\t\t\t\t__func__, __LINE__, tx_level, irq_status);\n\t\t\tlist_del(&queue_cmd->list);\n\t\t} else {\n\t\t\tatomic_add(1, &cpp_dev->irq_cnt);\n\t\t}\n\t\tqueue_cmd->irq_status = irq_status;\n\t\tqueue_cmd->tx_level = tx_level;\n\t\tmemset(&queue_cmd->tx_fifo[0], 0, sizeof(queue_cmd->tx_fifo));\n\t\tfor (i = 0; i < tx_level; i++)\n\t\t\tqueue_cmd->tx_fifo[i] = tx_fifo[i];\n\n\t\tqueue_cmd->cmd_used = 1;\n\t\tcpp_dev->taskletq_idx =\n\t\t\t(cpp_dev->taskletq_idx + 1) % MSM_CPP_TASKLETQ_SIZE;\n\t\tlist_add_tail(&queue_cmd->list, &cpp_dev->tasklet_q);\n\t\tspin_unlock_irqrestore(&cpp_dev->tasklet_lock, flags);\n\n\t\ttasklet_schedule(&cpp_dev->cpp_tasklet);\n\t} else if (irq_status & 0x7C0) {\n\t\tpr_debug("irq_status: 0x%x\\n", irq_status);\n\t\tpr_debug("DEBUG_SP: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x40));\n\t\tpr_debug("DEBUG_T: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x44));\n\t\tpr_debug("DEBUG_N: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x48));\n\t\tpr_debug("DEBUG_R: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x4C));\n\t\tpr_debug("DEBUG_OPPC: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x50));\n\t\tpr_debug("DEBUG_MO: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x54));\n\t\tpr_debug("DEBUG_TIMER0: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x60));\n\t\tpr_debug("DEBUG_TIMER1: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x64));\n\t\tpr_debug("DEBUG_GPI: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x70));\n\t\tpr_debug("DEBUG_GPO: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x74));\n\t\tpr_debug("DEBUG_T0: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x80));\n\t\tpr_debug("DEBUG_R0: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x84));\n\t\tpr_debug("DEBUG_T1: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x88));\n\t\tpr_debug("DEBUG_R1: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x8C));\n\t}\nerr:\n\tmsm_camera_io_w(irq_status, cpp_dev->base + MSM_CPP_MICRO_IRQGEN_CLR);\n\treturn IRQ_HANDLED;\n}'
p5556
(dp5557
((g5546
g5553
tp5558
I1
tp5559
(dp5560
g12
g13
sg14
(dp5561
(I16
I23
tp5562
(lp5563
S'\t\tif (tx_level < MSM_CPP_TX_FIFO_LEVEL) {'
p5564
aS'\t\t\tfor (i = 0; i < tx_level; i++) {'
p5565
aS'\t\t\t\ttx_fifo[i] = msm_camera_io_r(cpp_dev->base +'
p5566
aS'\t\t\t\t\tMSM_CPP_MICRO_FIFO_TX_DATA);'
p5567
aS'\t\t\t}'
p5568
aS'\t\t} else {'
p5569
aS'\t\t\tpr_err("Fatal invalid tx level %d", tx_level);'
p5570
aS'\t\t\tgoto err;'
p5571
as(I78
I78
tp5572
(lp5573
S'err:'
p5574
assg32
I2
sg33
(dp5575
(I16
I18
tp5576
(lp5577
S'\t\tfor (i = 0; i < tx_level; i++) {'
p5578
aS'\t\t\ttx_fifo[i] = msm_camera_io_r(cpp_dev->base +'
p5579
aS'\t\t\t\tMSM_CPP_MICRO_FIFO_TX_DATA);'
p5580
assg41
(I1
I81
tp5581
sssssS'CVE-2018-11987'
p5582
(dp5583
(S'drivers/staging/android/ion/ion_system_heap.c'
p5584
S'ion_system_heap_destroy_pools'
p5585
tp5586
(dp5587
S'static void ion_system_heap_destroy_pools(struct ion_page_pool **pools)\n{\n\tint i;\n\tfor (i = 0; i < num_orders; i++)\n\t\tif (pools[i]) {\n\t\t\tion_page_pool_destroy(pools[i]);\n\t\t\tpools[i] = NULL;\n\t\t}\n}'
p5588
(dp5589
((g5584
g5585
tp5590
I1
tp5591
(dp5592
g12
g13
sg14
(dp5593
(I7
I8
tp5594
(lp5595
S'\t\t\tpools[i] = NULL;'
p5596
aS'\t\t}'
p5597
as(I5
I5
tp5598
(lp5599
S'\t\tif (pools[i]) {'
p5600
assg32
I1
sg33
(dp5601
(I5
I5
tp5602
(lp5603
S'\t\tif (pools[i])'
p5604
assg41
(I1
I9
tp5605
sssssS'CVE-2018-11984'
p5606
(dp5607
(S'drivers/char/diag/diag_masks.c'
p5608
S'diag_send_log_mask_update'
p5609
tp5610
(dp5611
S'static void diag_send_log_mask_update(uint8_t peripheral, int equip_id)\n{\n\tint err = 0, send_once = 0, i;\n\tint header_len = sizeof(struct diag_ctrl_log_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_ctrl_log_mask ctrl_pkt;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->log_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->log_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &log_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr)\n\t\treturn;\n\tbuf = mask_info->update_buf;\n\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tsend_once = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid log_mask status\\n", __func__);\n\t\treturn;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\n\t\tif (equip_id != i && equip_id != ALL_EQUIP_ID)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&mask->lock);\n\t\tctrl_pkt.cmd_type = DIAG_CTRL_MSG_LOG_MASK;\n\t\tctrl_pkt.stream_id = 1;\n\t\tctrl_pkt.status = mask_info->status;\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\t\tctrl_pkt.equip_id = i;\n\t\t\tctrl_pkt.num_items = mask->num_items_tools;\n\t\t\tctrl_pkt.log_mask_size = mask_size;\n\t\t}\n\t\tctrl_pkt.data_len = LOG_MASK_CTRL_HEADER_LEN + mask_size;\n\n\t\tif (header_len + mask_size > mask_info->update_buf_len) {\n\t\t\ttemp = krealloc(buf, header_len + mask_size,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: Unable to realloc log update buffer, new size: %d, equip_id: %d\\n",\n\t\t\t\t       header_len + mask_size, equip_id);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask_info->update_buf = temp;\n\t\t\tmask_info->update_buf_len = header_len + mask_size;\n\t\t\tbuf = temp;\n\t\t}\n\n\t\tmemcpy(buf, &ctrl_pkt, header_len);\n\t\tif (mask_size > 0 && mask_size <= LOG_MASK_SIZE)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending ctrl pkt to %d, e %d num_items %d size %d\\n",\n\t\t\t peripheral, i, ctrl_pkt.num_items,\n\t\t\t ctrl_pkt.log_mask_size);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL,\n\t\t\t\t    buf, header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send log masks to peripheral %d, equip_id: %d, err: %d\\n",\n\t\t\t       peripheral, i, err);\n\t\tif (send_once || equip_id != ALL_EQUIP_ID)\n\t\t\tbreak;\n\n\t}\n\tmutex_unlock(&mask_info->lock);\n}'
p5612
(dp5613
((g5608
g5609
tp5614
I1
tp5615
(dp5616
g33
(dp5617
(I108
I108
tp5618
(lp5619
S'\t\tif (mask_size > 0)'
p5620
assg14
(dp5621
(I108
I108
tp5622
(lp5623
S'\t\tif (mask_size > 0 && mask_size <= LOG_MASK_SIZE)'
p5624
as(I104
I104
tp5625
(lp5626
S'\t\t\tbuf = temp;'
p5627
as(I75
I77
tp5628
(lp5629
S'\t\tif (!mask->ptr)'
p5630
aS'\t\t\tcontinue;'
p5631
ag59
assg32
I2
sg12
g13
sg41
(I1
I127
tp5632
sssS'static void diag_send_log_mask_update(uint8_t peripheral, int equip_id)\n{\n\tint err = 0, send_once = 0, i;\n\tint header_len = sizeof(struct diag_ctrl_log_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_ctrl_log_mask ctrl_pkt;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->log_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->log_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &log_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr)\n\t\treturn;\n\tbuf = mask_info->update_buf;\n\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tsend_once = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid log_mask status\\n", __func__);\n\t\treturn;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (equip_id != i && equip_id != ALL_EQUIP_ID)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&mask->lock);\n\t\tctrl_pkt.cmd_type = DIAG_CTRL_MSG_LOG_MASK;\n\t\tctrl_pkt.stream_id = 1;\n\t\tctrl_pkt.status = mask_info->status;\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\t\tctrl_pkt.equip_id = i;\n\t\t\tctrl_pkt.num_items = mask->num_items_tools;\n\t\t\tctrl_pkt.log_mask_size = mask_size;\n\t\t}\n\t\tctrl_pkt.data_len = LOG_MASK_CTRL_HEADER_LEN + mask_size;\n\n\t\tif (header_len + mask_size > mask_info->update_buf_len) {\n\t\t\ttemp = krealloc(buf, header_len + mask_size,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: Unable to realloc log update buffer, new size: %d, equip_id: %d\\n",\n\t\t\t\t       header_len + mask_size, equip_id);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask_info->update_buf = temp;\n\t\t\tmask_info->update_buf_len = header_len + mask_size;\n\t\t\tbuf = temp;\n\t\t}\n\n\t\tmemcpy(buf, &ctrl_pkt, header_len);\n\t\tif (mask_size > 0 && mask_size <= LOG_MASK_SIZE)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending ctrl pkt to %d, e %d num_items %d size %d\\n",\n\t\t\t peripheral, i, ctrl_pkt.num_items,\n\t\t\t ctrl_pkt.log_mask_size);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL,\n\t\t\t\t    buf, header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send log masks to peripheral %d, equip_id: %d, err: %d\\n",\n\t\t\t       peripheral, i, err);\n\t\tif (send_once || equip_id != ALL_EQUIP_ID)\n\t\t\tbreak;\n\n\t}\n\tmutex_unlock(&mask_info->lock);\n}'
p5633
(dp5634
((g5608
g5609
tp5635
I1
tp5636
(dp5637
g33
(dp5638
(I105
I105
tp5639
(lp5640
S'\t\tif (mask_size > 0)'
p5641
assg14
(dp5642
(I101
I101
tp5643
(lp5644
S'\t\t\tbuf = temp;'
p5645
as(I105
I105
tp5646
(lp5647
S'\t\tif (mask_size > 0 && mask_size <= LOG_MASK_SIZE)'
p5648
assg32
I2
sg12
g13
sg41
(I1
I124
tp5649
ssss(g5608
S'diag_send_msg_mask_update'
p5650
tp5651
(dp5652
S'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tstruct diag_md_session_t *md_session_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t\t\tmd_session_info =\n\t\t\t\t\tdriver->md_session_map[peripheral];\n\t\t\t}\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t\t\tmd_session_info = driver->md_session_map[upd];\n\t\t\t}\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tif (md_session_info)\n\t\tmsg_mask_tbl_count_local = md_session_info->msg_mask_tbl_count;\n\telse\n\t\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p5653
(dp5654
((g5608
g5650
tp5655
I1
tp5656
(dp5657
g12
g13
sg14
(dp5658
(I13
I13
tp5659
(lp5660
S'\tstruct diag_md_session_t *md_session_info = NULL;'
p5661
as(I40
I41
tp5662
(lp5663
S'\t\t\t\tmd_session_info = driver->md_session_map[upd];'
p5664
aS'\t\t\t}'
p5665
as(I60
I63
tp5666
(lp5667
S'\tif (md_session_info)'
p5668
aS'\t\tmsg_mask_tbl_count_local = md_session_info->msg_mask_tbl_count;'
p5669
aS'\telse'
p5670
aS'\t\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;'
p5671
as(I82
I83
tp5672
(lp5673
S'\t\tif (!mask->ptr)'
p5674
aS'\t\t\tcontinue;'
p5675
as(I37
I37
tp5676
(lp5677
S'\t\t\tif (upd && driver->md_session_map[upd]) {'
p5678
as(I7
I7
tp5679
(lp5680
S'\tuint8_t msg_mask_tbl_count_local = 0;'
p5681
as(I108
I108
tp5682
(lp5683
S'\t\t\t\tbuf = temp;'
p5684
as(I32
I34
tp5685
(lp5686
S'\t\t\t\tmd_session_info ='
p5687
aS'\t\t\t\t\tdriver->md_session_map[peripheral];'
p5688
aS'\t\t\t}'
p5689
as(I29
I29
tp5690
(lp5691
S'\t\t\tif (driver->md_session_map[peripheral]) {'
p5692
assg32
I3
sg33
(dp5693
(I60
I60
tp5694
(lp5695
S'\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;'
p5696
as(I37
I37
tp5697
(lp5698
S'\t\t\tif (upd && driver->md_session_map[upd])'
p5699
as(I7
I7
tp5700
(lp5701
S'\tuint8_t msg_mask_tbl_count_local;'
p5702
as(I29
I29
tp5703
(lp5704
S'\t\t\tif (driver->md_session_map[peripheral])'
p5705
assg41
(I1
I142
tp5706
sssS'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p5707
(dp5708
((g5608
g5650
tp5709
I1
tp5710
(dp5711
g14
(dp5712
(I97
I97
tp5713
(lp5714
S'\t\t\t\tbuf = temp;'
p5715
assg32
I3
sg12
g13
sg41
(I1
I131
tp5716
sssS'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p5717
(dp5718
((g5608
g5650
tp5719
I1
tp5720
(dp5721
g14
(dp5722
(I73
I74
tp5723
(lp5724
S'\t\tif (!mask->ptr)'
p5725
aS'\t\t\tcontinue;'
p5726
as(I99
I99
tp5727
(lp5728
S'\t\t\t\tbuf = temp;'
p5729
assg32
I3
sg12
g13
sg41
(I1
I133
tp5730
ssss(g5608
S'diag_send_event_mask_update'
p5731
tp5732
(dp5733
S'static void diag_send_event_mask_update(uint8_t peripheral)\n{\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint32_t pd_mask = 0;\n\tint num_bytes = EVENT_COUNT_TO_BYTES(driver->last_event_id);\n\tint write_len = 0, err = 0, i = 0, temp_len = 0;\n\tstruct diag_ctrl_event_mask header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (num_bytes <= 0 || num_bytes > driver->event_mask_size) {\n\t\tpr_debug("diag: In %s, invalid event mask length %d\\n",\n\t\t\t __func__, num_bytes);\n\t\treturn;\n\t}\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->event_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->event_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &event_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\n\tbuf = mask_info->update_buf;\n\tmutex_lock(&mask_info->lock);\n\theader.cmd_type = DIAG_CTRL_MSG_EVENT_MASK;\n\theader.stream_id = 1;\n\theader.status = mask_info->status;\n\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\theader.event_config = 0;\n\t\theader.event_mask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\theader.event_config = 1;\n\t\theader.event_mask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\theader.event_config = 1;\n\t\theader.event_mask_size = num_bytes;\n\t\tif (num_bytes + sizeof(header) > mask_info->update_buf_len) {\n\t\t\ttemp_len = num_bytes + sizeof(header);\n\t\t\ttemp = krealloc(buf, temp_len, GFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: Unable to realloc event mask update buffer\\n");\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t}\n\t\t}\n\t\tif (num_bytes > 0 && num_bytes < mask_info->mask_len)\n\t\t\tmemcpy(buf + sizeof(header), mask_info->ptr, num_bytes);\n\t\telse {\n\t\t\tpr_err("diag: num_bytes(%d) is not satisfying length condition\\n",\n\t\t\t\tnum_bytes);\n\t\t\tgoto err;\n\t\t}\n\t\twrite_len += num_bytes;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\theader.data_len = EVENT_MASK_CTRL_HEADER_LEN + header.event_mask_size;\n\tmemcpy(buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\terr = diagfwd_write(peripheral, TYPE_CNTL, buf, write_len);\n\tif (err && err != -ENODEV)\n\t\tpr_err_ratelimited("diag: Unable to send event masks to peripheral %d\\n",\n\t\t       peripheral);\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p5734
(dp5735
((g5608
g5731
tp5736
I1
tp5737
(dp5738
g33
(dp5739
(I82
I82
tp5740
(lp5741
S'\t\tmemcpy(buf + sizeof(header), mask_info->ptr, num_bytes);'
p5742
assg14
(dp5743
(I82
I88
tp5744
(lp5745
S'\t\tif (num_bytes > 0 && num_bytes < mask_info->mask_len)'
p5746
aS'\t\t\tmemcpy(buf + sizeof(header), mask_info->ptr, num_bytes);'
p5747
aS'\t\telse {'
p5748
aS'\t\t\tpr_err("diag: num_bytes(%d) is not satisfying length condition\\n",'
p5749
aS'\t\t\t\tnum_bytes);'
p5750
aS'\t\t\tgoto err;'
p5751
aS'\t\t}'
p5752
as(I79
I79
tp5753
(lp5754
S'\t\t\t\tbuf = temp;'
p5755
assg32
I1
sg12
g13
sg41
(I1
I106
tp5756
sssssS'CVE-2019-15926'
p5757
(dp5758
(S'drivers/net/wireless/ath/ath6kl/wmi.c'
p5759
S'ath6kl_wmi_cac_event_rx'
p5760
tp5761
(dp5762
S'static int ath6kl_wmi_cac_event_rx(struct wmi *wmi, u8 *datap, int len,\n\t\t\t\t   struct ath6kl_vif *vif)\n{\n\tstruct wmi_cac_event *reply;\n\tstruct ieee80211_tspec_ie *ts;\n\tu16 active_tsids, tsinfo;\n\tu8 tsid, index;\n\tu8 ts_id;\n\n\tif (len < sizeof(struct wmi_cac_event))\n\t\treturn -EINVAL;\n\n\treply = (struct wmi_cac_event *) datap;\n\tif (reply->ac >= WMM_NUM_AC) {\n\t\tath6kl_err("invalid AC: %d\\n", reply->ac);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((reply->cac_indication == CAC_INDICATION_ADMISSION_RESP) &&\n\t    (reply->status_code != IEEE80211_TSPEC_STATUS_ADMISS_ACCEPTED)) {\n\t\tts = (struct ieee80211_tspec_ie *) &(reply->tspec_suggestion);\n\t\ttsinfo = le16_to_cpu(ts->tsinfo);\n\t\ttsid = (tsinfo >> IEEE80211_WMM_IE_TSPEC_TID_SHIFT) &\n\t\t\tIEEE80211_WMM_IE_TSPEC_TID_MASK;\n\n\t\tath6kl_wmi_delete_pstream_cmd(wmi, vif->fw_vif_idx,\n\t\t\t\t\t      reply->ac, tsid);\n\t} else if (reply->cac_indication == CAC_INDICATION_NO_RESP) {\n\t\t/*\n\t\t * Following assumes that there is only one outstanding\n\t\t * ADDTS request when this event is received\n\t\t */\n\t\tspin_lock_bh(&wmi->lock);\n\t\tactive_tsids = wmi->stream_exist_for_ac[reply->ac];\n\t\tspin_unlock_bh(&wmi->lock);\n\n\t\tfor (index = 0; index < sizeof(active_tsids) * 8; index++) {\n\t\t\tif ((active_tsids >> index) & 1)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (index < (sizeof(active_tsids) * 8))\n\t\t\tath6kl_wmi_delete_pstream_cmd(wmi, vif->fw_vif_idx,\n\t\t\t\t\t\t      reply->ac, index);\n\t}\n\n\t/*\n\t * Clear active tsids and Add missing handling\n\t * for delete qos stream from AP\n\t */\n\telse if (reply->cac_indication == CAC_INDICATION_DELETE) {\n\t\tts = (struct ieee80211_tspec_ie *) &(reply->tspec_suggestion);\n\t\ttsinfo = le16_to_cpu(ts->tsinfo);\n\t\tts_id = ((tsinfo >> IEEE80211_WMM_IE_TSPEC_TID_SHIFT) &\n\t\t\t IEEE80211_WMM_IE_TSPEC_TID_MASK);\n\n\t\tspin_lock_bh(&wmi->lock);\n\t\twmi->stream_exist_for_ac[reply->ac] &= ~(1 << ts_id);\n\t\tactive_tsids = wmi->stream_exist_for_ac[reply->ac];\n\t\tspin_unlock_bh(&wmi->lock);\n\n\t\t/* Indicate stream inactivity to driver layer only if all tsids\n\t\t * within this AC are deleted.\n\t\t */\n\t\tif (!active_tsids) {\n\t\t\tath6kl_indicate_tx_activity(wmi->parent_dev, reply->ac,\n\t\t\t\t\t\t    false);\n\t\t\twmi->fat_pipe_exist &= ~(1 << reply->ac);\n\t\t}\n\t}\n\n\treturn 0;\n}'
p5763
(dp5764
((g5759
g5760
tp5765
I1
tp5766
(dp5767
g14
(dp5768
(I14
I17
tp5769
(lp5770
S'\tif (reply->ac >= WMM_NUM_AC) {'
p5771
aS'\t\tath6kl_err("invalid AC: %d\\n", reply->ac);'
p5772
aS'\t\treturn -EINVAL;'
p5773
aS'\t}'
p5774
assg32
I4
sg12
g13
sg41
(I1
I72
tp5775
ssss(g5759
S'ath6kl_wmi_pstream_timeout_event_rx'
p5776
tp5777
(dp5778
S'static int ath6kl_wmi_pstream_timeout_event_rx(struct wmi *wmi, u8 *datap,\n\t\t\t\t\t       int len)\n{\n\tstruct wmi_pstream_timeout_event *ev;\n\n\tif (len < sizeof(struct wmi_pstream_timeout_event))\n\t\treturn -EINVAL;\n\n\tev = (struct wmi_pstream_timeout_event *) datap;\n\tif (ev->traffic_class >= WMM_NUM_AC) {\n\t\tath6kl_err("invalid traffic class: %d\\n", ev->traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * When the pstream (fat pipe == AC) timesout, it means there were\n\t * no thinStreams within this pstream & it got implicitly created\n\t * due to data flow on this AC. We start the inactivity timer only\n\t * for implicitly created pstream. Just reset the host state.\n\t */\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[ev->traffic_class] = 0;\n\twmi->fat_pipe_exist &= ~(1 << ev->traffic_class);\n\tspin_unlock_bh(&wmi->lock);\n\n\t/* Indicate inactivity to driver layer for this fatpipe (pstream) */\n\tath6kl_indicate_tx_activity(wmi->parent_dev, ev->traffic_class, false);\n\n\treturn 0;\n}'
p5779
(dp5780
((g5759
g5776
tp5781
I1
tp5782
(dp5783
g14
(dp5784
(I10
I13
tp5785
(lp5786
S'\tif (ev->traffic_class >= WMM_NUM_AC) {'
p5787
aS'\t\tath6kl_err("invalid traffic class: %d\\n", ev->traffic_class);'
p5788
aS'\t\treturn -EINVAL;'
p5789
aS'\t}'
p5790
assg32
I3
sg12
g13
sg41
(I1
I30
tp5791
ssss(g5759
S'ath6kl_wmi_delete_pstream_cmd'
p5792
tp5793
(dp5794
S'int ath6kl_wmi_delete_pstream_cmd(struct wmi *wmi, u8 if_idx, u8 traffic_class,\n\t\t\t\t  u8 tsid)\n{\n\tstruct sk_buff *skb;\n\tstruct wmi_delete_pstream_cmd *cmd;\n\tu16 active_tsids = 0;\n\tint ret;\n\n\tif (traffic_class >= WMM_NUM_AC) {\n\t\tath6kl_err("invalid traffic class: %d\\n", traffic_class);\n\t\treturn -EINVAL;\n\t}\n\n\tskb = ath6kl_wmi_get_new_buf(sizeof(*cmd));\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tcmd = (struct wmi_delete_pstream_cmd *) skb->data;\n\tcmd->traffic_class = traffic_class;\n\tcmd->tsid = tsid;\n\n\tspin_lock_bh(&wmi->lock);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\tif (!(active_tsids & (1 << tsid))) {\n\t\tdev_kfree_skb(skb);\n\t\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t\t   "TSID %d doesn\'t exist for traffic class: %d\\n",\n\t\t\t   tsid, traffic_class);\n\t\treturn -ENODATA;\n\t}\n\n\tath6kl_dbg(ATH6KL_DBG_WMI,\n\t\t   "sending delete_pstream_cmd: traffic class: %d tsid=%d\\n",\n\t\t   traffic_class, tsid);\n\n\tret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, WMI_DELETE_PSTREAM_CMDID,\n\t\t\t\t  SYNC_BEFORE_WMIFLAG);\n\n\tspin_lock_bh(&wmi->lock);\n\twmi->stream_exist_for_ac[traffic_class] &= ~(1 << tsid);\n\tactive_tsids = wmi->stream_exist_for_ac[traffic_class];\n\tspin_unlock_bh(&wmi->lock);\n\n\t/*\n\t * Indicate stream inactivity to driver layer only if all tsids\n\t * within this AC are deleted.\n\t */\n\tif (!active_tsids) {\n\t\tath6kl_indicate_tx_activity(wmi->parent_dev,\n\t\t\t\t\t    traffic_class, false);\n\t\twmi->fat_pipe_exist &= ~(1 << traffic_class);\n\t}\n\n\treturn ret;\n}'
p5795
(dp5796
((g5759
g5792
tp5797
I1
tp5798
(dp5799
g12
g13
sg14
(dp5800
(I9
I9
tp5801
(lp5802
S'\tif (traffic_class >= WMM_NUM_AC) {'
p5803
assg32
I4
sg33
(dp5804
(I9
I9
tp5805
(lp5806
S'\tif (traffic_class > 3) {'
p5807
assg41
(I1
I57
tp5808
sssssS'CVE-2019-10571'
p5809
(dp5810
(S'drivers/gpu/msm/adreno_snapshot.c'
p5811
S'kgsl_snapshot_push_object'
p5812
tp5813
(dp5814
S'void kgsl_snapshot_push_object(struct kgsl_process_private *process,\n\tuint64_t gpuaddr, uint64_t dwords)\n{\n\tint index;\n\tstruct kgsl_mem_entry *entry;\n\n\tif (process == NULL)\n\t\treturn;\n\n\t/*\n\t * Sometimes IBs can be reused in the same dump.  Because we parse from\n\t * oldest to newest, if we come across an IB that has already been used,\n\t * assume that it has been reused and update the list with the newest\n\t * size.\n\t */\n\n\tfor (index = 0; index < objbufptr; index++) {\n\t\tif (objbuf[index].gpuaddr == gpuaddr &&\n\t\t\tobjbuf[index].entry->priv == process) {\n\t\t\t/*\n\t\t\t * Check if newly requested size is within the\n\t\t\t * allocated range or not, otherwise continue\n\t\t\t * with previous size.\n\t\t\t */\n\t\t\tif (!kgsl_gpuaddr_in_memdesc(\n\t\t\t\t&objbuf[index].entry->memdesc,\n\t\t\t\tgpuaddr, dwords << 2)) {\n\t\t\t\tKGSL_CORE_ERR(\n\t\t\t\t\t"snapshot: IB 0x%016llx size is not within the memdesc range\\n",\n\t\t\t\t\tgpuaddr);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tobjbuf[index].size = max_t(uint64_t,\n\t\t\t\t\t\tobjbuf[index].size,\n\t\t\t\t\t\tdwords << 2);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (objbufptr == SNAPSHOT_OBJ_BUFSIZE) {\n\t\tKGSL_CORE_ERR("snapshot: too many snapshot objects\\n");\n\t\treturn;\n\t}\n\n\tentry = kgsl_sharedmem_find(process, gpuaddr);\n\tif (entry == NULL) {\n\t\tKGSL_CORE_ERR("snapshot: Can\'t find entry for 0x%016llX\\n",\n\t\t\tgpuaddr);\n\t\treturn;\n\t}\n\n\tif (!kgsl_gpuaddr_in_memdesc(&entry->memdesc, gpuaddr, dwords << 2)) {\n\t\tKGSL_CORE_ERR("snapshot: Mem entry 0x%016llX is too small\\n",\n\t\t\tgpuaddr);\n\t\tkgsl_mem_entry_put(entry);\n\t\treturn;\n\t}\n\n\t/* Put it on the list of things to parse */\n\tobjbuf[objbufptr].gpuaddr = gpuaddr;\n\tobjbuf[objbufptr].size = dwords << 2;\n\tobjbuf[objbufptr++].entry = entry;\n}'
p5815
(dp5816
((g5811
g5812
tp5817
I1
tp5818
(dp5819
g14
(dp5820
(I20
I32
tp5821
(lp5822
S'\t\t\t/*'
p5823
aS'\t\t\t * Check if newly requested size is within the'
p5824
aS'\t\t\t * allocated range or not, otherwise continue'
p5825
aS'\t\t\t * with previous size.'
p5826
aS'\t\t\t */'
p5827
aS'\t\t\tif (!kgsl_gpuaddr_in_memdesc('
p5828
aS'\t\t\t\t&objbuf[index].entry->memdesc,'
p5829
aS'\t\t\t\tgpuaddr, dwords << 2)) {'
p5830
aS'\t\t\t\tKGSL_CORE_ERR('
p5831
aS'\t\t\t\t\t"snapshot: IB 0x%016llx size is not within the memdesc range\\n",'
p5832
aS'\t\t\t\t\tgpuaddr);'
p5833
aS'\t\t\t\treturn;'
p5834
aS'\t\t\t}'
p5835
assg32
I3
sg12
g13
sg41
(I1
I64
tp5836
sssssS'CVE-2019-14821'
p5837
(dp5838
(S'virt/kvm/coalesced_mmio.c'
p5839
S'coalesced_mmio_write'
p5840
tp5841
(dp5842
S'static int coalesced_mmio_write(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_io_device *this, gpa_t addr,\n\t\t\t\tint len, const void *val)\n{\n\tstruct kvm_coalesced_mmio_dev *dev = to_mmio(this);\n\tstruct kvm_coalesced_mmio_ring *ring = dev->kvm->coalesced_mmio_ring;\n\t__u32 insert;\n\n\tif (!coalesced_mmio_in_range(dev, addr, len))\n\t\treturn -EOPNOTSUPP;\n\n\tspin_lock(&dev->kvm->ring_lock);\n\n\tinsert = READ_ONCE(ring->last);\n\tif (!coalesced_mmio_has_room(dev, insert) ||\n\t    insert >= KVM_COALESCED_MMIO_MAX) {\n\t\tspin_unlock(&dev->kvm->ring_lock);\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\t/* copy data in first free entry of the ring */\n\n\tring->coalesced_mmio[insert].phys_addr = addr;\n\tring->coalesced_mmio[insert].len = len;\n\tmemcpy(ring->coalesced_mmio[insert].data, val, len);\n\tsmp_wmb();\n\tring->last = (insert + 1) % KVM_COALESCED_MMIO_MAX;\n\tspin_unlock(&dev->kvm->ring_lock);\n\treturn 0;\n}'
p5843
(dp5844
((g5839
g5840
tp5845
I1
tp5846
(dp5847
g33
(dp5848
(I23
I25
tp5849
(lp5850
S'\tring->coalesced_mmio[ring->last].phys_addr = addr;'
p5851
aS'\tring->coalesced_mmio[ring->last].len = len;'
p5852
aS'\tmemcpy(ring->coalesced_mmio[ring->last].data, val, len);'
p5853
as(I27
I27
tp5854
(lp5855
S'\tring->last = (ring->last + 1) % KVM_COALESCED_MMIO_MAX;'
p5856
as(I14
I14
tp5857
(lp5858
S'\tif (!coalesced_mmio_has_room(dev)) {'
p5859
assg14
(dp5860
(I27
I27
tp5861
(lp5862
S'\tring->last = (insert + 1) % KVM_COALESCED_MMIO_MAX;'
p5863
as(I23
I25
tp5864
(lp5865
S'\tring->coalesced_mmio[insert].phys_addr = addr;'
p5866
aS'\tring->coalesced_mmio[insert].len = len;'
p5867
aS'\tmemcpy(ring->coalesced_mmio[insert].data, val, len);'
p5868
as(I7
I7
tp5869
(lp5870
S'\t__u32 insert;'
p5871
as(I14
I16
tp5872
(lp5873
S'\tinsert = READ_ONCE(ring->last);'
p5874
aS'\tif (!coalesced_mmio_has_room(dev, insert) ||'
p5875
aS'\t    insert >= KVM_COALESCED_MMIO_MAX) {'
p5876
assg32
I5
sg12
g13
sg41
(I1
I30
tp5877
ssss(g5839
S'coalesced_mmio_has_room'
p5878
tp5879
(dp5880
S"static int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev, u32 last)\n{\n\tstruct kvm_coalesced_mmio_ring *ring;\n\tunsigned avail;\n\n\t/* Are we able to batch it ? */\n\n\t/* last is the first free entry\n\t * check if we don't meet the first used entry\n\t * there is always one unused entry in the buffer\n\t */\n\tring = dev->kvm->coalesced_mmio_ring;\n\tavail = (ring->first - last - 1) % KVM_COALESCED_MMIO_MAX;\n\tif (avail == 0) {\n\t\t/* full */\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
p5881
(dp5882
((g5839
g5878
tp5883
I1
tp5884
(dp5885
g12
g13
sg14
(dp5886
(I1
I1
tp5887
(lp5888
S'static int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev, u32 last)'
p5889
as(I13
I13
tp5890
(lp5891
S'\tavail = (ring->first - last - 1) % KVM_COALESCED_MMIO_MAX;'
p5892
assg32
I2
sg33
(dp5893
(I1
I1
tp5894
(lp5895
S'static int coalesced_mmio_has_room(struct kvm_coalesced_mmio_dev *dev)'
p5896
as(I13
I13
tp5897
(lp5898
S'\tavail = (ring->first - ring->last - 1) % KVM_COALESCED_MMIO_MAX;'
p5899
assg41
(I1
I20
tp5900
sssssS'CVE-2019-10572'
p5901
(dp5902
(S'drivers/media/platform/msm/vidc/hfi_response_handler.c'
p5903
S'hfi_parse_init_done_properties'
p5904
tp5905
(dp5906
S'static enum vidc_status hfi_parse_init_done_properties(\n\t\tstruct msm_vidc_capability *capabilities,\n\t\tu32 num_sessions, u8 *data_ptr, u32 num_properties,\n\t\tu32 rem_bytes)\n{\n\tenum vidc_status status = VIDC_ERR_NONE;\n\tu32 prop_id, next_offset;\n\tu32 codecs = 0, domain = 0;\n\n#define VALIDATE_PROPERTY_STRUCTURE_SIZE(pkt_size, property_size) ({\\\n\t\tif (pkt_size < property_size) { \\\n\t\t\tstatus = VIDC_ERR_BAD_PARAM; \\\n\t\t\tbreak; \\\n\t\t} \\\n})\n\n#define VALIDATE_PROPERTY_PAYLOAD_SIZE(pkt_size, payload_size, \\\n\t\tproperty_count) ({\\\n\t\tif (pkt_size/payload_size < property_count) { \\\n\t\t\tstatus = VIDC_ERR_BAD_PARAM; \\\n\t\t\tbreak; \\\n\t\t} \\\n})\n\n\twhile (status == VIDC_ERR_NONE && num_properties &&\n\t\t\trem_bytes >= sizeof(u32)) {\n\n\t\tprop_id = *((u32 *)data_ptr);\n\t\tnext_offset = sizeof(u32);\n\n\t\tswitch (prop_id) {\n\t\tcase HFI_PROPERTY_PARAM_CODEC_MASK_SUPPORTED:\n\t\t{\n\t\t\tstruct hfi_codec_mask_supported *prop =\n\t\t\t\t(struct hfi_codec_mask_supported *)\n\t\t\t\t(data_ptr + next_offset);\n\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(*prop));\n\n\t\t\tcodecs = prop->codecs;\n\t\t\tdomain = prop->video_domains;\n\t\t\tnext_offset += sizeof(struct hfi_codec_mask_supported);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_CAPABILITY_SUPPORTED:\n\t\t{\n\t\t\tstruct hfi_capability_supported_info *prop =\n\t\t\t\t(struct hfi_capability_supported_info *)\n\t\t\t\t(data_ptr + next_offset);\n\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(*prop));\n\t\t\tVALIDATE_PROPERTY_PAYLOAD_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset - sizeof(u32),\n\t\t\t\t\tsizeof(struct hfi_capability_supported),\n\t\t\t\t\tprop->num_capabilities);\n\n\t\t\tnext_offset += sizeof(u32) +\n\t\t\t\tprop->num_capabilities *\n\t\t\t\tsizeof(struct hfi_capability_supported);\n\n\t\t\tcopy_caps_to_sessions(&prop->rg_data[0],\n\t\t\t\t\tprop->num_capabilities,\n\t\t\t\t\tcapabilities, num_sessions,\n\t\t\t\t\tcodecs, domain);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_UNCOMPRESSED_FORMAT_SUPPORTED:\n\t\t{\n\t\t\tstruct hfi_uncompressed_format_supported *prop =\n\t\t\t\t(struct hfi_uncompressed_format_supported *)\n\t\t\t\t(data_ptr + next_offset);\n\t\t\tu32 num_format_entries;\n\t\t\tchar *fmt_ptr;\n\t\t\tstruct hfi_uncompressed_plane_info *plane_info;\n\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(*prop));\n\n\t\t\tnum_format_entries = prop->format_entries;\n\t\t\tnext_offset = sizeof(*prop);\n\t\t\tfmt_ptr = (char *)&prop->rg_format_info[0];\n\n\t\t\twhile (num_format_entries) {\n\t\t\t\tu32 bytes_to_skip;\n\n\t\t\t\tplane_info =\n\t\t\t\t(struct hfi_uncompressed_plane_info *) fmt_ptr;\n\n\t\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\t\tnext_offset,\n\t\t\t\t\t\tsizeof(*plane_info));\n\n\t\t\t\tbytes_to_skip = sizeof(*plane_info) -\n\t\t\t\t\tsizeof(struct\n\t\t\t\t\thfi_uncompressed_plane_constraints) +\n\t\t\t\t\tplane_info->num_planes *\n\t\t\t\t\tsizeof(struct\n\t\t\t\t\thfi_uncompressed_plane_constraints);\n\n\t\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\t\tnext_offset,\n\t\t\t\t\t\tbytes_to_skip);\n\n\t\t\t\tfmt_ptr += bytes_to_skip;\n\t\t\t\tnext_offset += bytes_to_skip;\n\t\t\t\tnum_format_entries--;\n\t\t\t}\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_PROPERTIES_SUPPORTED:\n\t\t{\n\t\t\tstruct hfi_properties_supported *prop =\n\t\t\t\t(struct hfi_properties_supported *)\n\t\t\t\t(data_ptr + next_offset);\n\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(*prop));\n\t\t\tVALIDATE_PROPERTY_PAYLOAD_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset - sizeof(*prop) +\n\t\t\t\t\tsizeof(u32), sizeof(u32),\n\t\t\t\t\tprop->num_properties);\n\n\t\t\tnext_offset += sizeof(*prop) - sizeof(u32)\n\t\t\t\t+ prop->num_properties * sizeof(u32);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_SUPPORTED:\n\t\t{\n\t\t\tstruct hfi_profile_level_supported *prop =\n\t\t\t\t(struct hfi_profile_level_supported *)\n\t\t\t\t(data_ptr + next_offset);\n\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(*prop));\n\t\t\tVALIDATE_PROPERTY_PAYLOAD_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset -\n\t\t\t\t\tsizeof(u32),\n\t\t\t\t\tsizeof(struct hfi_profile_level),\n\t\t\t\t\tprop->profile_count);\n\n\t\t\tnext_offset += sizeof(u32) +\n\t\t\t\tprop->profile_count *\n\t\t\t\tsizeof(struct hfi_profile_level);\n\n\t\t\tif (prop->profile_count > MAX_PROFILE_COUNT) {\n\t\t\t\tprop->profile_count = MAX_PROFILE_COUNT;\n\t\t\t\tdprintk(VIDC_WARN,\n\t\t\t\t\t"prop count exceeds max profile count\\n");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tcopy_profile_caps_to_sessions(\n\t\t\t\t\t&prop->rg_profile_level[0],\n\t\t\t\t\tprop->profile_count, capabilities,\n\t\t\t\t\tnum_sessions, codecs, domain);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SUPPORTED:\n\t\t{\n\t\t\tstruct hfi_nal_stream_format_supported *prop =\n\t\t\t\t(struct hfi_nal_stream_format_supported *)\n\t\t\t\t\t(data_ptr + next_offset);\n\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(*prop));\n\n\t\t\tcopy_nal_stream_format_caps_to_sessions(\n\t\t\t\t\tprop->nal_stream_format_supported,\n\t\t\t\t\tcapabilities, num_sessions,\n\t\t\t\t\tcodecs, domain);\n\n\t\t\tnext_offset +=\n\t\t\t\tsizeof(struct hfi_nal_stream_format_supported);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_NAL_STREAM_FORMAT_SELECT:\n\t\t{\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(u32));\n\t\t\tnext_offset += sizeof(u32);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_PARAM_VENC_INTRA_REFRESH:\n\t\t{\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(struct hfi_intra_refresh));\n\t\t\tnext_offset +=\n\t\t\t\tsizeof(struct hfi_intra_refresh);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tcase HFI_PROPERTY_TME_VERSION_SUPPORTED:\n\t\t{\n\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -\n\t\t\t\t\tnext_offset,\n\t\t\t\t\tsizeof(u32));\n\t\t\tcapabilities->tme_version =\n\t\t\t\t*((u32 *)(data_ptr + next_offset));\n\t\t\tnext_offset +=\n\t\t\t\tsizeof(u32);\n\t\t\tnum_properties--;\n\t\t\tbreak;\n\t\t}\n\t\tdefault:\n\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t"%s: default case - data_ptr %pK, prop_id 0x%x\\n",\n\t\t\t\t__func__, data_ptr, prop_id);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (rem_bytes > next_offset) {\n\t\t\trem_bytes -= next_offset;\n\t\t\tdata_ptr += next_offset;\n\t\t} else {\n\t\t\trem_bytes = 0;\n\t\t}\n\t}\n\n\treturn status;\n}'
p5907
(dp5908
((g5903
g5904
tp5909
I1
tp5910
(dp5911
g33
(dp5912
(I82
I85
tp5913
(lp5914
S'\t\t\tif ((rem_bytes - next_offset) < sizeof(*prop)) {'
p5915
aS'\t\t\t\tstatus = VIDC_ERR_BAD_PARAM;'
p5916
aS'\t\t\t\tbreak;'
p5917
aS'\t\t\t}'
p5918
as(I54
I58
tp5919
(lp5920
S'\t\t\tif ((rem_bytes - next_offset) < prop->num_capabilities *'
p5921
aS'\t\t\t\tsizeof(struct hfi_capability_supported)) {'
p5922
aS'\t\t\t\tstatus = VIDC_ERR_BAD_PARAM;'
p5923
aS'\t\t\t\tbreak;'
p5924
aS'\t\t\t}'
p5925
as(I227
I228
tp5926
(lp5927
S'\t\trem_bytes -= next_offset;'
p5928
aS'\t\tdata_ptr += next_offset;'
p5929
as(I96
I100
tp5930
(lp5931
S'\t\t\t\tif ((rem_bytes - next_offset) <'
p5932
aS'\t\t\t\t\t\tsizeof(*plane_info)) {'
p5933
aS'\t\t\t\t\tstatus = VIDC_ERR_BAD_PARAM;'
p5934
aS'\t\t\t\t\tbreak;'
p5935
aS'\t\t\t\t}'
p5936
assg14
(dp5937
(I82
I85
tp5938
(lp5939
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p5940
aS'\t\t\t\t\tnext_offset,'
p5941
aS'\t\t\t\t\tsizeof(*prop));'
p5942
ag59
as(I38
I41
tp5943
(lp5944
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p5945
aS'\t\t\t\t\tnext_offset,'
p5946
aS'\t\t\t\t\tsizeof(*prop));'
p5947
ag59
as(I54
I61
tp5948
(lp5949
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p5950
aS'\t\t\t\t\tnext_offset,'
p5951
aS'\t\t\t\t\tsizeof(*prop));'
p5952
aS'\t\t\tVALIDATE_PROPERTY_PAYLOAD_SIZE(rem_bytes -'
p5953
aS'\t\t\t\t\tnext_offset - sizeof(u32),'
p5954
aS'\t\t\t\t\tsizeof(struct hfi_capability_supported),'
p5955
aS'\t\t\t\t\tprop->num_capabilities);'
p5956
ag59
as(I176
I179
tp5957
(lp5958
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p5959
aS'\t\t\t\t\tnext_offset,'
p5960
aS'\t\t\t\t\tsizeof(*prop));'
p5961
ag59
as(I123
I131
tp5962
(lp5963
g59
aS'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p5964
aS'\t\t\t\t\tnext_offset,'
p5965
aS'\t\t\t\t\tsizeof(*prop));'
p5966
aS'\t\t\tVALIDATE_PROPERTY_PAYLOAD_SIZE(rem_bytes -'
p5967
aS'\t\t\t\t\tnext_offset - sizeof(*prop) +'
p5968
aS'\t\t\t\t\tsizeof(u32), sizeof(u32),'
p5969
aS'\t\t\t\t\tprop->num_properties);'
p5970
ag59
as(I10
I24
tp5971
(lp5972
S'#define VALIDATE_PROPERTY_STRUCTURE_SIZE(pkt_size, property_size) ({\\'
p5973
aS'\t\tif (pkt_size < property_size) { \\'
p5974
aS'\t\t\tstatus = VIDC_ERR_BAD_PARAM; \\'
p5975
aS'\t\t\tbreak; \\'
p5976
aS'\t\t} \\'
p5977
aS'})'
p5978
ag59
aS'#define VALIDATE_PROPERTY_PAYLOAD_SIZE(pkt_size, payload_size, \\'
p5979
aS'\t\tproperty_count) ({\\'
p5980
aS'\t\tif (pkt_size/payload_size < property_count) { \\'
p5981
aS'\t\t\tstatus = VIDC_ERR_BAD_PARAM; \\'
p5982
aS'\t\t\tbreak; \\'
p5983
aS'\t\t} \\'
p5984
aS'})'
p5985
ag59
as(I201
I203
tp5986
(lp5987
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p5988
aS'\t\t\t\t\tnext_offset,'
p5989
aS'\t\t\t\t\tsizeof(struct hfi_intra_refresh));'
p5990
as(I227
I233
tp5991
(lp5992
g59
aS'\t\tif (rem_bytes > next_offset) {'
p5993
aS'\t\t\trem_bytes -= next_offset;'
p5994
aS'\t\t\tdata_ptr += next_offset;'
p5995
aS'\t\t} else {'
p5996
aS'\t\t\trem_bytes = 0;'
p5997
aS'\t\t}'
p5998
as(I107
I110
tp5999
(lp6000
S'\t\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p6001
aS'\t\t\t\t\t\tnext_offset,'
p6002
aS'\t\t\t\t\t\tbytes_to_skip);'
p6003
ag59
as(I96
I99
tp6004
(lp6005
S'\t\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p6006
aS'\t\t\t\t\t\tnext_offset,'
p6007
aS'\t\t\t\t\t\tsizeof(*plane_info));'
p6008
ag59
as(I211
I213
tp6009
(lp6010
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p6011
aS'\t\t\t\t\tnext_offset,'
p6012
aS'\t\t\t\t\tsizeof(u32));'
p6013
as(I192
I194
tp6014
(lp6015
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p6016
aS'\t\t\t\t\tnext_offset,'
p6017
aS'\t\t\t\t\tsizeof(u32));'
p6018
as(I143
I151
tp6019
(lp6020
S'\t\t\tVALIDATE_PROPERTY_STRUCTURE_SIZE(rem_bytes -'
p6021
aS'\t\t\t\t\tnext_offset,'
p6022
aS'\t\t\t\t\tsizeof(*prop));'
p6023
aS'\t\t\tVALIDATE_PROPERTY_PAYLOAD_SIZE(rem_bytes -'
p6024
aS'\t\t\t\t\tnext_offset -'
p6025
aS'\t\t\t\t\tsizeof(u32),'
p6026
aS'\t\t\t\t\tsizeof(struct hfi_profile_level),'
p6027
aS'\t\t\t\t\tprop->profile_count);'
p6028
ag59
assg32
I5
sg12
g13
sg41
(I1
I237
tp6029
sssssS'CVE-2019-2314'
p6030
(dp6031
(S'drivers/gpu/drm/msm/dp/dp_debug.c'
p6032
S'dp_debug_write_edid'
p6033
tp6034
(dp6035
S'static ssize_t dp_debug_write_edid(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *edid = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t edid_size = 0;\n\tsize_t size = 0, edid_buf_index = 0;\n\tssize_t rc = count;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_1K);\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tedid_size = size / char_to_nib;\n\tbuf_t = buf;\n\n\tif (dp_debug_get_edid_buf(debug))\n\t\tgoto bail;\n\n\tif (edid_size != debug->edid_size) {\n\t\tpr_debug("realloc debug edid\\n");\n\n\t\tif (debug->edid) {\n\t\t\tdevm_kfree(debug->dev, debug->edid);\n\n\t\t\tdebug->edid = devm_kzalloc(debug->dev,\n\t\t\t\t\t\tedid_size, GFP_KERNEL);\n\t\t\tif (!debug->edid) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tdebug->edid_size = edid_size;\n\n\t\t\tdebug->aux->set_sim_mode(debug->aux,\n\t\t\t\t\tdebug->dp_debug.sim_mode,\n\t\t\t\t\tdebug->edid, debug->dpcd);\n\t\t}\n\t}\n\n\twhile (edid_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (edid_buf_index < debug->edid_size)\n\t\t\tdebug->edid[edid_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tedid = debug->edid;\nbail:\n\tkfree(buf);\n\n\tif (!debug->dp_debug.sim_mode)\n\t\tdebug->panel->set_edid(debug->panel, edid);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p6036
(dp6037
((g6032
g6033
tp6038
I1
tp6039
(dp6040
g33
(dp6041
(I37
I38
tp6042
(lp6043
S'\t\tpr_debug("clearing debug edid\\n");'
p6044
aS'\t\tgoto bail;'
p6045
assg14
(dp6046
(I37
I54
tp6047
(lp6048
S'\t\tpr_debug("realloc debug edid\\n");'
p6049
ag59
aS'\t\tif (debug->edid) {'
p6050
aS'\t\t\tdevm_kfree(debug->dev, debug->edid);'
p6051
ag59
aS'\t\t\tdebug->edid = devm_kzalloc(debug->dev,'
p6052
aS'\t\t\t\t\t\tedid_size, GFP_KERNEL);'
p6053
aS'\t\t\tif (!debug->edid) {'
p6054
aS'\t\t\t\trc = -ENOMEM;'
p6055
aS'\t\t\t\tgoto bail;'
p6056
aS'\t\t\t}'
p6057
ag59
aS'\t\t\tdebug->edid_size = edid_size;'
p6058
ag59
aS'\t\t\tdebug->aux->set_sim_mode(debug->aux,'
p6059
aS'\t\t\t\t\tdebug->dp_debug.sim_mode,'
p6060
aS'\t\t\t\t\tdebug->edid, debug->dpcd);'
p6061
aS'\t\t}'
p6062
as(I14
I15
tp6063
(lp6064
S'\tmutex_lock(&debug->lock);'
p6065
ag59
as(I82
I82
tp6066
(lp6067
S'\tmutex_unlock(&debug->lock);'
p6068
assg32
I4
sg12
g13
sg41
(I1
I84
tp6069
sssS'static ssize_t dp_debug_write_edid(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *edid = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t edid_size = 0;\n\tsize_t size = 0, edid_buf_index = 0;\n\tssize_t rc = count;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_1K);\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tedid_size = size / char_to_nib;\n\tbuf_t = buf;\n\n\tif (dp_debug_get_edid_buf(debug))\n\t\tgoto bail;\n\n\tif (edid_size != debug->edid_size) {\n\t\tpr_debug("clearing debug edid\\n");\n\t\tgoto bail;\n\t}\n\n\twhile (edid_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (edid_buf_index < debug->edid_size)\n\t\t\tdebug->edid[edid_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tedid = debug->edid;\nbail:\n\tkfree(buf);\n\n\tif (!debug->dp_debug.sim_mode)\n\t\tdebug->panel->set_edid(debug->panel, edid);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p6070
(dp6071
((g6032
g6033
tp6072
I1
tp6073
(dp6074
g14
(dp6075
(I14
I15
tp6076
(lp6077
S'\tmutex_lock(&debug->lock);'
p6078
ag59
as(I66
I66
tp6079
(lp6080
S'\tmutex_unlock(&debug->lock);'
p6081
assg32
I4
sg12
g13
sg41
(I1
I68
tp6082
ssss(g6032
S'dp_debug_get'
p6083
tp6084
(dp6085
S'struct dp_debug *dp_debug_get(struct device *dev, struct dp_panel *panel,\n\t\t\tstruct dp_usbpd *usbpd, struct dp_link *link,\n\t\t\tstruct dp_aux *aux, struct drm_connector **connector,\n\t\t\tstruct dp_catalog *catalog)\n{\n\tint rc = 0;\n\tstruct dp_debug_private *debug;\n\tstruct dp_debug *dp_debug;\n\n\tif (!dev || !panel || !usbpd || !link || !catalog) {\n\t\tpr_err("invalid input\\n");\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdebug = devm_kzalloc(dev, sizeof(*debug), GFP_KERNEL);\n\tif (!debug) {\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tINIT_WORK(&debug->sim_work, dp_debug_sim_work);\n\n\tdebug->dp_debug.debug_en = false;\n\tdebug->usbpd = usbpd;\n\tdebug->link = link;\n\tdebug->panel = panel;\n\tdebug->aux = aux;\n\tdebug->dev = dev;\n\tdebug->connector = connector;\n\tdebug->catalog = catalog;\n\n\tdp_debug = &debug->dp_debug;\n\tdp_debug->vdisplay = 0;\n\tdp_debug->hdisplay = 0;\n\tdp_debug->vrefresh = 0;\n\n\tmutex_init(&debug->lock);\n\n\trc = dp_debug_init(dp_debug);\n\tif (rc) {\n\t\tdevm_kfree(dev, debug);\n\t\tgoto error;\n\t}\n\n\treturn dp_debug;\nerror:\n\treturn ERR_PTR(rc);\n}'
p6086
(dp6087
((g6032
g6083
tp6088
I1
tp6089
(dp6090
g14
(dp6091
(I38
I39
tp6092
(lp6093
S'\tmutex_init(&debug->lock);'
p6094
ag59
assg32
I7
sg12
g13
sg41
(I1
I49
tp6095
ssss(g6032
S'dp_debug_write_sim'
p6096
tp6097
(dp6098
S"static ssize_t dp_debug_write_sim(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tchar buf[SZ_8];\n\tsize_t len = 0;\n\tint sim;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tmutex_lock(&debug->lock);\n\n\t/* Leave room for termination char */\n\tlen = min_t(size_t, count, SZ_8 - 1);\n\tif (copy_from_user(buf, user_buff, len))\n\t\tgoto end;\n\n\tbuf[len] = '\\0';\n\n\tif (kstrtoint(buf, 10, &sim) != 0)\n\t\tgoto end;\n\n\tif (sim) {\n\t\tif (dp_debug_get_edid_buf(debug))\n\t\t\tgoto end;\n\n\t\tif (dp_debug_get_dpcd_buf(debug))\n\t\t\tgoto error;\n\t} else {\n\t\tif (debug->edid) {\n\t\t\tdevm_kfree(debug->dev, debug->edid);\n\t\t\tdebug->edid = NULL;\n\t\t}\n\n\t\tif (debug->dpcd) {\n\t\t\tdevm_kfree(debug->dev, debug->dpcd);\n\t\t\tdebug->dpcd = NULL;\n\t\t}\n\t}\n\n\tdebug->dp_debug.sim_mode = !!sim;\n\n\tdebug->aux->set_sim_mode(debug->aux, debug->dp_debug.sim_mode,\n\t\t\tdebug->edid, debug->dpcd);\nend:\n\tmutex_unlock(&debug->lock);\n\treturn len;\nerror:\n\tdevm_kfree(debug->dev, debug->edid);\n\tmutex_unlock(&debug->lock);\n\treturn len;\n}"
p6099
(dp6100
((g6032
g6096
tp6101
I1
tp6102
(dp6103
g14
(dp6104
(I54
I54
tp6105
(lp6106
S'\tmutex_unlock(&debug->lock);'
p6107
as(I15
I16
tp6108
(lp6109
S'\tmutex_lock(&debug->lock);'
p6110
ag59
as(I50
I50
tp6111
(lp6112
S'\tmutex_unlock(&debug->lock);'
p6113
assg32
I4
sg12
g13
sg41
(I1
I56
tp6114
ssss(g6032
S'dp_debug_write_dpcd'
p6115
tp6116
(dp6117
S'static ssize_t dp_debug_write_dpcd(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *dpcd = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t dpcd_size = 0;\n\tsize_t size = 0, dpcd_buf_index = 0;\n\tssize_t rc = count;\n\tchar offset_ch[5];\n\tu32 offset;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_2K);\n\tif (size < 4)\n\t\tgoto bail;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tmemcpy(offset_ch, buf, 4);\n\toffset_ch[4] = \'\\0\';\n\n\tif (kstrtoint(offset_ch, 16, &offset)) {\n\t\tpr_err("offset kstrtoint error\\n");\n\t\tgoto bail;\n\t}\n\n\tif (dp_debug_get_dpcd_buf(debug))\n\t\tgoto bail;\n\n\tif (offset == 0xFFFF) {\n\t\tpr_err("clearing dpcd\\n");\n\t\tmemset(debug->dpcd, 0, debug->dpcd_size);\n\t\tgoto bail;\n\t}\n\n\tsize -= 4;\n\tif (size == 0)\n\t\tgoto bail;\n\n\tdpcd_size = size / char_to_nib;\n\tbuf_t = buf + 4;\n\n\tdpcd_buf_index = offset;\n\n\twhile (dpcd_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (dpcd_buf_index < debug->dpcd_size)\n\t\t\tdebug->dpcd[dpcd_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tdpcd = debug->dpcd;\nbail:\n\tkfree(buf);\n\tif (debug->dp_debug.sim_mode)\n\t\tdebug->aux->dpcd_updated(debug->aux);\n\telse\n\t\tdebug->panel->set_dpcd(debug->panel, dpcd);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p6118
(dp6119
((g6032
g6115
tp6120
I1
tp6121
(dp6122
g14
(dp6123
(I16
I17
tp6124
(lp6125
S'\tmutex_lock(&debug->lock);'
p6126
ag59
as(I52
I53
tp6127
(lp6128
S'\tif (size == 0)'
p6129
aS'\t\tgoto bail;'
p6130
as(I22
I23
tp6131
(lp6132
S'\tif (size < 4)'
p6133
aS'\t\tgoto bail;'
p6134
as(I86
I86
tp6135
(lp6136
S'\tmutex_unlock(&debug->lock);'
p6137
assg32
I4
sg12
g13
sg41
(I1
I88
tp6138
sssS'static ssize_t dp_debug_write_dpcd(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *dpcd = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t dpcd_size = 0;\n\tsize_t size = 0, dpcd_buf_index = 0;\n\tssize_t rc = count;\n\tchar offset_ch[5];\n\tu32 offset;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_2K);\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tmemcpy(offset_ch, buf, 4);\n\toffset_ch[4] = \'\\0\';\n\n\tif (kstrtoint(offset_ch, 16, &offset)) {\n\t\tpr_err("offset kstrtoint error\\n");\n\t\tgoto bail;\n\t}\n\n\tif (dp_debug_get_dpcd_buf(debug))\n\t\tgoto bail;\n\n\tif (offset == 0xFFFF) {\n\t\tpr_err("clearing dpcd\\n");\n\t\tmemset(debug->dpcd, 0, debug->dpcd_size);\n\t\tgoto bail;\n\t}\n\n\tsize -= 4;\n\n\tdpcd_size = size / char_to_nib;\n\tbuf_t = buf + 4;\n\n\tdpcd_buf_index = offset;\n\n\twhile (dpcd_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (dpcd_buf_index < debug->dpcd_size)\n\t\t\tdebug->dpcd[dpcd_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tdpcd = debug->dpcd;\nbail:\n\tkfree(buf);\n\tif (debug->dp_debug.sim_mode)\n\t\tdebug->aux->dpcd_updated(debug->aux);\n\telse\n\t\tdebug->panel->set_dpcd(debug->panel, dpcd);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p6139
(dp6140
((g6032
g6115
tp6141
I1
tp6142
(dp6143
g14
(dp6144
(I16
I17
tp6145
(lp6146
S'\tmutex_lock(&debug->lock);'
p6147
ag59
as(I82
I82
tp6148
(lp6149
S'\tmutex_unlock(&debug->lock);'
p6150
assg32
I4
sg12
g13
sg41
(I1
I84
tp6151
ssss(g6032
S'dp_debug_put'
p6152
tp6153
(dp6154
S'void dp_debug_put(struct dp_debug *dp_debug)\n{\n\tstruct dp_debug_private *debug;\n\n\tif (!dp_debug)\n\t\treturn;\n\n\tdebug = container_of(dp_debug, struct dp_debug_private, dp_debug);\n\n\tdp_debug_deinit(dp_debug);\n\n\tmutex_destroy(&debug->lock);\n\n\tif (debug->edid)\n\t\tdevm_kfree(debug->dev, debug->edid);\n\n\tif (debug->dpcd)\n\t\tdevm_kfree(debug->dev, debug->dpcd);\n\n\tdevm_kfree(debug->dev, debug);\n}'
p6155
(dp6156
((g6032
g6152
tp6157
I1
tp6158
(dp6159
g14
(dp6160
(I12
I13
tp6161
(lp6162
S'\tmutex_destroy(&debug->lock);'
p6163
ag59
assg32
I1
sg12
g13
sg41
(I1
I21
tp6164
sssssS'CVE-2019-15666'
p6165
(dp6166
(S'net/xfrm/xfrm_user.c'
p6167
S'verify_newpolicy_info'
p6168
tp6169
(dp6170
S'static int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tif (p->sel.prefixlen_d > 32 || p->sel.prefixlen_s > 32)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tif (p->sel.prefixlen_d > 128 || p->sel.prefixlen_s > 128)\n\t\t\treturn -EINVAL;\n\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && (xfrm_policy_id2dir(p->index) != p->dir))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p6171
(dp6172
((g6167
g6168
tp6173
I1
tp6174
(dp6175
g12
g13
sg14
(dp6176
(I49
I49
tp6177
(lp6178
S'\tif (p->index && (xfrm_policy_id2dir(p->index) != p->dir))'
p6179
assg32
I1
sg33
(dp6180
(I49
I49
tp6181
(lp6182
S'\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))'
p6183
assg41
(I1
I53
tp6184
sssssS'CVE-2019-15213'
p6185
(dp6186
(S'drivers/media/usb/dvb-usb/dvb-usb-init.c'
p6187
S'dvb_usb_device_exit'
p6188
tp6189
(dp6190
S'void dvb_usb_device_exit(struct usb_interface *intf)\n{\n\tstruct dvb_usb_device *d = usb_get_intfdata(intf);\n\tconst char *default_name = "generic DVB-USB module";\n\tchar name[40];\n\n\tusb_set_intfdata(intf, NULL);\n\tif (d != NULL && d->desc != NULL) {\n\t\tstrscpy(name, d->desc->name, sizeof(name));\n\t\tdvb_usb_exit(d);\n\t} else {\n\t\tstrscpy(name, default_name, sizeof(name));\n\t}\n\tinfo("%s successfully deinitialized and disconnected.", name);\n\n}'
p6191
(dp6192
((g6187
g6188
tp6193
I1
tp6194
(dp6195
g12
g13
sg14
(dp6196
(I4
I5
tp6197
(lp6198
S'\tconst char *default_name = "generic DVB-USB module";'
p6199
aS'\tchar name[40];'
p6200
as(I11
I12
tp6201
(lp6202
S'\t} else {'
p6203
aS'\t\tstrscpy(name, default_name, sizeof(name));'
p6204
as(I9
I9
tp6205
(lp6206
S'\t\tstrscpy(name, d->desc->name, sizeof(name));'
p6207
assg32
I1
sg33
(dp6208
(I4
I4
tp6209
(lp6210
S'\tconst char *name = "generic DVB-USB module";'
p6211
as(I9
I9
tp6212
(lp6213
S'\t\tname = d->desc->name;'
p6214
assg41
(I1
I16
tp6215
sssssS'CVE-2019-15212'
p6216
(dp6217
(S'drivers/usb/misc/rio500.c'
p6218
S'probe_rio'
p6219
tp6220
(dp6221
S'static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval = 0;\n\n\tmutex_lock(&rio500_mutex);\n\tif (rio->present) {\n\t\tdev_info(&intf->dev, "Second USB Rio at address %d refused\\n", dev->devnum);\n\t\tretval = -EBUSY;\n\t\tgoto bail_out;\n\t} else {\n\t\tdev_info(&intf->dev, "USB Rio found at address %d\\n", dev->devnum);\n\t}\n\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t"Not able to get a minor for this device.\\n");\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\n\trio->rio_dev = dev;\n\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t"probe_rio: Not enough memory for the output buffer\\n");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, "obuf address:%p\\n", rio->obuf);\n\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t"probe_rio: Not enough memory for the input buffer\\n");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, "ibuf address:%p\\n", rio->ibuf);\n\n\tmutex_init(&(rio->lock));\n\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\nbail_out:\n\tmutex_unlock(&rio500_mutex);\n\n\treturn retval;\n}'
p6222
(dp6223
((g6218
g6219
tp6224
I1
tp6225
(dp6226
g12
g13
sg14
(dp6227
(I41
I42
tp6228
(lp6229
S'\t\tretval = -ENOMEM;'
p6230
aS'\t\tgoto bail_out;'
p6231
as(I50
I51
tp6232
(lp6233
S'bail_out:'
p6234
aS'\tmutex_unlock(&rio500_mutex);'
p6235
as(I53
I53
tp6236
(lp6237
S'\treturn retval;'
p6238
as(I21
I22
tp6239
(lp6240
S'\t\tretval = -ENOMEM;'
p6241
aS'\t\tgoto bail_out;'
p6242
as(I6
I15
tp6243
(lp6244
S'\tint retval = 0;'
p6245
ag59
aS'\tmutex_lock(&rio500_mutex);'
p6246
aS'\tif (rio->present) {'
p6247
aS'\t\tdev_info(&intf->dev, "Second USB Rio at address %d refused\\n", dev->devnum);'
p6248
aS'\t\tretval = -EBUSY;'
p6249
aS'\t\tgoto bail_out;'
p6250
aS'\t} else {'
p6251
aS'\t\tdev_info(&intf->dev, "USB Rio found at address %d\\n", dev->devnum);'
p6252
aS'\t}'
p6253
as(I31
I32
tp6254
(lp6255
S'\t\tretval = -ENOMEM;'
p6256
aS'\t\tgoto bail_out;'
p6257
assg32
I2
sg33
(dp6258
(I31
I31
tp6259
(lp6260
S'\t\treturn -ENOMEM;'
p6261
as(I41
I41
tp6262
(lp6263
S'\t\treturn -ENOMEM;'
p6264
as(I53
I53
tp6265
(lp6266
S'\treturn 0;'
p6267
as(I6
I8
tp6268
(lp6269
S'\tint retval;'
p6270
ag59
aS'\tdev_info(&intf->dev, "USB Rio found at address %d\\n", dev->devnum);'
p6271
as(I21
I21
tp6272
(lp6273
S'\t\treturn -ENOMEM;'
p6274
assg41
(I1
I54
tp6275
sssssS'CVE-2019-15211'
p6276
(dp6277
(S'drivers/media/radio/radio-raremono.c'
p6278
S'raremono_device_release'
p6279
tp6280
(dp6281
s(g6278
S'usb_raremono_probe'
p6282
tp6283
(dp6284
S'static int usb_raremono_probe(struct usb_interface *intf,\n\t\t\t\tconst struct usb_device_id *id)\n{\n\tstruct raremono_device *radio;\n\tint retval = 0;\n\n\tradio = kzalloc(sizeof(*radio), GFP_KERNEL);\n\tif (!radio)\n\t\treturn -ENOMEM;\n\tradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);\n\tif (!radio->buffer) {\n\t\tkfree(radio);\n\t\treturn -ENOMEM;\n\t}\n\n\tradio->usbdev = interface_to_usbdev(intf);\n\tradio->intf = intf;\n\n\t/*\n\t * This device uses the same USB IDs as the si470x SiLabs reference\n\t * design. So do an additional check: attempt to read the device ID\n\t * from the si470x: the lower 12 bits are 0x0242 for the si470x. The\n\t * Raremono always returns 0x0800 (the meaning of that is unknown, but\n\t * at least it works).\n\t *\n\t * We use this check to determine which device we are dealing with.\n\t */\n\tmsleep(20);\n\tretval = usb_control_msg(radio->usbdev,\n\t\tusb_rcvctrlpipe(radio->usbdev, 0),\n\t\tHID_REQ_GET_REPORT,\n\t\tUSB_TYPE_CLASS | USB_RECIP_INTERFACE | USB_DIR_IN,\n\t\t1, 2,\n\t\tradio->buffer, 3, 500);\n\tif (retval != 3 ||\n\t    (get_unaligned_be16(&radio->buffer[1]) & 0xfff) == 0x0242) {\n\t\tdev_info(&intf->dev, "this is not Thanko\'s Raremono.\\n");\n\t\tretval = -ENODEV;\n\t\tgoto free_mem;\n\t}\n\n\tdev_info(&intf->dev, "Thanko\'s Raremono connected: (%04X:%04X)\\n",\n\t\t\tid->idVendor, id->idProduct);\n\n\tretval = v4l2_device_register(&intf->dev, &radio->v4l2_dev);\n\tif (retval < 0) {\n\t\tdev_err(&intf->dev, "couldn\'t register v4l2_device\\n");\n\t\tgoto free_mem;\n\t}\n\n\tmutex_init(&radio->lock);\n\n\tstrlcpy(radio->vdev.name, radio->v4l2_dev.name,\n\t\tsizeof(radio->vdev.name));\n\tradio->vdev.v4l2_dev = &radio->v4l2_dev;\n\tradio->vdev.fops = &usb_raremono_fops;\n\tradio->vdev.ioctl_ops = &usb_raremono_ioctl_ops;\n\tradio->vdev.lock = &radio->lock;\n\tradio->vdev.release = video_device_release_empty;\n\tradio->v4l2_dev.release = raremono_device_release;\n\n\tusb_set_intfdata(intf, &radio->v4l2_dev);\n\n\tvideo_set_drvdata(&radio->vdev, radio);\n\n\traremono_cmd_main(radio, BAND_FM, 95160);\n\n\tretval = video_register_device(&radio->vdev, VFL_TYPE_RADIO, -1);\n\tif (retval == 0) {\n\t\tdev_info(&intf->dev, "V4L2 device registered as %s\\n",\n\t\t\t\tvideo_device_node_name(&radio->vdev));\n\t\treturn 0;\n\t}\n\tdev_err(&intf->dev, "could not register video device\\n");\n\tv4l2_device_unregister(&radio->v4l2_dev);\n\nfree_mem:\n\tkfree(radio->buffer);\n\tkfree(radio);\n\treturn retval;\n}'
p6285
(dp6286
((g6278
g6282
tp6287
I1
tp6288
(dp6289
g12
g13
sg14
(dp6290
(I76
I79
tp6291
(lp6292
g59
aS'free_mem:'
p6293
aS'\tkfree(radio->buffer);'
p6294
aS'\tkfree(radio);'
p6295
as(I48
I48
tp6296
(lp6297
S'\t\tgoto free_mem;'
p6298
as(I38
I39
tp6299
(lp6300
S'\t\tretval = -ENODEV;'
p6301
aS'\t\tgoto free_mem;'
p6302
as(I14
I14
tp6303
(lp6304
S'\t}'
p6305
as(I7
I12
tp6306
(lp6307
S'\tradio = kzalloc(sizeof(*radio), GFP_KERNEL);'
p6308
aS'\tif (!radio)'
p6309
aS'\t\treturn -ENOMEM;'
p6310
aS'\tradio->buffer = kmalloc(BUFFER_LENGTH, GFP_KERNEL);'
p6311
aS'\tif (!radio->buffer) {'
p6312
aS'\t\tkfree(radio);'
p6313
as(I60
I60
tp6314
(lp6315
S'\tradio->v4l2_dev.release = raremono_device_release;'
p6316
assg32
I2
sg33
(dp6317
(I7
I11
tp6318
(lp6319
S'\tradio = devm_kzalloc(&intf->dev, sizeof(struct raremono_device), GFP_KERNEL);'
p6320
aS'\tif (radio)'
p6321
aS'\t\tradio->buffer = devm_kmalloc(&intf->dev, BUFFER_LENGTH, GFP_KERNEL);'
p6322
ag59
aS'\tif (!radio || !radio->buffer)'
p6323
as(I48
I48
tp6324
(lp6325
S'\t\treturn retval;'
p6326
as(I38
I38
tp6327
(lp6328
S'\t\treturn -ENODEV;'
p6329
assg41
(I1
I81
tp6330
sssssS'CVE-2019-15215'
p6331
(dp6332
(S'drivers/media/usb/cpia2/cpia2_usb.c'
p6333
S'cpia2_usb_disconnect'
p6334
tp6335
(dp6336
S'static void cpia2_usb_disconnect(struct usb_interface *intf)\n{\n\tstruct camera_data *cam = usb_get_intfdata(intf);\n\tusb_set_intfdata(intf, NULL);\n\n\tDBG("Stopping stream\\n");\n\tcpia2_usb_stream_stop(cam);\n\n\tmutex_lock(&cam->v4l2_lock);\n\tDBG("Unregistering camera\\n");\n\tcpia2_unregister_camera(cam);\n\tv4l2_device_disconnect(&cam->v4l2_dev);\n\tmutex_unlock(&cam->v4l2_lock);\n\n\tif(cam->buffers) {\n\t\tDBG("Wakeup waiting processes\\n");\n\t\tcam->curbuff->status = FRAME_READY;\n\t\tcam->curbuff->length = 0;\n\t\twake_up_interruptible(&cam->wq_stream);\n\t}\n\n\tDBG("Releasing interface\\n");\n\tusb_driver_release_interface(&cpia2_driver, intf);\n\n\tv4l2_device_put(&cam->v4l2_dev);\n\n\tLOG("CPiA2 camera disconnected.\\n");\n}'
p6337
(dp6338
((g6333
g6334
tp6339
I1
tp6340
(dp6341
g12
g13
sg14
(dp6342
(I25
I26
tp6343
(lp6344
S'\tv4l2_device_put(&cam->v4l2_dev);'
p6345
ag59
assg32
I1
sg33
(dp6346
(I14
I14
tp6347
(lp6348
S'\tv4l2_device_put(&cam->v4l2_dev);'
p6349
assg41
(I1
I28
tp6350
sssssS'CVE-2019-15214'
p6351
(dp6352
(S'sound/core/init.c'
p6353
S'snd_card_disconnect'
p6354
tp6355
(dp6356
S"int snd_card_disconnect(struct snd_card *card)\n{\n\tstruct snd_monitor_file *mfile;\n\n\tif (!card)\n\t\treturn -EINVAL;\n\n\tspin_lock(&card->files_lock);\n\tif (card->shutdown) {\n\t\tspin_unlock(&card->files_lock);\n\t\treturn 0;\n\t}\n\tcard->shutdown = 1;\n\tspin_unlock(&card->files_lock);\n\n\t/* replace file->f_op with special dummy operations */\n\tspin_lock(&card->files_lock);\n\tlist_for_each_entry(mfile, &card->files_list, list) {\n\t\t/* it's critical part, use endless loop */\n\t\t/* we have no room to fail */\n\t\tmfile->disconnected_f_op = mfile->file->f_op;\n\n\t\tspin_lock(&shutdown_lock);\n\t\tlist_add(&mfile->shutdown_list, &shutdown_files);\n\t\tspin_unlock(&shutdown_lock);\n\n\t\tmfile->file->f_op = &snd_shutdown_f_ops;\n\t\tfops_get(mfile->file->f_op);\n\t}\n\tspin_unlock(&card->files_lock);\t\n\n\t/* notify all connected devices about disconnection */\n\t/* at this point, they cannot respond to any calls except release() */\n\n#if IS_ENABLED(CONFIG_SND_MIXER_OSS)\n\tif (snd_mixer_oss_notify_callback)\n\t\tsnd_mixer_oss_notify_callback(card, SND_MIXER_OSS_NOTIFY_DISCONNECT);\n#endif\n\n\t/* notify all devices that we are disconnected */\n\tsnd_device_disconnect_all(card);\n\n\tsnd_info_card_disconnect(card);\n\tif (card->registered) {\n\t\tdevice_del(&card->card_dev);\n\t\tcard->registered = false;\n\t}\n\n\t/* disable fops (user space) operations for ALSA API */\n\tmutex_lock(&snd_card_mutex);\n\tsnd_cards[card->number] = NULL;\n\tclear_bit(card->number, snd_cards_lock);\n\tmutex_unlock(&snd_card_mutex);\n\n#ifdef CONFIG_PM\n\twake_up(&card->power_sleep);\n#endif\n\treturn 0;\t\n}"
p6357
(dp6358
((g6353
g6354
tp6359
I1
tp6360
(dp6361
g12
g13
sg14
(dp6362
(I48
I54
tp6363
(lp6364
g59
aS'\t/* disable fops (user space) operations for ALSA API */'
p6365
aS'\tmutex_lock(&snd_card_mutex);'
p6366
aS'\tsnd_cards[card->number] = NULL;'
p6367
aS'\tclear_bit(card->number, snd_cards_lock);'
p6368
aS'\tmutex_unlock(&snd_card_mutex);'
p6369
ag59
as(I16
I16
tp6370
(lp6371
S'\t/* replace file->f_op with special dummy operations */'
p6372
as(I32
I32
tp6373
(lp6374
S'\t/* notify all connected devices about disconnection */'
p6375
assg32
I1
sg33
(dp6376
(I32
I32
tp6377
(lp6378
S'\t/* phase 3: notify all connected devices about disconnection */'
p6379
as(I16
I23
tp6380
(lp6381
S'\t/* phase 1: disable fops (user space) operations for ALSA API */'
p6382
aS'\tmutex_lock(&snd_card_mutex);'
p6383
aS'\tsnd_cards[card->number] = NULL;'
p6384
aS'\tclear_bit(card->number, snd_cards_lock);'
p6385
aS'\tmutex_unlock(&snd_card_mutex);'
p6386
aS'\t'
p6387
aS'\t/* phase 2: replace file->f_op with special dummy operations */'
p6388
ag6387
assg41
(I1
I59
tp6389
sssssS'CVE-2018-3574'
p6390
(dp6391
(S'drivers/staging/android/ion/ion.c'
p6392
S'ion_sync_for_device'
p6393
tp6394
(dp6395
S'static int ion_sync_for_device(struct ion_client *client, int fd)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct ion_buffer *buffer;\n\n\tdmabuf = dma_buf_get(fd);\n\tif (IS_ERR(dmabuf))\n\t\treturn PTR_ERR(dmabuf);\n\n\t/* if this memory came from ion */\n\tif (dmabuf->ops != &dma_buf_ops) {\n\t\tpr_err("%s: can not sync dmabuf from another exporter\\n",\n\t\t       __func__);\n\t\tdma_buf_put(dmabuf);\n\t\treturn -EINVAL;\n\t}\n\tbuffer = dmabuf->priv;\n\n\tif (!is_buffer_hlos_assigned(buffer)) {\n\t\tpr_err("%s: cannot sync a secure dmabuf\\n", __func__);\n\t\tdma_buf_put(dmabuf);\n\t\treturn -EINVAL;\n\t}\n\tdma_sync_sg_for_device(NULL, buffer->sg_table->sgl,\n\t\t\t       buffer->sg_table->nents, DMA_BIDIRECTIONAL);\n\tdma_buf_put(dmabuf);\n\treturn 0;\n}'
p6396
(dp6397
((g6392
g6393
tp6398
I1
tp6399
(dp6400
g14
(dp6401
(I19
I23
tp6402
(lp6403
S'\tif (!is_buffer_hlos_assigned(buffer)) {'
p6404
aS'\t\tpr_err("%s: cannot sync a secure dmabuf\\n", __func__);'
p6405
aS'\t\tdma_buf_put(dmabuf);'
p6406
aS'\t\treturn -EINVAL;'
p6407
aS'\t}'
p6408
assg32
I2
sg12
g13
sg41
(I1
I28
tp6409
ssss(S'drivers/staging/android/ion/msm/msm_ion.c'
p6410
S'MAKE_HEAP_TYPE_MAPPING'
p6411
tp6412
(dp6413
s(g6410
S'msm_ion_custom_ioctl'
p6414
tp6415
(dp6416
S'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tlock_client(client);\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id_nolock(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd_nolock(client,\n\t\t\t\t\t\t\t   data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (start && check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free_nolock(client, handle);\n\n\t\tunlock_client(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p6417
(dp6418
((g6410
g6414
tp6419
I1
tp6420
(dp6421
g33
(dp6422
(I41
I42
tp6423
(lp6424
S'\t\t\thandle = ion_import_dma_buf_fd(client,'
p6425
aS'\t\t\t\t\t\t       data.flush_data.fd);'
p6426
as(I32
I32
tp6427
(lp6428
S'\t\t\thandle = ion_handle_get_by_id('
p6429
as(I57
I57
tp6430
(lp6431
S'\t\tif (check_vaddr_bounds(start, end)) {'
p6432
as(I53
I55
tp6433
(lp6434
S'\t\tstart = (unsigned long)data.flush_data.vaddr;'
p6435
aS'\t\tend = (unsigned long)data.flush_data.vaddr'
p6436
aS'\t\t\t+ data.flush_data.length;'
p6437
as(I69
I69
tp6438
(lp6439
S'\t\tion_free(client, handle);'
p6440
assg14
(dp6441
(I32
I32
tp6442
(lp6443
S'\t\t\thandle = ion_handle_get_by_id_nolock('
p6444
as(I37
I37
tp6445
(lp6446
S'\t\t\t\tunlock_client(client);'
p6447
as(I110
I110
tp6448
(lp6449
S'\t\t\t\t     (enum ion_heap_type)'
p6450
as(I53
I55
tp6451
(lp6452
S'\t\tstart = (unsigned long)data.flush_data.vaddr +'
p6453
aS'\t\t\tdata.flush_data.offset;'
p6454
aS'\t\tend = start + data.flush_data.length;'
p6455
as(I71
I71
tp6456
(lp6457
S'\t\tunlock_client(client);'
p6458
as(I30
I30
tp6459
(lp6460
S'\t\tlock_client(client);'
p6461
as(I41
I42
tp6462
(lp6463
S'\t\t\thandle = ion_import_dma_buf_fd_nolock(client,'
p6464
aS'\t\t\t\t\t\t\t   data.flush_data.fd);'
p6465
as(I81
I89
tp6466
(lp6467
S'\t\t\t\t     (enum ion_heap_type)'
p6468
aS'\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,'
p6469
aS'\t\t\t\t     (void *)data.prefetch_data.len,'
p6470
aS'\t\t\t\t     ion_secure_cma_prefetch);'
p6471
aS'\t\tif (ret)'
p6472
aS'\t\t\treturn ret;'
p6473
ag59
aS'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6474
aS'\t\t\t\t     (enum ion_heap_type)'
p6475
as(I46
I46
tp6476
(lp6477
S'\t\t\t\tunlock_client(client);'
p6478
as(I57
I57
tp6479
(lp6480
S'\t\tif (start && check_vaddr_bounds(start, end)) {'
p6481
as(I100
I107
tp6482
(lp6483
S'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6484
aS'\t\t\t\t     (enum ion_heap_type)'
p6485
aS'\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,'
p6486
aS'\t\t\t\t     (void *)data.prefetch_data.len,'
p6487
aS'\t\t\t\t     ion_secure_cma_drain_pool);'
p6488
ag59
aS'\t\tif (ret)'
p6489
aS'\t\t\treturn ret;'
p6490
as(I69
I69
tp6491
(lp6492
S'\t\tion_free_nolock(client, handle);'
p6493
assg32
I3
sg12
g13
sg41
(I1
I124
tp6494
sssS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd(client,\n\t\t\t\t\t\t       data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free(client, handle);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\tION_HEAP_TYPE_SECURE_DMA,\n\t\t\t(void *)data.prefetch_data.len,\n\t\t\tion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p6495
(dp6496
((g6410
g6414
tp6497
I1
tp6498
(dp6499
g12
g13
sg14
(dp6500
(I76
I82
tp6501
(lp6502
S'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6503
aS'\t\t\tION_HEAP_TYPE_SECURE_DMA,'
p6504
aS'\t\t\t(void *)data.prefetch_data.len,'
p6505
aS'\t\t\tion_secure_cma_prefetch);'
p6506
aS'\t\tif (ret)'
p6507
aS'\t\t\treturn ret;'
p6508
ag59
as(I50
I52
tp6509
(lp6510
S'\t\tstart = (unsigned long)data.flush_data.vaddr +'
p6511
aS'\t\t\tdata.flush_data.offset;'
p6512
aS'\t\tend = start + data.flush_data.length;'
p6513
as(I94
I100
tp6514
(lp6515
S'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6516
aS'\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,'
p6517
aS'\t\t\t\t     (void *)data.prefetch_data.len,'
p6518
aS'\t\t\t\t     ion_secure_cma_drain_pool);'
p6519
ag59
aS'\t\tif (ret)'
p6520
aS'\t\t\treturn ret;'
p6521
assg32
I3
sg33
(dp6522
(I50
I52
tp6523
(lp6524
S'\t\tstart = (unsigned long)data.flush_data.vaddr;'
p6525
aS'\t\tend = (unsigned long)data.flush_data.vaddr'
p6526
aS'\t\t\t+ data.flush_data.length;'
p6527
assg41
(I1
I116
tp6528
sssS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd(client,\n\t\t\t\t\t\t       data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free(client, handle);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p6529
(dp6530
((g6410
g6414
tp6531
I1
tp6532
(dp6533
g12
g13
sg14
(dp6534
(I50
I52
tp6535
(lp6536
S'\t\tstart = (unsigned long)data.flush_data.vaddr +'
p6537
aS'\t\t\tdata.flush_data.offset;'
p6538
aS'\t\tend = start + data.flush_data.length;'
p6539
assg32
I3
sg33
(dp6540
(I50
I52
tp6541
(lp6542
S'\t\tstart = (unsigned long)data.flush_data.vaddr;'
p6543
aS'\t\tend = (unsigned long)data.flush_data.vaddr'
p6544
aS'\t\t\t+ data.flush_data.length;'
p6545
assg41
(I1
I102
tp6546
sssS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tlock_client(client);\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id_nolock(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd_nolock(client,\n\t\t\t\t\t\t\t   data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free_nolock(client, handle);\n\n\t\tunlock_client(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\tION_HEAP_TYPE_SECURE_DMA,\n\t\t\t(void *)data.prefetch_data.len,\n\t\t\tion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p6547
(dp6548
((g6410
g6414
tp6549
I1
tp6550
(dp6551
g33
(dp6552
(I41
I42
tp6553
(lp6554
S'\t\t\thandle = ion_import_dma_buf_fd(client,'
p6555
aS'\t\t\t\t\t\t       data.flush_data.fd);'
p6556
as(I32
I32
tp6557
(lp6558
S'\t\t\thandle = ion_handle_get_by_id('
p6559
as(I69
I69
tp6560
(lp6561
S'\t\tion_free(client, handle);'
p6562
as(I53
I55
tp6563
(lp6564
S'\t\tstart = (unsigned long)data.flush_data.vaddr;'
p6565
aS'\t\tend = (unsigned long)data.flush_data.vaddr'
p6566
aS'\t\t\t+ data.flush_data.length;'
p6567
assg14
(dp6568
(I41
I42
tp6569
(lp6570
S'\t\t\thandle = ion_import_dma_buf_fd_nolock(client,'
p6571
aS'\t\t\t\t\t\t\t   data.flush_data.fd);'
p6572
as(I80
I86
tp6573
(lp6574
S'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6575
aS'\t\t\tION_HEAP_TYPE_SECURE_DMA,'
p6576
aS'\t\t\t(void *)data.prefetch_data.len,'
p6577
aS'\t\t\tion_secure_cma_prefetch);'
p6578
aS'\t\tif (ret)'
p6579
aS'\t\t\treturn ret;'
p6580
ag59
as(I32
I32
tp6581
(lp6582
S'\t\t\thandle = ion_handle_get_by_id_nolock('
p6583
as(I37
I37
tp6584
(lp6585
S'\t\t\t\tunlock_client(client);'
p6586
as(I53
I55
tp6587
(lp6588
S'\t\tstart = (unsigned long)data.flush_data.vaddr +'
p6589
aS'\t\t\tdata.flush_data.offset;'
p6590
aS'\t\tend = start + data.flush_data.length;'
p6591
as(I46
I46
tp6592
(lp6593
S'\t\t\t\tunlock_client(client);'
p6594
as(I98
I104
tp6595
(lp6596
S'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6597
aS'\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,'
p6598
aS'\t\t\t\t     (void *)data.prefetch_data.len,'
p6599
aS'\t\t\t\t     ion_secure_cma_drain_pool);'
p6600
ag59
aS'\t\tif (ret)'
p6601
aS'\t\t\treturn ret;'
p6602
as(I30
I30
tp6603
(lp6604
S'\t\tlock_client(client);'
p6605
as(I71
I71
tp6606
(lp6607
S'\t\tunlock_client(client);'
p6608
as(I69
I69
tp6609
(lp6610
S'\t\tion_free_nolock(client, handle);'
p6611
assg32
I3
sg12
g13
sg41
(I1
I120
tp6612
sssS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tlock_client(client);\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id_nolock(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd_nolock(client,\n\t\t\t\t\t\t\t   data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free_nolock(client, handle);\n\n\t\tunlock_client(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p6613
(dp6614
((g6410
g6414
tp6615
I1
tp6616
(dp6617
g33
(dp6618
(I41
I42
tp6619
(lp6620
S'\t\t\thandle = ion_import_dma_buf_fd(client,'
p6621
aS'\t\t\t\t\t\t       data.flush_data.fd);'
p6622
as(I32
I32
tp6623
(lp6624
S'\t\t\thandle = ion_handle_get_by_id('
p6625
as(I69
I69
tp6626
(lp6627
S'\t\tion_free(client, handle);'
p6628
as(I53
I55
tp6629
(lp6630
S'\t\tstart = (unsigned long)data.flush_data.vaddr;'
p6631
aS'\t\tend = (unsigned long)data.flush_data.vaddr'
p6632
aS'\t\t\t+ data.flush_data.length;'
p6633
assg14
(dp6634
(I32
I32
tp6635
(lp6636
S'\t\t\thandle = ion_handle_get_by_id_nolock('
p6637
as(I37
I37
tp6638
(lp6639
S'\t\t\t\tunlock_client(client);'
p6640
as(I110
I110
tp6641
(lp6642
S'\t\t\t\t     (enum ion_heap_type)'
p6643
as(I53
I55
tp6644
(lp6645
S'\t\tstart = (unsigned long)data.flush_data.vaddr +'
p6646
aS'\t\t\tdata.flush_data.offset;'
p6647
aS'\t\tend = start + data.flush_data.length;'
p6648
as(I71
I71
tp6649
(lp6650
S'\t\tunlock_client(client);'
p6651
as(I30
I30
tp6652
(lp6653
S'\t\tlock_client(client);'
p6654
as(I41
I42
tp6655
(lp6656
S'\t\t\thandle = ion_import_dma_buf_fd_nolock(client,'
p6657
aS'\t\t\t\t\t\t\t   data.flush_data.fd);'
p6658
as(I81
I89
tp6659
(lp6660
S'\t\t\t\t     (enum ion_heap_type)'
p6661
aS'\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,'
p6662
aS'\t\t\t\t     (void *)data.prefetch_data.len,'
p6663
aS'\t\t\t\t     ion_secure_cma_prefetch);'
p6664
aS'\t\tif (ret)'
p6665
aS'\t\t\treturn ret;'
p6666
ag59
aS'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6667
aS'\t\t\t\t     (enum ion_heap_type)'
p6668
as(I46
I46
tp6669
(lp6670
S'\t\t\t\tunlock_client(client);'
p6671
as(I100
I107
tp6672
(lp6673
S'\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,'
p6674
aS'\t\t\t\t     (enum ion_heap_type)'
p6675
aS'\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,'
p6676
aS'\t\t\t\t     (void *)data.prefetch_data.len,'
p6677
aS'\t\t\t\t     ion_secure_cma_drain_pool);'
p6678
ag59
aS'\t\tif (ret)'
p6679
aS'\t\t\treturn ret;'
p6680
as(I69
I69
tp6681
(lp6682
S'\t\tion_free_nolock(client, handle);'
p6683
assg32
I3
sg12
g13
sg41
(I1
I124
tp6684
ssss(g6410
S'ion_do_cache_op'
p6685
tp6686
(dp6687
S'static int ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,\n\t\t\t   void *uaddr, unsigned long offset, unsigned long len,\n\t\t\t   unsigned int cmd)\n{\n\tint ret = -EINVAL;\n\tunsigned long flags;\n\tstruct sg_table *table;\n\tstruct page *page;\n\tstruct ion_buffer *buffer;\n\n\tif (!ion_handle_validate(client, handle)) {\n\t\tpr_err("%s: invalid handle passed to %s.\\n",\n\t\t       __func__, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer = get_buffer(handle);\n\tmutex_lock(&buffer->lock);\n\tflags = buffer->flags;\n\tmutex_unlock(&buffer->lock);\n\n\tif (!ION_IS_CACHED(flags))\n\t\treturn 0;\n\n\tif (!is_buffer_hlos_assigned(ion_handle_buffer(handle)))\n\t\treturn 0;\n\n\ttable = buffer->sg_table;\n\n\tif (IS_ERR_OR_NULL(table))\n\t\treturn PTR_ERR(table);\n\n\tpage = sg_page(table->sgl);\n\n\tif (page)\n\t\tret = ion_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t  offset, len, cmd);\n\telse\n\t\tret = ion_no_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t     offset, len, cmd);\n\n\treturn ret;\n}'
p6688
(dp6689
((g6410
g6685
tp6690
I1
tp6691
(dp6692
g33
(dp6693
(I28
I28
tp6694
(lp6695
S'\ttable = ion_sg_table(client, handle);'
p6696
as(I11
I12
tp6697
(lp6698
S'\tret = ion_handle_get_flags(client, handle, &flags);'
p6699
aS'\tif (ret)'
p6700
as(I25
I25
tp6701
(lp6702
S'\tif (flags & ION_FLAG_SECURE)'
p6703
assg14
(dp6704
(I15
I20
tp6705
(lp6706
S'\t}'
p6707
ag59
aS'\tbuffer = get_buffer(handle);'
p6708
aS'\tmutex_lock(&buffer->lock);'
p6709
aS'\tflags = buffer->flags;'
p6710
aS'\tmutex_unlock(&buffer->lock);'
p6711
as(I25
I25
tp6712
(lp6713
S'\tif (!is_buffer_hlos_assigned(ion_handle_buffer(handle)))'
p6714
as(I28
I28
tp6715
(lp6716
S'\ttable = buffer->sg_table;'
p6717
as(I9
I9
tp6718
(lp6719
S'\tstruct ion_buffer *buffer;'
p6720
as(I11
I13
tp6721
(lp6722
S'\tif (!ion_handle_validate(client, handle)) {'
p6723
aS'\t\tpr_err("%s: invalid handle passed to %s.\\n",'
p6724
aS'\t\t       __func__, __func__);'
p6725
assg32
I6
sg12
g13
sg41
(I1
I43
tp6726
sssS'static int ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,\n\t\t\t   void *uaddr, unsigned long offset, unsigned long len,\n\t\t\t   unsigned int cmd)\n{\n\tint ret = -EINVAL;\n\tunsigned long flags;\n\tstruct sg_table *table;\n\tstruct page *page;\n\n\tret = ion_handle_get_flags(client, handle, &flags);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (!ION_IS_CACHED(flags))\n\t\treturn 0;\n\n\tif (!is_buffer_hlos_assigned(ion_handle_buffer(handle)))\n\t\treturn 0;\n\n\ttable = ion_sg_table(client, handle);\n\n\tif (IS_ERR_OR_NULL(table))\n\t\treturn PTR_ERR(table);\n\n\tpage = sg_page(table->sgl);\n\n\tif (page)\n\t\tret = ion_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t  offset, len, cmd);\n\telse\n\t\tret = ion_no_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t     offset, len, cmd);\n\n\treturn ret;\n}'
p6727
(dp6728
((g6410
g6685
tp6729
I1
tp6730
(dp6731
g12
g13
sg14
(dp6732
(I17
I17
tp6733
(lp6734
S'\tif (!is_buffer_hlos_assigned(ion_handle_buffer(handle)))'
p6735
assg32
I6
sg33
(dp6736
(I17
I17
tp6737
(lp6738
S'\tif (flags & ION_FLAG_SECURE)'
p6739
assg41
(I1
I35
tp6740
sssssS'CVE-2019-10494'
p6741
(dp6742
(S'drivers/media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c'
p6743
S'msm_jpegdma_dqbuf'
p6744
tp6745
(dp6746
S'static int msm_jpegdma_dqbuf(struct file *file,\n\tvoid *fh, struct v4l2_buffer *buf)\n{\n\tstruct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);\n\tint ret;\n\n\tmutex_lock(&ctx->lock);\n\tret = v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);\n\tmutex_unlock(&ctx->lock);\n\treturn ret;\n}'
p6747
(dp6748
((g6743
g6744
tp6749
I1
tp6750
(dp6751
g33
(dp6752
(I7
I7
tp6753
(lp6754
S'\treturn v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);'
p6755
assg14
(dp6756
(I5
I5
tp6757
(lp6758
S'\tint ret;'
p6759
as(I7
I10
tp6760
(lp6761
S'\tmutex_lock(&ctx->lock);'
p6762
aS'\tret = v4l2_m2m_dqbuf(file, ctx->m2m_ctx, buf);'
p6763
aS'\tmutex_unlock(&ctx->lock);'
p6764
aS'\treturn ret;'
p6765
assg32
I3
sg12
g13
sg41
(I1
I11
tp6766
ssss(g6743
S'msm_jpegdma_streamon'
p6767
tp6768
(dp6769
S'static int msm_jpegdma_streamon(struct file *file,\n\tvoid *fh, enum v4l2_buf_type buf_type)\n{\n\tstruct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);\n\tint ret;\n\n\tmutex_lock(&ctx->lock);\n\tif (!msm_jpegdma_config_ok(ctx)) {\n\t\tmutex_unlock(&ctx->lock);\n\t\treturn -EINVAL;\n\t}\n\tret = v4l2_m2m_streamon(file, ctx->m2m_ctx, buf_type);\n\tif (ret < 0)\n\t\tdev_err(ctx->jdma_device->dev, "Stream on fail\\n");\n\tmutex_unlock(&ctx->lock);\n\treturn ret;\n}'
p6770
(dp6771
((g6743
g6767
tp6772
I1
tp6773
(dp6774
g12
g13
sg14
(dp6775
(I15
I15
tp6776
(lp6777
S'\tmutex_unlock(&ctx->lock);'
p6778
as(I11
I11
tp6779
(lp6780
S'\t}'
p6781
as(I7
I9
tp6782
(lp6783
S'\tmutex_lock(&ctx->lock);'
p6784
aS'\tif (!msm_jpegdma_config_ok(ctx)) {'
p6785
aS'\t\tmutex_unlock(&ctx->lock);'
p6786
assg32
I3
sg33
(dp6787
(I15
I15
tp6788
(lp6789
g59
as(I7
I7
tp6790
(lp6791
S'\tif (!msm_jpegdma_config_ok(ctx))'
p6792
as(I11
I11
tp6793
(lp6794
g59
assg41
(I1
I17
tp6795
sssssS'CVE-2019-2308'
p6796
(dp6797
(S'drivers/char/adsprpc.c'
p6798
S'fastrpc_munmap_on_dsp_rh'
p6799
tp6800
(dp6801
S'static int fastrpc_munmap_on_dsp_rh(struct fastrpc_file *fl, uint64_t phys,\n\t\t\t\t\t\tsize_t size, uint32_t flags)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tint tgid = 0;\n\tint destVM[1] = {VMID_HLOS};\n\tint destVMperm[1] = {PERM_READ | PERM_WRITE | PERM_EXEC};\n\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\t\tstruct scm_desc desc = {0};\n\t\tremote_arg_t ra[2];\n\n\t\tstruct {\n\t\t\tuint8_t skey;\n\t\t} routargs;\n\n\t\tif (fl == NULL)\n\t\t\tgoto bail;\n\t\ttgid = fl->tgid;\n\t\tra[0].buf.pv = (void *)&tgid;\n\t\tra[0].buf.len = sizeof(tgid);\n\t\tra[1].buf.pv = (void *)&routargs;\n\t\tra[1].buf.len = sizeof(routargs);\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(9, 1, 1);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\n\n\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.args[3] = routargs.skey;\n\t\tdesc.arginfo = SCM_ARGS(4);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_CLEAR_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\tdestVM, destVMperm, 1));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn err;\n}'
p6802
(dp6803
((g6798
g6799
tp6804
I1
tp6805
(dp6806
g33
(dp6807
(I13
I14
tp6808
(lp6809
S'\t\tremote_arg_t ra[1];'
p6810
aS'\t\tint err = 0;'
p6811
as(I27
I28
tp6812
(lp6813
S'\t\tioctl.inv.handle = 1;'
p6814
aS'\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);'
p6815
as(I19
I20
tp6816
(lp6817
S'\t\tra[0].buf.pv = (void *)&routargs;'
p6818
aS'\t\tra[0].buf.len = sizeof(routargs);'
p6819
as(I33
I34
tp6820
(lp6821
S'\t\tif (fl == NULL)'
p6822
aS'\t\t\tgoto bail;'
p6823
assg14
(dp6824
(I13
I14
tp6825
(lp6826
S'\t\tremote_arg_t ra[2];'
p6827
ag59
as(I19
I25
tp6828
(lp6829
S'\t\tif (fl == NULL)'
p6830
aS'\t\t\tgoto bail;'
p6831
aS'\t\ttgid = fl->tgid;'
p6832
aS'\t\tra[0].buf.pv = (void *)&tgid;'
p6833
aS'\t\tra[0].buf.len = sizeof(tgid);'
p6834
aS'\t\tra[1].buf.pv = (void *)&routargs;'
p6835
aS'\t\tra[1].buf.len = sizeof(routargs);'
p6836
as(I27
I28
tp6837
(lp6838
S'\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6839
aS'\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(9, 1, 1);'
p6840
as(I33
I33
tp6841
(lp6842
g59
as(I6
I6
tp6843
(lp6844
S'\tint tgid = 0;'
p6845
assg32
I4
sg12
g13
sg41
(I1
I57
tp6846
sssS'static int fastrpc_munmap_on_dsp_rh(struct fastrpc_file *fl, uint64_t phys,\n\t\t\t\t\t\tsize_t size, uint32_t flags)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tint tgid = 0;\n\tint destVM[1] = {VMID_HLOS};\n\tint destVMperm[1] = {PERM_READ | PERM_WRITE | PERM_EXEC};\n\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\t\tstruct scm_desc desc = {0};\n\t\tremote_arg_t ra[2];\n\n\t\tstruct {\n\t\t\tuint8_t skey;\n\t\t} routargs;\n\n\t\tif (fl == NULL)\n\t\t\tgoto bail;\n\t\ttgid = fl->tgid;\n\t\tra[0].buf.pv = (void *)&tgid;\n\t\tra[0].buf.len = sizeof(tgid);\n\t\tra[1].buf.pv = (void *)&routargs;\n\t\tra[1].buf.len = sizeof(routargs);\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(9, 1, 1);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\n\n\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err == AEE_EUNSUPPORTED) {\n\t\t\tremote_arg_t ra[1];\n\n\t\t\tpr_warn("ADSPRPC:Failed to get security key with updated remote call, falling back to older method");\n\t\t\tra[0].buf.pv = (void *)&routargs;\n\t\t\tra[0].buf.len = sizeof(routargs);\n\t\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);\n\t\t\tioctl.inv.pra = ra;\n\t\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\t}\n\t\tif (err)\n\t\t\tgoto bail;\n\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.args[3] = routargs.skey;\n\t\tdesc.arginfo = SCM_ARGS(4);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_CLEAR_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\tdestVM, destVMperm, 1));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn err;\n}'
p6847
(dp6848
((g6798
g6799
tp6849
I1
tp6850
(dp6851
g33
(dp6852
(I13
I14
tp6853
(lp6854
S'\t\tremote_arg_t ra[1];'
p6855
aS'\t\tint err = 0;'
p6856
as(I27
I28
tp6857
(lp6858
S'\t\tioctl.inv.handle = 1;'
p6859
aS'\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);'
p6860
as(I19
I20
tp6861
(lp6862
S'\t\tra[0].buf.pv = (void *)&routargs;'
p6863
aS'\t\tra[0].buf.len = sizeof(routargs);'
p6864
as(I33
I34
tp6865
(lp6866
S'\t\tif (fl == NULL)'
p6867
aS'\t\t\tgoto bail;'
p6868
assg14
(dp6869
(I19
I25
tp6870
(lp6871
S'\t\tif (fl == NULL)'
p6872
aS'\t\t\tgoto bail;'
p6873
aS'\t\ttgid = fl->tgid;'
p6874
aS'\t\tra[0].buf.pv = (void *)&tgid;'
p6875
aS'\t\tra[0].buf.len = sizeof(tgid);'
p6876
aS'\t\tra[1].buf.pv = (void *)&routargs;'
p6877
aS'\t\tra[1].buf.len = sizeof(routargs);'
p6878
as(I37
I47
tp6879
(lp6880
S'\t\tif (err == AEE_EUNSUPPORTED) {'
p6881
aS'\t\t\tremote_arg_t ra[1];'
p6882
ag59
aS'\t\t\tpr_warn("ADSPRPC:Failed to get security key with updated remote call, falling back to older method");'
p6883
aS'\t\t\tra[0].buf.pv = (void *)&routargs;'
p6884
aS'\t\t\tra[0].buf.len = sizeof(routargs);'
p6885
aS'\t\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);'
p6886
aS'\t\t\tioctl.inv.pra = ra;'
p6887
aS'\t\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,'
p6888
aS'\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));'
p6889
aS'\t\t}'
p6890
as(I6
I6
tp6891
(lp6892
S'\tint tgid = 0;'
p6893
as(I13
I14
tp6894
(lp6895
S'\t\tremote_arg_t ra[2];'
p6896
ag59
as(I50
I50
tp6897
(lp6898
g59
as(I27
I28
tp6899
(lp6900
S'\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6901
aS'\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(9, 1, 1);'
p6902
as(I33
I33
tp6903
(lp6904
g59
assg32
I4
sg12
g13
sg41
(I1
I69
tp6905
sssS'static int fastrpc_munmap_on_dsp_rh(struct fastrpc_file *fl, uint64_t phys,\n\t\t\t\t\t\tsize_t size, uint32_t flags)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tint destVM[1] = {VMID_HLOS};\n\tint destVMperm[1] = {PERM_READ | PERM_WRITE | PERM_EXEC};\n\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\t\tstruct scm_desc desc = {0};\n\t\tremote_arg_t ra[1];\n\t\tint err = 0;\n\t\tstruct {\n\t\t\tuint8_t skey;\n\t\t} routargs;\n\n\t\tra[0].buf.pv = (void *)&routargs;\n\t\tra[0].buf.len = sizeof(routargs);\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tif (fl == NULL)\n\t\t\tgoto bail;\n\n\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.args[3] = routargs.skey;\n\t\tdesc.arginfo = SCM_ARGS(4);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_CLEAR_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\tdestVM, destVMperm, 1));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn err;\n}'
p6906
(dp6907
((g6798
g6799
tp6908
I1
tp6909
(dp6910
g12
g13
sg14
(dp6911
(I21
I21
tp6912
(lp6913
S'\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6914
assg32
I4
sg33
(dp6915
(I21
I21
tp6916
(lp6917
S'\t\tioctl.inv.handle = 1;'
p6918
assg41
(I1
I52
tp6919
ssss(g6798
S'fastrpc_mmap_on_dsp'
p6920
tp6921
(dp6922
S'static int fastrpc_mmap_on_dsp(struct fastrpc_file *fl, uint32_t flags,\n\t\t\t\t\tuintptr_t va, uint64_t phys,\n\t\t\t\t\tsize_t size, uintptr_t *raddr)\n{\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tstruct fastrpc_apps *me = &gfa;\n\tstruct smq_phy_page page;\n\tint num = 1;\n\tremote_arg_t ra[3];\n\tint err = 0;\n\tstruct {\n\t\tint pid;\n\t\tuint32_t flags;\n\t\tuintptr_t vaddrin;\n\t\tint num;\n\t} inargs;\n\tstruct {\n\t\tuintptr_t vaddrout;\n\t} routargs;\n\n\tinargs.pid = fl->tgid;\n\tinargs.vaddrin = (uintptr_t)va;\n\tinargs.flags = flags;\n\tinargs.num = fl->apps->compat ? num * sizeof(page) : num;\n\tra[0].buf.pv = (void *)&inargs;\n\tra[0].buf.len = sizeof(inargs);\n\tpage.addr = phys;\n\tpage.size = size;\n\tra[1].buf.pv = (void *)&page;\n\tra[1].buf.len = num * sizeof(page);\n\n\tra[2].buf.pv = (void *)&routargs;\n\tra[2].buf.len = sizeof(routargs);\n\n\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\tif (fl->apps->compat)\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(4, 2, 1);\n\telse\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(2, 2, 1);\n\tioctl.inv.pra = ra;\n\tioctl.fds = NULL;\n\tioctl.attrs = NULL;\n\tioctl.crc = NULL;\n\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t*raddr = (uintptr_t)routargs.vaddrout;\n\tif (err)\n\t\tgoto bail;\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct scm_desc desc = {0};\n\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.arginfo = SCM_ARGS(3);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\thlosvm, 1, me->channel[fl->cid].rhvm.vmid,\n\t\t\t\tme->channel[fl->cid].rhvm.vmperm,\n\t\t\t\tme->channel[fl->cid].rhvm.vmcount));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\nbail:\n\treturn err;\n}'
p6923
(dp6924
((g6798
g6920
tp6925
I1
tp6926
(dp6927
g12
g13
sg14
(dp6928
(I35
I35
tp6929
(lp6930
S'\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6931
assg32
I6
sg33
(dp6932
(I35
I35
tp6933
(lp6934
S'\tioctl.inv.handle = 1;'
p6935
assg41
(I1
I68
tp6936
ssss(g6798
S'fastrpc_internal_invoke'
p6937
tp6938
(dp6939
S'static int fastrpc_internal_invoke(struct fastrpc_file *fl, uint32_t mode,\n\t\t\t\t   uint32_t kernel,\n\t\t\t\t   struct fastrpc_ioctl_invoke_crc *inv)\n{\n\tstruct smq_invoke_ctx *ctx = NULL;\n\tstruct fastrpc_ioctl_invoke *invoke = &inv->inv;\n\tint cid = fl->cid;\n\tint interrupted = 0;\n\tint err = 0;\n\tstruct timespec invoket = {0};\n\tint64_t *perf_counter = getperfcounter(fl, PERF_COUNT);\n\n\tif (fl->profile)\n\t\tgetnstimeofday(&invoket);\n\n\tif (!kernel) {\n\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);\n\t\tif (err) {\n\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",\n\t\t\t\t__func__, current->comm, cid);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tVERIFY(err, fl->sctx != NULL);\n\tif (err)\n\t\tgoto bail;\n\tVERIFY(err, fl->cid >= 0 && fl->cid < NUM_CHANNELS);\n\tif (err)\n\t\tgoto bail;\n\n\tif (!kernel) {\n\t\tVERIFY(err, 0 == context_restore_interrupted(fl, inv,\n\t\t\t\t\t\t\t\t&ctx));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (fl->sctx->smmu.faults)\n\t\t\terr = FASTRPC_ENOSUCH;\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (ctx)\n\t\t\tgoto wait;\n\t}\n\n\tVERIFY(err, 0 == context_alloc(fl, kernel, inv, &ctx));\n\tif (err)\n\t\tgoto bail;\n\n\tif (REMOTE_SCALARS_LENGTH(ctx->sc)) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_GETARGS),\n\t\tVERIFY(err, 0 == get_args(kernel, ctx));\n\t\tPERF_END);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tif (!fl->sctx->smmu.coherent) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\t\tinv_args_pre(ctx);\n\t\tPERF_END);\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_LINK),\n\tVERIFY(err, 0 == fastrpc_invoke_send(ctx, kernel, invoke->handle));\n\tPERF_END);\n\n\tif (err)\n\t\tgoto bail;\n wait:\n\tif (kernel)\n\t\twait_for_completion(&ctx->work);\n\telse {\n\t\tinterrupted = wait_for_completion_interruptible(&ctx->work);\n\t\tVERIFY(err, 0 == (err = interrupted));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\tif (!fl->sctx->smmu.coherent)\n\t\tinv_args(ctx);\n\tPERF_END);\n\n\tVERIFY(err, 0 == (err = ctx->retval));\n\tif (err)\n\t\tgoto bail;\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_PUTARGS),\n\tVERIFY(err, 0 == put_args(kernel, ctx, invoke->pra));\n\tPERF_END);\n\tif (err)\n\t\tgoto bail;\n bail:\n\tif (ctx && interrupted == -ERESTARTSYS)\n\t\tcontext_save_interrupted(ctx);\n\telse if (ctx)\n\t\tcontext_free(ctx);\n\tif (fl->ssrcount != fl->apps->channel[cid].ssrcount)\n\t\terr = ECONNRESET;\n\n\tif (fl->profile && !interrupted) {\n\t\tif (invoke->handle != FASTRPC_STATIC_HANDLE_LISTENER) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_INVOKE);\n\n\t\t\tif (count)\n\t\t\t\t*count += getnstimediff(&invoket);\n\t\t}\n\t\tif (invoke->handle > FASTRPC_STATIC_HANDLE_MAX) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_COUNT);\n\n\t\t\tif (count)\n\t\t\t\t*count = *count+1;\n\t\t}\n\t}\n\treturn err;\n}'
p6940
(dp6941
((g6798
g6937
tp6942
I1
tp6943
(dp6944
g14
(dp6945
(I16
I23
tp6946
(lp6947
S'\tif (!kernel) {'
p6948
aS'\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);'
p6949
aS'\t\tif (err) {'
p6950
aS'\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",'
p6951
aS'\t\t\t\t__func__, current->comm, cid);'
p6952
aS'\t\t\tgoto bail;'
p6953
aS'\t\t}'
p6954
aS'\t}'
p6955
assg32
I4
sg12
g13
sg41
(I1
I116
tp6956
sssS'static int fastrpc_internal_invoke(struct fastrpc_file *fl, uint32_t mode,\n\t\t\t\t   uint32_t kernel,\n\t\t\t\t   struct fastrpc_ioctl_invoke_crc *inv)\n{\n\tstruct smq_invoke_ctx *ctx = NULL;\n\tstruct fastrpc_ioctl_invoke *invoke = &inv->inv;\n\tint cid = fl->cid;\n\tint interrupted = 0;\n\tint err = 0;\n\tstruct timespec invoket = {0};\n\tint64_t *perf_counter = getperfcounter(fl, PERF_COUNT);\n\n\tif (fl->profile)\n\t\tgetnstimeofday(&invoket);\n\n\tif (!kernel) {\n\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);\n\t\tif (err) {\n\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",\n\t\t\t\t__func__, current->comm, cid);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tVERIFY(err, fl->sctx != NULL);\n\tif (err)\n\t\tgoto bail;\n\tVERIFY(err, fl->cid >= 0 && fl->cid < NUM_CHANNELS);\n\tif (err)\n\t\tgoto bail;\n\n\tif (!kernel) {\n\t\tVERIFY(err, 0 == context_restore_interrupted(fl, inv,\n\t\t\t\t\t\t\t\t&ctx));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (fl->sctx->smmu.faults)\n\t\t\terr = FASTRPC_ENOSUCH;\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (ctx)\n\t\t\tgoto wait;\n\t}\n\n\tVERIFY(err, 0 == context_alloc(fl, kernel, inv, &ctx));\n\tif (err)\n\t\tgoto bail;\n\n\tif (REMOTE_SCALARS_LENGTH(ctx->sc)) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_GETARGS),\n\t\tVERIFY(err, 0 == get_args(kernel, ctx));\n\t\tPERF_END);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tif (!fl->sctx->smmu.coherent) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\t\tinv_args_pre(ctx);\n\t\tPERF_END);\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_LINK),\n\tVERIFY(err, 0 == fastrpc_invoke_send(ctx, kernel, invoke->handle));\n\tPERF_END);\n\n\tif (err)\n\t\tgoto bail;\n wait:\n\tif (kernel)\n\t\twait_for_completion(&ctx->work);\n\telse {\n\t\tinterrupted = wait_for_completion_interruptible(&ctx->work);\n\t\tVERIFY(err, 0 == (err = interrupted));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\tif (ctx->handle)\n\t\tglink_rx_done(ctx->handle, ctx->ptr, true);\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\tif (!fl->sctx->smmu.coherent)\n\t\tinv_args(ctx);\n\tPERF_END);\n\n\tVERIFY(err, 0 == (err = ctx->retval));\n\tif (err)\n\t\tgoto bail;\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_PUTARGS),\n\tVERIFY(err, 0 == put_args(kernel, ctx, invoke->pra));\n\tPERF_END);\n\tif (err)\n\t\tgoto bail;\n bail:\n\tif (ctx && interrupted == -ERESTARTSYS)\n\t\tcontext_save_interrupted(ctx);\n\telse if (ctx)\n\t\tcontext_free(ctx);\n\tif (fl->ssrcount != fl->apps->channel[cid].ssrcount)\n\t\terr = ECONNRESET;\n\n\tif (fl->profile && !interrupted) {\n\t\tif (invoke->handle != FASTRPC_STATIC_HANDLE_LISTENER) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_INVOKE);\n\n\t\t\tif (count)\n\t\t\t\t*count += getnstimediff(&invoket);\n\t\t}\n\t\tif (invoke->handle > FASTRPC_STATIC_HANDLE_MAX) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_COUNT);\n\n\t\t\tif (count)\n\t\t\t\t*count = *count+1;\n\t\t}\n\t}\n\treturn err;\n}'
p6957
(dp6958
((g6798
g6937
tp6959
I1
tp6960
(dp6961
g33
(dp6962
(I78
I78
tp6963
(lp6964
g59
assg14
(dp6965
(I78
I79
tp6966
(lp6967
S'\tif (ctx->handle)'
p6968
aS'\t\tglink_rx_done(ctx->handle, ctx->ptr, true);'
p6969
as(I16
I23
tp6970
(lp6971
S'\tif (!kernel) {'
p6972
aS'\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);'
p6973
aS'\t\tif (err) {'
p6974
aS'\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",'
p6975
aS'\t\t\t\t__func__, current->comm, cid);'
p6976
aS'\t\t\tgoto bail;'
p6977
aS'\t\t}'
p6978
aS'\t}'
p6979
assg32
I4
sg12
g13
sg41
(I1
I117
tp6980
ssss(g6798
S'fastrpc_init_process'
p6981
tp6982
(dp6983
S'static int fastrpc_init_process(struct fastrpc_file *fl,\n\t\t\t\tstruct fastrpc_ioctl_init_attrs *uproc)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tstruct fastrpc_ioctl_init *init = &uproc->init;\n\tstruct smq_phy_page pages[1];\n\tstruct fastrpc_mmap *file = NULL, *mem = NULL;\n\tstruct fastrpc_buf *imem = NULL;\n\tunsigned long imem_dma_attr = 0;\n\tchar *proc_name = NULL;\n\n\tVERIFY(err, 0 == (err = fastrpc_channel_open(fl)));\n\tif (err)\n\t\tgoto bail;\n\tif (init->flags == FASTRPC_INIT_ATTACH ||\n\t\t\tinit->flags == FASTRPC_INIT_ATTACH_SENSORS) {\n\t\tremote_arg_t ra[1];\n\t\tint tgid = fl->tgid;\n\n\t\tra[0].buf.pv = (void *)&tgid;\n\t\tra[0].buf.len = sizeof(tgid);\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(0, 1, 0);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tif (init->flags == FASTRPC_INIT_ATTACH)\n\t\t\tfl->pd = 0;\n\t\telse if (init->flags == FASTRPC_INIT_ATTACH_SENSORS) {\n\t\t\tfl->spdname = SENSORS_PDR_SERVICE_LOCATION_CLIENT_NAME;\n\t\t\tfl->pd = 2;\n\t\t}\n\t\tVERIFY(err, !(err = fastrpc_internal_invoke(fl,\n\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t} else if (init->flags == FASTRPC_INIT_CREATE) {\n\t\tremote_arg_t ra[6];\n\t\tint fds[6];\n\t\tint mflags = 0;\n\t\tint memlen;\n\t\tstruct {\n\t\t\tint pgid;\n\t\t\tunsigned int namelen;\n\t\t\tunsigned int filelen;\n\t\t\tunsigned int pageslen;\n\t\t\tint attrs;\n\t\t\tint siglen;\n\t\t} inbuf;\n\n\t\tinbuf.pgid = fl->tgid;\n\t\tinbuf.namelen = strlen(current->comm) + 1;\n\t\tinbuf.filelen = init->filelen;\n\t\tfl->pd = 1;\n\n\t\tVERIFY(err, access_ok(0, (void __user *)init->file,\n\t\t\tinit->filelen));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (init->filelen) {\n\t\t\tmutex_lock(&fl->fl_map_mutex);\n\t\t\tVERIFY(err, !fastrpc_mmap_create(fl, init->filefd, 0,\n\t\t\t\tinit->file, init->filelen, mflags, &file));\n\t\t\tmutex_unlock(&fl->fl_map_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t}\n\t\tinbuf.pageslen = 1;\n\n\t\tVERIFY(err, !init->mem);\n\t\tif (err) {\n\t\t\terr = -EINVAL;\n\t\t\tpr_err("adsprpc: %s: %s: ERROR: donated memory allocated in userspace\\n",\n\t\t\t\tcurrent->comm, __func__);\n\t\t\tgoto bail;\n\t\t}\n\t\tmemlen = ALIGN(max(1024*1024*3, (int)init->filelen * 4),\n\t\t\t\t\t\t1024*1024);\n\t\timem_dma_attr = DMA_ATTR_EXEC_MAPPING |\n\t\t\t\t\t\tDMA_ATTR_NO_KERNEL_MAPPING |\n\t\t\t\t\t\tDMA_ATTR_FORCE_NON_COHERENT;\n\t\terr = fastrpc_buf_alloc(fl, memlen, imem_dma_attr, 0, 0, &imem);\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tfl->init_mem = imem;\n\n\t\tinbuf.pageslen = 1;\n\t\tra[0].buf.pv = (void *)&inbuf;\n\t\tra[0].buf.len = sizeof(inbuf);\n\t\tfds[0] = 0;\n\n\t\tra[1].buf.pv = (void *)current->comm;\n\t\tra[1].buf.len = inbuf.namelen;\n\t\tfds[1] = 0;\n\n\t\tra[2].buf.pv = (void *)init->file;\n\t\tra[2].buf.len = inbuf.filelen;\n\t\tfds[2] = init->filefd;\n\n\t\tpages[0].addr = imem->phys;\n\t\tpages[0].size = imem->size;\n\t\tra[3].buf.pv = (void *)pages;\n\t\tra[3].buf.len = 1 * sizeof(*pages);\n\t\tfds[3] = 0;\n\n\t\tinbuf.attrs = uproc->attrs;\n\t\tra[4].buf.pv = (void *)&(inbuf.attrs);\n\t\tra[4].buf.len = sizeof(inbuf.attrs);\n\t\tfds[4] = 0;\n\n\t\tinbuf.siglen = uproc->siglen;\n\t\tra[5].buf.pv = (void *)&(inbuf.siglen);\n\t\tra[5].buf.len = sizeof(inbuf.siglen);\n\t\tfds[5] = 0;\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(6, 4, 0);\n\t\tif (uproc->attrs)\n\t\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 6, 0);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = fds;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tVERIFY(err, !(err = fastrpc_internal_invoke(fl,\n\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t} else if (init->flags == FASTRPC_INIT_CREATE_STATIC) {\n\t\tremote_arg_t ra[3];\n\t\tuint64_t phys = 0;\n\t\tsize_t size = 0;\n\t\tint fds[3];\n\t\tstruct {\n\t\t\tint pgid;\n\t\t\tunsigned int namelen;\n\t\t\tunsigned int pageslen;\n\t\t} inbuf;\n\n\t\tif (!init->filelen)\n\t\t\tgoto bail;\n\n\t\tproc_name = kzalloc(init->filelen, GFP_KERNEL);\n\t\tVERIFY(err, !IS_ERR_OR_NULL(proc_name));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tVERIFY(err, 0 == copy_from_user((void *)proc_name,\n\t\t\t(void __user *)init->file, init->filelen));\n\t\tif (err)\n\t\t\tgoto bail;\n\n\t\tfl->pd = 1;\n\t\tinbuf.pgid = current->tgid;\n\t\tinbuf.namelen = init->filelen;\n\t\tinbuf.pageslen = 0;\n\n\t\tif (!strcmp(proc_name, "audiopd")) {\n\t\t\tfl->spdname = AUDIO_PDR_SERVICE_LOCATION_CLIENT_NAME;\n\t\t\tVERIFY(err, !fastrpc_mmap_remove_pdr(fl));\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!me->staticpd_flags) {\n\t\t\tinbuf.pageslen = 1;\n\t\t\tmutex_lock(&fl->fl_map_mutex);\n\t\t\tVERIFY(err, !fastrpc_mmap_create(fl, -1, 0, init->mem,\n\t\t\t\t init->memlen, ADSP_MMAP_REMOTE_HEAP_ADDR,\n\t\t\t\t &mem));\n\t\t\tmutex_unlock(&fl->fl_map_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t\tphys = mem->phys;\n\t\t\tsize = mem->size;\n\t\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\thlosvm, 1, me->channel[fl->cid].rhvm.vmid,\n\t\t\t\tme->channel[fl->cid].rhvm.vmperm,\n\t\t\t\tme->channel[fl->cid].rhvm.vmcount));\n\t\t\tif (err) {\n\t\t\t\tpr_err("ADSPRPC: hyp_assign_phys fail err %d",\n\t\t\t\t\t\t\t err);\n\t\t\t\tpr_err("map->phys %llx, map->size %d\\n",\n\t\t\t\t\t\t\t phys, (int)size);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tme->staticpd_flags = 1;\n\t\t}\n\n\t\tra[0].buf.pv = (void *)&inbuf;\n\t\tra[0].buf.len = sizeof(inbuf);\n\t\tfds[0] = 0;\n\n\t\tra[1].buf.pv = (void *)proc_name;\n\t\tra[1].buf.len = inbuf.namelen;\n\t\tfds[1] = 0;\n\n\t\tpages[0].addr = phys;\n\t\tpages[0].size = size;\n\n\t\tra[2].buf.pv = (void *)pages;\n\t\tra[2].buf.len = sizeof(*pages);\n\t\tfds[2] = 0;\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(8, 3, 0);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tVERIFY(err, !(err = fastrpc_internal_invoke(fl,\n\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t} else {\n\t\terr = -ENOTTY;\n\t}\nbail:\n\tkfree(proc_name);\n\tif (err && (init->flags == FASTRPC_INIT_CREATE_STATIC))\n\t\tme->staticpd_flags = 0;\n\tif (mem && err) {\n\t\tif (mem->flags == ADSP_MMAP_REMOTE_HEAP_ADDR)\n\t\t\thyp_assign_phys(mem->phys, (uint64_t)mem->size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\thlosvm, hlosvmperm, 1);\n\t\tmutex_lock(&fl->fl_map_mutex);\n\t\tfastrpc_mmap_free(mem, 0);\n\t\tmutex_unlock(&fl->fl_map_mutex);\n\t}\n\tif (file) {\n\t\tmutex_lock(&fl->fl_map_mutex);\n\t\tfastrpc_mmap_free(file, 0);\n\t\tmutex_unlock(&fl->fl_map_mutex);\n\t}\n\treturn err;\n}'
p6984
(dp6985
((g6798
g6981
tp6986
I1
tp6987
(dp6988
g12
g13
sg14
(dp6989
(I24
I24
tp6990
(lp6991
S'\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6992
as(I119
I119
tp6993
(lp6994
S'\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6995
as(I205
I205
tp6996
(lp6997
S'\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p6998
assg32
I2
sg33
(dp6999
(I24
I24
tp7000
(lp7001
S'\t\tioctl.inv.handle = 1;'
p7002
as(I119
I119
tp7003
(lp7004
S'\t\tioctl.inv.handle = 1;'
p7005
as(I205
I205
tp7006
(lp7007
S'\t\tioctl.inv.handle = 1;'
p7008
assg41
(I1
I239
tp7009
ssss(g6798
S'fastrpc_release_current_dsp_process'
p7010
tp7011
(dp7012
S'static int fastrpc_release_current_dsp_process(struct fastrpc_file *fl)\n{\n\tint err = 0;\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tremote_arg_t ra[1];\n\tint tgid = 0;\n\n\tVERIFY(err, fl->cid >= 0 && fl->cid < NUM_CHANNELS);\n\tif (err)\n\t\tgoto bail;\n\tVERIFY(err, fl->apps->channel[fl->cid].chan != NULL);\n\tif (err)\n\t\tgoto bail;\n\ttgid = fl->tgid;\n\tra[0].buf.pv = (void *)&tgid;\n\tra[0].buf.len = sizeof(tgid);\n\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\tioctl.inv.sc = REMOTE_SCALARS_MAKE(1, 1, 0);\n\tioctl.inv.pra = ra;\n\tioctl.fds = NULL;\n\tioctl.attrs = NULL;\n\tioctl.crc = NULL;\n\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\nbail:\n\treturn err;\n}'
p7013
(dp7014
((g6798
g7010
tp7015
I1
tp7016
(dp7017
g12
g13
sg14
(dp7018
(I17
I17
tp7019
(lp7020
S'\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p7021
assg32
I1
sg33
(dp7022
(I17
I17
tp7023
(lp7024
S'\tioctl.inv.handle = 1;'
p7025
assg41
(I1
I27
tp7026
ssss(g6798
S'fastrpc_munmap_on_dsp'
p7027
tp7028
(dp7029
S'static int fastrpc_munmap_on_dsp(struct fastrpc_file *fl, uintptr_t raddr,\n\t\t\t\tuint64_t phys, size_t size, uint32_t flags)\n{\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tremote_arg_t ra[1];\n\tint err = 0;\n\tstruct {\n\t\tint pid;\n\t\tuintptr_t vaddrout;\n\t\tsize_t size;\n\t} inargs;\n\n\tinargs.pid = fl->tgid;\n\tinargs.size = size;\n\tinargs.vaddrout = raddr;\n\tra[0].buf.pv = (void *)&inargs;\n\tra[0].buf.len = sizeof(inargs);\n\n\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\tif (fl->apps->compat)\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(5, 1, 0);\n\telse\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(3, 1, 0);\n\tioctl.inv.pra = ra;\n\tioctl.fds = NULL;\n\tioctl.attrs = NULL;\n\tioctl.crc = NULL;\n\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\tif (err)\n\t\tgoto bail;\n\tif (flags == ADSP_MMAP_HEAP_ADDR ||\n\t\t\t\tflags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !fastrpc_munmap_on_dsp_rh(fl, phys, size, flags));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\nbail:\n\treturn err;\n}'
p7030
(dp7031
((g6798
g7027
tp7032
I1
tp7033
(dp7034
g12
g13
sg14
(dp7035
(I19
I19
tp7036
(lp7037
S'\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;'
p7038
assg32
I5
sg33
(dp7039
(I19
I19
tp7040
(lp7041
S'\tioctl.inv.handle = 1;'
p7042
assg41
(I1
I40
tp7043
sssssS'CVE-2019-10544'
p7044
(dp7045
(S'drivers/char/diag/diag_masks.c'
p7046
S'diag_cmd_get_msg_mask'
p7047
tp7048
(dp7049
S'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p7050
(dp7051
((g7046
g7047
tp7052
I1
tp7053
(dp7054
g12
g13
sg14
(dp7055
(I19
I19
tp7056
(lp7057
S'\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {'
p7058
assg32
I5
sg33
(dp7059
(I19
I19
tp7060
(lp7061
S'\t    !mask_info) {'
p7062
assg41
(I1
I76
tp7063
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p7064
(dp7065
((g7046
g7047
tp7066
I1
tp7067
(dp7068
g12
g13
sg14
(dp7069
(I18
I19
tp7070
(lp7071
S'\tif (!src_buf || !dest_buf || dest_len <= 0 ||'
p7072
aS'\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {'
p7073
assg32
I5
sg33
(dp7074
(I18
I19
tp7075
(lp7076
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p7077
aS'\t    !mask_info) {'
p7078
assg41
(I1
I76
tp7079
sssssS'CVE-2019-10547'
p7080
(dp7081
(S'drivers/soc/qcom/secure_buffer.c'
p7082
S'batched_hyp_assign'
p7083
tp7084
(dp7085
s(g7082
S'hyp_assign_table'
p7086
tp7087
(dp7088
S'int hyp_assign_table(struct sg_table *table,\n\t\t\tu32 *source_vm_list, int source_nelems,\n\t\t\tint *dest_vmids, int *dest_perms,\n\t\t\tint dest_nelems)\n{\n\tint ret = 0;\n\tstruct scm_desc desc = {0};\n\tu32 *source_vm_copy;\n\tsize_t source_vm_copy_size;\n\tstruct dest_vm_and_perm_info *dest_vm_copy;\n\tsize_t dest_vm_copy_size;\n\n\tif (!table || !table->sgl || !source_vm_list || !source_nelems ||\n\t    !dest_vmids || !dest_perms || !dest_nelems)\n\t\treturn -EINVAL;\n\n\t/*\n\t * We can only pass cache-aligned sizes to hypervisor, so we need\n\t * to kmalloc and memcpy the source_vm_list here.\n\t */\n\tsource_vm_copy_size = sizeof(*source_vm_copy) * source_nelems;\n\tsource_vm_copy = kzalloc(source_vm_copy_size, GFP_KERNEL);\n\tif (!source_vm_copy)\n\t\treturn -ENOMEM;\n\n\tmemcpy(source_vm_copy, source_vm_list, source_vm_copy_size);\n\n\n\tdest_vm_copy = populate_dest_info(dest_vmids, dest_nelems, dest_perms,\n\t\t\t\t\t  &dest_vm_copy_size);\n\tif (!dest_vm_copy) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free_source;\n\t}\n\n\tmutex_lock(&secure_buffer_mutex);\n\n\tdesc.args[2] = virt_to_phys(source_vm_copy);\n\tdesc.args[3] = source_vm_copy_size;\n\tdesc.args[4] = virt_to_phys(dest_vm_copy);\n\tdesc.args[5] = dest_vm_copy_size;\n\tdesc.args[6] = 0;\n\n\tdesc.arginfo = SCM_ARGS(7, SCM_RO, SCM_VAL, SCM_RO, SCM_VAL, SCM_RO,\n\t\t\t\tSCM_VAL, SCM_VAL);\n\n\tdmac_flush_range(source_vm_copy,\n\t\t\t (void *)source_vm_copy + source_vm_copy_size);\n\tdmac_flush_range(dest_vm_copy,\n\t\t\t (void *)dest_vm_copy + dest_vm_copy_size);\n\n\tret = batched_hyp_assign(table, &desc);\n\n\tmutex_unlock(&secure_buffer_mutex);\n\tkfree(dest_vm_copy);\nout_free_source:\n\tkfree(source_vm_copy);\n\treturn ret;\n}'
p7089
(dp7090
((g7082
g7086
tp7091
I1
tp7092
(dp7093
g12
g13
sg14
(dp7094
(I56
I56
tp7095
(lp7096
S'out_free_source:'
p7097
as(I13
I15
tp7098
(lp7099
S'\tif (!table || !table->sgl || !source_vm_list || !source_nelems ||'
p7100
aS'\t    !dest_vmids || !dest_perms || !dest_nelems)'
p7101
aS'\t\treturn -EINVAL;'
p7102
as(I52
I52
tp7103
(lp7104
S'\tret = batched_hyp_assign(table, &desc);'
p7105
as(I33
I33
tp7106
(lp7107
S'\t\tgoto out_free_source;'
p7108
assg32
I6
sg33
(dp7109
(I49
I50
tp7110
(lp7111
S'\tdmac_flush_range(sg_table_copy,'
p7112
aS'\t\t\t (void *)sg_table_copy + sg_table_copy_size);'
p7113
as(I13
I14
tp7114
(lp7115
S'\tint batch_start, batch_end;'
p7116
aS'\tu64 batch_size;'
p7117
as(I56
I56
tp7118
(lp7119
S'out_free:'
p7120
as(I38
I45
tp7121
(lp7122
S'\tsg_table_copy = get_info_list_from_table(table, &sg_table_copy_size);'
p7123
aS'\tif (!sg_table_copy) {'
p7124
aS'\t\tret = -ENOMEM;'
p7125
aS'\t\tgoto out_unlock;'
p7126
aS'\t}'
p7127
ag59
aS'\tdesc.args[0] = virt_to_phys(sg_table_copy);'
p7128
aS'\tdesc.args[1] = sg_table_copy_size;'
p7129
as(I54
I54
tp7130
(lp7131
S'out_unlock:'
p7132
as(I12
I13
tp7133
(lp7134
S'\tstruct mem_prot_info *sg_table_copy;'
p7135
aS'\tsize_t sg_table_copy_size;'
p7136
as(I52
I85
tp7137
(lp7138
S'\tbatch_start = 0;'
p7139
aS'\twhile (batch_start < table->nents) {'
p7140
aS'\t\t/* Ensure no size zero batches */'
p7141
aS'\t\tbatch_size = sg_table_copy[batch_start].size;'
p7142
aS'\t\tbatch_end = batch_start + 1;'
p7143
aS'\t\twhile (1) {'
p7144
aS'\t\t\tu64 size;'
p7145
ag59
aS'\t\t\tif (batch_end >= table->nents)'
p7146
aS'\t\t\t\tbreak;'
p7147
aS'\t\t\tif (batch_end - batch_start >= BATCH_MAX_SECTIONS)'
p7148
aS'\t\t\t\tbreak;'
p7149
ag59
aS'\t\t\tsize = sg_table_copy[batch_end].size;'
p7150
aS'\t\t\tif (size + batch_size >= BATCH_MAX_SIZE)'
p7151
aS'\t\t\t\tbreak;'
p7152
ag59
aS'\t\t\tbatch_size += size;'
p7153
aS'\t\t\tbatch_end++;'
p7154
aS'\t\t}'
p7155
ag59
aS'\t\tdesc.args[0] = virt_to_phys(&sg_table_copy[batch_start]);'
p7156
aS'\t\tdesc.args[1] = (batch_end - batch_start) *'
p7157
aS'\t\t\t\tsizeof(sg_table_copy[0]);'
p7158
ag59
aS'\t\tret = scm_call2(SCM_SIP_FNID(SCM_SVC_MP,'
p7159
aS'\t\t\t\tMEM_PROT_ASSIGN_ID), &desc);'
p7160
aS'\t\tif (ret) {'
p7161
aS'\t\t\tpr_info("%s: Failed to assign memory protection, ret = %d\\n",'
p7162
aS'\t\t\t\t__func__, ret);'
p7163
aS'\t\t\tbreak;'
p7164
aS'\t\t}'
p7165
aS'\t\tbatch_start = batch_end;'
p7166
aS'\t}'
p7167
as(I33
I33
tp7168
(lp7169
S'\t\tgoto out_free;'
p7170
assg41
(I1
I59
tp7171
ssss(g7082
S'get_batches_from_sgl'
p7172
tp7173
(dp7174
ssS'CVE-2018-11919'
p7175
(dp7176
(S'drivers/soc/qcom/msm_bus/msm_bus_fabric_adhoc.c'
p7177
S'msm_bus_device_init'
p7178
tp7179
(dp7180
S'static struct device *msm_bus_device_init(\n\t\t\tstruct msm_bus_node_device_type *pdata)\n{\n\tstruct device *bus_dev = NULL;\n\tstruct msm_bus_node_device_type *bus_node = NULL;\n\tstruct msm_bus_node_info_type *node_info = NULL;\n\tint ret = 0;\n\n\t/**\n\t* Init here so we can use devm calls\n\t*/\n\n\tbus_node = kzalloc(sizeof(struct msm_bus_node_device_type), GFP_KERNEL);\n\tif (!bus_node) {\n\t\tret = -ENOMEM;\n\t\tgoto err_device_init;\n\t}\n\tbus_dev = &bus_node->dev;\n\tdevice_initialize(bus_dev);\n\n\tnode_info = devm_kzalloc(bus_dev,\n\t\t\tsizeof(struct msm_bus_node_info_type), GFP_KERNEL);\n\tif (!node_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_device;\n\t}\n\n\tbus_node->node_info = node_info;\n\tbus_node->ap_owned = pdata->ap_owned;\n\tbus_dev->of_node = pdata->of_node;\n\n\tret = msm_bus_copy_node_info(pdata, bus_dev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tbus_dev->bus = &msm_bus_type;\n\tdev_set_name(bus_dev, bus_node->node_info->name);\n\n\tret = device_add(bus_dev);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error registering device %d",\n\t\t\t\t__func__, pdata->node_info->id);\n\t\tgoto err_put_device;\n\t}\n\tdevice_create_file(bus_dev, &dev_attr_bw);\n\tINIT_LIST_HEAD(&bus_node->devlist);\n\treturn bus_dev;\n\nerr_put_device:\n\tput_device(bus_dev);\n\tbus_dev = NULL;\n\tkfree(bus_node);\nerr_device_init:\n\treturn ERR_PTR(ret);\n}'
p7181
(dp7182
((g7177
g7178
tp7183
I1
tp7184
(dp7185
g12
g13
sg14
(dp7186
(I24
I25
tp7187
(lp7188
S'\t\tret = -ENOMEM;'
p7189
aS'\t\tgoto err_put_device;'
p7190
as(I48
I54
tp7191
(lp7192
g59
aS'err_put_device:'
p7193
aS'\tput_device(bus_dev);'
p7194
aS'\tbus_dev = NULL;'
p7195
aS'\tkfree(bus_node);'
p7196
aS'err_device_init:'
p7197
aS'\treturn ERR_PTR(ret);'
p7198
as(I40
I40
tp7199
(lp7200
S'\tif (ret) {'
p7201
as(I43
I43
tp7202
(lp7203
S'\t\tgoto err_put_device;'
p7204
as(I15
I16
tp7205
(lp7206
S'\t\tret = -ENOMEM;'
p7207
aS'\t\tgoto err_device_init;'
p7208
as(I32
I34
tp7209
(lp7210
S'\tret = msm_bus_copy_node_info(pdata, bus_dev);'
p7211
aS'\tif (ret)'
p7212
aS'\t\tgoto err_put_device;'
p7213
assg32
I1
sg33
(dp7214
(I32
I38
tp7215
(lp7216
S'\tif (msm_bus_copy_node_info(pdata, bus_dev) < 0) {'
p7217
aS'\t\tdevm_kfree(bus_dev, bus_node);'
p7218
aS'\t\tdevm_kfree(bus_dev, node_info);'
p7219
aS'\t\tkfree(bus_dev);'
p7220
aS'\t\tbus_dev = NULL;'
p7221
aS'\t\tgoto exit_device_init;'
p7222
aS'\t}'
p7223
as(I40
I40
tp7224
(lp7225
S'\tif (ret < 0) {'
p7226
as(I15
I18
tp7227
(lp7228
S'\t\tMSM_BUS_ERR("%s:Bus node alloc failed\\n", __func__);'
p7229
aS'\t\tkfree(bus_dev);'
p7230
aS'\t\tbus_dev = NULL;'
p7231
aS'\t\tgoto exit_device_init;'
p7232
as(I24
I28
tp7233
(lp7234
S'\t\tMSM_BUS_ERR("%s:Bus node info alloc failed\\n", __func__);'
p7235
aS'\t\tdevm_kfree(bus_dev, bus_node);'
p7236
aS'\t\tkfree(bus_dev);'
p7237
aS'\t\tbus_dev = NULL;'
p7238
aS'\t\tgoto exit_device_init;'
p7239
as(I47
I48
tp7240
(lp7241
g59
aS'exit_device_init:'
p7242
as(I43
I51
tp7243
(lp7244
S'\t\tdevm_kfree(bus_dev, bus_node);'
p7245
aS'\t\tdevm_kfree(bus_dev, node_info->dev_connections);'
p7246
aS'\t\tdevm_kfree(bus_dev, node_info->connections);'
p7247
aS'\t\tdevm_kfree(bus_dev, node_info->black_connections);'
p7248
aS'\t\tdevm_kfree(bus_dev, node_info->black_listed_connections);'
p7249
aS'\t\tdevm_kfree(bus_dev, node_info);'
p7250
aS'\t\tkfree(bus_dev);'
p7251
aS'\t\tbus_dev = NULL;'
p7252
aS'\t\tgoto exit_device_init;'
p7253
assg41
(I1
I55
tp7254
ssss(g7177
S'msm_bus_device_probe'
p7255
tp7256
(dp7257
S'static int msm_bus_device_probe(struct platform_device *pdev)\n{\n\tunsigned int i, ret;\n\tstruct msm_bus_device_node_registration *pdata;\n\n\t/* If possible, get pdata from device-tree */\n\tif (pdev->dev.of_node)\n\t\tpdata = msm_bus_of_to_pdata(pdev);\n\telse {\n\t\tpdata = (struct msm_bus_device_node_registration *)pdev->\n\t\t\tdev.platform_data;\n\t}\n\n\tif (IS_ERR_OR_NULL(pdata)) {\n\t\tMSM_BUS_ERR("No platform data found");\n\t\tret = -ENODATA;\n\t\tgoto exit_device_probe;\n\t}\n\n\tfor (i = 0; i < pdata->num_devices; i++) {\n\t\tstruct device *node_dev = NULL;\n\n\t\tnode_dev = msm_bus_device_init(&pdata->info[i]);\n\n\t\tif (IS_ERR(node_dev)) {\n\t\t\tMSM_BUS_ERR("%s: Error during dev init for %d",\n\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\tret = PTR_ERR(node_dev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\n\t\tret = msm_bus_init_clk(node_dev, &pdata->info[i]);\n\t\tif (ret) {\n\t\t\tMSM_BUS_ERR("\\n Failed to init bus clk. ret %d", ret);\n\t\t\tmsm_bus_device_remove(pdev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\t\t/*Is this a fabric device ?*/\n\t\tif (pdata->info[i].node_info->is_fab_dev) {\n\t\t\tMSM_BUS_DBG("%s: %d is a fab", __func__,\n\t\t\t\t\t\tpdata->info[i].node_info->id);\n\t\t\tret = msm_bus_fabric_init(node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing fab %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL,\n\t\t\t\t\t\tmsm_bus_setup_dev_conn);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error setting up dev connections", __func__);\n\t\tgoto exit_device_probe;\n\t}\n\n\t/*\n\t * Setup the QoS for the nodes, don\'t check the error codes as we\n\t * defer QoS programming to the first transaction in cases of failure\n\t * and we want to continue the probe.\n\t */\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);\n\n\t/* Register the arb layer ops */\n\tmsm_bus_arb_setops_adhoc(&arb_ops);\n\tbus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);\n\n\tdevm_kfree(&pdev->dev, pdata->info);\n\tdevm_kfree(&pdev->dev, pdata);\n\n\tdev_info(&pdev->dev, "Bus scaling driver probe successful\\n");\n\nexit_device_probe:\n\treturn ret;\n}'
p7258
(dp7259
((g7177
g7255
tp7260
I1
tp7261
(dp7262
g12
g13
sg14
(dp7263
(I28
I28
tp7264
(lp7265
S'\t\t\tret = PTR_ERR(node_dev);'
p7266
as(I25
I25
tp7267
(lp7268
S'\t\tif (IS_ERR(node_dev)) {'
p7269
assg32
I1
sg33
(dp7270
(I28
I28
tp7271
(lp7272
S'\t\t\tret = -ENXIO;'
p7273
as(I25
I25
tp7274
(lp7275
S'\t\tif (!node_dev) {'
p7276
assg41
(I1
I76
tp7277
ssss(S'drivers/soc/qcom/msm_bus/msm_bus_fabric_rpmh.c'
p7278
S'msm_bus_device_init'
p7279
tp7280
(dp7281
S'static struct device *msm_bus_device_init(\n\t\t\tstruct msm_bus_node_device_type *pdata)\n{\n\tstruct device *bus_dev = NULL;\n\tstruct msm_bus_node_device_type *bus_node = NULL;\n\tstruct msm_bus_node_info_type *node_info = NULL;\n\tint ret = -ENODEV, i = 0;\n\n\t/**\n\t* Init here so we can use devm calls\n\t*/\n\n\tbus_node = kzalloc(sizeof(struct msm_bus_node_device_type), GFP_KERNEL);\n\tif (!bus_node) {\n\t\tret = -ENOMEM;\n\t\tgoto err_device_init;\n\t}\n\tbus_dev = &bus_node->dev;\n\tdevice_initialize(bus_dev);\n\n\tnode_info = devm_kzalloc(bus_dev,\n\t\t\tsizeof(struct msm_bus_node_info_type), GFP_KERNEL);\n\tif (!node_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_device;\n\t}\n\n\tbus_node->node_info = node_info;\n\tbus_node->ap_owned = pdata->ap_owned;\n\tbus_node->dirty = false;\n\tbus_node->num_qos_bcms = pdata->num_qos_bcms;\n\tif (bus_node->num_qos_bcms) {\n\t\tbus_node->qos_bcms = devm_kzalloc(bus_dev,\n\t\t\t\t\t(sizeof(struct qos_bcm_type) *\n\t\t\t\t\tbus_node->num_qos_bcms), GFP_KERNEL);\n\t\tif (!bus_node->qos_bcms) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_put_device;\n\t\t}\n\t\tfor (i = 0; i < bus_node->num_qos_bcms; i++) {\n\t\t\tbus_node->qos_bcms[i].qos_bcm_id =\n\t\t\t\t\tpdata->qos_bcms[i].qos_bcm_id;\n\t\t\tbus_node->qos_bcms[i].vec.vec_a =\n\t\t\t\t\tpdata->qos_bcms[i].vec.vec_a;\n\t\t\tbus_node->qos_bcms[i].vec.vec_b =\n\t\t\t\t\tpdata->qos_bcms[i].vec.vec_b;\n\t\t}\n\t}\n\n\tbus_dev->of_node = pdata->of_node;\n\n\tret = msm_bus_copy_node_info(pdata, bus_dev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tbus_dev->bus = &msm_bus_type;\n\tdev_set_name(bus_dev, bus_node->node_info->name);\n\n\tret = device_add(bus_dev);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error registering device %d",\n\t\t\t\t__func__, pdata->node_info->id);\n\t\tgoto err_put_device;\n\t}\n\tdevice_create_file(bus_dev, &dev_attr_bw);\n\tINIT_LIST_HEAD(&bus_node->devlist);\n\treturn bus_dev;\n\nerr_put_device:\n\tput_device(bus_dev);\n\tbus_dev = NULL;\n\tkfree(bus_node);\nerr_device_init:\n\treturn ERR_PTR(ret);\n}'
p7282
(dp7283
((g7278
g7279
tp7284
I1
tp7285
(dp7286
g12
g13
sg14
(dp7287
(I24
I25
tp7288
(lp7289
S'\t\tret = -ENOMEM;'
p7290
aS'\t\tgoto err_put_device;'
p7291
as(I68
I74
tp7292
(lp7293
g59
aS'err_put_device:'
p7294
aS'\tput_device(bus_dev);'
p7295
aS'\tbus_dev = NULL;'
p7296
aS'\tkfree(bus_node);'
p7297
aS'err_device_init:'
p7298
aS'\treturn ERR_PTR(ret);'
p7299
as(I36
I39
tp7300
(lp7301
S'\t\tif (!bus_node->qos_bcms) {'
p7302
aS'\t\t\tret = -ENOMEM;'
p7303
aS'\t\t\tgoto err_put_device;'
p7304
aS'\t\t}'
p7305
as(I52
I54
tp7306
(lp7307
S'\tret = msm_bus_copy_node_info(pdata, bus_dev);'
p7308
aS'\tif (ret)'
p7309
aS'\t\tgoto err_put_device;'
p7310
as(I60
I60
tp7311
(lp7312
S'\tif (ret) {'
p7313
as(I15
I16
tp7314
(lp7315
S'\t\tret = -ENOMEM;'
p7316
aS'\t\tgoto err_device_init;'
p7317
as(I7
I7
tp7318
(lp7319
S'\tint ret = -ENODEV, i = 0;'
p7320
as(I63
I63
tp7321
(lp7322
S'\t\tgoto err_put_device;'
p7323
assg32
I1
sg33
(dp7324
(I52
I58
tp7325
(lp7326
S'\tif (msm_bus_copy_node_info(pdata, bus_dev) < 0) {'
p7327
aS'\t\tdevm_kfree(bus_dev, bus_node);'
p7328
aS'\t\tdevm_kfree(bus_dev, node_info);'
p7329
aS'\t\tkfree(bus_dev);'
p7330
aS'\t\tbus_dev = NULL;'
p7331
aS'\t\tgoto exit_device_init;'
p7332
aS'\t}'
p7333
as(I63
I71
tp7334
(lp7335
S'\t\tdevm_kfree(bus_dev, bus_node);'
p7336
aS'\t\tdevm_kfree(bus_dev, node_info->dev_connections);'
p7337
aS'\t\tdevm_kfree(bus_dev, node_info->connections);'
p7338
aS'\t\tdevm_kfree(bus_dev, node_info->black_connections);'
p7339
aS'\t\tdevm_kfree(bus_dev, node_info->black_listed_connections);'
p7340
aS'\t\tdevm_kfree(bus_dev, node_info);'
p7341
aS'\t\tkfree(bus_dev);'
p7342
aS'\t\tbus_dev = NULL;'
p7343
aS'\t\tgoto exit_device_init;'
p7344
as(I15
I18
tp7345
(lp7346
S'\t\tMSM_BUS_ERR("%s:Bus node alloc failed\\n", __func__);'
p7347
aS'\t\tkfree(bus_dev);'
p7348
aS'\t\tbus_dev = NULL;'
p7349
aS'\t\tgoto exit_device_init;'
p7350
as(I24
I28
tp7351
(lp7352
S'\t\tMSM_BUS_ERR("%s:Bus node info alloc failed\\n", __func__);'
p7353
aS'\t\tdevm_kfree(bus_dev, bus_node);'
p7354
aS'\t\tkfree(bus_dev);'
p7355
aS'\t\tbus_dev = NULL;'
p7356
aS'\t\tgoto exit_device_init;'
p7357
as(I36
I37
tp7358
(lp7359
S'\t\tif (!bus_node->qos_bcms)'
p7360
aS'\t\t\tgoto exit_device_init;'
p7361
as(I60
I60
tp7362
(lp7363
S'\tif (ret < 0) {'
p7364
as(I67
I68
tp7365
(lp7366
g59
aS'exit_device_init:'
p7367
as(I7
I7
tp7368
(lp7369
S'\tint ret = 0, i = 0;'
p7370
assg41
(I1
I75
tp7371
ssss(g7278
S'msm_bus_device_probe'
p7372
tp7373
(dp7374
S'static int msm_bus_device_probe(struct platform_device *pdev)\n{\n\tunsigned int i = 1, ret;\n\tstruct msm_bus_device_node_registration *pdata;\n\n\tMSM_BUS_ERR("msm_bus: Probe started");\n\t/* If possible, get pdata from device-tree */\n\tif (pdev->dev.of_node)\n\t\tpdata = msm_bus_of_to_pdata(pdev);\n\telse {\n\t\tpdata = (struct msm_bus_device_node_registration *)pdev->\n\t\t\tdev.platform_data;\n\t}\n\n\tMSM_BUS_ERR("msm_bus: DT Parsing complete");\n\n\tif (IS_ERR_OR_NULL(pdata)) {\n\t\tMSM_BUS_ERR("No platform data found");\n\t\tret = -ENODATA;\n\t\tgoto exit_device_probe;\n\t}\n\n\tfor (i = 0; i < pdata->num_devices; i++) {\n\t\tstruct device *node_dev = NULL;\n\n\t\tnode_dev = msm_bus_device_init(&pdata->info[i]);\n\n\t\tif (IS_ERR(node_dev)) {\n\t\t\tMSM_BUS_ERR("%s: Error during dev init for %d",\n\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\tret = PTR_ERR(node_dev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\n\t\tret = msm_bus_init_clk(node_dev, &pdata->info[i]);\n\t\tif (ret) {\n\t\t\tMSM_BUS_ERR("\\n Failed to init bus clk. ret %d", ret);\n\t\t\tmsm_bus_device_remove(pdev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\t\t/*Is this a fabric device ?*/\n\t\tif (pdata->info[i].node_info->is_fab_dev) {\n\t\t\tMSM_BUS_DBG("%s: %d is a fab", __func__,\n\t\t\t\t\t\tpdata->info[i].node_info->id);\n\t\t\tret = msm_bus_fabric_init(node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing fab %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t\tif (pdata->info[i].node_info->is_bcm_dev) {\n\t\t\tret = msm_bus_bcm_init(node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing bcm %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t\tif (pdata->info[i].node_info->is_rsc_dev) {\n\t\t\tret = msm_bus_rsc_init(pdev, node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing rsc %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL,\n\t\t\t\t\t\tmsm_bus_setup_dev_conn);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error setting up dev connections", __func__);\n\t\tgoto exit_device_probe;\n\t}\n\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL,\n\t\t\t\t\t\tmsm_bus_postcon_setup);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error post connection setup", __func__);\n\t\tgoto exit_device_probe;\n\t}\n\n\t/*\n\t * Setup the QoS for the nodes, don\'t check the error codes as we\n\t * defer QoS programming to the first transaction in cases of failure\n\t * and we want to continue the probe.\n\t */\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);\n\n\t/* Register the arb layer ops */\n\tmsm_bus_arb_setops_adhoc(&arb_ops);\n\tbus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);\n\n\tdevm_kfree(&pdev->dev, pdata->info);\n\tdevm_kfree(&pdev->dev, pdata);\nexit_device_probe:\n\treturn ret;\n}'
p7375
(dp7376
((g7278
g7372
tp7377
I1
tp7378
(dp7379
g12
g13
sg14
(dp7380
(I28
I28
tp7381
(lp7382
S'\t\tif (IS_ERR(node_dev)) {'
p7383
as(I31
I31
tp7384
(lp7385
S'\t\t\tret = PTR_ERR(node_dev);'
p7386
assg32
I1
sg33
(dp7387
(I28
I28
tp7388
(lp7389
S'\t\tif (!node_dev) {'
p7390
as(I31
I31
tp7391
(lp7392
S'\t\t\tret = -ENXIO;'
p7393
assg41
(I1
I99
tp7394
sssssS'CVE-2019-2301'
p7395
(dp7396
(S'drivers/soc/qcom/glink_spi_xprt.c'
p7397
S'glink_spi_xprt_rx_cmd'
p7398
tp7399
(dp7400
S'static int glink_spi_xprt_rx_cmd(struct edge_info *einfo, void *dst,\n\t\t\t\t uint32_t size)\n{\n\tuint32_t read_id;\n\tuint32_t size_to_read = size;\n\tuint32_t offset = 0;\n\tint ret;\n\n\tread_id = einfo->rx_fifo_read;\n\tif ((read_id > (einfo->rx_fifo_start + einfo->fifo_size)) ||\n\t\t(read_id < einfo->rx_fifo_start)) {\n\t\tpr_err("%s: Invalid rx_fifo_read: %d, start: %d, size: %d\\n",\n\t\t\t__func__, read_id, einfo->rx_fifo_start,\n\t\t\teinfo->fifo_size);\n\t\treturn -EINVAL;\n\t}\n\tdo {\n\t\tif ((read_id + size_to_read) >=\n\t\t    (einfo->rx_fifo_start + einfo->fifo_size))\n\t\t\tsize_to_read = einfo->rx_fifo_start + einfo->fifo_size\n\t\t\t\t\t- read_id;\n\t\tret = glink_spi_xprt_rx_data(einfo, (void *)(size_t)read_id,\n\t\t\t\t\t     dst + offset, size_to_read);\n\t\tif (ret < 0) {\n\t\t\tpr_err("%s: Error %d reading data\\n", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\t\tread_id += size_to_read;\n\t\toffset += size_to_read;\n\t\tif (read_id >= (einfo->rx_fifo_start + einfo->fifo_size))\n\t\t\tread_id = einfo->rx_fifo_start;\n\t\tsize_to_read = size - offset;\n\t} while (size_to_read);\n\n\tret = glink_spi_xprt_reg_write(einfo, einfo->rx_fifo_read_reg_addr,\n\t\t\t\tread_id);\n\tif (ret < 0)\n\t\tpr_err("%s: Error %d writing %s rx_fifo_read_reg_addr %d\\n",\n\t\t\t__func__, ret, einfo->xprt_cfg.edge,\n\t\t\teinfo->rx_fifo_read_reg_addr);\n\telse\n\t\teinfo->rx_fifo_read = read_id;\n\n\treturn ret;\n}'
p7401
(dp7402
((g7397
g7398
tp7403
I1
tp7404
(dp7405
g14
(dp7406
(I10
I16
tp7407
(lp7408
S'\tif ((read_id > (einfo->rx_fifo_start + einfo->fifo_size)) ||'
p7409
aS'\t\t(read_id < einfo->rx_fifo_start)) {'
p7410
aS'\t\tpr_err("%s: Invalid rx_fifo_read: %d, start: %d, size: %d\\n",'
p7411
aS'\t\t\t__func__, read_id, einfo->rx_fifo_start,'
p7412
aS'\t\t\teinfo->fifo_size);'
p7413
aS'\t\treturn -EINVAL;'
p7414
aS'\t}'
p7415
assg32
I3
sg12
g13
sg41
(I1
I45
tp7416
ssss(g7397
S'process_rx_cmd'
p7417
tp7418
(dp7419
S'static void process_rx_cmd(struct edge_info *einfo,\n\t\t\t   void *rx_data, int rx_size)\n{\n\tstruct command {\n\t\tuint16_t id;\n\t\tuint16_t param1;\n\t\tuint32_t param2;\n\t\tuint32_t param3;\n\t\tuint32_t param4;\n\t};\n\tstruct intent_desc {\n\t\tuint32_t size;\n\t\tuint32_t id;\n\t\tuint64_t addr;\n\t};\n\tstruct rx_desc {\n\t\tuint32_t size;\n\t\tuint32_t size_left;\n\t\tuint64_t addr;\n\t};\n\tstruct rx_short_data_desc {\n\t\tunsigned char data[SHORT_PKT_SIZE];\n\t};\n\tstruct command *cmd = NULL;\n\tstruct intent_desc *intents;\n\tstruct rx_desc *rx_descp;\n\tstruct rx_short_data_desc *rx_sd_descp;\n\tuint64_t offset = 0;\n\tint rcu_id;\n\tuint16_t rcid;\n\tuint16_t name_len;\n\tuint16_t prio;\n\tchar *name;\n\tbool granted;\n\tint i;\n\n\trcu_id = srcu_read_lock(&einfo->use_ref);\n\tif (einfo->in_ssr) {\n\t\tsrcu_read_unlock(&einfo->use_ref, rcu_id);\n\t\treturn;\n\t}\n\n\twhile (offset < rx_size) {\n\t\tif (offset + sizeof(*cmd) > rx_size)\n\t\t\tgoto err;\n\t\tcmd = (struct command *)(rx_data + offset);\n\t\toffset += sizeof(*cmd);\n\t\tswitch (cmd->id) {\n\t\tcase VERSION_CMD:\n\t\t\tif (cmd->param3)\n\t\t\t\teinfo->fifo_size = cmd->param3;\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_version(\n\t\t\t\t&einfo->xprt_if, cmd->param1, cmd->param2);\n\t\t\tbreak;\n\n\t\tcase VERSION_ACK_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_version_ack(\n\t\t\t\t&einfo->xprt_if, cmd->param1, cmd->param2);\n\t\t\tbreak;\n\n\t\tcase OPEN_CMD:\n\t\t\trcid = cmd->param1;\n\t\t\tname_len = (uint16_t)(cmd->param2 & 0xFFFF);\n\t\t\tif (name_len > GLINK_NAME_SIZE)\n\t\t\t\tgoto err;\n\t\t\tprio = (uint16_t)((cmd->param2 & 0xFFFF0000) >> 16);\n\t\t\tif (offset + ALIGN(name_len, FIFO_ALIGNMENT) >\n\t\t\t\trx_size)\n\t\t\t\tgoto err;\n\t\t\tname = (char *)(rx_data + offset);\n\t\t\toffset += ALIGN(name_len, FIFO_ALIGNMENT);\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_ch_remote_open(\n\t\t\t\t&einfo->xprt_if, rcid, name, prio);\n\t\t\tbreak;\n\n\t\tcase CLOSE_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->\n\t\t\t\t\trx_cmd_ch_remote_close(\n\t\t\t\t\t\t&einfo->xprt_if, cmd->param1);\n\t\t\tbreak;\n\n\t\tcase OPEN_ACK_CMD:\n\t\t\tprio = (uint16_t)(cmd->param2 & 0xFFFF);\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_ch_open_ack(\n\t\t\t\t&einfo->xprt_if, cmd->param1, prio);\n\t\t\tbreak;\n\n\t\tcase CLOSE_ACK_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_ch_close_ack(\n\t\t\t\t\t&einfo->xprt_if, cmd->param1);\n\t\t\tbreak;\n\n\t\tcase RX_INTENT_CMD:\n\t\t\tfor (i = 0; i < cmd->param2; i++) {\n\t\t\t\tif (offset + sizeof(*intents) > rx_size)\n\t\t\t\t\tgoto err;\n\t\t\t\tintents = (struct intent_desc *)\n\t\t\t\t\t\t(rx_data + offset);\n\t\t\t\toffset += sizeof(*intents);\n\t\t\t\teinfo->xprt_if.glink_core_if_ptr->\n\t\t\t\t\trx_cmd_remote_rx_intent_put_cookie(\n\t\t\t\t\t&einfo->xprt_if, cmd->param1,\n\t\t\t\t\tintents->id, intents->size,\n\t\t\t\t\t(void *)(uintptr_t)(intents->addr));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase RX_DONE_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_tx_done(\n\t\t\t\t&einfo->xprt_if, cmd->param1, cmd->param2,\n\t\t\t\tfalse);\n\t\t\tbreak;\n\n\t\tcase RX_INTENT_REQ_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->\n\t\t\t\trx_cmd_remote_rx_intent_req(\n\t\t\t\t\t&einfo->xprt_if, cmd->param1,\n\t\t\t\t\tcmd->param2);\n\t\t\tbreak;\n\n\t\tcase RX_INTENT_REQ_ACK_CMD:\n\t\t\tgranted = cmd->param2 == 1 ? true : false;\n\t\t\teinfo->xprt_if.glink_core_if_ptr->\n\t\t\t\trx_cmd_rx_intent_req_ack(&einfo->xprt_if,\n\t\t\t\t\t\tcmd->param1, granted);\n\t\t\tbreak;\n\n\t\tcase TX_DATA_CMD:\n\t\tcase TX_DATA_CONT_CMD:\n\t\tcase TRACER_PKT_CMD:\n\t\tcase TRACER_PKT_CONT_CMD:\n\t\t\tif (offset + sizeof(*rx_descp) > rx_size)\n\t\t\t\tgoto err;\n\t\t\trx_descp = (struct rx_desc *)(rx_data + offset);\n\t\t\toffset += sizeof(*rx_descp);\n\t\t\tprocess_rx_data(einfo, cmd->id, cmd->param1,\n\t\t\t\t\tcmd->param2,\n\t\t\t\t\t(void *)(uintptr_t)(rx_descp->addr),\n\t\t\t\t\trx_descp->size, rx_descp->size_left);\n\t\t\tbreak;\n\n\t\tcase TX_SHORT_DATA_CMD:\n\t\t\tif (offset + sizeof(*rx_sd_descp) > rx_size)\n\t\t\t\tgoto err;\n\t\t\trx_sd_descp = (struct rx_short_data_desc *)\n\t\t\t\t\t\t\t(rx_data + offset);\n\t\t\toffset += sizeof(*rx_sd_descp);\n\t\t\tprocess_rx_data(einfo, cmd->id, cmd->param1,\n\t\t\t\t\tcmd->param2, (void *)rx_sd_descp->data,\n\t\t\t\t\tcmd->param3, cmd->param4);\n\t\t\tbreak;\n\n\t\tcase READ_NOTIF_CMD:\n\t\t\tbreak;\n\n\t\tcase SIGNALS_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_remote_sigs(\n\t\t\t\t&einfo->xprt_if, cmd->param1, cmd->param2);\n\t\t\tbreak;\n\n\t\tcase RX_DONE_W_REUSE_CMD:\n\t\t\teinfo->xprt_if.glink_core_if_ptr->rx_cmd_tx_done(\n\t\t\t\t&einfo->xprt_if, cmd->param1,\n\t\t\t\tcmd->param2, true);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tpr_err("Unrecognized command: %d\\n", cmd->id);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsrcu_read_unlock(&einfo->use_ref, rcu_id);\n\treturn;\nerr:\n\tsrcu_read_unlock(&einfo->use_ref, rcu_id);\n\tif (cmd)\n\t\tpr_err("%s: invalid size of rx_data: %d, cmd : %d\\n",\n\t\t\t__func__, rx_size, cmd->id);\n\treturn;\n}'
p7420
(dp7421
((g7397
g7417
tp7422
I1
tp7423
(dp7424
g12
g13
sg14
(dp7425
(I64
I65
tp7426
(lp7427
S'\t\t\tif (name_len > GLINK_NAME_SIZE)'
p7428
aS'\t\t\t\tgoto err;'
p7429
as(I132
I133
tp7430
(lp7431
S'\t\t\tif (offset + sizeof(*rx_descp) > rx_size)'
p7432
aS'\t\t\t\tgoto err;'
p7433
as(I24
I24
tp7434
(lp7435
S'\tstruct command *cmd = NULL;'
p7436
as(I173
I179
tp7437
(lp7438
S'\treturn;'
p7439
aS'err:'
p7440
aS'\tsrcu_read_unlock(&einfo->use_ref, rcu_id);'
p7441
aS'\tif (cmd)'
p7442
aS'\t\tpr_err("%s: invalid size of rx_data: %d, cmd : %d\\n",'
p7443
aS'\t\t\t__func__, rx_size, cmd->id);'
p7444
aS'\treturn;'
p7445
as(I44
I45
tp7446
(lp7447
S'\t\tif (offset + sizeof(*cmd) > rx_size)'
p7448
aS'\t\t\tgoto err;'
p7449
as(I143
I144
tp7450
(lp7451
S'\t\t\tif (offset + sizeof(*rx_sd_descp) > rx_size)'
p7452
aS'\t\t\t\tgoto err;'
p7453
as(I28
I28
tp7454
(lp7455
S'\tuint64_t offset = 0;'
p7456
as(I95
I96
tp7457
(lp7458
S'\t\t\t\tif (offset + sizeof(*intents) > rx_size)'
p7459
aS'\t\t\t\t\tgoto err;'
p7460
as(I67
I69
tp7461
(lp7462
S'\t\t\tif (offset + ALIGN(name_len, FIFO_ALIGNMENT) >'
p7463
aS'\t\t\t\trx_size)'
p7464
aS'\t\t\t\tgoto err;'
p7465
assg32
I3
sg33
(dp7466
(I24
I24
tp7467
(lp7468
S'\tstruct command *cmd;'
p7469
as(I28
I28
tp7470
(lp7471
S'\tint offset = 0;'
p7472
assg41
(I1
I180
tp7473
sssssS'CVE-2018-18397'
p7474
(dp7475
(S'fs/userfaultfd.c'
p7476
S'userfaultfd_register'
p7477
tp7478
(dp7479
S"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }),\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
p7480
(dp7481
((g7476
g7477
tp7482
I1
tp7483
(dp7484
g14
(dp7485
(I80
I91
tp7486
(lp7487
S'\t\t/*'
p7488
aS'\t\t * UFFDIO_COPY will fill file holes even without'
p7489
aS'\t\t * PROT_WRITE. This check enforces that if this is a'
p7490
aS'\t\t * MAP_SHARED, the process has write permission to the backing'
p7491
aS'\t\t * file. If VM_MAYWRITE is set it also enforces that on a'
p7492
aS'\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further'
p7493
aS'\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.'
p7494
aS'\t\t */'
p7495
aS'\t\tret = -EPERM;'
p7496
aS'\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))'
p7497
aS'\t\t\tgoto out_unlock;'
p7498
ag59
as(I117
I117
tp7499
(lp7500
S'\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));'
p7501
assg32
I2
sg12
g13
sg41
(I1
I182
tp7502
sssS"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }),\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
p7503
(dp7504
((g7476
g7477
tp7505
I1
tp7506
(dp7507
g14
(dp7508
(I120
I120
tp7509
(lp7510
S'\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));'
p7511
as(I52
I54
tp7512
(lp7513
S'\tif (!mmget_still_valid(mm))'
p7514
aS'\t\tgoto out_unlock;'
p7515
ag59
as(I83
I94
tp7516
(lp7517
S'\t\t/*'
p7518
aS'\t\t * UFFDIO_COPY will fill file holes even without'
p7519
aS'\t\t * PROT_WRITE. This check enforces that if this is a'
p7520
aS'\t\t * MAP_SHARED, the process has write permission to the backing'
p7521
aS'\t\t * file. If VM_MAYWRITE is set it also enforces that on a'
p7522
aS'\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further'
p7523
aS'\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.'
p7524
aS'\t\t */'
p7525
aS'\t\tret = -EPERM;'
p7526
aS'\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))'
p7527
aS'\t\t\tgoto out_unlock;'
p7528
ag59
assg32
I2
sg12
g13
sg41
(I1
I185
tp7529
ssss(g7476
S'userfaultfd_unregister'
p7530
tp7531
(dp7532
S"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX,\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
p7533
(dp7534
((g7476
g7530
tp7535
I1
tp7536
(dp7537
g14
(dp7538
(I30
I32
tp7539
(lp7540
S'\tif (!mmget_still_valid(mm))'
p7541
aS'\t\tgoto out_unlock;'
p7542
ag59
as(I79
I79
tp7543
(lp7544
S'\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));'
p7545
assg32
I2
sg12
g13
sg41
(I1
I133
tp7546
sssS"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX,\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
p7547
(dp7548
((g7476
g7530
tp7549
I1
tp7550
(dp7551
g14
(dp7552
(I76
I76
tp7553
(lp7554
S'\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));'
p7555
assg32
I2
sg12
g13
sg41
(I1
I130
tp7556
ssss(S'mm/userfaultfd.c'
p7557
S'__mcopy_atomic'
p7558
tp7559
(dp7560
S"static __always_inline ssize_t __mcopy_atomic(struct mm_struct *dst_mm,\n\t\t\t\t\t      unsigned long dst_start,\n\t\t\t\t\t      unsigned long src_start,\n\t\t\t\t\t      unsigned long len,\n\t\t\t\t\t      bool zeropage)\n{\n\tstruct vm_area_struct *dst_vma;\n\tssize_t err;\n\tpmd_t *dst_pmd;\n\tunsigned long src_addr, dst_addr;\n\tlong copied;\n\tstruct page *page;\n\n\t/*\n\t * Sanitize the command parameters:\n\t */\n\tBUG_ON(dst_start & ~PAGE_MASK);\n\tBUG_ON(len & ~PAGE_MASK);\n\n\t/* Does the address range wrap, or is the span zero-sized? */\n\tBUG_ON(src_start + len <= src_start);\n\tBUG_ON(dst_start + len <= dst_start);\n\n\tsrc_addr = src_start;\n\tdst_addr = dst_start;\n\tcopied = 0;\n\tpage = NULL;\nretry:\n\tdown_read(&dst_mm->mmap_sem);\n\n\t/*\n\t * Make sure the vma is not shared, that the dst range is\n\t * both valid and fully within a single existing vma.\n\t */\n\terr = -EINVAL;\n\tdst_vma = find_vma(dst_mm, dst_start);\n\tif (!dst_vma || (dst_vma->vm_flags & VM_SHARED))\n\t\tgoto out_unlock;\n\tif (dst_start < dst_vma->vm_start ||\n\t    dst_start + len > dst_vma->vm_end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the vma is registered in uffd, this is required to\n\t * enforce the VM_MAYWRITE check done at uffd registration\n\t * time.\n\t */\n\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\tgoto out_unlock;\n\n\t/*\n\t * FIXME: only allow copying on anonymous vmas, tmpfs should\n\t * be added.\n\t */\n\tif (dst_vma->vm_ops)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Ensure the dst_vma has a anon_vma or this page\n\t * would get a NULL anon_vma when moved in the\n\t * dst_vma.\n\t */\n\terr = -ENOMEM;\n\tif (unlikely(anon_vma_prepare(dst_vma)))\n\t\tgoto out_unlock;\n\n\twhile (src_addr < src_start + len) {\n\t\tpmd_t dst_pmdval;\n\n\t\tBUG_ON(dst_addr >= dst_start + len);\n\n\t\tdst_pmd = mm_alloc_pmd(dst_mm, dst_addr);\n\t\tif (unlikely(!dst_pmd)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst_pmdval = pmd_read_atomic(dst_pmd);\n\t\t/*\n\t\t * If the dst_pmd is mapped as THP don't\n\t\t * override it and just be strict.\n\t\t */\n\t\tif (unlikely(pmd_trans_huge(dst_pmdval))) {\n\t\t\terr = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pmd_none(dst_pmdval)) &&\n\t\t    unlikely(__pte_alloc(dst_mm, dst_pmd, dst_addr))) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* If an huge pmd materialized from under us fail */\n\t\tif (unlikely(pmd_trans_huge(*dst_pmd))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(pmd_none(*dst_pmd));\n\t\tBUG_ON(pmd_trans_huge(*dst_pmd));\n\n\t\tif (!zeropage)\n\t\t\terr = mcopy_atomic_pte(dst_mm, dst_pmd, dst_vma,\n\t\t\t\t\t       dst_addr, src_addr, &page);\n\t\telse\n\t\t\terr = mfill_zeropage_pte(dst_mm, dst_pmd, dst_vma,\n\t\t\t\t\t\t dst_addr);\n\n\t\tcond_resched();\n\n\t\tif (unlikely(err == -EFAULT)) {\n\t\t\tvoid *page_kaddr;\n\n\t\t\tup_read(&dst_mm->mmap_sem);\n\t\t\tBUG_ON(!page);\n\n\t\t\tpage_kaddr = kmap(page);\n\t\t\terr = copy_from_user(page_kaddr,\n\t\t\t\t\t     (const void __user *) src_addr,\n\t\t\t\t\t     PAGE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tif (unlikely(err)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t} else\n\t\t\tBUG_ON(page);\n\n\t\tif (!err) {\n\t\t\tdst_addr += PAGE_SIZE;\n\t\t\tsrc_addr += PAGE_SIZE;\n\t\t\tcopied += PAGE_SIZE;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\terr = -EINTR;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout_unlock:\n\tup_read(&dst_mm->mmap_sem);\nout:\n\tif (page)\n\t\tput_page(page);\n\tBUG_ON(copied < 0);\n\tBUG_ON(err > 0);\n\tBUG_ON(!copied && !err);\n\treturn copied ? copied : err;\n}"
p7561
(dp7562
((g7557
g7558
tp7563
I1
tp7564
(dp7565
g12
g13
sg14
(dp7566
(I44
I46
tp7567
(lp7568
S'\t * Check the vma is registered in uffd, this is required to'
p7569
aS'\t * enforce the VM_MAYWRITE check done at uffd registration'
p7570
aS'\t * time.'
p7571
assg32
I5
sg33
(dp7572
(I44
I50
tp7573
(lp7574
S'\t * Be strict and only allow __mcopy_atomic on userfaultfd'
p7575
aS'\t * registered ranges to prevent userland errors going'
p7576
aS'\t * unnoticed. As far as the VM consistency is concerned, it'
p7577
aS"\t * would be perfectly safe to remove this check, but there's"
p7578
aS'\t * no useful usage for __mcopy_atomic ouside of userfaultfd'
p7579
aS'\t * registered ranges. This is after all why these are ioctls'
p7580
aS'\t * belonging to the userfaultfd and not syscalls.'
p7581
assg41
(I1
I150
tp7582
sssssS'CVE-2017-18595'
p7583
(dp7584
(S'kernel/trace/trace.c'
p7585
S'allocate_trace_buffer'
p7586
tp7587
(dp7588
S'allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}'
p7589
(dp7590
((g7585
g7586
tp7591
I1
tp7592
(dp7593
g14
(dp7594
(I16
I16
tp7595
(lp7596
S'\t\tbuf->buffer = NULL;'
p7597
assg32
I3
sg12
g13
sg41
(I1
I25
tp7598
sssssS'CVE-2019-9503'
p7599
(dp7600
(S'drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h'
p7601
S'brcmf_fweh_process_skb'
p7602
tp7603
(dp7604
S'static inline void brcmf_fweh_process_skb(struct brcmf_pub *drvr,\n\t\t\t\t\t  struct sk_buff *skb, u16 stype)\n{\n\tstruct brcmf_event *event_packet;\n\tu16 subtype, usr_stype;\n\n\t/* only process events when protocol matches */\n\tif (skb->protocol != cpu_to_be16(ETH_P_LINK_CTL))\n\t\treturn;\n\n\tif ((skb->len + ETH_HLEN) < sizeof(*event_packet))\n\t\treturn;\n\n\tevent_packet = (struct brcmf_event *)skb_mac_header(skb);\n\n\t/* check subtype if needed */\n\tif (unlikely(stype)) {\n\t\tsubtype = get_unaligned_be16(&event_packet->hdr.subtype);\n\t\tif (subtype != stype)\n\t\t\treturn;\n\t}\n\n\t/* check for BRCM oui match */\n\tif (memcmp(BRCM_OUI, &event_packet->hdr.oui[0],\n\t\t   sizeof(event_packet->hdr.oui)))\n\t\treturn;\n\n\t/* final match on usr_subtype */\n\tusr_stype = get_unaligned_be16(&event_packet->hdr.usr_subtype);\n\tif (usr_stype != BCMILCP_BCM_SUBTYPE_EVENT)\n\t\treturn;\n\n\tbrcmf_fweh_process_event(drvr, event_packet, skb->len + ETH_HLEN);\n}'
p7605
(dp7606
((g7601
g7602
tp7607
I1
tp7608
(dp7609
g12
g13
sg14
(dp7610
(I15
I23
tp7611
(lp7612
g59
aS'\t/* check subtype if needed */'
p7613
aS'\tif (unlikely(stype)) {'
p7614
aS'\t\tsubtype = get_unaligned_be16(&event_packet->hdr.subtype);'
p7615
aS'\t\tif (subtype != stype)'
p7616
aS'\t\t\treturn;'
p7617
aS'\t}'
p7618
ag59
aS'\t/* check for BRCM oui match */'
p7619
as(I5
I5
tp7620
(lp7621
S'\tu16 subtype, usr_stype;'
p7622
as(I2
I2
tp7623
(lp7624
S'\t\t\t\t\t  struct sk_buff *skb, u16 stype)'
p7625
assg32
I3
sg33
(dp7626
(I14
I14
tp7627
(lp7628
S'\t/* check for BRCM oui match */'
p7629
as(I5
I5
tp7630
(lp7631
S'\tu16 usr_stype;'
p7632
as(I2
I2
tp7633
(lp7634
S'\t\t\t\t\t  struct sk_buff *skb)'
p7635
assg41
(I1
I34
tp7636
ssss(S'drivers/net/wireless/broadcom/brcm80211/brcmfmac/msgbuf.c'
p7637
S'brcmf_msgbuf_process_event'
p7638
tp7639
(dp7640
S'static void brcmf_msgbuf_process_event(struct brcmf_msgbuf *msgbuf, void *buf)\n{\n\tstruct msgbuf_rx_event *event;\n\tu32 idx;\n\tu16 buflen;\n\tstruct sk_buff *skb;\n\tstruct brcmf_if *ifp;\n\n\tevent = (struct msgbuf_rx_event *)buf;\n\tidx = le32_to_cpu(event->msg.request_id);\n\tbuflen = le16_to_cpu(event->event_data_len);\n\n\tif (msgbuf->cur_eventbuf)\n\t\tmsgbuf->cur_eventbuf--;\n\tbrcmf_msgbuf_rxbuf_event_post(msgbuf);\n\n\tskb = brcmf_msgbuf_get_pktid(msgbuf->drvr->bus_if->dev,\n\t\t\t\t     msgbuf->rx_pktids, idx);\n\tif (!skb)\n\t\treturn;\n\n\tif (msgbuf->rx_dataoffset)\n\t\tskb_pull(skb, msgbuf->rx_dataoffset);\n\n\tskb_trim(skb, buflen);\n\n\tifp = brcmf_get_ifp(msgbuf->drvr, event->msg.ifidx);\n\tif (!ifp || !ifp->ndev) {\n\t\tbrcmf_err("Received pkt for invalid ifidx %d\\n",\n\t\t\t  event->msg.ifidx);\n\t\tgoto exit;\n\t}\n\n\tskb->protocol = eth_type_trans(skb, ifp->ndev);\n\n\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0);\n\nexit:\n\tbrcmu_pkt_buf_free_skb(skb);\n}'
p7641
(dp7642
((g7637
g7638
tp7643
I1
tp7644
(dp7645
g12
g13
sg14
(dp7646
(I36
I36
tp7647
(lp7648
S'\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0);'
p7649
assg32
I2
sg33
(dp7650
(I36
I36
tp7651
(lp7652
S'\tbrcmf_fweh_process_skb(ifp->drvr, skb);'
p7653
assg41
(I1
I40
tp7654
ssss(S'drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c'
p7655
S'brcmf_rx_event'
p7656
tp7657
(dp7658
S'void brcmf_rx_event(struct device *dev, struct sk_buff *skb)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(EVENT, "Enter: %s: rxp=%p\\n", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0);\n\tbrcmu_pkt_buf_free_skb(skb);\n}'
p7659
(dp7660
((g7655
g7656
tp7661
I1
tp7662
(dp7663
g12
g13
sg14
(dp7664
(I12
I12
tp7665
(lp7666
S'\tbrcmf_fweh_process_skb(ifp->drvr, skb, 0);'
p7667
assg32
I2
sg33
(dp7668
(I12
I12
tp7669
(lp7670
S'\tbrcmf_fweh_process_skb(ifp->drvr, skb);'
p7671
assg41
(I1
I14
tp7672
ssss(g7655
S'brcmf_rx_frame'
p7673
tp7674
(dp7675
S'void brcmf_rx_frame(struct device *dev, struct sk_buff *skb, bool handle_event)\n{\n\tstruct brcmf_if *ifp;\n\tstruct brcmf_bus *bus_if = dev_get_drvdata(dev);\n\tstruct brcmf_pub *drvr = bus_if->drvr;\n\n\tbrcmf_dbg(DATA, "Enter: %s: rxp=%p\\n", dev_name(dev), skb);\n\n\tif (brcmf_rx_hdrpull(drvr, skb, &ifp))\n\t\treturn;\n\n\tif (brcmf_proto_is_reorder_skb(skb)) {\n\t\tbrcmf_proto_rxreorder(ifp, skb);\n\t} else {\n\t\t/* Process special event packets */\n\t\tif (handle_event)\n\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb,\n\t\t\t\t\t       BCMILCP_SUBTYPE_VENDOR_LONG);\n\n\t\tbrcmf_netif_rx(ifp, skb);\n\t}\n}'
p7676
(dp7677
((g7655
g7673
tp7678
I1
tp7679
(dp7680
g12
g13
sg14
(dp7681
(I17
I18
tp7682
(lp7683
S'\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb,'
p7684
aS'\t\t\t\t\t       BCMILCP_SUBTYPE_VENDOR_LONG);'
p7685
assg32
I3
sg33
(dp7686
(I17
I17
tp7687
(lp7688
S'\t\t\tbrcmf_fweh_process_skb(ifp->drvr, skb);'
p7689
assg41
(I1
I22
tp7690
sssssS'CVE-2019-2260'
p7691
(dp7692
(S'kernel/events/core.c'
p7693
S'perf_event_zombie_cleanup'
p7694
tp7695
(dp7696
S'static void perf_event_zombie_cleanup(unsigned int cpu)\n{\n\tstruct perf_event *event, *tmp;\n\n\tspin_lock(&zombie_list_lock);\n\n\tlist_for_each_entry_safe(event, tmp, &zombie_list, zombie_entry) {\n\t\tif (event->cpu != cpu)\n\t\t\tcontinue;\n\n\t\tlist_del(&event->zombie_entry);\n\t\tspin_unlock(&zombie_list_lock);\n\n\t\t/*\n\t\t * The detachment of the event with the\n\t\t * PMU expects it to be in an active state\n\t\t */\n\t\tevent->state = PERF_EVENT_STATE_ACTIVE;\n\t\t__perf_event_release_kernel(event);\n\n\t\tspin_lock(&zombie_list_lock);\n\t}\n\n\tspin_unlock(&zombie_list_lock);\n}'
p7697
(dp7698
((g7693
g7694
tp7699
I1
tp7700
(dp7701
g12
g13
sg14
(dp7702
(I19
I19
tp7703
(lp7704
S'\t\t__perf_event_release_kernel(event);'
p7705
assg32
I1
sg33
(dp7706
(I19
I19
tp7707
(lp7708
S'\t\tperf_event_release_kernel(event);'
p7709
assg41
(I1
I25
tp7710
ssss(g7693
S'perf_event_release_kernel'
p7711
tp7712
(dp7713
S'int perf_event_release_kernel(struct perf_event *event)\n{\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = __perf_event_release_kernel(event);\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}'
p7714
(dp7715
((g7693
g7711
tp7716
I1
tp7717
(dp7718
g12
g13
sg14
(dp7719
(I5
I7
tp7720
(lp7721
S'\tmutex_lock(&pmus_lock);'
p7722
aS'\tret = __perf_event_release_kernel(event);'
p7723
aS'\tmutex_unlock(&pmus_lock);'
p7724
as(I3
I3
tp7725
(lp7726
S'\tint ret;'
p7727
as(I9
I9
tp7728
(lp7729
S'\treturn ret;'
p7730
assg32
I1
sg33
(dp7731
(I9
I120
tp7732
(lp7733
S'\t\tevent->state = PERF_EVENT_STATE_ZOMBIE;'
p7734
ag59
aS'\t\tspin_lock(&zombie_list_lock);'
p7735
aS'\t\tlist_add_tail(&event->zombie_entry, &zombie_list);'
p7736
aS'\t\tspin_unlock(&zombie_list_lock);'
p7737
ag59
aS'\t\treturn 0;'
p7738
aS'\t}'
p7739
aS'#endif'
p7740
ag59
aS'\t/*'
p7741
aS'\t * If we got here through err_file: fput(event_file); we will not have'
p7742
aS'\t * attached to a context yet.'
p7743
aS'\t */'
p7744
aS'\tif (!ctx) {'
p7745
aS'\t\tWARN_ON_ONCE(event->attach_state &'
p7746
aS'\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));'
p7747
aS'\t\tgoto no_ctx;'
p7748
aS'\t}'
p7749
ag59
aS'\tif (!is_kernel_event(event)) {'
p7750
aS'\t\tperf_remove_from_owner(event);'
p7751
aS'\t}'
p7752
ag59
aS'\tctx = perf_event_ctx_lock(event);'
p7753
aS'\tWARN_ON_ONCE(ctx->parent_ctx);'
p7754
aS'\tperf_remove_from_context(event, DETACH_GROUP);'
p7755
ag59
aS'\tif (perf_event_delete_kernel_shared(event) > 0) {'
p7756
aS'\t\tperf_event__state_init(event);'
p7757
aS'\t\tperf_install_in_context(ctx, event, event->cpu);'
p7758
ag59
aS'\t\tperf_event_ctx_unlock(event, ctx);'
p7759
ag59
aS'\t\tperf_event_enable(event);'
p7760
ag59
aS'\t\treturn 0;'
p7761
aS'\t}'
p7762
ag59
aS'\traw_spin_lock_irq(&ctx->lock);'
p7763
aS'\t/*'
p7764
aS'\t * Mark this even as STATE_DEAD, there is no external reference to it'
p7765
aS'\t * anymore.'
p7766
aS'\t *'
p7767
aS'\t * Anybody acquiring event->child_mutex after the below loop _must_'
p7768
aS'\t * also see this, most importantly inherit_event() which will avoid'
p7769
aS'\t * placing more children on the list.'
p7770
aS'\t *'
p7771
aS'\t * Thus this guarantees that we will in fact observe and kill _ALL_'
p7772
aS'\t * child events.'
p7773
aS'\t */'
p7774
aS'\tevent->state = PERF_EVENT_STATE_DEAD;'
p7775
aS'\traw_spin_unlock_irq(&ctx->lock);'
p7776
ag59
aS'\tperf_event_ctx_unlock(event, ctx);'
p7777
ag59
aS'again:'
p7778
aS'\tmutex_lock(&event->child_mutex);'
p7779
aS'\tlist_for_each_entry(child, &event->child_list, child_list) {'
p7780
ag59
aS'\t\t/*'
p7781
aS'\t\t * Cannot change, child events are not migrated, see the'
p7782
aS'\t\t * comment with perf_event_ctx_lock_nested().'
p7783
aS'\t\t */'
p7784
aS'\t\tctx = lockless_dereference(child->ctx);'
p7785
aS'\t\t/*'
p7786
aS'\t\t * Since child_mutex nests inside ctx::mutex, we must jump'
p7787
aS'\t\t * through hoops. We start by grabbing a reference on the ctx.'
p7788
aS'\t\t *'
p7789
aS'\t\t * Since the event cannot get freed while we hold the'
p7790
aS'\t\t * child_mutex, the context must also exist and have a !0'
p7791
aS'\t\t * reference count.'
p7792
aS'\t\t */'
p7793
aS'\t\tget_ctx(ctx);'
p7794
ag59
aS'\t\t/*'
p7795
aS'\t\t * Now that we have a ctx ref, we can drop child_mutex, and'
p7796
aS'\t\t * acquire ctx::mutex without fear of it going away. Then we'
p7797
aS'\t\t * can re-acquire child_mutex.'
p7798
aS'\t\t */'
p7799
aS'\t\tmutex_unlock(&event->child_mutex);'
p7800
aS'\t\tmutex_lock(&ctx->mutex);'
p7801
aS'\t\tmutex_lock(&event->child_mutex);'
p7802
ag59
aS'\t\t/*'
p7803
aS'\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our'
p7804
aS"\t\t * state, if child is still the first entry, it didn't get freed"
p7805
aS'\t\t * and we can continue doing so.'
p7806
aS'\t\t */'
p7807
aS'\t\ttmp = list_first_entry_or_null(&event->child_list,'
p7808
aS'\t\t\t\t\t       struct perf_event, child_list);'
p7809
aS'\t\tif (tmp == child) {'
p7810
aS'\t\t\tperf_remove_from_context(child, DETACH_GROUP);'
p7811
aS'\t\t\tlist_del(&child->child_list);'
p7812
aS'\t\t\tfree_event(child);'
p7813
aS'\t\t\t/*'
p7814
aS'\t\t\t * This matches the refcount bump in inherit_event();'
p7815
aS"\t\t\t * this can't be the last reference."
p7816
aS'\t\t\t */'
p7817
aS'\t\t\tput_event(event);'
p7818
aS'\t\t}'
p7819
ag59
aS'\t\tmutex_unlock(&event->child_mutex);'
p7820
aS'\t\tmutex_unlock(&ctx->mutex);'
p7821
aS'\t\tput_ctx(ctx);'
p7822
aS'\t\tgoto again;'
p7823
aS'\t}'
p7824
aS'\tmutex_unlock(&event->child_mutex);'
p7825
ag59
aS'no_ctx:'
p7826
aS"\tput_event(event); /* Must be the 'last' reference */"
p7827
aS'\treturn 0;'
p7828
as(I3
I4
tp7829
(lp7830
S'\tstruct perf_event_context *ctx = event->ctx;'
p7831
aS'\tstruct perf_event *child, *tmp;'
p7832
as(I5
I13
tp7833
(lp7834
S'\t/*'
p7835
aS'\t * If the cpu associated to this event is offline, set the event as a'
p7836
aS'\t *  zombie event. The cleanup of the cpu would be done if the CPU is'
p7837
aS'\t *  back online.'
p7838
aS'\t */'
p7839
aS'#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE'
p7840
aS'\tif (event->cpu != -1 && !cpu_online(event->cpu)) {'
p7841
aS'\t\tif (event->state == PERF_EVENT_STATE_ZOMBIE)'
p7842
aS'\t\t\treturn 0;'
p7843
assg41
(I1
I10
tp7844
ssss(g7693
S'perf_event_start_swevents'
p7845
tp7846
(dp7847
S'static int perf_event_start_swevents(unsigned int cpu)\n{\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tstruct perf_event *event;\n\tint idx;\n\n\tmutex_lock(&pmus_lock);\n\tperf_event_zombie_cleanup(cpu);\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tctx = &per_cpu_ptr(pmu->pmu_cpu_context, cpu)->ctx;\n\t\tmutex_lock(&ctx->mutex);\n\t\traw_spin_lock(&ctx->lock);\n\t\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\t\tcheck_hotplug_start_event(event);\n\t\traw_spin_unlock(&ctx->lock);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\tper_cpu(is_hotplugging, cpu) = false;\n\tmutex_unlock(&pmus_lock);\n\n\treturn 0;\n}'
p7848
(dp7849
((g7693
g7845
tp7850
I1
tp7851
(dp7852
g14
(dp7853
(I8
I8
tp7854
(lp7855
S'\tmutex_lock(&pmus_lock);'
p7856
as(I23
I24
tp7857
(lp7858
S'\tmutex_unlock(&pmus_lock);'
p7859
ag59
assg32
I1
sg12
g13
sg41
(I1
I26
tp7860
ssss(g7693
S'__perf_event_release_kernel'
p7861
tp7862
(dp7863
s(g7693
S'perf_event_exit_cpu'
p7864
tp7865
(dp7866
S'int perf_event_exit_cpu(unsigned int cpu)\n{\n\tmutex_lock(&pmus_lock);\n\tper_cpu(is_hotplugging, cpu) = true;\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_unlock(&pmus_lock);\n\treturn 0;\n}'
p7867
(dp7868
((g7693
g7864
tp7869
I1
tp7870
(dp7871
g14
(dp7872
(I3
I3
tp7873
(lp7874
S'\tmutex_lock(&pmus_lock);'
p7875
as(I6
I6
tp7876
(lp7877
S'\tmutex_unlock(&pmus_lock);'
p7878
assg32
I1
sg12
g13
sg41
(I1
I8
tp7879
sssS'int perf_event_exit_cpu(unsigned int cpu)\n{\n\n\tmutex_lock(&pmus_lock);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_unlock(&pmus_lock);\n\treturn 0;\n}'
p7880
(dp7881
((g7693
g7864
tp7882
I1
tp7883
(dp7884
g12
g13
sg14
(dp7885
(I3
I4
tp7886
(lp7887
g59
aS'\tmutex_lock(&pmus_lock);'
p7888
as(I6
I6
tp7889
(lp7890
S'\tmutex_unlock(&pmus_lock);'
p7891
assg32
I1
sg33
(dp7892
(I3
I3
tp7893
(lp7894
S'\tper_cpu(is_hotplugging, cpu) = true;'
p7895
assg41
(I1
I8
tp7896
sssssS'CVE-2019-2283'
p7897
(dp7898
(S'drivers/soc/qcom/glink_smem_native_xprt.c'
p7899
S'fifo_read'
p7900
tp7901
(dp7902
S'static int fifo_read(struct edge_info *einfo, void *_data, int len)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tvoid *data = _data;\n\tint orig_len = len;\n\tuint32_t read_index = einfo->rx_ch_desc->read_index;\n\tuint32_t write_index = einfo->rx_ch_desc->write_index;\n\tuint32_t fifo_size = einfo->rx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index > fifo_size && write_index > fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->rx_fifo + read_index;\n\t\tif (read_index <= write_index)\n\t\t\tn = write_index - read_index;\n\t\telse\n\t\t\tn = fifo_size - read_index;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->read_from_fifo(data, ptr, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\tread_index += n;\n\t\tif (read_index >= fifo_size)\n\t\t\tread_index -= fifo_size;\n\t}\n\teinfo->rx_ch_desc->read_index = read_index;\n\n\treturn orig_len - len;\n}'
p7903
(dp7904
((g7899
g7900
tp7905
I1
tp7906
(dp7907
g14
(dp7908
(I12
I13
tp7909
(lp7910
S'\tif (read_index > fifo_size && write_index > fifo_size)'
p7911
aS'\t\treturn 0;'
p7912
assg32
I3
sg12
g13
sg41
(I1
I39
tp7913
sssS'static int fifo_read(struct edge_info *einfo, void *_data, int len)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tvoid *data = _data;\n\tint orig_len = len;\n\tuint32_t read_index = einfo->rx_ch_desc->read_index;\n\tuint32_t write_index = einfo->rx_ch_desc->write_index;\n\tuint32_t fifo_size = einfo->rx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || write_index >= fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->rx_fifo + read_index;\n\t\tif (read_index <= write_index)\n\t\t\tn = write_index - read_index;\n\t\telse\n\t\t\tn = fifo_size - read_index;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->read_from_fifo(data, ptr, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\tread_index += n;\n\t\tif (read_index >= fifo_size)\n\t\t\tread_index -= fifo_size;\n\t}\n\teinfo->rx_ch_desc->read_index = read_index;\n\n\treturn orig_len - len;\n}'
p7914
(dp7915
((g7899
g7900
tp7916
I1
tp7917
(dp7918
g14
(dp7919
(I12
I13
tp7920
(lp7921
S'\tif (read_index >= fifo_size || write_index >= fifo_size)'
p7922
aS'\t\treturn 0;'
p7923
assg32
I3
sg12
g13
sg41
(I1
I39
tp7924
sssS'static int fifo_read(struct edge_info *einfo, void *_data, int len)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tvoid *data = _data;\n\tint orig_len = len;\n\tuint32_t read_index = einfo->rx_ch_desc->read_index;\n\tuint32_t write_index = einfo->rx_ch_desc->write_index;\n\tuint32_t fifo_size = einfo->rx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || write_index >= fifo_size) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\twhile (len) {\n\t\tptr = einfo->rx_fifo + read_index;\n\t\tif (read_index <= write_index)\n\t\t\tn = write_index - read_index;\n\t\telse\n\t\t\tn = fifo_size - read_index;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->read_from_fifo(data, ptr, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\tread_index += n;\n\t\tif (read_index >= fifo_size)\n\t\t\tread_index -= fifo_size;\n\t}\n\teinfo->rx_ch_desc->read_index = read_index;\n\n\treturn orig_len - len;\n}'
p7925
(dp7926
((g7899
g7900
tp7927
I1
tp7928
(dp7929
g14
(dp7930
(I12
I15
tp7931
(lp7932
S'\tif (read_index >= fifo_size || write_index >= fifo_size) {'
p7933
aS'\t\tWARN_ON_ONCE(1);'
p7934
aS'\t\treturn -EINVAL;'
p7935
aS'\t}'
p7936
assg32
I3
sg12
g13
sg41
(I1
I41
tp7937
ssss(g7899
S'fifo_write_body'
p7938
tp7939
(dp7940
S'static int fifo_write_body(struct edge_info *einfo, const void *_data,\n\t\t\t\tint len, uint32_t *write_index)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tconst void *data = _data;\n\tuint32_t read_index = einfo->tx_ch_desc->read_index;\n\tuint32_t fifo_size = einfo->tx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index > fifo_size && *write_index > fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->tx_fifo + *write_index;\n\t\tif (*write_index < read_index) {\n\t\t\tn = read_index - *write_index - FIFO_FULL_RESERVE;\n\t\t} else {\n\t\t\tif (read_index < FIFO_FULL_RESERVE)\n\t\t\t\tn = fifo_size + read_index - *write_index -\n\t\t\t\t\t\t\tFIFO_FULL_RESERVE;\n\t\t\telse\n\t\t\t\tn = fifo_size - *write_index;\n\t\t}\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->write_to_fifo(ptr, data, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\t*write_index += n;\n\t\tif (*write_index >= fifo_size)\n\t\t\t*write_index -= fifo_size;\n\t}\n\treturn len;\n}'
p7941
(dp7942
((g7899
g7938
tp7943
I1
tp7944
(dp7945
g14
(dp7946
(I11
I12
tp7947
(lp7948
S'\tif (read_index > fifo_size && *write_index > fifo_size)'
p7949
aS'\t\treturn 0;'
p7950
assg32
I4
sg12
g13
sg41
(I1
I41
tp7951
sssS'static int fifo_write_body(struct edge_info *einfo, const void *_data,\n\t\t\t\tint len, uint32_t *write_index)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tconst void *data = _data;\n\tuint32_t read_index = einfo->tx_ch_desc->read_index;\n\tuint32_t fifo_size = einfo->tx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || *write_index >= fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->tx_fifo + *write_index;\n\t\tif (*write_index < read_index) {\n\t\t\tn = read_index - *write_index - FIFO_FULL_RESERVE;\n\t\t} else {\n\t\t\tif (read_index < FIFO_FULL_RESERVE)\n\t\t\t\tn = fifo_size + read_index - *write_index -\n\t\t\t\t\t\t\tFIFO_FULL_RESERVE;\n\t\t\telse\n\t\t\t\tn = fifo_size - *write_index;\n\t\t}\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->write_to_fifo(ptr, data, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\t*write_index += n;\n\t\tif (*write_index >= fifo_size)\n\t\t\t*write_index -= fifo_size;\n\t}\n\treturn len;\n}'
p7952
(dp7953
((g7899
g7938
tp7954
I1
tp7955
(dp7956
g14
(dp7957
(I11
I12
tp7958
(lp7959
S'\tif (read_index >= fifo_size || *write_index >= fifo_size)'
p7960
aS'\t\treturn 0;'
p7961
assg32
I4
sg12
g13
sg41
(I1
I41
tp7962
sssS'static int fifo_write_body(struct edge_info *einfo, const void *_data,\n\t\t\t\tint len, uint32_t *write_index)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tconst void *data = _data;\n\tuint32_t read_index = einfo->tx_ch_desc->read_index;\n\tuint32_t fifo_size = einfo->tx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || *write_index >= fifo_size) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\twhile (len) {\n\t\tptr = einfo->tx_fifo + *write_index;\n\t\tif (*write_index < read_index) {\n\t\t\tn = read_index - *write_index - FIFO_FULL_RESERVE;\n\t\t} else {\n\t\t\tif (read_index < FIFO_FULL_RESERVE)\n\t\t\t\tn = fifo_size + read_index - *write_index -\n\t\t\t\t\t\t\tFIFO_FULL_RESERVE;\n\t\t\telse\n\t\t\t\tn = fifo_size - *write_index;\n\t\t}\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->write_to_fifo(ptr, data, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\t*write_index += n;\n\t\tif (*write_index >= fifo_size)\n\t\t\t*write_index -= fifo_size;\n\t}\n\treturn len;\n}'
p7963
(dp7964
((g7899
g7938
tp7965
I1
tp7966
(dp7967
g14
(dp7968
(I11
I14
tp7969
(lp7970
S'\tif (read_index >= fifo_size || *write_index >= fifo_size) {'
p7971
aS'\t\tWARN_ON_ONCE(1);'
p7972
aS'\t\treturn -EINVAL;'
p7973
aS'\t}'
p7974
assg32
I4
sg12
g13
sg41
(I1
I43
tp7975
sssssS'CVE-2019-2287'
p7976
(dp7977
(S'drivers/media/platform/msm/vidc/hfi_response_handler.c'
p7978
S'hfi_fill_codec_info'
p7979
tp7980
(dp7981
S'static int hfi_fill_codec_info(u8 *data_ptr,\n\t\tstruct vidc_hal_sys_init_done *sys_init_done) {\n\tu32 i;\n\tu32 codecs = 0, codec_count = 0, size = 0;\n\tstruct msm_vidc_capability *capability;\n\tu32 prop_id = *((u32 *)data_ptr);\n\tu8 *orig_data_ptr = data_ptr;\n\n\tif (prop_id ==  HFI_PROPERTY_PARAM_CODEC_SUPPORTED) {\n\t\tstruct hfi_codec_supported *prop;\n\n\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\tprop = (struct hfi_codec_supported *) data_ptr;\n\t\tsys_init_done->dec_codec_supported =\n\t\t\tprop->decoder_codec_supported;\n\t\tsys_init_done->enc_codec_supported =\n\t\t\tprop->encoder_codec_supported;\n\t\tsize = sizeof(struct hfi_codec_supported) + sizeof(u32);\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"%s: prop_id %#x, expected codec_supported property\\n",\n\t\t\t__func__, prop_id);\n\t}\n\n\tcodecs = sys_init_done->dec_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_DECODER);\n\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported decoder sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcodecs = sys_init_done->enc_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_ENCODER);\n\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsys_init_done->codec_count = codec_count;\n\n\tprop_id = *((u32 *)(orig_data_ptr + size));\n\tif (prop_id == HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED) {\n\t\tstruct hfi_max_sessions_supported *prop =\n\t\t\t(struct hfi_max_sessions_supported *)\n\t\t\t(orig_data_ptr + size + sizeof(u32));\n\n\t\tsys_init_done->max_sessions_supported = prop->max_sessions;\n\t\tsize += sizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\tdprintk(VIDC_DBG, "max_sessions_supported %d\\n",\n\t\t\t\tprop->max_sessions);\n\t}\n\treturn size;\n}'
p7982
(dp7983
((g7978
g7979
tp7984
I1
tp7985
(dp7986
g14
(dp7987
(I34
I38
tp7988
(lp7989
S'\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {'
p7990
aS'\t\t\t\tdprintk(VIDC_ERR,'
p7991
aS'\t\t\t\t\t"Max supported decoder sessions reached");'
p7992
aS'\t\t\t\tbreak;'
p7993
aS'\t\t\t}'
p7994
as(I50
I54
tp7995
(lp7996
S'\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {'
p7997
aS'\t\t\t\tdprintk(VIDC_ERR,'
p7998
aS'\t\t\t\t\t"Max supported sessions reached");'
p7999
aS'\t\t\t\tbreak;'
p8000
aS'\t\t\t}'
p8001
assg32
I2
sg12
g13
sg41
(I1
I71
tp8002
sssS'static int hfi_fill_codec_info(u8 *data_ptr,\n\t\tstruct vidc_hal_sys_init_done *sys_init_done, u32 rem_size) {\n\tu32 i;\n\tu32 codecs = 0, codec_count = 0, size = 0;\n\tstruct msm_vidc_capability *capability;\n\tu32 prop_id = *((u32 *)data_ptr);\n\tu8 *orig_data_ptr = data_ptr;\n\n\tif (prop_id ==  HFI_PROPERTY_PARAM_CODEC_SUPPORTED) {\n\t\tstruct hfi_codec_supported *prop;\n\n\t\tif (!validate_pkt_size(rem_size - sizeof(u32),\n\t\t\t\t       sizeof(struct hfi_codec_supported)))\n\t\t\treturn -E2BIG;\n\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\tprop = (struct hfi_codec_supported *) data_ptr;\n\t\tsys_init_done->dec_codec_supported =\n\t\t\tprop->decoder_codec_supported;\n\t\tsys_init_done->enc_codec_supported =\n\t\t\tprop->encoder_codec_supported;\n\t\tsize = sizeof(struct hfi_codec_supported) + sizeof(u32);\n\t\trem_size -=\n\t\t\tsizeof(struct hfi_codec_supported) + sizeof(u32);\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"%s: prop_id %#x, expected codec_supported property\\n",\n\t\t\t__func__, prop_id);\n\t}\n\n\tcodecs = sys_init_done->dec_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_DECODER);\n\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported decoder sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcodecs = sys_init_done->enc_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_ENCODER);\n\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsys_init_done->codec_count = codec_count;\n\n\tif (!validate_pkt_size(rem_size, sizeof(u32)))\n\t\treturn -E2BIG;\n\tprop_id = *((u32 *)(orig_data_ptr + size));\n\tif (prop_id == HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED) {\n\t\tstruct hfi_max_sessions_supported *prop;\n\n\t\tif (!validate_pkt_size(rem_size - sizeof(u32), sizeof(struct\n\t\t\t\thfi_max_sessions_supported)))\n\t\t\treturn -E2BIG;\n\t\tprop = (struct hfi_max_sessions_supported *)\n\t\t\t(orig_data_ptr + size + sizeof(u32));\n\n\t\tsys_init_done->max_sessions_supported = prop->max_sessions;\n\t\tsize += sizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\trem_size -=\n\t\t\tsizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\tdprintk(VIDC_DBG, "max_sessions_supported %d\\n",\n\t\t\t\tprop->max_sessions);\n\t}\n\treturn size;\n}'
p8003
(dp8004
((g7978
g7979
tp8005
I1
tp8006
(dp8007
g12
g13
sg14
(dp8008
(I64
I65
tp8009
(lp8010
S'\tif (!validate_pkt_size(rem_size, sizeof(u32)))'
p8011
aS'\t\treturn -E2BIG;'
p8012
as(I22
I23
tp8013
(lp8014
S'\t\trem_size -='
p8015
aS'\t\t\tsizeof(struct hfi_codec_supported) + sizeof(u32);'
p8016
as(I12
I14
tp8017
(lp8018
S'\t\tif (!validate_pkt_size(rem_size - sizeof(u32),'
p8019
aS'\t\t\t\t       sizeof(struct hfi_codec_supported)))'
p8020
aS'\t\t\treturn -E2BIG;'
p8021
as(I55
I59
tp8022
(lp8023
S'\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {'
p8024
aS'\t\t\t\tdprintk(VIDC_ERR,'
p8025
aS'\t\t\t\t\t"Max supported sessions reached");'
p8026
aS'\t\t\t\tbreak;'
p8027
aS'\t\t\t}'
p8028
as(I68
I73
tp8029
(lp8030
S'\t\tstruct hfi_max_sessions_supported *prop;'
p8031
ag59
aS'\t\tif (!validate_pkt_size(rem_size - sizeof(u32), sizeof(struct'
p8032
aS'\t\t\t\thfi_max_sessions_supported)))'
p8033
aS'\t\t\treturn -E2BIG;'
p8034
aS'\t\tprop = (struct hfi_max_sessions_supported *)'
p8035
as(I39
I43
tp8036
(lp8037
S'\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {'
p8038
aS'\t\t\t\tdprintk(VIDC_ERR,'
p8039
aS'\t\t\t\t\t"Max supported decoder sessions reached");'
p8040
aS'\t\t\t\tbreak;'
p8041
aS'\t\t\t}'
p8042
as(I2
I2
tp8043
(lp8044
S'\t\tstruct vidc_hal_sys_init_done *sys_init_done, u32 rem_size) {'
p8045
as(I78
I79
tp8046
(lp8047
S'\t\trem_size -='
p8048
aS'\t\t\tsizeof(struct hfi_max_sessions_supported) + sizeof(u32);'
p8049
assg32
I3
sg33
(dp8050
(I68
I69
tp8051
(lp8052
S'\t\tstruct hfi_max_sessions_supported *prop ='
p8053
aS'\t\t\t(struct hfi_max_sessions_supported *)'
p8054
as(I2
I2
tp8055
(lp8056
S'\t\tstruct vidc_hal_sys_init_done *sys_init_done) {'
p8057
assg41
(I1
I84
tp8058
sssssS'CVE-2018-20961'
p8059
(dp8060
(S'drivers/usb/gadget/function/f_midi.c'
p8061
S'f_midi_set_alt'
p8062
tp8063
(dp8064
S'static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen,\n\t\t\t\t\t\tmidi->gadget->extra_buf_alloc);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen, 0);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, "%s: couldn\'t enqueue request: %d\\n",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tif (req->buf != NULL)\n\t\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}'
p8065
(dp8066
((g8061
g8062
tp8067
I1
tp8068
(dp8069
g12
g13
sg14
(dp8070
(I47
I48
tp8071
(lp8072
S'\t\t\tif (req->buf != NULL)'
p8073
aS'\t\t\t\tfree_ep_req(midi->out_ep, req);'
p8074
assg32
I3
sg33
(dp8075
(I47
I47
tp8076
(lp8077
S'\t\t\tfree_ep_req(midi->out_ep, req);'
p8078
assg41
(I1
I54
tp8079
ssss(S'drivers/usb/gadget/u_f.h'
p8080
S'free_ep_req'
p8081
tp8082
(dp8083
S'static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}'
p8084
(dp8085
((g8080
g8081
tp8086
I1
tp8087
(dp8088
g14
(dp8089
(I3
I3
tp8090
(lp8091
S'\tWARN_ON(req->buf == NULL);'
p8092
as(I5
I5
tp8093
(lp8094
S'\treq->buf = NULL;'
p8095
assg32
I2
sg12
g13
sg41
(I1
I7
tp8096
sssssS'CVE-2019-2284'
p8097
(dp8098
(S'drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c'
p8099
S'cam_req_mgr_link'
p8100
tp8101
(dp8102
S'int cam_req_mgr_link(struct cam_req_mgr_link_info *link_info)\n{\n\tint                                     rc = 0;\n\tint                                     wq_flag = 0;\n\tchar                                    buf[128];\n\tstruct cam_create_dev_hdl               root_dev;\n\tstruct cam_req_mgr_core_session        *cam_session;\n\tstruct cam_req_mgr_core_link           *link;\n\n\tif (!link_info) {\n\t\tCAM_DBG(CAM_CRM, "NULL pointer");\n\t\treturn -EINVAL;\n\t}\n\tif (link_info->num_devices > CAM_REQ_MGR_MAX_HANDLES) {\n\t\tCAM_ERR(CAM_CRM, "Invalid num devices %d",\n\t\t\tlink_info->num_devices);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&g_crm_core_dev->crm_lock);\n\n\t/* session hdl\'s priv data is cam session struct */\n\tcam_session = (struct cam_req_mgr_core_session *)\n\t\tcam_get_device_priv(link_info->session_hdl);\n\tif (!cam_session) {\n\t\tCAM_DBG(CAM_CRM, "NULL pointer");\n\t\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Allocate link struct and map it with session\'s request queue */\n\tlink = __cam_req_mgr_reserve_link(cam_session);\n\tif (!link) {\n\t\tCAM_ERR(CAM_CRM, "failed to reserve new link");\n\t\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\t\treturn -EINVAL;\n\t}\n\tCAM_DBG(CAM_CRM, "link reserved %pK %x", link, link->link_hdl);\n\n\tmemset(&root_dev, 0, sizeof(struct cam_create_dev_hdl));\n\troot_dev.session_hdl = link_info->session_hdl;\n\troot_dev.priv = (void *)link;\n\n\tmutex_lock(&link->lock);\n\t/* Create unique dev handle for link */\n\tlink->link_hdl = cam_create_device_hdl(&root_dev);\n\tif (link->link_hdl < 0) {\n\t\tCAM_ERR(CAM_CRM,\n\t\t\t"Insufficient memory to create new device handle");\n\t\trc = link->link_hdl;\n\t\tgoto link_hdl_fail;\n\t}\n\tlink_info->link_hdl = link->link_hdl;\n\n\t/* Allocate memory to hold data of all linked devs */\n\trc = __cam_req_mgr_create_subdevs(&link->l_dev,\n\t\tlink_info->num_devices);\n\tif (rc < 0) {\n\t\tCAM_ERR(CAM_CRM,\n\t\t\t"Insufficient memory to create new crm subdevs");\n\t\tgoto create_subdev_failed;\n\t}\n\n\t/* Using device ops query connected devs, prepare request tables */\n\trc = __cam_req_mgr_setup_link_info(link, link_info);\n\tif (rc < 0)\n\t\tgoto setup_failed;\n\n\tspin_lock_bh(&link->link_state_spin_lock);\n\tlink->state = CAM_CRM_LINK_STATE_READY;\n\tspin_unlock_bh(&link->link_state_spin_lock);\n\n\t/* Create worker for current link */\n\tsnprintf(buf, sizeof(buf), "%x-%x",\n\t\tlink_info->session_hdl, link->link_hdl);\n\twq_flag = CAM_WORKQ_FLAG_HIGH_PRIORITY | CAM_WORKQ_FLAG_SERIAL;\n\trc = cam_req_mgr_workq_create(buf, CRM_WORKQ_NUM_TASKS,\n\t\t&link->workq, CRM_WORKQ_USAGE_NON_IRQ, wq_flag);\n\tif (rc < 0) {\n\t\tCAM_ERR(CAM_CRM, "FATAL: unable to create worker");\n\t\t__cam_req_mgr_destroy_link_info(link);\n\t\tgoto setup_failed;\n\t}\n\n\t/* Assign payload to workqueue tasks */\n\trc = __cam_req_mgr_setup_payload(link->workq);\n\tif (rc < 0) {\n\t\t__cam_req_mgr_destroy_link_info(link);\n\t\tcam_req_mgr_workq_destroy(&link->workq);\n\t\tgoto setup_failed;\n\t}\n\n\tmutex_unlock(&link->lock);\n\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\treturn rc;\nsetup_failed:\n\t__cam_req_mgr_destroy_subdev(link->l_dev);\ncreate_subdev_failed:\n\tcam_destroy_device_hdl(link->link_hdl);\n\tlink_info->link_hdl = 0;\nlink_hdl_fail:\n\tmutex_unlock(&link->lock);\n\t__cam_req_mgr_unreserve_link(cam_session, link);\n\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\treturn rc;\n}'
p8103
(dp8104
((g8099
g8100
tp8105
I1
tp8106
(dp8107
g33
(dp8108
(I31
I32
tp8109
(lp8110
S'\tmutex_lock(&g_crm_core_dev->crm_lock);'
p8111
ag59
assg14
(dp8112
(I20
I21
tp8113
(lp8114
S'\tmutex_lock(&g_crm_core_dev->crm_lock);'
p8115
ag59
as(I27
I27
tp8116
(lp8117
S'\t\tmutex_unlock(&g_crm_core_dev->crm_lock);'
p8118
assg32
I1
sg12
g13
sg41
(I1
I106
tp8119
sssssS'CVE-2019-10126'
p8120
(dp8121
(S'drivers/net/wireless/marvell/mwifiex/ie.c'
p8122
S'mwifiex_uap_parse_tail_ies'
p8123
tp8124
(dp8125
S"static int mwifiex_uap_parse_tail_ies(struct mwifiex_private *priv,\n\t\t\t\t      struct cfg80211_beacon_data *info)\n{\n\tstruct mwifiex_ie *gen_ie;\n\tstruct ieee_types_header *hdr;\n\tstruct ieee80211_vendor_ie *vendorhdr;\n\tu16 gen_idx = MWIFIEX_AUTO_IDX_MASK, ie_len = 0;\n\tint left_len, parsed_len = 0;\n\tunsigned int token_len;\n\tint err = 0;\n\n\tif (!info->tail || !info->tail_len)\n\t\treturn 0;\n\n\tgen_ie = kzalloc(sizeof(*gen_ie), GFP_KERNEL);\n\tif (!gen_ie)\n\t\treturn -ENOMEM;\n\n\tleft_len = info->tail_len;\n\n\t/* Many IEs are generated in FW by parsing bss configuration.\n\t * Let's not add them here; else we may end up duplicating these IEs\n\t */\n\twhile (left_len > sizeof(struct ieee_types_header)) {\n\t\thdr = (void *)(info->tail + parsed_len);\n\t\ttoken_len = hdr->len + sizeof(struct ieee_types_header);\n\t\tif (token_len > left_len) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tswitch (hdr->element_id) {\n\t\tcase WLAN_EID_SSID:\n\t\tcase WLAN_EID_SUPP_RATES:\n\t\tcase WLAN_EID_COUNTRY:\n\t\tcase WLAN_EID_PWR_CONSTRAINT:\n\t\tcase WLAN_EID_EXT_SUPP_RATES:\n\t\tcase WLAN_EID_HT_CAPABILITY:\n\t\tcase WLAN_EID_HT_OPERATION:\n\t\tcase WLAN_EID_VHT_CAPABILITY:\n\t\tcase WLAN_EID_VHT_OPERATION:\n\t\tcase WLAN_EID_VENDOR_SPECIFIC:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr, token_len);\n\t\t\tie_len += token_len;\n\t\t\tbreak;\n\t\t}\n\t\tleft_len -= token_len;\n\t\tparsed_len += token_len;\n\t}\n\n\t/* parse only WPA vendor IE from tail, WMM IE is configured by\n\t * bss_config command\n\t */\n\tvendorhdr = (void *)cfg80211_find_vendor_ie(WLAN_OUI_MICROSOFT,\n\t\t\t\t\t\t    WLAN_OUI_TYPE_MICROSOFT_WPA,\n\t\t\t\t\t\t    info->tail, info->tail_len);\n\tif (vendorhdr) {\n\t\ttoken_len = vendorhdr->len + sizeof(struct ieee_types_header);\n\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr, token_len);\n\t\tie_len += token_len;\n\t}\n\n\tif (!ie_len)\n\t\tgoto out;\n\n\tgen_ie->ie_index = cpu_to_le16(gen_idx);\n\tgen_ie->mgmt_subtype_mask = cpu_to_le16(MGMT_MASK_BEACON |\n\t\t\t\t\t\tMGMT_MASK_PROBE_RESP |\n\t\t\t\t\t\tMGMT_MASK_ASSOC_RESP);\n\tgen_ie->ie_length = cpu_to_le16(ie_len);\n\n\tif (mwifiex_update_uap_custom_ie(priv, gen_ie, &gen_idx, NULL, NULL,\n\t\t\t\t\t NULL, NULL)) {\n\t\terr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tpriv->gen_idx = gen_idx;\n\n out:\n\tkfree(gen_ie);\n\treturn err;\n}"
p8126
(dp8127
((g8122
g8123
tp8128
I1
tp8129
(dp8130
g33
(dp8131
(I84
I85
tp8132
(lp8133
S'\t\tkfree(gen_ie);'
p8134
aS'\t\treturn -1;'
p8135
as(I92
I92
tp8136
(lp8137
S'\treturn 0;'
p8138
as(I53
I54
tp8139
(lp8140
S'\t\tleft_len -= hdr->len + sizeof(struct ieee_types_header);'
p8141
aS'\t\tparsed_len += hdr->len + sizeof(struct ieee_types_header);'
p8142
as(I45
I47
tp8143
(lp8144
S'\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr,'
p8145
aS'\t\t\t       hdr->len + sizeof(struct ieee_types_header));'
p8146
aS'\t\t\tie_len += hdr->len + sizeof(struct ieee_types_header);'
p8147
as(I64
I66
tp8148
(lp8149
S'\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr,'
p8150
aS'\t\t       vendorhdr->len + sizeof(struct ieee_types_header));'
p8151
aS'\t\tie_len += vendorhdr->len + sizeof(struct ieee_types_header);'
p8152
as(I73
I76
tp8153
(lp8154
S'\tif (!ie_len) {'
p8155
aS'\t\tkfree(gen_ie);'
p8156
aS'\t\treturn 0;'
p8157
aS'\t}'
p8158
assg14
(dp8159
(I9
I10
tp8160
(lp8161
S'\tunsigned int token_len;'
p8162
aS'\tint err = 0;'
p8163
as(I26
I31
tp8164
(lp8165
S'\t\ttoken_len = hdr->len + sizeof(struct ieee_types_header);'
p8166
aS'\t\tif (token_len > left_len) {'
p8167
aS'\t\t\terr = -EINVAL;'
p8168
aS'\t\t\tgoto out;'
p8169
aS'\t\t}'
p8170
ag59
as(I89
I90
tp8171
(lp8172
g59
aS' out:'
p8173
as(I45
I50
tp8174
(lp8175
S'\t\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {'
p8176
aS'\t\t\t\terr = -EINVAL;'
p8177
aS'\t\t\t\tgoto out;'
p8178
aS'\t\t\t}'
p8179
aS'\t\t\tmemcpy(gen_ie->ie_buffer + ie_len, hdr, token_len);'
p8180
aS'\t\t\tie_len += token_len;'
p8181
as(I64
I70
tp8182
(lp8183
S'\t\ttoken_len = vendorhdr->len + sizeof(struct ieee_types_header);'
p8184
aS'\t\tif (ie_len + token_len > IEEE_MAX_IE_SIZE) {'
p8185
aS'\t\t\terr = -EINVAL;'
p8186
aS'\t\t\tgoto out;'
p8187
aS'\t\t}'
p8188
aS'\t\tmemcpy(gen_ie->ie_buffer + ie_len, vendorhdr, token_len);'
p8189
aS'\t\tie_len += token_len;'
p8190
as(I53
I54
tp8191
(lp8192
S'\t\tleft_len -= token_len;'
p8193
aS'\t\tparsed_len += token_len;'
p8194
as(I92
I92
tp8195
(lp8196
S'\treturn err;'
p8197
as(I73
I74
tp8198
(lp8199
S'\tif (!ie_len)'
p8200
aS'\t\tgoto out;'
p8201
as(I84
I85
tp8202
(lp8203
S'\t\terr = -EINVAL;'
p8204
aS'\t\tgoto out;'
p8205
assg32
I2
sg12
g13
sg41
(I1
I93
tp8206
sssssS'CVE-2018-1000204'
p8207
(dp8208
(S'drivers/scsi/sg.c'
p8209
S'sg_build_indirect'
p8210
tp8211
(dp8212
S'sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don\'t know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t"sg_build_indirect: buff_size=%d, blk_size=%d\\n",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t "sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t "sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}'
p8213
(dp8214
((g8209
g8210
tp8215
I1
tp8216
(dp8217
g12
g13
sg14
(dp8218
(I49
I49
tp8219
(lp8220
S'\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);'
p8221
assg32
I3
sg33
(dp8222
(I49
I49
tp8223
(lp8224
S'\t\tschp->pages[k] = alloc_pages(gfp_mask, order);'
p8225
assg41
(I1
I83
tp8226
sssssS'CVE-2018-3564'
p8227
(dp8228
(S'drivers/char/adsprpc.c'
p8229
S'fastrpc_file_free'
p8230
tp8231
(dp8232
S'static int fastrpc_file_free(struct fastrpc_file *fl)\n{\n\tstruct hlist_node *n = NULL;\n\tstruct fastrpc_mmap *map = NULL, *lmap = NULL;\n\tstruct fastrpc_perf *perf = NULL, *fperf = NULL;\n\tint cid;\n\n\tif (!fl)\n\t\treturn 0;\n\tcid = fl->cid;\n\n\t(void)fastrpc_release_current_dsp_process(fl);\n\n\tspin_lock(&fl->apps->hlock);\n\thlist_del_init(&fl->hn);\n\tspin_unlock(&fl->apps->hlock);\n\n\tif (!fl->sctx) {\n\t\tkfree(fl);\n\t\treturn 0;\n\t}\n\tspin_lock(&fl->hlock);\n\tfl->file_close = 1;\n\tspin_unlock(&fl->hlock);\n\tfastrpc_context_list_dtor(fl);\n\tfastrpc_buf_list_free(fl);\n\tmutex_lock(&fl->fl_map_mutex);\n\tdo {\n\t\tlmap = NULL;\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\thlist_del_init(&map->hn);\n\t\t\tlmap = map;\n\t\t\tbreak;\n\t\t}\n\t\tfastrpc_mmap_free(lmap, 1);\n\t} while (lmap);\n\tmutex_unlock(&fl->fl_map_mutex);\n\tif (fl->refcount && (fl->ssrcount == fl->apps->channel[cid].ssrcount))\n\t\tkref_put_mutex(&fl->apps->channel[cid].kref,\n\t\t\t\tfastrpc_channel_close, &fl->apps->smd_mutex);\n\tif (fl->sctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->sctx);\n\tif (fl->secsctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->secsctx);\n\n\tmutex_lock(&fl->perf_mutex);\n\tdo {\n\t\tstruct hlist_node *pn = NULL;\n\n\t\tfperf = NULL;\n\t\thlist_for_each_entry_safe(perf, pn, &fl->perf, hn) {\n\t\t\thlist_del_init(&perf->hn);\n\t\t\tfperf = perf;\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fperf);\n\t} while (fperf);\n\tmutex_unlock(&fl->perf_mutex);\n\tmutex_destroy(&fl->perf_mutex);\n\tmutex_destroy(&fl->fl_map_mutex);\n\tmutex_destroy(&fl->map_mutex);\n\tkfree(fl);\n\treturn 0;\n}'
p8233
(dp8234
((g8229
g8230
tp8235
I1
tp8236
(dp8237
g14
(dp8238
(I61
I61
tp8239
(lp8240
S'\tmutex_destroy(&fl->map_mutex);'
p8241
assg32
I1
sg12
g13
sg41
(I1
I64
tp8242
sssS'static int fastrpc_file_free(struct fastrpc_file *fl)\n{\n\tstruct hlist_node *n = NULL;\n\tstruct fastrpc_mmap *map = NULL, *lmap = NULL;\n\tstruct fastrpc_perf *perf = NULL, *fperf = NULL;\n\tint cid;\n\n\tif (!fl)\n\t\treturn 0;\n\tcid = fl->cid;\n\n\t(void)fastrpc_release_current_dsp_process(fl);\n\n\tspin_lock(&fl->apps->hlock);\n\thlist_del_init(&fl->hn);\n\tspin_unlock(&fl->apps->hlock);\n\tkfree(fl->debug_buf);\n\n\tif (!fl->sctx) {\n\t\tkfree(fl);\n\t\treturn 0;\n\t}\n\tspin_lock(&fl->hlock);\n\tfl->file_close = 1;\n\tspin_unlock(&fl->hlock);\n\tif (!IS_ERR_OR_NULL(fl->init_mem))\n\t\tfastrpc_buf_free(fl->init_mem, 0);\n\tfastrpc_context_list_dtor(fl);\n\tfastrpc_cached_buf_list_free(fl);\n\tmutex_lock(&fl->fl_map_mutex);\n\tdo {\n\t\tlmap = NULL;\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\thlist_del_init(&map->hn);\n\t\t\tlmap = map;\n\t\t\tbreak;\n\t\t}\n\t\tfastrpc_mmap_free(lmap, 1);\n\t} while (lmap);\n\tmutex_unlock(&fl->fl_map_mutex);\n\tif (fl->refcount && (fl->ssrcount == fl->apps->channel[cid].ssrcount))\n\t\tkref_put_mutex(&fl->apps->channel[cid].kref,\n\t\t\t\tfastrpc_channel_close, &fl->apps->smd_mutex);\n\tif (fl->sctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->sctx);\n\tif (fl->secsctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->secsctx);\n\n\tmutex_lock(&fl->perf_mutex);\n\tdo {\n\t\tstruct hlist_node *pn = NULL;\n\n\t\tfperf = NULL;\n\t\thlist_for_each_entry_safe(perf, pn, &fl->perf, hn) {\n\t\t\thlist_del_init(&perf->hn);\n\t\t\tfperf = perf;\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fperf);\n\t} while (fperf);\n\tfastrpc_remote_buf_list_free(fl);\n\tmutex_unlock(&fl->perf_mutex);\n\tmutex_destroy(&fl->perf_mutex);\n\tmutex_destroy(&fl->fl_map_mutex);\n\tmutex_destroy(&fl->map_mutex);\n\tkfree(fl);\n\treturn 0;\n}'
p8243
(dp8244
((g8229
g8230
tp8245
I1
tp8246
(dp8247
g33
(dp8248
(I29
I29
tp8249
(lp8250
S'\tfastrpc_buf_list_free(fl);'
p8251
assg14
(dp8252
(I61
I61
tp8253
(lp8254
S'\tfastrpc_remote_buf_list_free(fl);'
p8255
as(I65
I65
tp8256
(lp8257
S'\tmutex_destroy(&fl->map_mutex);'
p8258
as(I26
I27
tp8259
(lp8260
S'\tif (!IS_ERR_OR_NULL(fl->init_mem))'
p8261
aS'\t\tfastrpc_buf_free(fl->init_mem, 0);'
p8262
as(I17
I17
tp8263
(lp8264
S'\tkfree(fl->debug_buf);'
p8265
as(I29
I29
tp8266
(lp8267
S'\tfastrpc_cached_buf_list_free(fl);'
p8268
assg32
I1
sg12
g13
sg41
(I1
I68
tp8269
sssS'static int fastrpc_file_free(struct fastrpc_file *fl)\n{\n\tstruct hlist_node *n = NULL;\n\tstruct fastrpc_mmap *map = NULL, *lmap = NULL;\n\tstruct fastrpc_perf *perf = NULL, *fperf = NULL;\n\tint cid;\n\n\tif (!fl)\n\t\treturn 0;\n\tcid = fl->cid;\n\n\t(void)fastrpc_release_current_dsp_process(fl);\n\n\tspin_lock(&fl->apps->hlock);\n\thlist_del_init(&fl->hn);\n\tspin_unlock(&fl->apps->hlock);\n\tkfree(fl->debug_buf);\n\n\tif (!fl->sctx) {\n\t\tkfree(fl);\n\t\treturn 0;\n\t}\n\tspin_lock(&fl->hlock);\n\tfl->file_close = 1;\n\tspin_unlock(&fl->hlock);\n\tfastrpc_context_list_dtor(fl);\n\tfastrpc_buf_list_free(fl);\n\tmutex_lock(&fl->fl_map_mutex);\n\tdo {\n\t\tlmap = NULL;\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\thlist_del_init(&map->hn);\n\t\t\tlmap = map;\n\t\t\tbreak;\n\t\t}\n\t\tfastrpc_mmap_free(lmap, 1);\n\t} while (lmap);\n\tmutex_unlock(&fl->fl_map_mutex);\n\tif (fl->refcount && (fl->ssrcount == fl->apps->channel[cid].ssrcount))\n\t\tkref_put_mutex(&fl->apps->channel[cid].kref,\n\t\t\t\tfastrpc_channel_close, &fl->apps->smd_mutex);\n\tif (fl->sctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->sctx);\n\tif (fl->secsctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->secsctx);\n\n\tmutex_lock(&fl->perf_mutex);\n\tdo {\n\t\tstruct hlist_node *pn = NULL;\n\n\t\tfperf = NULL;\n\t\thlist_for_each_entry_safe(perf, pn, &fl->perf, hn) {\n\t\t\thlist_del_init(&perf->hn);\n\t\t\tfperf = perf;\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fperf);\n\t} while (fperf);\n\tmutex_unlock(&fl->perf_mutex);\n\tmutex_destroy(&fl->perf_mutex);\n\tmutex_destroy(&fl->fl_map_mutex);\n\tmutex_destroy(&fl->map_mutex);\n\tkfree(fl);\n\treturn 0;\n}'
p8270
(dp8271
((g8229
g8230
tp8272
I1
tp8273
(dp8274
g14
(dp8275
(I17
I17
tp8276
(lp8277
S'\tkfree(fl->debug_buf);'
p8278
as(I62
I62
tp8279
(lp8280
S'\tmutex_destroy(&fl->map_mutex);'
p8281
assg32
I1
sg12
g13
sg41
(I1
I65
tp8282
ssss(g8229
S'fastrpc_device_release'
p8283
tp8284
(dp8285
S'static int fastrpc_device_release(struct inode *inode, struct file *file)\n{\n\tstruct fastrpc_file *fl = (struct fastrpc_file *)file->private_data;\n\n\tif (fl) {\n\t\tif (fl->qos_request && pm_qos_request_active(&fl->pm_qos_req))\n\t\t\tpm_qos_remove_request(&fl->pm_qos_req);\n\t\tif (fl->debugfs_file != NULL)\n\t\t\tdebugfs_remove(fl->debugfs_file);\n\t\tfastrpc_file_free(fl);\n\t\tfile->private_data = NULL;\n\t}\n\treturn 0;\n}'
p8286
(dp8287
((g8229
g8283
tp8288
I1
tp8289
(dp8290
g12
g13
sg41
(I1
I14
tp8291
sg32
I2
sg33
(dp8292
(I10
I10
tp8293
(lp8294
S'\t\tmutex_destroy(&fl->map_mutex);'
p8295
assssssS'CVE-2019-9245'
p8296
(dp8297
(S'fs/f2fs/xattr.c'
p8298
S'lookup_all_xattrs'
p8299
tp8300
(dp8301
S'static int lookup_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\tunsigned int index, unsigned int len,\n\t\t\t\tconst char *name, struct f2fs_xattr_entry **xe,\n\t\t\t\tvoid **base_addr, int *base_size)\n{\n\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;\n\tvoid *last_addr = NULL;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tint err = 0;\n\n\tif (!xnid && !inline_size)\n\t\treturn -ENODATA;\n\n\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;\n\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t*xe = __find_inline_xattr(inode, txattr_addr, &last_addr,\n\t\t\t\t\t\tindex, len, name);\n\t\tif (*xe) {\n\t\t\t*base_size = inline_size;\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\t/* read from xattr node block */\n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (last_addr)\n\t\tcur_addr = XATTR_HDR(last_addr) - 1;\n\telse\n\t\tcur_addr = txattr_addr;\n\n\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);\n\tif (!*xe) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\ncheck:\n\tif (IS_XATTR_LAST_ENTRY(*xe)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t*base_addr = txattr_addr;\n\treturn 0;\nout:\n\tkvfree(txattr_addr);\n\treturn err;\n}'
p8302
(dp8303
((g8298
g8299
tp8304
I1
tp8305
(dp8306
g12
g13
sg14
(dp8307
(I62
I62
tp8308
(lp8309
S'\tkvfree(txattr_addr);'
p8310
as(I4
I4
tp8311
(lp8312
S'\t\t\t\tvoid **base_addr, int *base_size)'
p8313
as(I6
I7
tp8314
(lp8315
S'\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;'
p8316
aS'\tvoid *last_addr = NULL;'
p8317
as(I48
I52
tp8318
(lp8319
S'\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);'
p8320
aS'\tif (!*xe) {'
p8321
aS'\t\terr = -EFAULT;'
p8322
aS'\t\tgoto out;'
p8323
aS'\t}'
p8324
as(I20
I21
tp8325
(lp8326
S'\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);'
p8327
ag59
as(I30
I31
tp8328
(lp8329
S'\t\tif (*xe) {'
p8330
aS'\t\t\t*base_size = inline_size;'
p8331
as(I12
I12
tp8332
(lp8333
S'\tif (!xnid && !inline_size)'
p8334
as(I15
I16
tp8335
(lp8336
S'\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;'
p8337
aS'\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);'
p8338
as(I33
I33
tp8339
(lp8340
S'\t\t}'
p8341
assg32
I8
sg33
(dp8342
(I62
I62
tp8343
(lp8344
S'\tkzfree(txattr_addr);'
p8345
as(I4
I4
tp8346
(lp8347
S'\t\t\t\tvoid **base_addr)'
p8348
as(I6
I6
tp8349
(lp8350
S'\tvoid *cur_addr, *txattr_addr, *last_addr = NULL;'
p8351
as(I48
I48
tp8352
(lp8353
S'\t*xe = __find_xattr(cur_addr, index, len, name);'
p8354
as(I12
I12
tp8355
(lp8356
S'\tif (!size && !inline_size)'
p8357
as(I15
I16
tp8358
(lp8359
S'\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode),'
p8360
aS'\t\t\tinline_size + size + XATTR_PADDING_SIZE, GFP_NOFS);'
p8361
as(I9
I9
tp8362
(lp8363
S'\tunsigned int size = xnid ? VALID_XATTR_BLOCK_SIZE : 0;'
p8364
as(I30
I30
tp8365
(lp8366
S'\t\tif (*xe)'
p8367
assg41
(I1
I64
tp8368
sssS'static int lookup_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\tunsigned int index, unsigned int len,\n\t\t\t\tconst char *name, struct f2fs_xattr_entry **xe,\n\t\t\t\tvoid **base_addr, int *base_size)\n{\n\tvoid *cur_addr, *txattr_addr, *last_addr = NULL;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int size = xnid ? VALID_XATTR_BLOCK_SIZE : 0;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tint err = 0;\n\n\tif (!size && !inline_size)\n\t\treturn -ENODATA;\n\n\t*base_size = inline_size + size + XATTR_PADDING_SIZE;\n\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t*xe = __find_inline_xattr(inode, txattr_addr, &last_addr,\n\t\t\t\t\t\tindex, len, name);\n\t\tif (*xe) {\n\t\t\t*base_size = inline_size;\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\t/* read from xattr node block */\n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (last_addr)\n\t\tcur_addr = XATTR_HDR(last_addr) - 1;\n\telse\n\t\tcur_addr = txattr_addr;\n\n\t*xe = __find_xattr(cur_addr, index, len, name);\ncheck:\n\tif (IS_XATTR_LAST_ENTRY(*xe)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t*base_addr = txattr_addr;\n\treturn 0;\nout:\n\tkzfree(txattr_addr);\n\treturn err;\n}'
p8369
(dp8370
((g8298
g8299
tp8371
I1
tp8372
(dp8373
g12
g13
sg14
(dp8374
(I28
I29
tp8375
(lp8376
S'\t\tif (*xe) {'
p8377
aS'\t\t\t*base_size = inline_size;'
p8378
as(I4
I4
tp8379
(lp8380
S'\t\t\t\tvoid **base_addr, int *base_size)'
p8381
as(I15
I16
tp8382
(lp8383
S'\t*base_size = inline_size + size + XATTR_PADDING_SIZE;'
p8384
aS'\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);'
p8385
as(I31
I31
tp8386
(lp8387
S'\t\t}'
p8388
assg32
I8
sg33
(dp8389
(I4
I4
tp8390
(lp8391
S'\t\t\t\tvoid **base_addr)'
p8392
as(I15
I16
tp8393
(lp8394
S'\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode),'
p8395
aS'\t\t\tinline_size + size + XATTR_PADDING_SIZE, GFP_NOFS);'
p8396
as(I28
I28
tp8397
(lp8398
S'\t\tif (*xe)'
p8399
assg41
(I1
I58
tp8400
sssS'static int lookup_all_xattrs(struct inode *inode, struct page *ipage,\n\t\t\t\tunsigned int index, unsigned int len,\n\t\t\t\tconst char *name, struct f2fs_xattr_entry **xe,\n\t\t\t\tvoid **base_addr, int *base_size)\n{\n\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;\n\tvoid *last_addr = NULL;\n\tnid_t xnid = F2FS_I(inode)->i_xattr_nid;\n\tunsigned int inline_size = inline_xattr_size(inode);\n\tint err = 0;\n\n\tif (!xnid && !inline_size)\n\t\treturn -ENODATA;\n\n\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;\n\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);\n\tif (!txattr_addr)\n\t\treturn -ENOMEM;\n\n\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);\n\n\t/* read from inline xattr */\n\tif (inline_size) {\n\t\terr = read_inline_xattr(inode, ipage, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\n\t\t*xe = __find_inline_xattr(inode, txattr_addr, &last_addr,\n\t\t\t\t\t\tindex, len, name);\n\t\tif (*xe) {\n\t\t\t*base_size = inline_size;\n\t\t\tgoto check;\n\t\t}\n\t}\n\n\t/* read from xattr node block */\n\tif (xnid) {\n\t\terr = read_xattr_block(inode, txattr_addr);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\tif (last_addr)\n\t\tcur_addr = XATTR_HDR(last_addr) - 1;\n\telse\n\t\tcur_addr = txattr_addr;\n\n\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);\n\tif (!*xe) {\n\t\tf2fs_err(F2FS_I_SB(inode), "inode (%lu) has corrupted xattr",\n\t\t\t\t\t\t\t\tinode->i_ino);\n\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto out;\n\t}\ncheck:\n\tif (IS_XATTR_LAST_ENTRY(*xe)) {\n\t\terr = -ENODATA;\n\t\tgoto out;\n\t}\n\n\t*base_addr = txattr_addr;\n\treturn 0;\nout:\n\tkvfree(txattr_addr);\n\treturn err;\n}'
p8401
(dp8402
((g8298
g8299
tp8403
I1
tp8404
(dp8405
g12
g13
sg14
(dp8406
(I4
I4
tp8407
(lp8408
S'\t\t\t\tvoid **base_addr, int *base_size)'
p8409
as(I6
I7
tp8410
(lp8411
S'\tvoid *cur_addr, *txattr_addr, *last_txattr_addr;'
p8412
aS'\tvoid *last_addr = NULL;'
p8413
as(I20
I21
tp8414
(lp8415
S'\tlast_txattr_addr = (void *)txattr_addr + XATTR_SIZE(xnid, inode);'
p8416
ag59
as(I30
I31
tp8417
(lp8418
S'\t\tif (*xe) {'
p8419
aS'\t\t\t*base_size = inline_size;'
p8420
as(I12
I12
tp8421
(lp8422
S'\tif (!xnid && !inline_size)'
p8423
as(I15
I16
tp8424
(lp8425
S'\t*base_size = XATTR_SIZE(xnid, inode) + XATTR_PADDING_SIZE;'
p8426
aS'\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode), *base_size, GFP_NOFS);'
p8427
as(I33
I33
tp8428
(lp8429
S'\t\t}'
p8430
as(I48
I55
tp8431
(lp8432
S'\t*xe = __find_xattr(cur_addr, last_txattr_addr, index, len, name);'
p8433
aS'\tif (!*xe) {'
p8434
aS'\t\tf2fs_err(F2FS_I_SB(inode), "inode (%lu) has corrupted xattr",'
p8435
aS'\t\t\t\t\t\t\t\tinode->i_ino);'
p8436
aS'\t\tset_sbi_flag(F2FS_I_SB(inode), SBI_NEED_FSCK);'
p8437
aS'\t\terr = -EFSCORRUPTED;'
p8438
aS'\t\tgoto out;'
p8439
aS'\t}'
p8440
as(I65
I65
tp8441
(lp8442
S'\tkvfree(txattr_addr);'
p8443
assg32
I8
sg33
(dp8444
(I4
I4
tp8445
(lp8446
S'\t\t\t\tvoid **base_addr)'
p8447
as(I65
I65
tp8448
(lp8449
S'\tkzfree(txattr_addr);'
p8450
as(I6
I6
tp8451
(lp8452
S'\tvoid *cur_addr, *txattr_addr, *last_addr = NULL;'
p8453
as(I48
I48
tp8454
(lp8455
S'\t*xe = __find_xattr(cur_addr, index, len, name);'
p8456
as(I12
I12
tp8457
(lp8458
S'\tif (!size && !inline_size)'
p8459
as(I15
I16
tp8460
(lp8461
S'\ttxattr_addr = f2fs_kzalloc(F2FS_I_SB(inode),'
p8462
aS'\t\t\tinline_size + size + XATTR_PADDING_SIZE, GFP_NOFS);'
p8463
as(I9
I9
tp8464
(lp8465
S'\tunsigned int size = xnid ? VALID_XATTR_BLOCK_SIZE : 0;'
p8466
as(I30
I30
tp8467
(lp8468
S'\t\tif (*xe)'
p8469
assg41
(I1
I67
tp8470
ssss(g8298
S'f2fs_getxattr'
p8471
tp8472
(dp8473
S'int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkzfree(base_addr);\n\treturn error;\n}'
p8474
(dp8475
((g8298
g8471
tp8476
I1
tp8477
(dp8478
g33
(dp8479
(I19
I19
tp8480
(lp8481
S'\t\t\t\t&entry, &base_addr);'
p8482
assg14
(dp8483
(I33
I37
tp8484
(lp8485
g59
aS'\t\tif (base_size - (pval - (char *)base_addr) < size) {'
p8486
aS'\t\t\terror = -ERANGE;'
p8487
aS'\t\t\tgoto out;'
p8488
aS'\t\t}'
p8489
as(I8
I8
tp8490
(lp8491
S'\tint base_size;'
p8492
as(I19
I19
tp8493
(lp8494
S'\t\t\t\t&entry, &base_addr, &base_size);'
p8495
assg32
I6
sg12
g13
sg41
(I1
I44
tp8496
sssS'int f2fs_getxattr(struct inode *inode, int index, const char *name,\n\t\tvoid *buffer, size_t buffer_size, struct page *ipage)\n{\n\tstruct f2fs_xattr_entry *entry = NULL;\n\tint error = 0;\n\tunsigned int size, len;\n\tvoid *base_addr = NULL;\n\tint base_size;\n\n\tif (name == NULL)\n\t\treturn -EINVAL;\n\n\tlen = strlen(name);\n\tif (len > F2FS_NAME_LEN)\n\t\treturn -ERANGE;\n\n\tdown_read(&F2FS_I(inode)->i_xattr_sem);\n\terror = lookup_all_xattrs(inode, ipage, index, len, name,\n\t\t\t\t&entry, &base_addr, &base_size);\n\tup_read(&F2FS_I(inode)->i_xattr_sem);\n\tif (error)\n\t\treturn error;\n\n\tsize = le16_to_cpu(entry->e_value_size);\n\n\tif (buffer && size > buffer_size) {\n\t\terror = -ERANGE;\n\t\tgoto out;\n\t}\n\n\tif (buffer) {\n\t\tchar *pval = entry->e_name + entry->e_name_len;\n\n\t\tif (base_size - (pval - (char *)base_addr) < size) {\n\t\t\terror = -ERANGE;\n\t\t\tgoto out;\n\t\t}\n\t\tmemcpy(buffer, pval, size);\n\t}\n\terror = size;\nout:\n\tkvfree(base_addr);\n\treturn error;\n}'
p8497
(dp8498
((g8298
g8471
tp8499
I1
tp8500
(dp8501
g33
(dp8502
(I19
I19
tp8503
(lp8504
S'\t\t\t\t&entry, &base_addr);'
p8505
as(I42
I42
tp8506
(lp8507
S'\tkzfree(base_addr);'
p8508
assg14
(dp8509
(I33
I37
tp8510
(lp8511
g59
aS'\t\tif (base_size - (pval - (char *)base_addr) < size) {'
p8512
aS'\t\t\terror = -ERANGE;'
p8513
aS'\t\t\tgoto out;'
p8514
aS'\t\t}'
p8515
as(I8
I8
tp8516
(lp8517
S'\tint base_size;'
p8518
as(I19
I19
tp8519
(lp8520
S'\t\t\t\t&entry, &base_addr, &base_size);'
p8521
as(I42
I42
tp8522
(lp8523
S'\tkvfree(base_addr);'
p8524
assg32
I6
sg12
g13
sg41
(I1
I44
tp8525
sssssS'CVE-2019-10558'
p8526
(dp8527
(S'drivers/char/adsprpc.c'
p8528
S'context_free'
p8529
tp8530
(dp8531
S'static void context_free(struct smq_invoke_ctx *ctx)\n{\n\tint i;\n\tstruct fastrpc_apps *me = &gfa;\n\tint nbufs = REMOTE_SCALARS_INBUFS(ctx->sc) +\n\t\t    REMOTE_SCALARS_OUTBUFS(ctx->sc);\n\tspin_lock(&ctx->fl->hlock);\n\thlist_del_init(&ctx->hn);\n\tspin_unlock(&ctx->fl->hlock);\n\tmutex_lock(&ctx->fl->fl_map_mutex);\n\tfor (i = 0; i < nbufs; ++i)\n\t\tfastrpc_mmap_free(ctx->maps[i], 0);\n\n\tmutex_unlock(&ctx->fl->fl_map_mutex);\n\tfastrpc_buf_free(ctx->buf, 1);\n\tfastrpc_buf_free(ctx->lbuf, 1);\n\tctx->magic = 0;\n\tctx->ctxid = 0;\n\n\tspin_lock(&me->ctxlock);\n\tfor (i = 0; i < FASTRPC_CTX_MAX; i++) {\n\t\tif (me->ctxtable[i] == ctx) {\n\t\t\tme->ctxtable[i] = NULL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&me->ctxlock);\n\n\tkfree(ctx);\n}'
p8532
(dp8533
((g8528
g8529
tp8534
I1
tp8535
(dp8536
g14
(dp8537
(I16
I16
tp8538
(lp8539
S'\tfastrpc_buf_free(ctx->lbuf, 1);'
p8540
assg32
I1
sg12
g13
sg41
(I1
I30
tp8541
ssss(g8528
S'get_args'
p8542
tp8543
(dp8544
S'static int get_args(uint32_t kernel, struct smq_invoke_ctx *ctx)\n{\n\tstruct fastrpc_apps *me = &gfa;\n\tremote_arg64_t *rpra, *lrpra;\n\tremote_arg_t *lpra = ctx->lpra;\n\tstruct smq_invoke_buf *list;\n\tstruct smq_phy_page *pages, *ipage;\n\tuint32_t sc = ctx->sc;\n\tint inbufs = REMOTE_SCALARS_INBUFS(sc);\n\tint outbufs = REMOTE_SCALARS_OUTBUFS(sc);\n\tint handles, bufs = inbufs + outbufs;\n\tuintptr_t args;\n\tsize_t rlen = 0, copylen = 0, metalen = 0, lrpralen = 0;\n\tint i, oix;\n\tint err = 0;\n\tint mflags = 0;\n\tuint64_t *fdlist;\n\tuint32_t *crclist;\n\tint64_t *perf_counter = getperfcounter(ctx->fl, PERF_COUNT);\n\n\t/* calculate size of the metadata */\n\trpra = NULL;\n\tlist = smq_invoke_buf_start(rpra, sc);\n\tpages = smq_phy_page_start(sc, list);\n\tipage = pages;\n\n\tPERF(ctx->fl->profile, GET_COUNTER(perf_counter, PERF_MAP),\n\tfor (i = 0; i < bufs; ++i) {\n\t\tuintptr_t buf = (uintptr_t)lpra[i].buf.pv;\n\t\tsize_t len = lpra[i].buf.len;\n\n\t\tmutex_lock(&ctx->fl->fl_map_mutex);\n\t\tif (ctx->fds[i] && (ctx->fds[i] != -1)) {\n\t\t\tunsigned int attrs = 0;\n\n\t\t\tif (ctx->attrs)\n\t\t\t\tattrs = ctx->attrs[i];\n\n\t\t\tfastrpc_mmap_create(ctx->fl, ctx->fds[i],\n\t\t\t\t\tattrs, buf, len,\n\t\t\t\t\tmflags, &ctx->maps[i]);\n\t\t}\n\t\tmutex_unlock(&ctx->fl->fl_map_mutex);\n\t\tipage += 1;\n\t}\n\tPERF_END);\n\thandles = REMOTE_SCALARS_INHANDLES(sc) + REMOTE_SCALARS_OUTHANDLES(sc);\n\tmutex_lock(&ctx->fl->fl_map_mutex);\n\tfor (i = bufs; i < bufs + handles; i++) {\n\t\tint dmaflags = 0;\n\n\t\tif (ctx->attrs && (ctx->attrs[i] & FASTRPC_ATTR_NOMAP))\n\t\t\tdmaflags = FASTRPC_DMAHANDLE_NOMAP;\n\t\tVERIFY(err, !fastrpc_mmap_create(ctx->fl, ctx->fds[i],\n\t\t\tFASTRPC_ATTR_NOVA, 0, 0, dmaflags, &ctx->maps[i]));\n\t\tif (err) {\n\t\t\tmutex_unlock(&ctx->fl->fl_map_mutex);\n\t\t\tgoto bail;\n\t\t}\n\t\tipage += 1;\n\t}\n\tmutex_unlock(&ctx->fl->fl_map_mutex);\n\tif (!me->legacy) {\n\t\tmetalen = copylen = (size_t)&ipage[0] +\n\t\t\t\t(sizeof(uint64_t) * M_FDLIST) +\n\t\t\t\t(sizeof(uint32_t) * M_CRCLIST);\n\t} else {\n\t\tmetalen = copylen = (size_t)&ipage[0];\n\t}\n\n\t/* allocate new local rpra buffer */\n\tlrpralen = (size_t)&list[0];\n\tif (lrpralen) {\n\t\terr = fastrpc_buf_alloc(ctx->fl, lrpralen, 0, 0, 0, &ctx->lbuf);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\tif (ctx->lbuf->virt)\n\t\tmemset(ctx->lbuf->virt, 0, lrpralen);\n\n\tlrpra = ctx->lbuf->virt;\n\tctx->lrpra = lrpra;\n\n\t/* calculate len required for copying */\n\tfor (oix = 0; oix < inbufs + outbufs; ++oix) {\n\t\tint i = ctx->overps[oix]->raix;\n\t\tuintptr_t mstart, mend;\n\t\tsize_t len = lpra[i].buf.len;\n\n\t\tif (!len)\n\t\t\tcontinue;\n\t\tif (ctx->maps[i])\n\t\t\tcontinue;\n\t\tif (ctx->overps[oix]->offset == 0)\n\t\t\tcopylen = ALIGN(copylen, BALIGN);\n\t\tmstart = ctx->overps[oix]->mstart;\n\t\tmend = ctx->overps[oix]->mend;\n\t\tVERIFY(err, (mend - mstart) <= LONG_MAX);\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tcopylen += mend - mstart;\n\t\tVERIFY(err, copylen >= 0);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\tctx->used = copylen;\n\n\t/* allocate new buffer */\n\tif (copylen) {\n\t\terr = fastrpc_buf_alloc(ctx->fl, copylen, 0, 0, 0, &ctx->buf);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\tif (ctx->buf->virt && metalen <= copylen)\n\t\tmemset(ctx->buf->virt, 0, metalen);\n\n\t/* copy metadata */\n\trpra = ctx->buf->virt;\n\tctx->rpra = rpra;\n\tlist = smq_invoke_buf_start(rpra, sc);\n\tpages = smq_phy_page_start(sc, list);\n\tipage = pages;\n\targs = (uintptr_t)ctx->buf->virt + metalen;\n\tfor (i = 0; i < bufs + handles; ++i) {\n\t\tif (lpra[i].buf.len)\n\t\t\tlist[i].num = 1;\n\t\telse\n\t\t\tlist[i].num = 0;\n\t\tlist[i].pgidx = ipage - pages;\n\t\tipage++;\n\t}\n\n\t/* map ion buffers */\n\tPERF(ctx->fl->profile, GET_COUNTER(perf_counter, PERF_MAP),\n\tfor (i = 0; rpra && lrpra && i < inbufs + outbufs; ++i) {\n\t\tstruct fastrpc_mmap *map = ctx->maps[i];\n\t\tuint64_t buf = ptr_to_uint64(lpra[i].buf.pv);\n\t\tsize_t len = lpra[i].buf.len;\n\n\t\trpra[i].buf.pv = lrpra[i].buf.pv = 0;\n\t\trpra[i].buf.len = lrpra[i].buf.len = len;\n\t\tif (!len)\n\t\t\tcontinue;\n\t\tif (map) {\n\t\t\tstruct vm_area_struct *vma;\n\t\t\tuintptr_t offset;\n\t\t\tuint64_t num = buf_num_pages(buf, len);\n\t\t\tint idx = list[i].pgidx;\n\n\t\t\tif (map->attr & FASTRPC_ATTR_NOVA) {\n\t\t\t\toffset = 0;\n\t\t\t} else {\n\t\t\t\tdown_read(&current->mm->mmap_sem);\n\t\t\t\tVERIFY(err, NULL != (vma = find_vma(current->mm,\n\t\t\t\t\t\t\t\tmap->va)));\n\t\t\t\tif (err) {\n\t\t\t\t\tup_read(&current->mm->mmap_sem);\n\t\t\t\t\tgoto bail;\n\t\t\t\t}\n\t\t\t\toffset = buf_page_start(buf) - vma->vm_start;\n\t\t\t\tup_read(&current->mm->mmap_sem);\n\t\t\t\tVERIFY(err, offset < (uintptr_t)map->size);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tpages[idx].addr = map->phys + offset;\n\t\t\tpages[idx].size = num << PAGE_SHIFT;\n\t\t}\n\t\trpra[i].buf.pv = lrpra[i].buf.pv = buf;\n\t}\n\tPERF_END);\n\tfor (i = bufs; i < bufs + handles; ++i) {\n\t\tstruct fastrpc_mmap *map = ctx->maps[i];\n\n\t\tpages[i].addr = map->phys;\n\t\tpages[i].size = map->size;\n\t}\n\tif (!me->legacy) {\n\t\tfdlist = (uint64_t *)&pages[bufs + handles];\n\t\tfor (i = 0; i < M_FDLIST; i++)\n\t\t\tfdlist[i] = 0;\n\t\tcrclist = (uint32_t *)&fdlist[M_FDLIST];\n\t\tmemset(crclist, 0, sizeof(uint32_t)*M_CRCLIST);\n\t}\n\n\t/* copy non ion buffers */\n\tPERF(ctx->fl->profile, GET_COUNTER(perf_counter, PERF_COPY),\n\trlen = copylen - metalen;\n\tfor (oix = 0; rpra && lrpra && oix < inbufs + outbufs; ++oix) {\n\t\tint i = ctx->overps[oix]->raix;\n\t\tstruct fastrpc_mmap *map = ctx->maps[i];\n\t\tsize_t mlen;\n\t\tuint64_t buf;\n\t\tsize_t len = lpra[i].buf.len;\n\n\t\tif (!len)\n\t\t\tcontinue;\n\t\tif (map)\n\t\t\tcontinue;\n\t\tif (ctx->overps[oix]->offset == 0) {\n\t\t\trlen -= ALIGN(args, BALIGN) - args;\n\t\t\targs = ALIGN(args, BALIGN);\n\t\t}\n\t\tmlen = ctx->overps[oix]->mend - ctx->overps[oix]->mstart;\n\t\tVERIFY(err, rlen >= mlen);\n\t\tif (err)\n\t\t\tgoto bail;\n\t\trpra[i].buf.pv = lrpra[i].buf.pv =\n\t\t\t (args - ctx->overps[oix]->offset);\n\t\tpages[list[i].pgidx].addr = ctx->buf->phys -\n\t\t\t\t\t    ctx->overps[oix]->offset +\n\t\t\t\t\t    (copylen - rlen);\n\t\tpages[list[i].pgidx].addr =\n\t\t\tbuf_page_start(pages[list[i].pgidx].addr);\n\t\tbuf = rpra[i].buf.pv;\n\t\tpages[list[i].pgidx].size = buf_num_pages(buf, len) * PAGE_SIZE;\n\t\tif (i < inbufs) {\n\t\t\tK_COPY_FROM_USER(err, kernel, uint64_to_ptr(buf),\n\t\t\t\t\tlpra[i].buf.pv, len);\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t}\n\t\targs = args + mlen;\n\t\trlen -= mlen;\n\t}\n\tPERF_END);\n\n\tPERF(ctx->fl->profile, GET_COUNTER(perf_counter, PERF_FLUSH),\n\tfor (oix = 0; oix < inbufs + outbufs; ++oix) {\n\t\tint i = ctx->overps[oix]->raix;\n\t\tstruct fastrpc_mmap *map = ctx->maps[i];\n\n\t\tif (map && map->uncached)\n\t\t\tcontinue;\n\t\tif (ctx->fl->sctx->smmu.coherent &&\n\t\t\t!(map && (map->attr & FASTRPC_ATTR_NON_COHERENT)))\n\t\t\tcontinue;\n\t\tif (map && (map->attr & FASTRPC_ATTR_COHERENT))\n\t\t\tcontinue;\n\n\t\tif (rpra && lrpra && rpra[i].buf.len &&\n\t\t\tctx->overps[oix]->mstart) {\n\t\t\tif (map && map->handle)\n\t\t\t\tmsm_ion_do_cache_op(ctx->fl->apps->client,\n\t\t\t\t\tmap->handle,\n\t\t\t\t\tuint64_to_ptr(rpra[i].buf.pv),\n\t\t\t\t\trpra[i].buf.len,\n\t\t\t\t\tION_IOC_CLEAN_INV_CACHES);\n\t\t\telse\n\t\t\t\tdmac_flush_range(uint64_to_ptr(rpra[i].buf.pv),\n\t\t\t\t\tuint64_to_ptr(rpra[i].buf.pv\n\t\t\t\t\t\t+ rpra[i].buf.len));\n\t\t}\n\t}\n\tPERF_END);\n\tfor (i = bufs; rpra && lrpra && i < bufs + handles; i++) {\n\t\trpra[i].dma.fd = lrpra[i].dma.fd = ctx->fds[i];\n\t\trpra[i].dma.len = lrpra[i].dma.len = (uint32_t)lpra[i].buf.len;\n\t\trpra[i].dma.offset = lrpra[i].dma.offset =\n\t\t\t (uint32_t)(uintptr_t)lpra[i].buf.pv;\n\t}\n\n bail:\n\treturn err;\n}'
p8545
(dp8546
((g8528
g8542
tp8547
I1
tp8548
(dp8549
g12
g13
sg14
(dp8550
(I71
I84
tp8551
(lp8552
S'\t/* allocate new local rpra buffer */'
p8553
aS'\tlrpralen = (size_t)&list[0];'
p8554
aS'\tif (lrpralen) {'
p8555
aS'\t\terr = fastrpc_buf_alloc(ctx->fl, lrpralen, 0, 0, 0, &ctx->lbuf);'
p8556
aS'\t\tif (err)'
p8557
aS'\t\t\tgoto bail;'
p8558
aS'\t}'
p8559
aS'\tif (ctx->lbuf->virt)'
p8560
aS'\t\tmemset(ctx->lbuf->virt, 0, lrpralen);'
p8561
ag59
aS'\tlrpra = ctx->lbuf->virt;'
p8562
aS'\tctx->lrpra = lrpra;'
p8563
ag59
aS'\t/* calculate len required for copying */'
p8564
as(I189
I189
tp8565
(lp8566
S'\tfor (oix = 0; rpra && lrpra && oix < inbufs + outbufs; ++oix) {'
p8567
as(I208
I209
tp8568
(lp8569
S'\t\trpra[i].buf.pv = lrpra[i].buf.pv ='
p8570
aS'\t\t\t (args - ctx->overps[oix]->offset);'
p8571
as(I13
I13
tp8572
(lp8573
S'\tsize_t rlen = 0, copylen = 0, metalen = 0, lrpralen = 0;'
p8574
as(I256
I260
tp8575
(lp8576
S'\tfor (i = bufs; rpra && lrpra && i < bufs + handles; i++) {'
p8577
aS'\t\trpra[i].dma.fd = lrpra[i].dma.fd = ctx->fds[i];'
p8578
aS'\t\trpra[i].dma.len = lrpra[i].dma.len = (uint32_t)lpra[i].buf.len;'
p8579
aS'\t\trpra[i].dma.offset = lrpra[i].dma.offset ='
p8580
aS'\t\t\t (uint32_t)(uintptr_t)lpra[i].buf.pv;'
p8581
as(I140
I141
tp8582
(lp8583
S'\t\trpra[i].buf.pv = lrpra[i].buf.pv = 0;'
p8584
aS'\t\trpra[i].buf.len = lrpra[i].buf.len = len;'
p8585
as(I241
I242
tp8586
(lp8587
S'\t\tif (rpra && lrpra && rpra[i].buf.len &&'
p8588
aS'\t\t\tctx->overps[oix]->mstart) {'
p8589
as(I4
I4
tp8590
(lp8591
S'\tremote_arg64_t *rpra, *lrpra;'
p8592
as(I135
I135
tp8593
(lp8594
S'\tfor (i = 0; rpra && lrpra && i < inbufs + outbufs; ++i) {'
p8595
as(I169
I169
tp8596
(lp8597
S'\t\trpra[i].buf.pv = lrpra[i].buf.pv = buf;'
p8598
assg32
I2
sg33
(dp8599
(I189
I189
tp8600
(lp8601
S'\tfor (oix = 0; rpra && oix < inbufs + outbufs; ++oix) {'
p8602
as(I169
I169
tp8603
(lp8604
S'\t\trpra[i].buf.pv = buf;'
p8605
as(I208
I208
tp8606
(lp8607
S'\t\trpra[i].buf.pv = (args - ctx->overps[oix]->offset);'
p8608
as(I13
I13
tp8609
(lp8610
S'\tsize_t rlen = 0, copylen = 0, metalen = 0;'
p8611
as(I140
I141
tp8612
(lp8613
S'\t\trpra[i].buf.pv = 0;'
p8614
aS'\t\trpra[i].buf.len = len;'
p8615
as(I241
I241
tp8616
(lp8617
S'\t\tif (rpra && rpra[i].buf.len && ctx->overps[oix]->mstart) {'
p8618
as(I256
I259
tp8619
(lp8620
S'\tfor (i = bufs; rpra && i < bufs + handles; i++) {'
p8621
aS'\t\trpra[i].dma.fd = ctx->fds[i];'
p8622
aS'\t\trpra[i].dma.len = (uint32_t)lpra[i].buf.len;'
p8623
aS'\t\trpra[i].dma.offset = (uint32_t)(uintptr_t)lpra[i].buf.pv;'
p8624
as(I4
I4
tp8625
(lp8626
S'\tremote_arg64_t *rpra;'
p8627
as(I135
I135
tp8628
(lp8629
S'\tfor (i = 0; rpra && i < inbufs + outbufs; ++i) {'
p8630
as(I71
I71
tp8631
(lp8632
S'\t/* calculate len requreed for copying */'
p8633
assg41
(I1
I265
tp8634
ssss(g8528
S'inv_args'
p8635
tp8636
(dp8637
S'static void inv_args(struct smq_invoke_ctx *ctx)\n{\n\tint i, inbufs, outbufs;\n\tuint32_t sc = ctx->sc;\n\tremote_arg64_t *rpra = ctx->lrpra;\n\n\tinbufs = REMOTE_SCALARS_INBUFS(sc);\n\toutbufs = REMOTE_SCALARS_OUTBUFS(sc);\n\tfor (i = inbufs; i < inbufs + outbufs; ++i) {\n\t\tstruct fastrpc_mmap *map = ctx->maps[i];\n\n\t\tif (map && map->uncached)\n\t\t\tcontinue;\n\t\tif (!rpra[i].buf.len)\n\t\t\tcontinue;\n\t\tif (ctx->fl->sctx->smmu.coherent &&\n\t\t\t!(map && (map->attr & FASTRPC_ATTR_NON_COHERENT)))\n\t\t\tcontinue;\n\t\tif (map && (map->attr & FASTRPC_ATTR_COHERENT))\n\t\t\tcontinue;\n\n\t\tif (buf_page_start(ptr_to_uint64((void *)rpra)) ==\n\t\t\t\tbuf_page_start(rpra[i].buf.pv)) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (map && map->handle)\n\t\t\tmsm_ion_do_cache_op(ctx->fl->apps->client, map->handle,\n\t\t\t\t(char *)uint64_to_ptr(rpra[i].buf.pv),\n\t\t\t\trpra[i].buf.len, ION_IOC_INV_CACHES);\n\t\telse\n\t\t\tdmac_inv_range((char *)uint64_to_ptr(rpra[i].buf.pv),\n\t\t\t\t(char *)uint64_to_ptr(rpra[i].buf.pv\n\t\t\t\t\t\t + rpra[i].buf.len));\n\t}\n\n}'
p8638
(dp8639
((g8528
g8635
tp8640
I1
tp8641
(dp8642
g12
g13
sg14
(dp8643
(I5
I5
tp8644
(lp8645
S'\tremote_arg64_t *rpra = ctx->lrpra;'
p8646
assg32
I1
sg33
(dp8647
(I5
I5
tp8648
(lp8649
S'\tremote_arg64_t *rpra = ctx->rpra;'
p8650
assg41
(I1
I36
tp8651
ssss(g8528
S'put_args'
p8652
tp8653
(dp8654
S'static int put_args(uint32_t kernel, struct smq_invoke_ctx *ctx,\n\t\t    remote_arg_t *upra)\n{\n\tstruct fastrpc_apps *me = &gfa;\n\tuint32_t sc = ctx->sc;\n\tstruct smq_invoke_buf *list;\n\tstruct smq_phy_page *pages;\n\tstruct fastrpc_mmap *mmap;\n\tuint64_t *fdlist = NULL;\n\tuint32_t *crclist = NULL;\n\n\tremote_arg64_t *rpra = ctx->lrpra;\n\tint i, inbufs, outbufs, handles;\n\tint err = 0;\n\n\tinbufs = REMOTE_SCALARS_INBUFS(sc);\n\toutbufs = REMOTE_SCALARS_OUTBUFS(sc);\n\thandles = REMOTE_SCALARS_INHANDLES(sc) + REMOTE_SCALARS_OUTHANDLES(sc);\n\tlist = smq_invoke_buf_start(ctx->rpra, sc);\n\tpages = smq_phy_page_start(sc, list);\n\tif (!me->legacy) {\n\t\tfdlist = (uint64_t *)(pages + inbufs + outbufs + handles);\n\t\tcrclist = (uint32_t *)(fdlist + M_FDLIST);\n\t}\n\n\tfor (i = inbufs; i < inbufs + outbufs; ++i) {\n\t\tif (!ctx->maps[i]) {\n\t\t\tK_COPY_TO_USER(err, kernel,\n\t\t\t\tctx->lpra[i].buf.pv,\n\t\t\t\tuint64_to_ptr(rpra[i].buf.pv),\n\t\t\t\trpra[i].buf.len);\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t} else {\n\t\t\tmutex_lock(&ctx->fl->fl_map_mutex);\n\t\t\tfastrpc_mmap_free(ctx->maps[i], 0);\n\t\t\tmutex_unlock(&ctx->fl->fl_map_mutex);\n\t\t\tctx->maps[i] = NULL;\n\t\t}\n\t}\n\tmutex_lock(&ctx->fl->fl_map_mutex);\n\tif (fdlist && (inbufs + outbufs + handles)) {\n\t\tfor (i = 0; i < M_FDLIST; i++) {\n\t\t\tif (!fdlist[i])\n\t\t\t\tbreak;\n\t\t\tif (!fastrpc_mmap_find(ctx->fl, (int)fdlist[i], 0, 0,\n\t\t\t\t\t\t0, 0, &mmap))\n\t\t\t\tfastrpc_mmap_free(mmap, 0);\n\t\t}\n\t}\n\tmutex_unlock(&ctx->fl->fl_map_mutex);\n\tif (ctx->crc && crclist && rpra)\n\t\tK_COPY_TO_USER(err, kernel, ctx->crc,\n\t\t\tcrclist, M_CRCLIST*sizeof(uint32_t));\n\n bail:\n\treturn err;\n}'
p8655
(dp8656
((g8528
g8652
tp8657
I1
tp8658
(dp8659
g12
g13
sg14
(dp8660
(I12
I12
tp8661
(lp8662
S'\tremote_arg64_t *rpra = ctx->lrpra;'
p8663
assg32
I3
sg33
(dp8664
(I12
I12
tp8665
(lp8666
S'\tremote_arg64_t *rpra = ctx->rpra;'
p8667
assg41
(I1
I58
tp8668
sssssS'CVE-2019-10556'
p8669
(dp8670
(S'drivers/gpu/drm/msm/dsi-staging/dsi_display.c'
p8671
S'debugfs_dump_info_read'
p8672
tp8673
(dp8674
S'static ssize_t debugfs_dump_info_read(struct file *file,\n\t\t\t\t      char __user *user_buf,\n\t\t\t\t      size_t user_len,\n\t\t\t\t      loff_t *ppos)\n{\n\tstruct dsi_display *display = file->private_data;\n\tchar *buf;\n\tu32 len = 0;\n\tint i;\n\n\tif (!display)\n\t\treturn -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tbuf = kzalloc(SZ_4K, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tlen += snprintf(buf + len, (SZ_4K - len), "name = %s\\n", display->name);\n\tlen += snprintf(buf + len, (SZ_4K - len),\n\t\t\t"\\tResolution = %dx%d\\n",\n\t\t\tdisplay->config.video_timing.h_active,\n\t\t\tdisplay->config.video_timing.v_active);\n\n\tfor (i = 0; i < display->ctrl_count; i++) {\n\t\tlen += snprintf(buf + len, (SZ_4K - len),\n\t\t\t\t"\\tCTRL_%d:\\n\\t\\tctrl = %s\\n\\t\\tphy = %s\\n",\n\t\t\t\ti, display->ctrl[i].ctrl->name,\n\t\t\t\tdisplay->ctrl[i].phy->name);\n\t}\n\n\tlen += snprintf(buf + len, (SZ_4K - len),\n\t\t\t"\\tPanel = %s\\n", display->panel->name);\n\n\tlen += snprintf(buf + len, (SZ_4K - len),\n\t\t\t"\\tClock master = %s\\n",\n\t\t\tdisplay->ctrl[display->clk_master_idx].ctrl->name);\n\n\tif (len > user_len)\n\t\tlen = user_len;\n\n\tif (copy_to_user(user_buf, buf, len)) {\n\t\tkfree(buf);\n\t\treturn -EFAULT;\n\t}\n\n\t*ppos += len;\n\n\tkfree(buf);\n\treturn len;\n}'
p8675
(dp8676
((g8671
g8672
tp8677
I1
tp8678
(dp8679
g14
(dp8680
(I41
I43
tp8681
(lp8682
S'\tif (len > user_len)'
p8683
aS'\t\tlen = user_len;'
p8684
ag59
assg32
I4
sg12
g13
sg41
(I1
I53
tp8685
sssssS'CVE-2019-10555'
p8686
(dp8687
(S'drivers/video/fbdev/msm/mdss_dsi.c'
p8688
S'mdss_dsi_cmd_flush'
p8689
tp8690
(dp8691
S'static int mdss_dsi_cmd_flush(struct file *file, fl_owner_t id)\n{\n\tstruct buf_data *pcmds = file->private_data;\n\tunsigned int len;\n\tint blen, i;\n\tchar *buf, *bufp, *bp;\n\tstruct dsi_ctrl_hdr *dchdr;\n\n\tmutex_lock(&pcmds->dbg_mutex);\n\n\tif (!pcmds->string_buf) {\n\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate memory for command buffer\n\t * 3 bytes per number, and 2 bytes for the last one\n\t */\n\tblen = ((pcmds->sblen) + 2) / 3;\n\tbuf = kcalloc(1, blen, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err("%s: Failed to allocate memory\\n", __func__);\n\t\tkfree(pcmds->string_buf);\n\t\tpcmds->string_buf = NULL;\n\t\tpcmds->sblen = 0;\n\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Translate the input string to command array */\n\tbufp = pcmds->string_buf;\n\tfor (i = 0; i < blen; i++) {\n\t\tuint32_t value = 0;\n\t\tint step = 0;\n\n\t\tif (sscanf(bufp, "%02x%n", &value, &step) > 0) {\n\t\t\t*(buf+i) = (char)value;\n\t\t\tbufp += step;\n\t\t}\n\t}\n\n\t/* Scan dcs commands */\n\tbp = buf;\n\tlen = blen;\n\twhile (len >= sizeof(*dchdr)) {\n\t\tdchdr = (struct dsi_ctrl_hdr *)bp;\n\t\tdchdr->dlen = ntohs(dchdr->dlen);\n\t\tif (dchdr->dlen > (len - sizeof(*dchdr)) || dchdr->dlen < 0) {\n\t\t\tpr_err("%s: dtsi cmd=%x error, len=%d\\n",\n\t\t\t\t__func__, dchdr->dtype, dchdr->dlen);\n\t\t\tkfree(buf);\n\t\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbp += sizeof(*dchdr);\n\t\tlen -= sizeof(*dchdr);\n\t\tbp += dchdr->dlen;\n\t\tlen -= dchdr->dlen;\n\t}\n\tif (len != 0) {\n\t\tpr_err("%s: dcs_cmd=%x len=%d error!\\n", __func__,\n\t\t\t\tbp[0], len);\n\t\tkfree(buf);\n\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcmds->sync_flag) {\n\t\tpcmds->buf = buf;\n\t\tpcmds->blen = blen;\n\t\tpcmds->sync_flag = 0;\n\t} else {\n\t\tkfree(pcmds->buf);\n\t\tpcmds->buf = buf;\n\t\tpcmds->blen = blen;\n\t}\n\tmutex_unlock(&pcmds->dbg_mutex);\n\treturn 0;\n}'
p8692
(dp8693
((g8688
g8689
tp8694
I1
tp8695
(dp8696
g12
g13
sg14
(dp8697
(I4
I5
tp8698
(lp8699
S'\tunsigned int len;'
p8700
aS'\tint blen, i;'
p8701
as(I49
I49
tp8702
(lp8703
S'\t\tif (dchdr->dlen > (len - sizeof(*dchdr)) || dchdr->dlen < 0) {'
p8704
assg32
I2
sg33
(dp8705
(I4
I4
tp8706
(lp8707
S'\tint blen, len, i;'
p8708
as(I49
I49
tp8709
(lp8710
S'\t\tif (dchdr->dlen > len || dchdr->dlen < 0) {'
p8711
assg41
(I1
I80
tp8712
sssssS'CVE-2018-19824'
p8713
(dp8714
(S'sound/usb/card.c'
p8715
S'usb_audio_probe'
p8716
tp8717
(dp8718
S'static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\tstruct usb_interface_assoc_descriptor *assoc;\n\n\tassoc = intf->intf_assoc;\n\tif (assoc && assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t    assoc->bFunctionProtocol == UAC_VERSION_3 &&\n\t    assoc->bFunctionSubClass == FULL_ADC_3_0) {\n\t\tdev_info(&dev->dev, "No support for full-fledged ADC 3.0 yet!!\\n");\n\t\treturn -EINVAL;\n\t}\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it\'s already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, "USB device is in the shutdown state, cannot create a card instance\\n");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it\'s a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (enable[i] && ! usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t   &chip);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto __error;\n\t\t\t\tchip->pm_intf = intf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, "no available usb audio device\\n");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tintf->needs_remote_wakeup = 1;\n\tusb_enable_autosuspend(chip->dev);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}'
p8719
(dp8720
((g8715
g8716
tp8721
I1
tp8722
(dp8723
g33
(dp8724
(I126
I126
tp8725
(lp8726
S'\t\tatomic_dec(&chip->active);'
p8727
assg14
(dp8728
(I120
I123
tp8729
(lp8730
S'\t\t/* chip->active is inside the chip->card object,'
p8731
aS'\t\t * decrement before memory is possibly returned.'
p8732
aS'\t\t */'
p8733
aS'\t\tatomic_dec(&chip->active);'
p8734
assg32
I2
sg12
g13
sg41
(I1
I129
tp8735
sssssS'CVE-2019-14079'
p8736
(dp8737
(S'drivers/usb/gadget/udc/core.c'
p8738
S'usb_gadget_unmap_request_by_dev'
p8739
tp8740
(dp8741
S'void usb_gadget_unmap_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in)\n{\n\tif (req->length == 0)\n\t\treturn;\n\n\tif (req->num_mapped_sgs) {\n\t\tdma_unmap_sg(dev, req->sg, req->num_sgs,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\t\treq->num_mapped_sgs = 0;\n\t} else if (req->dma_mapped) {\n\t\tdma_unmap_single(dev, req->dma, req->length,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\treq->dma_mapped = 0;\n\t}\n}'
p8742
(dp8743
((g8738
g8739
tp8744
I1
tp8745
(dp8746
g12
g13
sg14
(dp8747
(I12
I12
tp8748
(lp8749
S'\t} else if (req->dma_mapped) {'
p8750
as(I15
I15
tp8751
(lp8752
S'\t\treq->dma_mapped = 0;'
p8753
assg32
I3
sg33
(dp8754
(I12
I12
tp8755
(lp8756
S'\t} else if (req->dma != DMA_ERROR_CODE) {'
p8757
assg41
(I1
I17
tp8758
ssss(g8738
S'usb_gadget_map_request_by_dev'
p8759
tp8760
(dp8761
S'int usb_gadget_map_request_by_dev(struct device *dev,\n\t\tstruct usb_request *req, int is_in)\n{\n\tif (req->length == 0)\n\t\treturn 0;\n\n\tif (req->num_sgs) {\n\t\tint     mapped;\n\n\t\tmapped = dma_map_sg(dev, req->sg, req->num_sgs,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\t\tif (mapped == 0) {\n\t\t\tdev_err(dev, "failed to map SGs\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treq->num_mapped_sgs = mapped;\n\t} else {\n\t\treq->dma = dma_map_single(dev, req->buf, req->length,\n\t\t\t\tis_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);\n\n\t\tif (dma_mapping_error(dev, req->dma)) {\n\t\t\tdev_err(dev, "failed to map buffer\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\treq->dma_mapped = 1;\n\t}\n\n\treturn 0;\n}'
p8762
(dp8763
((g8738
g8759
tp8764
I1
tp8765
(dp8766
g14
(dp8767
(I26
I27
tp8768
(lp8769
g59
aS'\t\treq->dma_mapped = 1;'
p8770
assg32
I3
sg12
g13
sg41
(I1
I31
tp8771
sssssS'CVE-2020-0030'
p8772
(dp8773
(S'drivers/android/binder.c'
p8774
S'binder_thread_release'
p8775
tp8776
(dp8777
S'static int binder_thread_release(struct binder_proc *proc,\n\t\t\t\t struct binder_thread *thread)\n{\n\tstruct binder_transaction *t;\n\tstruct binder_transaction *send_reply = NULL;\n\tint active_transactions = 0;\n\tstruct binder_transaction *last_t = NULL;\n\n\tbinder_inner_proc_lock(thread->proc);\n\t/*\n\t * take a ref on the proc so it survives\n\t * after we remove this thread from proc->threads.\n\t * The corresponding dec is when we actually\n\t * free the thread in binder_free_thread()\n\t */\n\tproc->tmp_ref++;\n\t/*\n\t * take a ref on this thread to ensure it\n\t * survives while we are releasing it\n\t */\n\tatomic_inc(&thread->tmp_ref);\n\trb_erase(&thread->rb_node, &proc->threads);\n\tt = thread->transaction_stack;\n\tif (t) {\n\t\tspin_lock(&t->lock);\n\t\tif (t->to_thread == thread)\n\t\t\tsend_reply = t;\n\t}\n\tthread->is_dead = true;\n\n\twhile (t) {\n\t\tlast_t = t;\n\t\tactive_transactions++;\n\t\tbinder_debug(BINDER_DEBUG_DEAD_TRANSACTION,\n\t\t\t     "release %d:%d transaction %d %s, still active\\n",\n\t\t\t      proc->pid, thread->pid,\n\t\t\t     t->debug_id,\n\t\t\t     (t->to_thread == thread) ? "in" : "out");\n\n\t\tif (t->to_thread == thread) {\n\t\t\tt->to_proc = NULL;\n\t\t\tt->to_thread = NULL;\n\t\t\tif (t->buffer) {\n\t\t\t\tt->buffer->transaction = NULL;\n\t\t\t\tt->buffer = NULL;\n\t\t\t}\n\t\t\tt = t->to_parent;\n\t\t} else if (t->from == thread) {\n\t\t\tt->from = NULL;\n\t\t\tt = t->from_parent;\n\t\t} else\n\t\t\tBUG();\n\t\tspin_unlock(&last_t->lock);\n\t\tif (t)\n\t\t\tspin_lock(&t->lock);\n\t}\n\n\t/*\n\t * If this thread used poll, make sure we remove the waitqueue\n\t * from any epoll data structures holding it with POLLFREE.\n\t * waitqueue_active() is safe to use here because we\'re holding\n\t * the inner lock.\n\t */\n\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&\n\t    waitqueue_active(&thread->wait)) {\n\t\twake_up_poll(&thread->wait, POLLHUP | POLLFREE);\n\t}\n\n\tbinder_inner_proc_unlock(thread->proc);\n\n\t/*\n\t * This is needed to avoid races between wake_up_poll() above and\n\t * and ep_remove_waitqueue() called for other reasons (eg the epoll file\n\t * descriptor being closed); ep_remove_waitqueue() holds an RCU read\n\t * lock, so we can be sure it\'s done after calling synchronize_rcu().\n\t */\n\tif (thread->looper & BINDER_LOOPER_STATE_POLL)\n\t\tsynchronize_rcu();\n\n\tif (send_reply)\n\t\tbinder_send_failed_reply(send_reply, BR_DEAD_REPLY);\n\tbinder_release_work(proc, &thread->todo);\n\tbinder_thread_dec_tmpref(thread);\n\treturn active_transactions;\n}'
p8778
(dp8779
((g8774
g8775
tp8780
I1
tp8781
(dp8782
g14
(dp8783
(I71
I79
tp8784
(lp8785
S'\t/*'
p8786
aS'\t * This is needed to avoid races between wake_up_poll() above and'
p8787
aS'\t * and ep_remove_waitqueue() called for other reasons (eg the epoll file'
p8788
aS'\t * descriptor being closed); ep_remove_waitqueue() holds an RCU read'
p8789
aS"\t * lock, so we can be sure it's done after calling synchronize_rcu()."
p8790
aS'\t */'
p8791
aS'\tif (thread->looper & BINDER_LOOPER_STATE_POLL)'
p8792
aS'\t\tsynchronize_rcu();'
p8793
ag59
as(I57
I68
tp8794
(lp8795
g59
aS'\t/*'
p8796
aS'\t * If this thread used poll, make sure we remove the waitqueue'
p8797
aS'\t * from any epoll data structures holding it with POLLFREE.'
p8798
aS"\t * waitqueue_active() is safe to use here because we're holding"
p8799
aS'\t * the inner lock.'
p8800
aS'\t */'
p8801
aS'\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&'
p8802
aS'\t    waitqueue_active(&thread->wait)) {'
p8803
aS'\t\twake_up_poll(&thread->wait, POLLHUP | POLLFREE);'
p8804
aS'\t}'
p8805
ag59
assg32
I2
sg12
g13
sg41
(I1
I85
tp8806
sssS'static int binder_thread_release(struct binder_proc *proc,\n\t\t\t\t struct binder_thread *thread)\n{\n\tstruct binder_transaction *t;\n\tstruct binder_transaction *send_reply = NULL;\n\tint active_transactions = 0;\n\tstruct binder_transaction *last_t = NULL;\n\n\tbinder_inner_proc_lock(thread->proc);\n\t/*\n\t * take a ref on the proc so it survives\n\t * after we remove this thread from proc->threads.\n\t * The corresponding dec is when we actually\n\t * free the thread in binder_free_thread()\n\t */\n\tatomic_inc(&proc->tmp_ref);\n\t/*\n\t * take a ref on this thread to ensure it\n\t * survives while we are releasing it\n\t */\n\tatomic_inc(&thread->tmp_ref);\n\trb_erase(&thread->rb_node, &proc->threads);\n\tt = thread->transaction_stack;\n\tif (t) {\n\t\tspin_lock(&t->lock);\n\t\tif (t->to_thread == thread)\n\t\t\tsend_reply = t;\n\t}\n\tthread->is_dead = true;\n\n\twhile (t) {\n\t\tlast_t = t;\n\t\tactive_transactions++;\n\t\tbinder_debug(BINDER_DEBUG_DEAD_TRANSACTION,\n\t\t\t     "release %d:%d transaction %d %s, still active\\n",\n\t\t\t      proc->pid, thread->pid,\n\t\t\t     t->debug_id,\n\t\t\t     (t->to_thread == thread) ? "in" : "out");\n\n\t\tif (t->to_thread == thread) {\n\t\t\tt->to_proc = NULL;\n\t\t\tt->to_thread = NULL;\n\t\t\tif (t->buffer) {\n\t\t\t\tt->buffer->transaction = NULL;\n\t\t\t\tt->buffer = NULL;\n\t\t\t}\n\t\t\tt = t->to_parent;\n\t\t} else if (t->from == thread) {\n\t\t\tt->from = NULL;\n\t\t\tt = t->from_parent;\n\t\t} else\n\t\t\tBUG();\n\t\tspin_unlock(&last_t->lock);\n\t\tif (t)\n\t\t\tspin_lock(&t->lock);\n\t}\n\n\t/*\n\t * If this thread used poll, make sure we remove the waitqueue\n\t * from any epoll data structures holding it with POLLFREE.\n\t * waitqueue_active() is safe to use here because we\'re holding\n\t * the inner lock.\n\t */\n\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&\n\t    waitqueue_active(&thread->wait)) {\n\t\twake_up_poll(&thread->wait, POLLHUP | POLLFREE);\n\t}\n\n\tbinder_inner_proc_unlock(thread->proc);\n\n\t/*\n\t * This is needed to avoid races between wake_up_poll() above and\n\t * and ep_remove_waitqueue() called for other reasons (eg the epoll file\n\t * descriptor being closed); ep_remove_waitqueue() holds an RCU read\n\t * lock, so we can be sure it\'s done after calling synchronize_rcu().\n\t */\n\tif (thread->looper & BINDER_LOOPER_STATE_POLL)\n\t\tsynchronize_rcu();\n\n\tif (send_reply)\n\t\tbinder_send_failed_reply(send_reply, BR_DEAD_REPLY);\n\tbinder_release_work(proc, &thread->todo);\n\tbinder_thread_dec_tmpref(thread);\n\treturn active_transactions;\n}'
p8807
(dp8808
((g8774
g8775
tp8809
I1
tp8810
(dp8811
g12
g13
sg14
(dp8812
(I16
I16
tp8813
(lp8814
S'\tatomic_inc(&proc->tmp_ref);'
p8815
as(I71
I79
tp8816
(lp8817
S'\t/*'
p8818
aS'\t * This is needed to avoid races between wake_up_poll() above and'
p8819
aS'\t * and ep_remove_waitqueue() called for other reasons (eg the epoll file'
p8820
aS'\t * descriptor being closed); ep_remove_waitqueue() holds an RCU read'
p8821
aS"\t * lock, so we can be sure it's done after calling synchronize_rcu()."
p8822
aS'\t */'
p8823
aS'\tif (thread->looper & BINDER_LOOPER_STATE_POLL)'
p8824
aS'\t\tsynchronize_rcu();'
p8825
ag59
as(I57
I68
tp8826
(lp8827
g59
aS'\t/*'
p8828
aS'\t * If this thread used poll, make sure we remove the waitqueue'
p8829
aS'\t * from any epoll data structures holding it with POLLFREE.'
p8830
aS"\t * waitqueue_active() is safe to use here because we're holding"
p8831
aS'\t * the inner lock.'
p8832
aS'\t */'
p8833
aS'\tif ((thread->looper & BINDER_LOOPER_STATE_POLL) &&'
p8834
aS'\t    waitqueue_active(&thread->wait)) {'
p8835
aS'\t\twake_up_poll(&thread->wait, POLLHUP | POLLFREE);'
p8836
aS'\t}'
p8837
ag59
assg32
I2
sg33
(dp8838
(I16
I16
tp8839
(lp8840
S'\tproc->tmp_ref++;'
p8841
assg41
(I1
I85
tp8842
sssssS'CVE-2019-2333'
p8843
(dp8844
(S'drivers/platform/msm/ipa/ipa_v3/ipa_intf.c'
p8845
S'ipa3_read'
p8846
tp8847
(dp8848
S'ssize_t ipa3_read(struct file *filp, char __user *buf, size_t count,\n\t\t  loff_t *f_pos)\n{\n\tchar __user *start;\n\tstruct ipa3_push_msg *msg = NULL;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint locked;\n\n\tstart = buf;\n\n\tadd_wait_queue(&ipa3_ctx->msg_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&ipa3_ctx->msg_lock);\n\t\tlocked = 1;\n\n\t\tif (!list_empty(&ipa3_ctx->msg_list)) {\n\t\t\tmsg = list_first_entry(&ipa3_ctx->msg_list,\n\t\t\t\t\tstruct ipa3_push_msg, link);\n\t\t\tlist_del(&msg->link);\n\t\t}\n\n\t\tIPADBG_LOW("msg=%p\\n", msg);\n\n\t\tif (msg) {\n\t\t\tlocked = 0;\n\t\t\tmutex_unlock(&ipa3_ctx->msg_lock);\n\t\t\tif (count < sizeof(struct ipa_msg_meta)) {\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (copy_to_user(buf, &msg->meta,\n\t\t\t\t\t  sizeof(struct ipa_msg_meta))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += sizeof(struct ipa_msg_meta);\n\t\t\tcount -= sizeof(struct ipa_msg_meta);\n\t\t\tif (msg->buff) {\n\t\t\t\tif (count >= msg->meta.msg_len) {\n\t\t\t\t\tif (copy_to_user(buf, msg->buff,\n\t\t\t\t\t\t\tmsg->meta.msg_len)) {\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t\tkfree(msg);\n\t\t\t\t\t\tmsg = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tkfree(msg);\n\t\t\t\t\tmsg = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuf += msg->meta.msg_len;\n\t\t\t\tcount -= msg->meta.msg_len;\n\t\t\t\tmsg->callback(msg->buff, msg->meta.msg_len,\n\t\t\t\t\t       msg->meta.msg_type);\n\t\t\t}\n\t\t\tIPA_STATS_INC_CNT(\n\t\t\t\tipa3_ctx->stats.msg_r[msg->meta.msg_type]);\n\t\t\tkfree(msg);\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\tlocked = 0;\n\t\tmutex_unlock(&ipa3_ctx->msg_lock);\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\n\tremove_wait_queue(&ipa3_ctx->msg_waitq, &wait);\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\n\tif (locked)\n\t\tmutex_unlock(&ipa3_ctx->msg_lock);\n\n\treturn ret;\n}'
p8849
(dp8850
((g8845
g8846
tp8851
I1
tp8852
(dp8853
g33
(dp8854
(I44
I45
tp8855
(lp8856
S'\t\t\t\tif (copy_to_user(buf, msg->buff,'
p8857
aS'\t\t\t\t\t\t  msg->meta.msg_len)) {'
p8858
assg14
(dp8859
(I44
I52
tp8860
(lp8861
S'\t\t\t\tif (count >= msg->meta.msg_len) {'
p8862
aS'\t\t\t\t\tif (copy_to_user(buf, msg->buff,'
p8863
aS'\t\t\t\t\t\t\tmsg->meta.msg_len)) {'
p8864
aS'\t\t\t\t\t\tret = -EFAULT;'
p8865
aS'\t\t\t\t\t\tkfree(msg);'
p8866
aS'\t\t\t\t\t\tmsg = NULL;'
p8867
aS'\t\t\t\t\t\tbreak;'
p8868
aS'\t\t\t\t\t}'
p8869
aS'\t\t\t\t} else {'
p8870
as(I28
I33
tp8871
(lp8872
S'\t\t\tif (count < sizeof(struct ipa_msg_meta)) {'
p8873
aS'\t\t\t\tkfree(msg);'
p8874
aS'\t\t\t\tmsg = NULL;'
p8875
aS'\t\t\t\tret = -EFAULT;'
p8876
aS'\t\t\t\tbreak;'
p8877
aS'\t\t\t}'
p8878
assg32
I4
sg12
g13
sg41
(I1
I92
tp8879
ssss(S'drivers/platform/msm/ipa/ipa_v2/ipa_intf.c'
p8880
S'ipa_read'
p8881
tp8882
(dp8883
S'ssize_t ipa_read(struct file *filp, char __user *buf, size_t count,\n\t\t  loff_t *f_pos)\n{\n\tchar __user *start;\n\tstruct ipa_push_msg *msg = NULL;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint locked;\n\n\tstart = buf;\n\n\tadd_wait_queue(&ipa_ctx->msg_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&ipa_ctx->msg_lock);\n\t\tlocked = 1;\n\t\tif (!list_empty(&ipa_ctx->msg_list)) {\n\t\t\tmsg = list_first_entry(&ipa_ctx->msg_list,\n\t\t\t\t\tstruct ipa_push_msg, link);\n\t\t\tlist_del(&msg->link);\n\t\t}\n\n\t\tif (msg) {\n\t\t\tIPADBG("msg=%pK\\n", msg);\n\t\t\tlocked = 0;\n\t\t\tmutex_unlock(&ipa_ctx->msg_lock);\n\t\t\tif (count < sizeof(struct ipa_msg_meta)) {\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (copy_to_user(buf, &msg->meta,\n\t\t\t\t\tsizeof(struct ipa_msg_meta))) {\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += sizeof(struct ipa_msg_meta);\n\t\t\tcount -= sizeof(struct ipa_msg_meta);\n\t\t\tif (msg->buff) {\n\t\t\t\tif (count >= msg->meta.msg_len) {\n\t\t\t\t\tif (copy_to_user(buf, msg->buff,\n\t\t\t\t\t\t\tmsg->meta.msg_len)) {\n\t\t\t\t\t\tkfree(msg);\n\t\t\t\t\t\tmsg = NULL;\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkfree(msg);\n\t\t\t\t\tmsg = NULL;\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuf += msg->meta.msg_len;\n\t\t\t\tcount -= msg->meta.msg_len;\n\t\t\t\tmsg->callback(msg->buff, msg->meta.msg_len,\n\t\t\t\t\t       msg->meta.msg_type);\n\t\t\t}\n\t\t\tIPA_STATS_INC_CNT(\n\t\t\t\tipa_ctx->stats.msg_r[msg->meta.msg_type]);\n\t\t\tkfree(msg);\n\t\t\tmsg = NULL;\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\tlocked = 0;\n\t\tmutex_unlock(&ipa_ctx->msg_lock);\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\n\tremove_wait_queue(&ipa_ctx->msg_waitq, &wait);\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\n\tif (locked)\n\t\tmutex_unlock(&ipa_ctx->msg_lock);\n\n\treturn ret;\n}'
p8884
(dp8885
((g8880
g8881
tp8886
I1
tp8887
(dp8888
g33
(dp8889
(I42
I43
tp8890
(lp8891
S'\t\t\t\tif (copy_to_user(buf, msg->buff,'
p8892
aS'\t\t\t\t\t\t  msg->meta.msg_len)) {'
p8893
as(I33
I33
tp8894
(lp8895
S'\t\t\t\t\t  sizeof(struct ipa_msg_meta))) {'
p8896
assg14
(dp8897
(I26
I31
tp8898
(lp8899
S'\t\t\tif (count < sizeof(struct ipa_msg_meta)) {'
p8900
aS'\t\t\t\tkfree(msg);'
p8901
aS'\t\t\t\tmsg = NULL;'
p8902
aS'\t\t\t\tret = -EFAULT;'
p8903
aS'\t\t\t\tbreak;'
p8904
aS'\t\t\t}'
p8905
as(I33
I33
tp8906
(lp8907
S'\t\t\t\t\tsizeof(struct ipa_msg_meta))) {'
p8908
as(I42
I50
tp8909
(lp8910
S'\t\t\t\tif (count >= msg->meta.msg_len) {'
p8911
aS'\t\t\t\t\tif (copy_to_user(buf, msg->buff,'
p8912
aS'\t\t\t\t\t\t\tmsg->meta.msg_len)) {'
p8913
aS'\t\t\t\t\t\tkfree(msg);'
p8914
aS'\t\t\t\t\t\tmsg = NULL;'
p8915
aS'\t\t\t\t\t\tret = -EFAULT;'
p8916
aS'\t\t\t\t\t\tbreak;'
p8917
aS'\t\t\t\t\t}'
p8918
aS'\t\t\t\t} else {'
p8919
assg32
I4
sg12
g13
sg41
(I1
I91
tp8920
sssssS'CVE-2019-14029'
p8921
(dp8922
(S'drivers/gpu/msm/adreno_dispatch.c'
p8923
S'adreno_dispatcher_queue_cmds'
p8924
tp8925
(dp8926
S'int adreno_dispatcher_queue_cmds(struct kgsl_device_private *dev_priv,\n\t\tstruct kgsl_context *context, struct kgsl_drawobj *drawobj[],\n\t\tuint32_t count, uint32_t *timestamp)\n\n{\n\tstruct kgsl_device *device = dev_priv->device;\n\tstruct adreno_device *adreno_dev = ADRENO_DEVICE(device);\n\tstruct adreno_context *drawctxt = ADRENO_CONTEXT(context);\n\tstruct adreno_dispatcher_drawqueue *dispatch_q;\n\tint ret;\n\tunsigned int i, user_ts;\n\n\tif (!count)\n\t\treturn -EINVAL;\n\n\tret = _check_context_state(&drawctxt->base);\n\tif (ret)\n\t\treturn ret;\n\n\tret = _verify_cmdobj(dev_priv, context, drawobj, count);\n\tif (ret)\n\t\treturn ret;\n\n\t/* wait for the suspend gate */\n\twait_for_completion(&device->halt_gate);\n\n\tspin_lock(&drawctxt->lock);\n\n\tret = _check_context_state_to_queue_cmds(drawctxt);\n\tif (ret) {\n\t\tspin_unlock(&drawctxt->lock);\n\t\treturn ret;\n\t}\n\n\tuser_ts = *timestamp;\n\n\t/*\n\t * If there is only one drawobj in the array and it is of\n\t * type SYNCOBJ_TYPE, skip comparing user_ts as it can be 0\n\t */\n\tif (!(count == 1 && drawobj[0]->type == SYNCOBJ_TYPE) &&\n\t\t(drawctxt->base.flags & KGSL_CONTEXT_USER_GENERATED_TS)) {\n\t\t/*\n\t\t * User specified timestamps need to be greater than the last\n\t\t * issued timestamp in the context\n\t\t */\n\t\tif (timestamp_cmp(drawctxt->timestamp, user_ts) >= 0) {\n\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\treturn -ERANGE;\n\t\t}\n\t}\n\n\tfor (i = 0; i < count; i++) {\n\n\t\tswitch (drawobj[i]->type) {\n\t\tcase MARKEROBJ_TYPE:\n\t\t\tret = _queue_markerobj(adreno_dev, drawctxt,\n\t\t\t\t\tCMDOBJ(drawobj[i]),\n\t\t\t\t\ttimestamp, user_ts);\n\t\t\tif (ret == 1) {\n\t\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\t\tgoto done;\n\t\t\t} else if (ret) {\n\t\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase CMDOBJ_TYPE:\n\t\t\tret = _queue_cmdobj(adreno_dev, drawctxt,\n\t\t\t\t\t\tCMDOBJ(drawobj[i]),\n\t\t\t\t\t\ttimestamp, user_ts);\n\t\t\tif (ret) {\n\t\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SYNCOBJ_TYPE:\n\t\t\t_queue_syncobj(drawctxt, SYNCOBJ(drawobj[i]),\n\t\t\t\t\t\ttimestamp);\n\t\t\tbreak;\n\t\tcase SPARSEOBJ_TYPE:\n\t\t\tret = _queue_sparseobj(adreno_dev, drawctxt,\n\t\t\t\t\tSPARSEOBJ(drawobj[i]),\n\t\t\t\t\ttimestamp, user_ts);\n\t\t\tif (ret == 1) {\n\t\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\t\t_retire_sparseobj(SPARSEOBJ(drawobj[i]),\n\t\t\t\t\t\tdrawctxt);\n\t\t\t\treturn 0;\n\t\t\t} else if (ret) {\n\t\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tspin_unlock(&drawctxt->lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t}\n\n\tdispatch_q = ADRENO_DRAWOBJ_DISPATCH_DRAWQUEUE(drawobj[0]);\n\n\t_track_context(adreno_dev, dispatch_q, drawctxt);\n\n\tspin_unlock(&drawctxt->lock);\n\n\tif (device->pwrctrl.l2pc_update_queue)\n\t\tkgsl_pwrctrl_update_l2pc(&adreno_dev->dev,\n\t\t\t\tKGSL_L2PC_QUEUE_TIMEOUT);\n\n\t/* Add the context to the dispatcher pending list */\n\tdispatcher_queue_context(adreno_dev, drawctxt);\n\n\t/*\n\t * Only issue commands if inflight is less than burst -this prevents us\n\t * from sitting around waiting for the mutex on a busy system - the work\n\t * loop will schedule it for us. Inflight is mutex protected but the\n\t * worse that can happen is that it will go to 0 after we check and if\n\t * it goes to 0 it is because the work loop decremented it and the work\n\t * queue will try to schedule new commands anyway.\n\t */\n\n\tif (dispatch_q->inflight < _context_drawobj_burst)\n\t\tadreno_dispatcher_issuecmds(adreno_dev);\ndone:\n\tif (test_and_clear_bit(ADRENO_CONTEXT_FAULT, &context->priv))\n\t\treturn -EPROTO;\n\n\treturn 0;\n}'
p8927
(dp8928
((g8923
g8924
tp8929
I1
tp8930
(dp8931
g14
(dp8932
(I37
I52
tp8933
(lp8934
S'\t/*'
p8935
aS'\t * If there is only one drawobj in the array and it is of'
p8936
aS'\t * type SYNCOBJ_TYPE, skip comparing user_ts as it can be 0'
p8937
aS'\t */'
p8938
aS'\tif (!(count == 1 && drawobj[0]->type == SYNCOBJ_TYPE) &&'
p8939
aS'\t\t(drawctxt->base.flags & KGSL_CONTEXT_USER_GENERATED_TS)) {'
p8940
aS'\t\t/*'
p8941
aS'\t\t * User specified timestamps need to be greater than the last'
p8942
aS'\t\t * issued timestamp in the context'
p8943
aS'\t\t */'
p8944
aS'\t\tif (timestamp_cmp(drawctxt->timestamp, user_ts) >= 0) {'
p8945
aS'\t\t\tspin_unlock(&drawctxt->lock);'
p8946
aS'\t\t\treturn -ERANGE;'
p8947
aS'\t\t}'
p8948
aS'\t}'
p8949
ag59
assg32
I5
sg12
g13
sg41
(I1
I131
tp8950
sssssS'CVE-2019-2330'
p8951
(dp8952
(S'drivers/staging/android/ion/ion_system_heap.c'
p8953
S'alloc_from_pool_preferred'
p8954
tp8955
(dp8956
S'static struct page_info *alloc_from_pool_preferred(\n\t\tstruct ion_system_heap *heap, struct ion_buffer *buffer,\n\t\tunsigned long size, unsigned int max_order)\n{\n\tstruct page *page;\n\tstruct page_info *info;\n\tint i;\n\n\tif (buffer->flags & ION_FLAG_POOL_FORCE_ALLOC)\n\t\tgoto force_alloc;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_orders; i++) {\n\t\tif (size < order_to_size(orders[i]))\n\t\t\tcontinue;\n\t\tif (max_order < orders[i])\n\t\t\tcontinue;\n\n\t\tpage = alloc_from_secure_pool_order(heap, buffer, orders[i]);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tinfo->page = page;\n\t\tinfo->order = orders[i];\n\t\tinfo->from_pool = true;\n\t\tINIT_LIST_HEAD(&info->list);\n\t\treturn info;\n\t}\n\n\tpage = split_page_from_secure_pool(heap, buffer);\n\tif (page) {\n\t\tinfo->page = page;\n\t\tinfo->order = 0;\n\t\tinfo->from_pool = true;\n\t\tINIT_LIST_HEAD(&info->list);\n\t\treturn info;\n\t}\n\n\tkfree(info);\nforce_alloc:\n\treturn alloc_largest_available(heap, buffer, size, max_order);\n}'
p8957
(dp8958
((g8953
g8954
tp8959
I1
tp8960
(dp8961
g14
(dp8962
(I9
I11
tp8963
(lp8964
S'\tif (buffer->flags & ION_FLAG_POOL_FORCE_ALLOC)'
p8965
aS'\t\tgoto force_alloc;'
p8966
ag59
as(I43
I43
tp8967
(lp8968
S'force_alloc:'
p8969
assg32
I4
sg12
g13
sg41
(I1
I45
tp8970
sssssS'CVE-2018-13893'
p8971
(dp8972
(S'drivers/char/diag/diagchar_core.c'
p8973
S'diag_md_session_exit'
p8974
tp8975
(dp8976
S'static void diag_md_session_exit(void)\n{\n\tint i;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i]) {\n\t\t\tsession_info = driver->md_session_map[i];\n\t\t\tdiag_log_mask_free(session_info->log_mask);\n\t\t\tkfree(session_info->log_mask);\n\t\t\tsession_info->log_mask = NULL;\n\t\t\tdiag_msg_mask_free(session_info->msg_mask,\n\t\t\t\tsession_info);\n\t\t\tkfree(session_info->msg_mask);\n\t\t\tsession_info->msg_mask = NULL;\n\t\t\tdiag_event_mask_free(session_info->event_mask);\n\t\t\tkfree(session_info->event_mask);\n\t\t\tsession_info->event_mask = NULL;\n\t\t\tkfree(session_info);\n\t\t\tsession_info = NULL;\n\t\t\tdriver->md_session_map[i] = NULL;\n\t\t}\n\t}\n\tmutex_destroy(&driver->md_session_lock);\n\tdriver->md_session_mask = 0;\n\tdriver->md_session_mode = DIAG_MD_NONE;\n}'
p8977
(dp8978
((g8973
g8974
tp8979
I1
tp8980
(dp8981
g12
g13
sg14
(dp8982
(I12
I13
tp8983
(lp8984
S'\t\t\tdiag_msg_mask_free(session_info->msg_mask,'
p8985
aS'\t\t\t\tsession_info);'
p8986
assg32
I1
sg33
(dp8987
(I12
I12
tp8988
(lp8989
S'\t\t\tdiag_msg_mask_free(session_info->msg_mask);'
p8990
assg41
(I1
I27
tp8991
ssss(S'drivers/char/diag/diag_masks.c'
p8992
S'diag_cmd_get_msg_mask'
p8993
tp8994
(dp8995
S'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p8996
(dp8997
((g8992
g8993
tp8998
I1
tp8999
(dp9000
g33
(dp9001
(I55
I55
tp9002
(lp9003
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9004
assg14
(dp9005
(I38
I39
tp9006
(lp9007
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9008
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9009
as(I7
I7
tp9010
(lp9011
S'\tuint8_t msg_mask_tbl_count = 0;'
p9012
as(I55
I55
tp9013
(lp9014
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9015
assg32
I5
sg12
g13
sg41
(I1
I76
tp9016
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p9017
(dp9018
((g8992
g8993
tp9019
I1
tp9020
(dp9021
g33
(dp9022
(I18
I19
tp9023
(lp9024
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p9025
aS'\t    !mask_info) {'
p9026
as(I55
I55
tp9027
(lp9028
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9029
assg14
(dp9030
(I38
I39
tp9031
(lp9032
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9033
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9034
as(I18
I19
tp9035
(lp9036
S'\tif (!src_buf || !dest_buf || dest_len <= 0 ||'
p9037
aS'\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {'
p9038
as(I7
I7
tp9039
(lp9040
S'\tuint8_t msg_mask_tbl_count = 0;'
p9041
as(I55
I55
tp9042
(lp9043
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9044
assg32
I5
sg12
g13
sg41
(I1
I76
tp9045
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p9046
(dp9047
((g8992
g8993
tp9048
I1
tp9049
(dp9050
g33
(dp9051
(I19
I19
tp9052
(lp9053
S'\t    !mask_info) {'
p9054
as(I55
I55
tp9055
(lp9056
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9057
assg14
(dp9058
(I55
I55
tp9059
(lp9060
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9061
as(I38
I39
tp9062
(lp9063
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9064
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9065
as(I7
I7
tp9066
(lp9067
S'\tuint8_t msg_mask_tbl_count = 0;'
p9068
as(I19
I19
tp9069
(lp9070
S'\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {'
p9071
assg32
I5
sg12
g13
sg41
(I1
I76
tp9072
ssss(g8992
S'diag_event_mask_copy'
p9073
tp9074
(dp9075
S'int diag_event_mask_copy(struct diag_mask_info *dest,\n\t\t\t struct diag_mask_info *src)\n{\n\tint err = 0;\n\n\tif (!src || !dest)\n\t\treturn -EINVAL;\n\n\tmutex_init(&dest->lock);\n\terr = __diag_mask_init(dest, EVENT_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&dest->lock);\n\tdest->mask_len = src->mask_len;\n\tdest->status = src->status;\n\tmemcpy(dest->ptr, src->ptr, dest->mask_len);\n\tmutex_unlock(&dest->lock);\n\n\treturn err;\n}'
p9076
(dp9077
((g8992
g9073
tp9078
I1
tp9079
(dp9080
g14
(dp9081
(I9
I9
tp9082
(lp9083
S'\tmutex_init(&dest->lock);'
p9084
assg32
I2
sg12
g13
sg41
(I1
I21
tp9085
ssss(g8973
S'diag_md_session_create'
p9086
tp9087
(dp9088
S'int diag_md_session_create(int mode, int peripheral_mask, int proc)\n{\n\tint i;\n\tint err = 0;\n\tstruct diag_md_session_t *new_session = NULL;\n\n\t/*\n\t * If a session is running with a peripheral mask and a new session\n\t * request comes in with same peripheral mask value then return\n\t * invalid param\n\t */\n\tif (driver->md_session_mode == DIAG_MD_PERIPHERAL &&\n\t    (driver->md_session_mask & peripheral_mask) != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tnew_session = kzalloc(sizeof(struct diag_md_session_t), GFP_KERNEL);\n\tif (!new_session) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -ENOMEM;\n\t}\n\tnew_session->peripheral_mask = 0;\n\tnew_session->pid = current->tgid;\n\tnew_session->task = current;\n\tnew_session->log_mask = kzalloc(sizeof(struct diag_mask_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_session->log_mask) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_peripheral;\n\t}\n\tnew_session->event_mask = kzalloc(sizeof(struct diag_mask_info),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!new_session->event_mask) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_peripheral;\n\t}\n\tnew_session->msg_mask = kzalloc(sizeof(struct diag_mask_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_session->msg_mask) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_peripheral;\n\t}\n\n\terr = diag_log_mask_copy(new_session->log_mask, &log_mask);\n\tif (err) {\n\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t "return value of log copy. err %d\\n", err);\n\t\tgoto fail_peripheral;\n\t}\n\terr = diag_event_mask_copy(new_session->event_mask, &event_mask);\n\tif (err) {\n\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t "return value of event copy. err %d\\n", err);\n\t\tgoto fail_peripheral;\n\t}\n\tnew_session->msg_mask_tbl_count = 0;\n\terr = diag_msg_mask_copy(new_session, new_session->msg_mask,\n\t\t&msg_mask);\n\tif (err) {\n\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t "return value of msg copy. err %d\\n", err);\n\t\tgoto fail_peripheral;\n\t}\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif ((MD_PERIPHERAL_MASK(i) & peripheral_mask) == 0)\n\t\t\tcontinue;\n\t\tif (driver->md_session_map[i] != NULL) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t "another instance present for %d\\n", i);\n\t\t\terr = -EEXIST;\n\t\t\tgoto fail_peripheral;\n\t\t}\n\t\tnew_session->peripheral_mask |= MD_PERIPHERAL_MASK(i);\n\t\tdriver->md_session_map[i] = new_session;\n\t\tdriver->md_session_mask |= MD_PERIPHERAL_MASK(i);\n\t}\n\tsetup_timer(&new_session->hdlc_reset_timer,\n\t\tdiag_md_hdlc_reset_timer_func,\n\t\tnew_session->pid);\n\n\tdriver->md_session_mode = DIAG_MD_PERIPHERAL;\n\tmutex_unlock(&driver->md_session_lock);\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t "created session in peripheral mode\\n");\n\treturn 0;\n\nfail_peripheral:\n\tdiag_log_mask_free(new_session->log_mask);\n\tkfree(new_session->log_mask);\n\tnew_session->log_mask = NULL;\n\tdiag_event_mask_free(new_session->event_mask);\n\tkfree(new_session->event_mask);\n\tnew_session->event_mask = NULL;\n\tdiag_msg_mask_free(new_session->msg_mask,\n\t\tnew_session);\n\tkfree(new_session->msg_mask);\n\tnew_session->msg_mask = NULL;\n\tkfree(new_session);\n\tnew_session = NULL;\n\tmutex_unlock(&driver->md_session_lock);\n\treturn err;\n}'
p9089
(dp9090
((g8973
g9086
tp9091
I1
tp9092
(dp9093
g12
g13
sg14
(dp9094
(I94
I95
tp9095
(lp9096
S'\tdiag_msg_mask_free(new_session->msg_mask,'
p9097
aS'\t\tnew_session);'
p9098
as(I56
I58
tp9099
(lp9100
S'\tnew_session->msg_mask_tbl_count = 0;'
p9101
aS'\terr = diag_msg_mask_copy(new_session, new_session->msg_mask,'
p9102
aS'\t\t&msg_mask);'
p9103
assg32
I3
sg33
(dp9104
(I56
I56
tp9105
(lp9106
S'\terr = diag_msg_mask_copy(new_session->msg_mask, &msg_mask);'
p9107
as(I94
I94
tp9108
(lp9109
S'\tdiag_msg_mask_free(new_session->msg_mask);'
p9110
assg41
(I1
I102
tp9111
ssss(g8992
S'diag_build_time_mask_init'
p9112
tp9113
(dp9114
S'static int diag_build_time_mask_init(void)\n{\n\tint err = 0;\n\n\t/* There is no need for update buffer for Build Time masks */\n\tmutex_init(&msg_bt_mask.lock);\n\terr = __diag_mask_init(&msg_bt_mask, MSG_MASK_SIZE, 0);\n\tif (err)\n\t\treturn err;\n\terr = diag_create_build_time_mask();\n\tif (err) {\n\t\tpr_err("diag: Unable to create msg build time masks, err: %d\\n",\n\t\t       err);\n\t\treturn err;\n\t}\n\tdriver->build_time_mask = &msg_bt_mask;\n\treturn 0;\n}'
p9115
(dp9116
((g8992
g9112
tp9117
I1
tp9118
(dp9119
g14
(dp9120
(I6
I6
tp9121
(lp9122
S'\tmutex_init(&msg_bt_mask.lock);'
p9123
assg32
I1
sg12
g13
sg41
(I1
I18
tp9124
ssss(g8973
S'diag_md_session_close'
p9125
tp9126
(dp9127
S'static void diag_md_session_close(int pid)\n{\n\tint i;\n\tuint8_t found = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != session_info)\n\t\t\tcontinue;\n\t\tdriver->md_session_map[i] = NULL;\n\t\tdriver->md_session_mask &= ~session_info->peripheral_mask;\n\t}\n\tdiag_log_mask_free(session_info->log_mask);\n\tkfree(session_info->log_mask);\n\tsession_info->log_mask = NULL;\n\tdiag_msg_mask_free(session_info->msg_mask,\n\t\tsession_info);\n\tkfree(session_info->msg_mask);\n\tsession_info->msg_mask = NULL;\n\tdiag_event_mask_free(session_info->event_mask);\n\tkfree(session_info->event_mask);\n\tsession_info->event_mask = NULL;\n\tdel_timer(&session_info->hdlc_reset_timer);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS && !found; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfound = 1;\n\t}\n\n\tdriver->md_session_mode = (found) ? DIAG_MD_PERIPHERAL : DIAG_MD_NONE;\n\tkfree(session_info);\n\tsession_info = NULL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "cleared up session\\n");\n}'
p9128
(dp9129
((g8973
g9125
tp9130
I1
tp9131
(dp9132
g12
g13
sg14
(dp9133
(I20
I21
tp9134
(lp9135
S'\tdiag_msg_mask_free(session_info->msg_mask,'
p9136
aS'\t\tsession_info);'
p9137
assg32
I1
sg33
(dp9138
(I20
I20
tp9139
(lp9140
S'\tdiag_msg_mask_free(session_info->msg_mask);'
p9141
assg41
(I1
I38
tp9142
ssss(g8992
S'diag_msg_mask_copy'
p9143
tp9144
(dp9145
S'int diag_msg_mask_copy(struct diag_md_session_t *new_session,\n\tstruct diag_mask_info *dest, struct diag_mask_info *src)\n{\n\tint i, err = 0, mask_size = 0;\n\tstruct diag_msg_mask_t *src_mask = NULL;\n\tstruct diag_msg_mask_t *dest_mask = NULL;\n\tstruct diag_ssid_range_t range;\n\n\tif (!src || !dest)\n\t\treturn -EINVAL;\n\n\tmutex_init(&dest->lock);\n\tmutex_lock(&dest->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tnew_session->msg_mask_tbl_count =\n\t\tdriver->msg_mask_tbl_count;\n\terr = __diag_mask_init(dest,\n\t\t(new_session->msg_mask_tbl_count *\n\t\tsizeof(struct diag_msg_mask_t)), APPS_BUF_SIZE);\n\tif (err) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&dest->lock);\n\t\treturn err;\n\t}\n\tsrc_mask = (struct diag_msg_mask_t *)src->ptr;\n\tdest_mask = (struct diag_msg_mask_t *)dest->ptr;\n\n\tdest->mask_len = src->mask_len;\n\tdest->status = src->status;\n\tfor (i = 0; i < new_session->msg_mask_tbl_count; i++) {\n\t\trange.ssid_first = src_mask->ssid_first;\n\t\trange.ssid_last = src_mask->ssid_last;\n\t\terr = diag_create_msg_mask_table_entry(dest_mask, &range);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (src_mask->range_tools < dest_mask->range)\n\t\t\tmask_size = src_mask->range_tools * sizeof(uint32_t);\n\t\telse\n\t\t\tmask_size = dest_mask->range * sizeof(uint32_t);\n\t\tmemcpy(dest_mask->ptr, src_mask->ptr, mask_size);\n\t\tsrc_mask++;\n\t\tdest_mask++;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&dest->lock);\n\treturn err;\n}'
p9146
(dp9147
((g8992
g9143
tp9148
I1
tp9149
(dp9150
g12
g13
sg14
(dp9151
(I1
I2
tp9152
(lp9153
S'int diag_msg_mask_copy(struct diag_md_session_t *new_session,'
p9154
aS'\tstruct diag_mask_info *dest, struct diag_mask_info *src)'
p9155
as(I12
I12
tp9156
(lp9157
S'\tmutex_init(&dest->lock);'
p9158
as(I15
I24
tp9159
(lp9160
S'\tnew_session->msg_mask_tbl_count ='
p9161
aS'\t\tdriver->msg_mask_tbl_count;'
p9162
aS'\terr = __diag_mask_init(dest,'
p9163
aS'\t\t(new_session->msg_mask_tbl_count *'
p9164
aS'\t\tsizeof(struct diag_msg_mask_t)), APPS_BUF_SIZE);'
p9165
aS'\tif (err) {'
p9166
aS'\t\tmutex_unlock(&driver->msg_mask_lock);'
p9167
aS'\t\tmutex_unlock(&dest->lock);'
p9168
aS'\t\treturn err;'
p9169
aS'\t}'
p9170
as(I30
I30
tp9171
(lp9172
S'\tfor (i = 0; i < new_session->msg_mask_tbl_count; i++) {'
p9173
assg32
I3
sg33
(dp9174
(I30
I30
tp9175
(lp9176
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++) {'
p9177
as(I1
I1
tp9178
(lp9179
S'int diag_msg_mask_copy(struct diag_mask_info *dest, struct diag_mask_info *src)'
p9180
as(I12
I14
tp9181
(lp9182
S'\terr = __diag_mask_init(dest, MSG_MASK_SIZE, APPS_BUF_SIZE);'
p9183
aS'\tif (err)'
p9184
aS'\t\treturn err;'
p9185
assg41
(I1
I47
tp9186
ssss(g8992
S'diag_cmd_get_ssid_range'
p9187
tp9188
(dp9189
S'static int diag_cmd_get_ssid_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tstruct diag_msg_ssid_query_t rsp;\n\tstruct diag_ssid_range_t ssid_range;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\tdriver->msg_mask_tbl_count;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_SSID_RANGE;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.count = msg_mask_tbl_count;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmask_ptr = (struct diag_msg_mask_t *)mask_info->ptr;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask_ptr++) {\n\t\tif (write_len + sizeof(ssid_range) > dest_len) {\n\t\t\tpr_err("diag: In %s, Truncating response due to size limitations of rsp buffer\\n",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tssid_range.ssid_first = mask_ptr->ssid_first;\n\t\tssid_range.ssid_last = mask_ptr->ssid_last_tools;\n\t\tmemcpy(dest_buf + write_len, &ssid_range, sizeof(ssid_range));\n\t\twrite_len += sizeof(ssid_range);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p9190
(dp9191
((g8992
g9187
tp9192
I1
tp9193
(dp9194
g33
(dp9195
(I46
I46
tp9196
(lp9197
S'\tfor (i = 0; i <  driver->msg_mask_tbl_count; i++, mask_ptr++) {'
p9198
as(I42
I42
tp9199
(lp9200
S'\trsp.count = driver->msg_mask_tbl_count;'
p9201
assg14
(dp9202
(I36
I37
tp9203
(lp9204
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9205
aS'\t\tdriver->msg_mask_tbl_count;'
p9206
as(I46
I46
tp9207
(lp9208
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask_ptr++) {'
p9209
as(I42
I42
tp9210
(lp9211
S'\trsp.count = msg_mask_tbl_count;'
p9212
as(I6
I6
tp9213
(lp9214
S'\tuint8_t msg_mask_tbl_count = 0;'
p9215
assg32
I5
sg12
g13
sg41
(I1
I60
tp9216
ssss(g8992
S'diag_send_msg_mask_update'
p9217
tp9218
(dp9219
S'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tstruct diag_md_session_t *md_session_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t\t\tmd_session_info =\n\t\t\t\t\tdriver->md_session_map[peripheral];\n\t\t\t}\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t\t\tmd_session_info = driver->md_session_map[upd];\n\t\t\t}\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tif (md_session_info)\n\t\tmsg_mask_tbl_count_local = md_session_info->msg_mask_tbl_count;\n\telse\n\t\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p9220
(dp9221
((g8992
g9217
tp9222
I1
tp9223
(dp9224
g12
g13
sg14
(dp9225
(I13
I13
tp9226
(lp9227
S'\tstruct diag_md_session_t *md_session_info = NULL;'
p9228
as(I40
I41
tp9229
(lp9230
S'\t\t\t\tmd_session_info = driver->md_session_map[upd];'
p9231
aS'\t\t\t}'
p9232
as(I60
I63
tp9233
(lp9234
S'\tif (md_session_info)'
p9235
aS'\t\tmsg_mask_tbl_count_local = md_session_info->msg_mask_tbl_count;'
p9236
aS'\telse'
p9237
aS'\t\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;'
p9238
as(I37
I37
tp9239
(lp9240
S'\t\t\tif (upd && driver->md_session_map[upd]) {'
p9241
as(I7
I7
tp9242
(lp9243
S'\tuint8_t msg_mask_tbl_count_local = 0;'
p9244
as(I32
I34
tp9245
(lp9246
S'\t\t\t\tmd_session_info ='
p9247
aS'\t\t\t\t\tdriver->md_session_map[peripheral];'
p9248
aS'\t\t\t}'
p9249
as(I29
I29
tp9250
(lp9251
S'\t\t\tif (driver->md_session_map[peripheral]) {'
p9252
assg32
I3
sg33
(dp9253
(I60
I60
tp9254
(lp9255
S'\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;'
p9256
as(I37
I37
tp9257
(lp9258
S'\t\t\tif (upd && driver->md_session_map[upd])'
p9259
as(I7
I7
tp9260
(lp9261
S'\tuint8_t msg_mask_tbl_count_local;'
p9262
as(I29
I29
tp9263
(lp9264
S'\t\t\tif (driver->md_session_map[peripheral])'
p9265
assg41
(I1
I142
tp9266
ssss(g8992
S'diag_log_mask_init'
p9267
tp9268
(dp9269
S'static int diag_log_mask_init(void)\n{\n\tint err = 0, i;\n\n\tmutex_init(&log_mask.lock);\n\terr = __diag_mask_init(&log_mask, LOG_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = diag_create_log_mask_table();\n\tif (err)\n\t\treturn err;\n\tdriver->log_mask = &log_mask;\n\n\tfor (i = 0; i < NUM_PERIPHERALS; i++)\n\t\tdriver->num_equip_id[i] = 0;\n\n\treturn 0;\n}'
p9270
(dp9271
((g8992
g9267
tp9272
I1
tp9273
(dp9274
g14
(dp9275
(I5
I5
tp9276
(lp9277
S'\tmutex_init(&log_mask.lock);'
p9278
assg32
I1
sg12
g13
sg41
(I1
I18
tp9279
ssss(g8992
S'__diag_mask_init'
p9280
tp9281
(dp9282
S'static int __diag_mask_init(struct diag_mask_info *mask_info, int mask_len,\n\t\t\t    int update_buf_len)\n{\n\tif (!mask_info || mask_len < 0 || update_buf_len < 0)\n\t\treturn -EINVAL;\n\n\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\tmask_info->mask_len = mask_len;\n\tmask_info->update_buf_len = update_buf_len;\n\tif (mask_len > 0) {\n\t\tmask_info->ptr = kzalloc(mask_len, GFP_KERNEL);\n\t\tif (!mask_info->ptr)\n\t\t\treturn -ENOMEM;\n\t\tkmemleak_not_leak(mask_info->ptr);\n\t}\n\tif (update_buf_len > 0) {\n\t\tmask_info->update_buf = kzalloc(update_buf_len, GFP_KERNEL);\n\t\tif (!mask_info->update_buf) {\n\t\t\tkfree(mask_info->ptr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkmemleak_not_leak(mask_info->update_buf);\n\t}\n\treturn 0;\n}'
p9283
(dp9284
((g8992
g9280
tp9285
I1
tp9286
(dp9287
g12
g13
sg41
(I1
I25
tp9288
sg32
I3
sg33
(dp9289
(I24
I24
tp9290
(lp9291
S'\tmutex_init(&mask_info->lock);'
p9292
assssS'static int __diag_mask_init(struct diag_mask_info *mask_info, int mask_len,\n\t\t\t    int update_buf_len)\n{\n\tif (!mask_info || mask_len < 0 || update_buf_len < 0)\n\t\treturn -EINVAL;\n\n\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\tmask_info->mask_len = mask_len;\n\tmask_info->update_buf_len = update_buf_len;\n\tif (mask_len > 0) {\n\t\tmask_info->ptr = kzalloc(mask_len, GFP_KERNEL);\n\t\tif (!mask_info->ptr)\n\t\t\treturn -ENOMEM;\n\t\tkmemleak_not_leak(mask_info->ptr);\n\t}\n\tif (update_buf_len > 0) {\n\t\tmask_info->update_buf = kzalloc(update_buf_len, GFP_KERNEL);\n\t\tif (!mask_info->update_buf) {\n\t\t\tkfree(mask_info->ptr);\n\t\t\tmask_info->ptr = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkmemleak_not_leak(mask_info->update_buf);\n\t}\n\treturn 0;\n}'
p9293
(dp9294
((g8992
g9280
tp9295
I1
tp9296
(dp9297
g33
(dp9298
(I25
I25
tp9299
(lp9300
S'\tmutex_init(&mask_info->lock);'
p9301
assg14
(dp9302
(I20
I20
tp9303
(lp9304
S'\t\t\tmask_info->ptr = NULL;'
p9305
assg32
I3
sg12
g13
sg41
(I1
I26
tp9306
ssss(g8992
S'diag_event_mask_init'
p9307
tp9308
(dp9309
S'static int diag_event_mask_init(void)\n{\n\tint err = 0, i;\n\n\tmutex_init(&event_mask.lock);\n\terr = __diag_mask_init(&event_mask, EVENT_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\tdriver->event_mask_size = EVENT_MASK_SIZE;\n\tdriver->last_event_id = APPS_EVENT_LAST_ID;\n\tdriver->event_mask = &event_mask;\n\n\tfor (i = 0; i < NUM_PERIPHERALS; i++)\n\t\tdriver->num_event_id[i] = 0;\n\n\treturn 0;\n}'
p9310
(dp9311
((g8992
g9307
tp9312
I1
tp9313
(dp9314
g14
(dp9315
(I5
I5
tp9316
(lp9317
S'\tmutex_init(&event_mask.lock);'
p9318
assg32
I1
sg12
g13
sg41
(I1
I17
tp9319
ssss(g8992
S'diag_log_mask_copy'
p9320
tp9321
(dp9322
S'int diag_log_mask_copy(struct diag_mask_info *dest, struct diag_mask_info *src)\n{\n\tint i, err = 0;\n\tstruct diag_log_mask_t *src_mask = NULL;\n\tstruct diag_log_mask_t *dest_mask = NULL;\n\n\tif (!src || !dest)\n\t\treturn -EINVAL;\n\n\tmutex_init(&dest->lock);\n\terr = __diag_mask_init(dest, LOG_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&dest->lock);\n\tsrc_mask = (struct diag_log_mask_t *)(src->ptr);\n\tdest_mask = (struct diag_log_mask_t *)(dest->ptr);\n\n\tdest->mask_len = src->mask_len;\n\tdest->status = src->status;\n\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, src_mask++, dest_mask++) {\n\t\tdest_mask->equip_id = src_mask->equip_id;\n\t\tdest_mask->num_items = src_mask->num_items;\n\t\tdest_mask->num_items_tools = src_mask->num_items_tools;\n\t\tmutex_init(&dest_mask->lock);\n\t\tdest_mask->range = src_mask->range;\n\t\tdest_mask->range_tools = src_mask->range_tools;\n\t\tdest_mask->ptr = kzalloc(dest_mask->range_tools, GFP_KERNEL);\n\t\tif (!dest_mask->ptr) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tkmemleak_not_leak(dest_mask->ptr);\n\t\tmemcpy(dest_mask->ptr, src_mask->ptr, dest_mask->range_tools);\n\t}\n\tmutex_unlock(&dest->lock);\n\n\treturn err;\n}'
p9323
(dp9324
((g8992
g9320
tp9325
I1
tp9326
(dp9327
g12
g13
sg14
(dp9328
(I7
I7
tp9329
(lp9330
S'\tif (!src || !dest)'
p9331
as(I10
I10
tp9332
(lp9333
S'\tmutex_init(&dest->lock);'
p9334
assg32
I2
sg33
(dp9335
(I7
I7
tp9336
(lp9337
S'\tif (!src)'
p9338
assg41
(I1
I40
tp9339
ssss(g8992
S'diag_cmd_set_all_msg_mask'
p9340
tp9341
(dp9342
S'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p9343
(dp9344
((g8992
g9340
tp9345
I1
tp9346
(dp9347
g33
(dp9348
(I17
I18
tp9349
(lp9350
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p9351
aS'\t    !mask_info) {'
p9352
as(I50
I50
tp9353
(lp9354
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9355
assg14
(dp9356
(I17
I18
tp9357
(lp9358
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p9359
aS'\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {'
p9360
as(I46
I47
tp9361
(lp9362
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9363
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9364
as(I11
I11
tp9365
(lp9366
S'\tuint8_t msg_mask_tbl_count = 0;'
p9367
as(I50
I50
tp9368
(lp9369
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9370
assg32
I5
sg12
g13
sg41
(I1
I91
tp9371
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p9372
(dp9373
((g8992
g9340
tp9374
I1
tp9375
(dp9376
g33
(dp9377
(I50
I50
tp9378
(lp9379
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9380
assg14
(dp9381
(I46
I47
tp9382
(lp9383
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9384
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9385
as(I11
I11
tp9386
(lp9387
S'\tuint8_t msg_mask_tbl_count = 0;'
p9388
as(I50
I50
tp9389
(lp9390
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9391
assg32
I5
sg12
g13
sg41
(I1
I91
tp9392
ssss(g8992
S'diag_msg_mask_free'
p9393
tp9394
(dp9395
S'void diag_msg_mask_free(struct diag_mask_info *mask_info,\n\tstruct diag_md_session_t *session_info)\n{\n\tint i;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tif (!mask_info || !mask_info->ptr)\n\t\treturn;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\treturn;\n\t}\n\tmsg_mask_tbl_count = (session_info) ?\n\t\tsession_info->msg_mask_tbl_count :\n\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tkfree(mask->ptr);\n\t\tmask->ptr = NULL;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\t__diag_mask_exit(mask_info);\n}'
p9396
(dp9397
((g8992
g9393
tp9398
I1
tp9399
(dp9400
g12
g13
sg14
(dp9401
(I1
I2
tp9402
(lp9403
S'void diag_msg_mask_free(struct diag_mask_info *mask_info,'
p9404
aS'\tstruct diag_md_session_t *session_info)'
p9405
as(I20
I23
tp9406
(lp9407
S'\tmsg_mask_tbl_count = (session_info) ?'
p9408
aS'\t\tsession_info->msg_mask_tbl_count :'
p9409
aS'\t\tdriver->msg_mask_tbl_count;'
p9410
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9411
as(I6
I6
tp9412
(lp9413
S'\tuint8_t msg_mask_tbl_count = 0;'
p9414
assg32
I2
sg33
(dp9415
(I20
I20
tp9416
(lp9417
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9418
as(I1
I1
tp9419
(lp9420
S'void diag_msg_mask_free(struct diag_mask_info *mask_info)'
p9421
assg41
(I1
I30
tp9422
ssss(g8992
S'diag_msg_mask_init'
p9423
tp9424
(dp9425
S'static int diag_msg_mask_init(void)\n{\n\tint err = 0, i;\n\n\tmutex_init(&msg_mask.lock);\n\terr = __diag_mask_init(&msg_mask, MSG_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\n\terr = diag_create_msg_mask_table();\n\tif (err) {\n\t\tpr_err("diag: Unable to create msg masks, err: %d\\n", err);\n\t\treturn err;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tdriver->msg_mask = &msg_mask;\n\tfor (i = 0; i < NUM_PERIPHERALS; i++)\n\t\tdriver->max_ssid_count[i] = 0;\n\tmutex_unlock(&driver->msg_mask_lock);\n\n\treturn 0;\n}'
p9426
(dp9427
((g8992
g9423
tp9428
I1
tp9429
(dp9430
g14
(dp9431
(I5
I5
tp9432
(lp9433
S'\tmutex_init(&msg_mask.lock);'
p9434
as(I9
I9
tp9435
(lp9436
g59
assg32
I1
sg12
g13
sg41
(I1
I22
tp9437
ssss(g8992
S'diag_copy_to_user_msg_mask'
p9438
tp9439
(dp9440
S'int diag_copy_to_user_msg_mask(char __user *buf, size_t count,\n\t\t\t       struct diag_md_session_t *info)\n{\n\tint i, err = 0, len = 0;\n\tint copy_len = 0, total_len = 0;\n\tstruct diag_msg_mask_userspace_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tunsigned char *ptr = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tif (!buf || count == 0)\n\t\treturn -EINVAL;\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!mask_info)\n\t\treturn -EIO;\n\n\tif (!mask_info->ptr || !mask_info->update_buf) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK, mask_info->update_buf: %pK\\n",\n\t\t\t__func__, mask_info->ptr, mask_info->update_buf);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)(mask_info->ptr);\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tptr = mask_info->update_buf;\n\t\tlen = 0;\n\t\tmutex_lock(&mask->lock);\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.range = mask->range_tools;\n\t\tmemcpy(ptr, &header, sizeof(header));\n\t\tlen += sizeof(header);\n\t\tcopy_len = (sizeof(uint32_t) * mask->range_tools);\n\t\tif ((len + copy_len) > mask_info->update_buf_len) {\n\t\t\tpr_err("diag: In %s, no space to update msg mask, first: %d, last: %d\\n",\n\t\t\t       __func__, mask->ssid_first,\n\t\t\t       mask->ssid_last_tools);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tmemcpy(ptr + len, mask->ptr, copy_len);\n\t\tlen += copy_len;\n\t\tmutex_unlock(&mask->lock);\n\t\t/* + sizeof(int) to account for data_type already in buf */\n\t\tif (total_len + sizeof(int) + len > count) {\n\t\t\tpr_err("diag: In %s, unable to send msg masks to user space, total_len: %d, count: %zu\\n",\n\t\t\t       __func__, total_len, count);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\terr = copy_to_user(buf + total_len, (void *)ptr, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s Unable to send msg masks to user space clients, err: %d\\n",\n\t\t\t       __func__, err);\n\t\t\tbreak;\n\t\t}\n\t\ttotal_len += len;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\treturn err ? err : total_len;\n}'
p9441
(dp9442
((g8992
g9438
tp9443
I1
tp9444
(dp9445
g33
(dp9446
(I35
I35
tp9447
(lp9448
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9449
assg14
(dp9450
(I35
I37
tp9451
(lp9452
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9453
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9454
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9455
as(I10
I10
tp9456
(lp9457
S'\tuint8_t msg_mask_tbl_count = 0;'
p9458
assg32
I3
sg12
g13
sg41
(I1
I77
tp9459
ssss(g8992
S'diag_cmd_set_msg_mask'
p9460
tp9461
(dp9462
S'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p9463
(dp9464
((g8992
g9460
tp9465
I1
tp9466
(dp9467
g33
(dp9468
(I20
I21
tp9469
(lp9470
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p9471
aS'\t    !mask_info) {'
p9472
as(I52
I52
tp9473
(lp9474
S'\t\tif (i < (driver->msg_mask_tbl_count - 1)) {'
p9475
as(I47
I47
tp9476
(lp9477
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9478
as(I105
I105
tp9479
(lp9480
S'\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);'
p9481
assg14
(dp9482
(I20
I21
tp9483
(lp9484
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p9485
aS'\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {'
p9486
as(I47
I49
tp9487
(lp9488
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9489
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9490
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9491
as(I52
I52
tp9492
(lp9493
S'\t\tif (i < (msg_mask_tbl_count - 1)) {'
p9494
as(I105
I107
tp9495
(lp9496
S'\t\tif (mask_size && src_len >= header_len + mask_size)'
p9497
aS'\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,'
p9498
aS'\t\t\t\tmask_size);'
p9499
as(I14
I14
tp9500
(lp9501
S'\tuint8_t msg_mask_tbl_count = 0;'
p9502
assg32
I5
sg12
g13
sg41
(I1
I152
tp9503
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tif (mask_size && src_len >= header_len + mask_size)\n\t\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p9504
(dp9505
((g8992
g9460
tp9506
I1
tp9507
(dp9508
g33
(dp9509
(I20
I21
tp9510
(lp9511
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p9512
aS'\t    !mask_info) {'
p9513
as(I52
I52
tp9514
(lp9515
S'\t\tif (i < (driver->msg_mask_tbl_count - 1)) {'
p9516
as(I134
I134
tp9517
(lp9518
S'\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);'
p9519
as(I47
I47
tp9520
(lp9521
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9522
as(I105
I105
tp9523
(lp9524
S'\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);'
p9525
assg14
(dp9526
(I105
I107
tp9527
(lp9528
S'\t\tif (mask_size && src_len >= header_len + mask_size)'
p9529
aS'\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,'
p9530
aS'\t\t\t\tmask_size);'
p9531
as(I134
I135
tp9532
(lp9533
S'\tif (mask_size && src_len >= header_len + mask_size)'
p9534
aS'\t\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);'
p9535
as(I14
I14
tp9536
(lp9537
S'\tuint8_t msg_mask_tbl_count = 0;'
p9538
as(I20
I21
tp9539
(lp9540
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p9541
aS'\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {'
p9542
as(I52
I52
tp9543
(lp9544
S'\t\tif (i < (msg_mask_tbl_count - 1)) {'
p9545
as(I47
I49
tp9546
(lp9547
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9548
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9549
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9550
assg32
I5
sg12
g13
sg41
(I1
I153
tp9551
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p9552
(dp9553
((g8992
g9460
tp9554
I1
tp9555
(dp9556
g33
(dp9557
(I52
I52
tp9558
(lp9559
S'\t\tif (i < (driver->msg_mask_tbl_count - 1)) {'
p9560
as(I47
I47
tp9561
(lp9562
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p9563
assg14
(dp9564
(I47
I49
tp9565
(lp9566
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p9567
aS'\t\t\tdriver->msg_mask_tbl_count;'
p9568
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p9569
as(I52
I52
tp9570
(lp9571
S'\t\tif (i < (msg_mask_tbl_count - 1)) {'
p9572
as(I14
I14
tp9573
(lp9574
S'\tuint8_t msg_mask_tbl_count = 0;'
p9575
assg32
I5
sg12
g13
sg41
(I1
I150
tp9576
sssssS'CVE-2018-20169'
p9577
(dp9578
(S'drivers/usb/core/usb.c'
p9579
S'__usb_get_extra_descriptor'
p9580
tp9581
(dp9582
S'int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr, size_t minsize)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2 || header->bLength > size) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t"%s: bogus descriptor, type %d length %d\\n",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}'
p9583
(dp9584
((g9579
g9580
tp9585
I1
tp9586
(dp9587
g12
g13
sg14
(dp9588
(I18
I18
tp9589
(lp9590
S'\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {'
p9591
as(I9
I9
tp9592
(lp9593
S'\t\tif (header->bLength < 2 || header->bLength > size) {'
p9594
as(I2
I2
tp9595
(lp9596
S'\t\t\t       unsigned char type, void **ptr, size_t minsize)'
p9597
assg32
I5
sg33
(dp9598
(I18
I18
tp9599
(lp9600
S'\t\tif (header->bDescriptorType == type) {'
p9601
as(I9
I9
tp9602
(lp9603
S'\t\tif (header->bLength < 2) {'
p9604
as(I2
I2
tp9605
(lp9606
S'\t\t\t       unsigned char type, void **ptr)'
p9607
assg41
(I1
I27
tp9608
ssss(S'drivers/usb/host/hwa-hc.c'
p9609
S'hwahc_security_create'
p9610
tp9611
(dp9612
S'static int hwahc_security_create(struct hwahc *hwahc)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct usb_device *usb_dev = hwahc->wa.usb_dev;\n\tstruct device *dev = &usb_dev->dev;\n\tstruct usb_security_descriptor *secd;\n\tstruct usb_encryption_descriptor *etd;\n\tvoid *itr, *top;\n\tsize_t itr_size, needed, bytes;\n\tu8 index;\n\tchar buf[64];\n\n\t/* Find the host\'s security descriptors in the config descr bundle */\n\tindex = (usb_dev->actconfig - usb_dev->config) /\n\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[index];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\ttop = itr + itr_size;\n\tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n\t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));\n\tif (result == -1) {\n\t\tdev_warn(dev, "BUG? WUSB host has no security descriptors\\n");\n\t\treturn 0;\n\t}\n\tneeded = sizeof(*secd);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, "BUG? Not enough data to process security "\n\t\t\t"descriptor header (%zu bytes left vs %zu needed)\\n",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\tneeded = le16_to_cpu(secd->wTotalLength);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, "BUG? Not enough data to process security "\n\t\t\t"descriptors (%zu bytes left vs %zu needed)\\n",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\t/* Walk over the sec descriptors and store CCM1\'s on wusbhc */\n\titr = (void *) secd + sizeof(*secd);\n\ttop = (void *) secd + le16_to_cpu(secd->wTotalLength);\n\tindex = 0;\n\tbytes = 0;\n\twhile (itr < top) {\n\t\tetd = itr;\n\t\tif (top - itr < sizeof(*etd)) {\n\t\t\tdev_err(dev, "BUG: bad host security descriptor; "\n\t\t\t\t"not enough data (%zu vs %zu left)\\n",\n\t\t\t\ttop - itr, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\tif (etd->bLength < sizeof(*etd)) {\n\t\t\tdev_err(dev, "BUG: bad host encryption descriptor; "\n\t\t\t\t"descriptor is too short "\n\t\t\t\t"(%zu vs %zu needed)\\n",\n\t\t\t\t(size_t)etd->bLength, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\titr += etd->bLength;\n\t\tbytes += snprintf(buf + bytes, sizeof(buf) - bytes,\n\t\t\t\t  "%s (0x%02x) ",\n\t\t\t\t  wusb_et_name(etd->bEncryptionType),\n\t\t\t\t  etd->bEncryptionValue);\n\t\twusbhc->ccm1_etd = etd;\n\t}\n\tdev_info(dev, "supported encryption types: %s\\n", buf);\n\tif (wusbhc->ccm1_etd == NULL) {\n\t\tdev_err(dev, "E: host doesn\'t support CCM-1 crypto\\n");\n\t\treturn 0;\n\t}\n\t/* Pretty print what we support */\n\treturn 0;\n}'
p9613
(dp9614
((g9609
g9610
tp9615
I1
tp9616
(dp9617
g12
g13
sg14
(dp9618
(I22
I22
tp9619
(lp9620
S'\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));'
p9621
assg32
I1
sg33
(dp9622
(I22
I22
tp9623
(lp9624
S'\t\t\tUSB_DT_SECURITY, (void **) &secd);'
p9625
assg41
(I1
I75
tp9626
ssss(S'drivers/usb/core/hub.c'
p9627
S'usb_enumerate_device_otg'
p9628
tp9629
(dp9630
S'static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we\'ve powered off VBUS; and HNP, switching roles\n\t * "host" to "peripheral".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t/* descriptor may appear anywhere in config */\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, "Dual-Role OTG device on %sHNP port\\n",\n\t\t\t\t\t(port1 == bus->otg_port) ? "" : "non-");\n\n\t\t/* enable HNP before suspend, it\'s simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, "can\'t set HNP mode: %d\\n",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t"set a_alt_hnp_support failed: %d\\n",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}'
p9631
(dp9632
((g9627
g9628
tp9633
I1
tp9634
(dp9635
g12
g13
sg14
(dp9636
(I21
I21
tp9637
(lp9638
S'\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));'
p9639
assg32
I1
sg33
(dp9640
(I21
I21
tp9641
(lp9642
S'\t\t\t\tUSB_DT_OTG, (void **) &desc);'
p9643
assg41
(I1
I63
tp9644
sssssS'CVE-2018-20511'
p9645
(dp9646
(S'drivers/net/appletalk/ipddp.c'
p9647
S'ipddp_ioctl'
p9648
tp9649
(dp9650
S'static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp) {\n\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n\t\t\t\trcp2.ip    = rp->ip;\n\t\t\t\trcp2.at    = rp->at;\n\t\t\t\trcp2.flags = rp->flags;\n\t\t\t}\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}'
p9651
(dp9652
((g9647
g9648
tp9653
I1
tp9654
(dp9655
g12
g13
sg14
(dp9656
(I20
I25
tp9657
(lp9658
S'\t\t\tif (rp) {'
p9659
aS'\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));'
p9660
aS'\t\t\t\trcp2.ip    = rp->ip;'
p9661
aS'\t\t\t\trcp2.at    = rp->at;'
p9662
aS'\t\t\t\trcp2.flags = rp->flags;'
p9663
aS'\t\t\t}'
p9664
assg32
I3
sg33
(dp9665
(I20
I21
tp9666
(lp9667
S'\t\t\tif (rp)'
p9668
aS'\t\t\t\tmemcpy(&rcp2, rp, sizeof(rcp2));'
p9669
assg41
(I1
I42
tp9670
sssssS'CVE-2019-2293'
p9671
(dp9672
(S'drivers/media/platform/msm/camera/cam_isp/isp_hw_mgr/cam_ife_hw_mgr.c'
p9673
S'cam_ife_mgr_acquire_hw'
p9674
tp9675
(dp9676
S'static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)\n{\n\tstruct cam_ife_hw_mgr *ife_hw_mgr            = hw_mgr_priv;\n\tstruct cam_hw_acquire_args *acquire_args     = acquire_hw_args;\n\tint rc                                       = -1;\n\tint i, j;\n\tstruct cam_ife_hw_mgr_ctx         *ife_ctx;\n\tstruct cam_isp_in_port_info       *in_port = NULL;\n\tstruct cam_cdm_acquire_data        cdm_acquire;\n\tuint32_t                           num_pix_port_per_in = 0;\n\tuint32_t                           num_rdi_port_per_in = 0;\n\tuint32_t                           total_pix_port = 0;\n\tuint32_t                           total_rdi_port = 0;\n\tuint32_t                           in_port_length = 0;\n\tuint32_t                           total_in_port_length = 0;\n\tstruct cam_isp_acquire_hw_info    *acquire_hw_info = NULL;\n\n\tCAM_DBG(CAM_ISP, "Enter...");\n\n\tif (!acquire_args || acquire_args->num_acq <= 0) {\n\t\tCAM_ERR(CAM_ISP, "Nothing to acquire. Seems like error");\n\t\treturn -EINVAL;\n\t}\n\n\t/* get the ife ctx */\n\trc = cam_ife_hw_mgr_get_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\n\tif (rc || !ife_ctx) {\n\t\tCAM_ERR(CAM_ISP, "Get ife hw context failed");\n\t\tgoto err;\n\t}\n\n\tife_ctx->common.cb_priv = acquire_args->context_data;\n\tfor (i = 0; i < CAM_ISP_HW_EVENT_MAX; i++)\n\t\tife_ctx->common.event_cb[i] = acquire_args->event_cb;\n\n\tife_ctx->hw_mgr = ife_hw_mgr;\n\n\n\tmemcpy(cdm_acquire.identifier, "ife", sizeof("ife"));\n\tcdm_acquire.cell_index = 0;\n\tcdm_acquire.handle = 0;\n\tcdm_acquire.userdata = ife_ctx;\n\tcdm_acquire.base_array_cnt = CAM_IFE_HW_NUM_MAX;\n\tfor (i = 0, j = 0; i < CAM_IFE_HW_NUM_MAX; i++) {\n\t\tif (ife_hw_mgr->cdm_reg_map[i])\n\t\t\tcdm_acquire.base_array[j++] =\n\t\t\t\tife_hw_mgr->cdm_reg_map[i];\n\t}\n\tcdm_acquire.base_array_cnt = j;\n\n\n\tcdm_acquire.id = CAM_CDM_VIRTUAL;\n\tcdm_acquire.cam_cdm_callback = cam_ife_cam_cdm_callback;\n\trc = cam_cdm_acquire(&cdm_acquire);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Failed to acquire the CDM HW");\n\t\tgoto free_ctx;\n\t}\n\n\tCAM_DBG(CAM_ISP, "Successfully acquired the CDM HW hdl=%x",\n\t\tcdm_acquire.handle);\n\tife_ctx->cdm_handle = cdm_acquire.handle;\n\tife_ctx->cdm_ops = cdm_acquire.ops;\n\n\tacquire_hw_info =\n\t\t(struct cam_isp_acquire_hw_info *)acquire_args->acquire_info;\n\tin_port = (struct cam_isp_in_port_info *)\n\t\t((uint8_t *)&acquire_hw_info->data +\n\t\t acquire_hw_info->input_info_offset);\n\n\t/* acquire HW resources */\n\tfor (i = 0; i < acquire_hw_info->num_inputs; i++) {\n\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +\n\t\t\t(in_port->num_out_res - 1) *\n\t\t\tsizeof(struct cam_isp_out_port_info);\n\t\ttotal_in_port_length += in_port_length;\n\n\t\tif (total_in_port_length > acquire_hw_info->input_info_size) {\n\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_res;\n\t\t}\n\t\trc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,\n\t\t\t&num_pix_port_per_in, &num_rdi_port_per_in);\n\t\ttotal_pix_port += num_pix_port_per_in;\n\t\ttotal_rdi_port += num_rdi_port_per_in;\n\n\t\tif (rc) {\n\t\t\tCAM_ERR(CAM_ISP, "can not acquire resource");\n\t\t\tgoto free_res;\n\t\t}\n\t\tin_port = (struct cam_isp_in_port_info *)((uint8_t *)in_port +\n\t\t\tin_port_length);\n\t}\n\n\t/* Check whether context has only RDI resource */\n\tif (!total_pix_port) {\n\t\tife_ctx->is_rdi_only_context = 1;\n\t\tCAM_DBG(CAM_ISP, "RDI only context");\n\t}\n\n\t/* Process base info */\n\trc = cam_ife_mgr_process_base_info(ife_ctx);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Process base info failed");\n\t\tgoto free_res;\n\t}\n\n\tacquire_args->ctxt_to_hw_map = ife_ctx;\n\tife_ctx->ctx_in_use = 1;\n\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->used_ctx_list, &ife_ctx);\n\n\tCAM_DBG(CAM_ISP, "Exit...(success)");\n\n\treturn 0;\nfree_res:\n\tcam_ife_hw_mgr_release_hw_for_ctx(ife_ctx);\n\tcam_cdm_release(ife_ctx->cdm_handle);\nfree_ctx:\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\nerr:\n\tCAM_DBG(CAM_ISP, "Exit...(rc=%d)", rc);\n\treturn rc;\n}'
p9677
(dp9678
((g9673
g9674
tp9679
I1
tp9680
(dp9681
g12
g13
sg14
(dp9682
(I65
I69
tp9683
(lp9684
S'\tacquire_hw_info ='
p9685
aS'\t\t(struct cam_isp_acquire_hw_info *)acquire_args->acquire_info;'
p9686
aS'\tin_port = (struct cam_isp_in_port_info *)'
p9687
aS'\t\t((uint8_t *)&acquire_hw_info->data +'
p9688
aS'\t\t acquire_hw_info->input_info_offset);'
p9689
as(I72
I80
tp9690
(lp9691
S'\tfor (i = 0; i < acquire_hw_info->num_inputs; i++) {'
p9692
aS'\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +'
p9693
aS'\t\t\t(in_port->num_out_res - 1) *'
p9694
aS'\t\t\tsizeof(struct cam_isp_out_port_info);'
p9695
aS'\t\ttotal_in_port_length += in_port_length;'
p9696
ag59
aS'\t\tif (total_in_port_length > acquire_hw_info->input_info_size) {'
p9697
aS'\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9698
aS'\t\t\trc = -EINVAL;'
p9699
as(I83
I93
tp9700
(lp9701
S'\t\trc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,'
p9702
aS'\t\t\t&num_pix_port_per_in, &num_rdi_port_per_in);'
p9703
aS'\t\ttotal_pix_port += num_pix_port_per_in;'
p9704
aS'\t\ttotal_rdi_port += num_rdi_port_per_in;'
p9705
ag59
aS'\t\tif (rc) {'
p9706
aS'\t\t\tCAM_ERR(CAM_ISP, "can not acquire resource");'
p9707
aS'\t\t\tgoto free_res;'
p9708
aS'\t\t}'
p9709
aS'\t\tin_port = (struct cam_isp_in_port_info *)((uint8_t *)in_port +'
p9710
aS'\t\t\tin_port_length);'
p9711
as(I1
I1
tp9712
(lp9713
S'static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv, void *acquire_hw_args)'
p9714
as(I14
I16
tp9715
(lp9716
S'\tuint32_t                           in_port_length = 0;'
p9717
aS'\tuint32_t                           total_in_port_length = 0;'
p9718
aS'\tstruct cam_isp_acquire_hw_info    *acquire_hw_info = NULL;'
p9719
assg32
I2
sg33
(dp9720
(I1
I2
tp9721
(lp9722
S'static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv,'
p9723
aS'\t\t\t\t\tvoid *acquire_hw_args)'
p9724
as(I72
I98
tp9725
(lp9726
S'\tfor (i = 0; i < acquire_args->num_acq; i++) {'
p9727
aS'\t\tif (isp_resource[i].resource_id != CAM_ISP_RES_ID_PORT)'
p9728
aS'\t\t\tcontinue;'
p9729
ag59
aS'\t\tCAM_DBG(CAM_ISP,'
p9730
aS'\t\t\t"start copy from user handle %lld with len = %d",'
p9731
aS'\t\t\tisp_resource[i].res_hdl,'
p9732
aS'\t\t\tisp_resource[i].length);'
p9733
ag59
aS'\t\tin_port = memdup_user((void __user *)isp_resource[i].res_hdl,'
p9734
aS'\t\t\tisp_resource[i].length);'
p9735
aS'\t\tif (!IS_ERR(in_port)) {'
p9736
aS'\t\t\trc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,'
p9737
aS'\t\t\t\t&num_pix_port_per_in, &num_rdi_port_per_in);'
p9738
aS'\t\t\ttotal_pix_port += num_pix_port_per_in;'
p9739
aS'\t\t\ttotal_rdi_port += num_rdi_port_per_in;'
p9740
ag59
aS'\t\t\tkfree(in_port);'
p9741
aS'\t\t\tif (rc) {'
p9742
aS'\t\t\t\tCAM_ERR(CAM_ISP, "can not acquire resource");'
p9743
aS'\t\t\t\tgoto free_res;'
p9744
aS'\t\t\t}'
p9745
aS'\t\t} else {'
p9746
aS'\t\t\tCAM_ERR(CAM_ISP,'
p9747
aS'\t\t\t\t"Copy from user failed with in_port = %pK",'
p9748
aS'\t\t\t\tin_port);'
p9749
aS'\t\t\trc = -EFAULT;'
p9750
as(I9
I9
tp9751
(lp9752
S'\tstruct cam_isp_resource           *isp_resource = NULL;'
p9753
as(I65
I65
tp9754
(lp9755
S'\tisp_resource = (struct cam_isp_resource *)acquire_args->acquire_info;'
p9756
assg41
(I1
I125
tp9757
sssS'static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv,\n\t\t\t\t\tvoid *acquire_hw_args)\n{\n\tstruct cam_ife_hw_mgr *ife_hw_mgr            = hw_mgr_priv;\n\tstruct cam_hw_acquire_args *acquire_args     = acquire_hw_args;\n\tint rc                                       = -1;\n\tint i, j;\n\tstruct cam_ife_hw_mgr_ctx         *ife_ctx;\n\tstruct cam_isp_in_port_info       *in_port = NULL;\n\tstruct cam_isp_resource           *isp_resource = NULL;\n\tstruct cam_cdm_acquire_data        cdm_acquire;\n\tuint32_t                           num_pix_port_per_in = 0;\n\tuint32_t                           num_rdi_port_per_in = 0;\n\tuint32_t                           total_pix_port = 0;\n\tuint32_t                           total_rdi_port = 0;\n\tuint32_t                           in_port_length = 0;\n\n\tCAM_DBG(CAM_ISP, "Enter...");\n\n\tif (!acquire_args || acquire_args->num_acq <= 0) {\n\t\tCAM_ERR(CAM_ISP, "Nothing to acquire. Seems like error");\n\t\treturn -EINVAL;\n\t}\n\n\t/* get the ife ctx */\n\trc = cam_ife_hw_mgr_get_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\n\tif (rc || !ife_ctx) {\n\t\tCAM_ERR(CAM_ISP, "Get ife hw context failed");\n\t\tgoto err;\n\t}\n\n\tife_ctx->common.cb_priv = acquire_args->context_data;\n\tfor (i = 0; i < CAM_ISP_HW_EVENT_MAX; i++)\n\t\tife_ctx->common.event_cb[i] = acquire_args->event_cb;\n\n\tife_ctx->hw_mgr = ife_hw_mgr;\n\n\n\tmemcpy(cdm_acquire.identifier, "ife", sizeof("ife"));\n\tcdm_acquire.cell_index = 0;\n\tcdm_acquire.handle = 0;\n\tcdm_acquire.userdata = ife_ctx;\n\tcdm_acquire.base_array_cnt = CAM_IFE_HW_NUM_MAX;\n\tfor (i = 0, j = 0; i < CAM_IFE_HW_NUM_MAX; i++) {\n\t\tif (ife_hw_mgr->cdm_reg_map[i])\n\t\t\tcdm_acquire.base_array[j++] =\n\t\t\t\tife_hw_mgr->cdm_reg_map[i];\n\t}\n\tcdm_acquire.base_array_cnt = j;\n\n\n\tcdm_acquire.id = CAM_CDM_VIRTUAL;\n\tcdm_acquire.cam_cdm_callback = cam_ife_cam_cdm_callback;\n\trc = cam_cdm_acquire(&cdm_acquire);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Failed to acquire the CDM HW");\n\t\tgoto free_ctx;\n\t}\n\n\tCAM_DBG(CAM_ISP, "Successfully acquired the CDM HW hdl=%x",\n\t\tcdm_acquire.handle);\n\tife_ctx->cdm_handle = cdm_acquire.handle;\n\tife_ctx->cdm_ops = cdm_acquire.ops;\n\n\tisp_resource = (struct cam_isp_resource *)acquire_args->acquire_info;\n\n\t/* acquire HW resources */\n\tfor (i = 0; i < acquire_args->num_acq; i++) {\n\t\tif (isp_resource[i].resource_id != CAM_ISP_RES_ID_PORT)\n\t\t\tcontinue;\n\n\t\tCAM_DBG(CAM_ISP,\n\t\t\t"start copy from user handle %lld with len = %d",\n\t\t\tisp_resource[i].res_hdl,\n\t\t\tisp_resource[i].length);\n\n\t\tin_port_length = sizeof(struct cam_isp_in_port_info);\n\n\t\tif (in_port_length > isp_resource[i].length) {\n\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_res;\n\t\t}\n\n\t\tin_port = memdup_user(\n\t\t\tu64_to_user_ptr(isp_resource[i].res_hdl),\n\t\t\tisp_resource[i].length);\n\t\tif (!IS_ERR(in_port)) {\n\t\t\tif (in_port->num_out_res > CAM_IFE_HW_OUT_RES_MAX) {\n\t\t\t\tCAM_ERR(CAM_ISP, "too many output res %d",\n\t\t\t\t\tin_port->num_out_res);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tkfree(in_port);\n\t\t\t\tgoto free_res;\n\t\t\t}\n\n\t\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +\n\t\t\t\t(in_port->num_out_res - 1) *\n\t\t\t\tsizeof(struct cam_isp_out_port_info);\n\t\t\tif (in_port_length > isp_resource[i].length) {\n\t\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tkfree(in_port);\n\t\t\t\tgoto free_res;\n\t\t\t}\n\n\t\t\trc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,\n\t\t\t\t&num_pix_port_per_in, &num_rdi_port_per_in);\n\t\t\ttotal_pix_port += num_pix_port_per_in;\n\t\t\ttotal_rdi_port += num_rdi_port_per_in;\n\n\t\t\tkfree(in_port);\n\t\t\tif (rc) {\n\t\t\t\tCAM_ERR(CAM_ISP, "can not acquire resource");\n\t\t\t\tgoto free_res;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_ISP,\n\t\t\t\t"Copy from user failed with in_port = %pK",\n\t\t\t\tin_port);\n\t\t\trc = -EFAULT;\n\t\t\tgoto free_res;\n\t\t}\n\t}\n\n\t/* Check whether context has only RDI resource */\n\tif (!total_pix_port) {\n\t\tife_ctx->is_rdi_only_context = 1;\n\t\tCAM_DBG(CAM_ISP, "RDI only context");\n\t}\n\n\t/* Process base info */\n\trc = cam_ife_mgr_process_base_info(ife_ctx);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Process base info failed");\n\t\tgoto free_res;\n\t}\n\n\tacquire_args->ctxt_to_hw_map = ife_ctx;\n\tife_ctx->ctx_in_use = 1;\n\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->used_ctx_list, &ife_ctx);\n\n\tCAM_DBG(CAM_ISP, "Exit...(success)");\n\n\treturn 0;\nfree_res:\n\tcam_ife_hw_mgr_release_hw_for_ctx(ife_ctx);\n\tcam_cdm_release(ife_ctx->cdm_handle);\nfree_ctx:\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\nerr:\n\tCAM_DBG(CAM_ISP, "Exit...(rc=%d)", rc);\n\treturn rc;\n}'
p9758
(dp9759
((g9673
g9674
tp9760
I1
tp9761
(dp9762
g33
(dp9763
(I77
I77
tp9764
(lp9765
S'\t\tin_port = memdup_user((void __user *)isp_resource[i].res_hdl,'
p9766
assg14
(dp9767
(I77
I86
tp9768
(lp9769
S'\t\tin_port_length = sizeof(struct cam_isp_in_port_info);'
p9770
ag59
aS'\t\tif (in_port_length > isp_resource[i].length) {'
p9771
aS'\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9772
aS'\t\t\trc = -EINVAL;'
p9773
aS'\t\t\tgoto free_res;'
p9774
aS'\t\t}'
p9775
ag59
aS'\t\tin_port = memdup_user('
p9776
aS'\t\t\tu64_to_user_ptr(isp_resource[i].res_hdl),'
p9777
as(I89
I106
tp9778
(lp9779
S'\t\t\tif (in_port->num_out_res > CAM_IFE_HW_OUT_RES_MAX) {'
p9780
aS'\t\t\t\tCAM_ERR(CAM_ISP, "too many output res %d",'
p9781
aS'\t\t\t\t\tin_port->num_out_res);'
p9782
aS'\t\t\t\trc = -EINVAL;'
p9783
aS'\t\t\t\tkfree(in_port);'
p9784
aS'\t\t\t\tgoto free_res;'
p9785
aS'\t\t\t}'
p9786
ag59
aS'\t\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +'
p9787
aS'\t\t\t\t(in_port->num_out_res - 1) *'
p9788
aS'\t\t\t\tsizeof(struct cam_isp_out_port_info);'
p9789
aS'\t\t\tif (in_port_length > isp_resource[i].length) {'
p9790
aS'\t\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9791
aS'\t\t\t\trc = -EINVAL;'
p9792
aS'\t\t\t\tkfree(in_port);'
p9793
aS'\t\t\t\tgoto free_res;'
p9794
aS'\t\t\t}'
p9795
ag59
as(I16
I16
tp9796
(lp9797
S'\tuint32_t                           in_port_length = 0;'
p9798
assg32
I2
sg12
g13
sg41
(I1
I155
tp9799
sssS'static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv,\n\t\t\t\t\tvoid *acquire_hw_args)\n{\n\tstruct cam_ife_hw_mgr *ife_hw_mgr            = hw_mgr_priv;\n\tstruct cam_hw_acquire_args *acquire_args     = acquire_hw_args;\n\tint rc                                       = -1;\n\tint i, j;\n\tstruct cam_ife_hw_mgr_ctx         *ife_ctx;\n\tstruct cam_isp_in_port_info       *in_port = NULL;\n\tstruct cam_isp_resource           *isp_resource = NULL;\n\tstruct cam_cdm_acquire_data        cdm_acquire;\n\tuint32_t                           num_pix_port_per_in = 0;\n\tuint32_t                           num_rdi_port_per_in = 0;\n\tuint32_t                           total_pix_port = 0;\n\tuint32_t                           total_rdi_port = 0;\n\tuint32_t                           in_port_length = 0;\n\n\tCAM_DBG(CAM_ISP, "Enter...");\n\n\tif (!acquire_args || acquire_args->num_acq <= 0) {\n\t\tCAM_ERR(CAM_ISP, "Nothing to acquire. Seems like error");\n\t\treturn -EINVAL;\n\t}\n\n\t/* get the ife ctx */\n\trc = cam_ife_hw_mgr_get_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\n\tif (rc || !ife_ctx) {\n\t\tCAM_ERR(CAM_ISP, "Get ife hw context failed");\n\t\tgoto err;\n\t}\n\n\tife_ctx->common.cb_priv = acquire_args->context_data;\n\tfor (i = 0; i < CAM_ISP_HW_EVENT_MAX; i++)\n\t\tife_ctx->common.event_cb[i] = acquire_args->event_cb;\n\n\tife_ctx->hw_mgr = ife_hw_mgr;\n\n\n\tmemcpy(cdm_acquire.identifier, "ife", sizeof("ife"));\n\tcdm_acquire.cell_index = 0;\n\tcdm_acquire.handle = 0;\n\tcdm_acquire.userdata = ife_ctx;\n\tcdm_acquire.base_array_cnt = CAM_IFE_HW_NUM_MAX;\n\tfor (i = 0, j = 0; i < CAM_IFE_HW_NUM_MAX; i++) {\n\t\tif (ife_hw_mgr->cdm_reg_map[i])\n\t\t\tcdm_acquire.base_array[j++] =\n\t\t\t\tife_hw_mgr->cdm_reg_map[i];\n\t}\n\tcdm_acquire.base_array_cnt = j;\n\n\n\tcdm_acquire.id = CAM_CDM_VIRTUAL;\n\tcdm_acquire.cam_cdm_callback = cam_ife_cam_cdm_callback;\n\trc = cam_cdm_acquire(&cdm_acquire);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Failed to acquire the CDM HW");\n\t\tgoto free_ctx;\n\t}\n\n\tCAM_DBG(CAM_ISP, "Successfully acquired the CDM HW hdl=%x",\n\t\tcdm_acquire.handle);\n\tife_ctx->cdm_handle = cdm_acquire.handle;\n\tife_ctx->cdm_ops = cdm_acquire.ops;\n\n\tisp_resource = (struct cam_isp_resource *)acquire_args->acquire_info;\n\n\t/* acquire HW resources */\n\tfor (i = 0; i < acquire_args->num_acq; i++) {\n\t\tif (isp_resource[i].resource_id != CAM_ISP_RES_ID_PORT)\n\t\t\tcontinue;\n\n\t\tCAM_DBG(CAM_ISP,\n\t\t\t"start copy from user handle %lld with len = %d",\n\t\t\tisp_resource[i].res_hdl,\n\t\t\tisp_resource[i].length);\n\n\t\tin_port_length = sizeof(struct cam_isp_in_port_info);\n\n\t\tif (in_port_length > isp_resource[i].length) {\n\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_res;\n\t\t}\n\n\t\tin_port = memdup_user(\n\t\t\tu64_to_user_ptr(isp_resource[i].res_hdl),\n\t\t\tisp_resource[i].length);\n\t\tif (!IS_ERR(in_port)) {\n\t\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +\n\t\t\t\t(in_port->num_out_res - 1) *\n\t\t\t\tsizeof(struct cam_isp_out_port_info);\n\t\t\tif (in_port_length > isp_resource[i].length) {\n\t\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tkfree(in_port);\n\t\t\t\tgoto free_res;\n\t\t\t}\n\n\t\t\trc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,\n\t\t\t\t&num_pix_port_per_in, &num_rdi_port_per_in);\n\t\t\ttotal_pix_port += num_pix_port_per_in;\n\t\t\ttotal_rdi_port += num_rdi_port_per_in;\n\n\t\t\tkfree(in_port);\n\t\t\tif (rc) {\n\t\t\t\tCAM_ERR(CAM_ISP, "can not acquire resource");\n\t\t\t\tgoto free_res;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_ISP,\n\t\t\t\t"Copy from user failed with in_port = %pK",\n\t\t\t\tin_port);\n\t\t\trc = -EFAULT;\n\t\t\tgoto free_res;\n\t\t}\n\t}\n\n\t/* Check whether context has only RDI resource */\n\tif (!total_pix_port) {\n\t\tife_ctx->is_rdi_only_context = 1;\n\t\tCAM_DBG(CAM_ISP, "RDI only context");\n\t}\n\n\t/* Process base info */\n\trc = cam_ife_mgr_process_base_info(ife_ctx);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Process base info failed");\n\t\tgoto free_res;\n\t}\n\n\tacquire_args->ctxt_to_hw_map = ife_ctx;\n\tife_ctx->ctx_in_use = 1;\n\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->used_ctx_list, &ife_ctx);\n\n\tCAM_DBG(CAM_ISP, "Exit...(success)");\n\n\treturn 0;\nfree_res:\n\tcam_ife_hw_mgr_release_hw_for_ctx(ife_ctx);\n\tcam_cdm_release(ife_ctx->cdm_handle);\nfree_ctx:\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\nerr:\n\tCAM_DBG(CAM_ISP, "Exit...(rc=%d)", rc);\n\treturn rc;\n}'
p9800
(dp9801
((g9673
g9674
tp9802
I1
tp9803
(dp9804
g33
(dp9805
(I77
I77
tp9806
(lp9807
S'\t\tin_port = memdup_user((void __user *)isp_resource[i].res_hdl,'
p9808
assg14
(dp9809
(I77
I86
tp9810
(lp9811
S'\t\tin_port_length = sizeof(struct cam_isp_in_port_info);'
p9812
ag59
aS'\t\tif (in_port_length > isp_resource[i].length) {'
p9813
aS'\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9814
aS'\t\t\trc = -EINVAL;'
p9815
aS'\t\t\tgoto free_res;'
p9816
aS'\t\t}'
p9817
ag59
aS'\t\tin_port = memdup_user('
p9818
aS'\t\t\tu64_to_user_ptr(isp_resource[i].res_hdl),'
p9819
as(I89
I98
tp9820
(lp9821
S'\t\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +'
p9822
aS'\t\t\t\t(in_port->num_out_res - 1) *'
p9823
aS'\t\t\t\tsizeof(struct cam_isp_out_port_info);'
p9824
aS'\t\t\tif (in_port_length > isp_resource[i].length) {'
p9825
aS'\t\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9826
aS'\t\t\t\trc = -EINVAL;'
p9827
aS'\t\t\t\tkfree(in_port);'
p9828
aS'\t\t\t\tgoto free_res;'
p9829
aS'\t\t\t}'
p9830
ag59
as(I16
I16
tp9831
(lp9832
S'\tuint32_t                           in_port_length = 0;'
p9833
assg32
I2
sg12
g13
sg41
(I1
I147
tp9834
sssS'static int cam_ife_mgr_acquire_hw(void *hw_mgr_priv,\n\t\t\t\t\tvoid *acquire_hw_args)\n{\n\tstruct cam_ife_hw_mgr *ife_hw_mgr            = hw_mgr_priv;\n\tstruct cam_hw_acquire_args *acquire_args     = acquire_hw_args;\n\tint rc                                       = -1;\n\tint i, j;\n\tstruct cam_ife_hw_mgr_ctx         *ife_ctx;\n\tstruct cam_isp_in_port_info       *in_port = NULL;\n\tstruct cam_isp_resource           *isp_resource = NULL;\n\tstruct cam_cdm_acquire_data        cdm_acquire;\n\tuint32_t                           num_pix_port_per_in = 0;\n\tuint32_t                           num_rdi_port_per_in = 0;\n\tuint32_t                           total_pix_port = 0;\n\tuint32_t                           total_rdi_port = 0;\n\tuint32_t                           in_port_length = 0;\n\n\tCAM_DBG(CAM_ISP, "Enter...");\n\n\tif (!acquire_args || acquire_args->num_acq <= 0) {\n\t\tCAM_ERR(CAM_ISP, "Nothing to acquire. Seems like error");\n\t\treturn -EINVAL;\n\t}\n\n\t/* get the ife ctx */\n\trc = cam_ife_hw_mgr_get_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\n\tif (rc || !ife_ctx) {\n\t\tCAM_ERR(CAM_ISP, "Get ife hw context failed");\n\t\tgoto err;\n\t}\n\n\tife_ctx->common.cb_priv = acquire_args->context_data;\n\tfor (i = 0; i < CAM_ISP_HW_EVENT_MAX; i++)\n\t\tife_ctx->common.event_cb[i] = acquire_args->event_cb;\n\n\tife_ctx->hw_mgr = ife_hw_mgr;\n\n\n\tmemcpy(cdm_acquire.identifier, "ife", sizeof("ife"));\n\tcdm_acquire.cell_index = 0;\n\tcdm_acquire.handle = 0;\n\tcdm_acquire.userdata = ife_ctx;\n\tcdm_acquire.base_array_cnt = CAM_IFE_HW_NUM_MAX;\n\tfor (i = 0, j = 0; i < CAM_IFE_HW_NUM_MAX; i++) {\n\t\tif (ife_hw_mgr->cdm_reg_map[i])\n\t\t\tcdm_acquire.base_array[j++] =\n\t\t\t\tife_hw_mgr->cdm_reg_map[i];\n\t}\n\tcdm_acquire.base_array_cnt = j;\n\n\n\tcdm_acquire.id = CAM_CDM_VIRTUAL;\n\tcdm_acquire.cam_cdm_callback = cam_ife_cam_cdm_callback;\n\trc = cam_cdm_acquire(&cdm_acquire);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Failed to acquire the CDM HW");\n\t\tgoto free_ctx;\n\t}\n\n\tCAM_DBG(CAM_ISP, "Successfully acquired the CDM HW hdl=%x",\n\t\tcdm_acquire.handle);\n\tife_ctx->cdm_handle = cdm_acquire.handle;\n\tife_ctx->cdm_ops = cdm_acquire.ops;\n\n\tisp_resource = (struct cam_isp_resource *)acquire_args->acquire_info;\n\n\t/* acquire HW resources */\n\tfor (i = 0; i < acquire_args->num_acq; i++) {\n\t\tif (isp_resource[i].resource_id != CAM_ISP_RES_ID_PORT)\n\t\t\tcontinue;\n\n\t\tCAM_DBG(CAM_ISP,\n\t\t\t"start copy from user handle %lld with len = %d",\n\t\t\tisp_resource[i].res_hdl,\n\t\t\tisp_resource[i].length);\n\n\t\tin_port_length = sizeof(struct cam_isp_in_port_info);\n\n\t\tif (in_port_length > isp_resource[i].length) {\n\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_res;\n\t\t}\n\n\t\tin_port = memdup_user((void __user *)isp_resource[i].res_hdl,\n\t\t\tisp_resource[i].length);\n\t\tif (!IS_ERR(in_port)) {\n\t\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +\n\t\t\t\t(in_port->num_out_res - 1) *\n\t\t\t\tsizeof(struct cam_isp_out_port_info);\n\t\t\tif (in_port_length > isp_resource[i].length) {\n\t\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");\n\t\t\t\trc = -EINVAL;\n\t\t\t\tkfree(in_port);\n\t\t\t\tgoto free_res;\n\t\t\t}\n\n\t\t\trc = cam_ife_mgr_acquire_hw_for_ctx(ife_ctx, in_port,\n\t\t\t\t&num_pix_port_per_in, &num_rdi_port_per_in);\n\t\t\ttotal_pix_port += num_pix_port_per_in;\n\t\t\ttotal_rdi_port += num_rdi_port_per_in;\n\n\t\t\tkfree(in_port);\n\t\t\tif (rc) {\n\t\t\t\tCAM_ERR(CAM_ISP, "can not acquire resource");\n\t\t\t\tgoto free_res;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_ISP,\n\t\t\t\t"Copy from user failed with in_port = %pK",\n\t\t\t\tin_port);\n\t\t\trc = -EFAULT;\n\t\t\tgoto free_res;\n\t\t}\n\t}\n\n\t/* Check whether context has only RDI resource */\n\tif (!total_pix_port) {\n\t\tife_ctx->is_rdi_only_context = 1;\n\t\tCAM_DBG(CAM_ISP, "RDI only context");\n\t}\n\n\t/* Process base info */\n\trc = cam_ife_mgr_process_base_info(ife_ctx);\n\tif (rc) {\n\t\tCAM_ERR(CAM_ISP, "Process base info failed");\n\t\tgoto free_res;\n\t}\n\n\tacquire_args->ctxt_to_hw_map = ife_ctx;\n\tife_ctx->ctx_in_use = 1;\n\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->used_ctx_list, &ife_ctx);\n\n\tCAM_DBG(CAM_ISP, "Exit...(success)");\n\n\treturn 0;\nfree_res:\n\tcam_ife_hw_mgr_release_hw_for_ctx(ife_ctx);\n\tcam_cdm_release(ife_ctx->cdm_handle);\nfree_ctx:\n\tcam_ife_hw_mgr_put_ctx(&ife_hw_mgr->free_ctx_list, &ife_ctx);\nerr:\n\tCAM_DBG(CAM_ISP, "Exit...(rc=%d)", rc);\n\treturn rc;\n}'
p9835
(dp9836
((g9673
g9674
tp9837
I1
tp9838
(dp9839
g14
(dp9840
(I88
I97
tp9841
(lp9842
S'\t\t\tin_port_length = sizeof(struct cam_isp_in_port_info) +'
p9843
aS'\t\t\t\t(in_port->num_out_res - 1) *'
p9844
aS'\t\t\t\tsizeof(struct cam_isp_out_port_info);'
p9845
aS'\t\t\tif (in_port_length > isp_resource[i].length) {'
p9846
aS'\t\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9847
aS'\t\t\t\trc = -EINVAL;'
p9848
aS'\t\t\t\tkfree(in_port);'
p9849
aS'\t\t\t\tgoto free_res;'
p9850
aS'\t\t\t}'
p9851
ag59
as(I77
I84
tp9852
(lp9853
S'\t\tin_port_length = sizeof(struct cam_isp_in_port_info);'
p9854
ag59
aS'\t\tif (in_port_length > isp_resource[i].length) {'
p9855
aS'\t\t\tCAM_ERR(CAM_ISP, "buffer size is not enough");'
p9856
aS'\t\t\trc = -EINVAL;'
p9857
aS'\t\t\tgoto free_res;'
p9858
aS'\t\t}'
p9859
ag59
as(I16
I16
tp9860
(lp9861
S'\tuint32_t                           in_port_length = 0;'
p9862
assg32
I2
sg12
g13
sg41
(I1
I146
tp9863
sssssS'CVE-2019-14049'
p9864
(dp9865
(S'drivers/staging/android/ion/ion_cma_heap.c'
p9866
S'ion_secure_cma_map_user'
p9867
tp9868
(dp9869
s(S'drivers/staging/android/ion/ion_system_heap.c'
p9870
S'ion_heap_is_system_heap_type'
p9871
tp9872
(dp9873
s(g9870
S'ion_system_heap_allocate'
p9874
tp9875
(dp9876
S'static int ion_system_heap_allocate(struct ion_heap *heap,\n\t\t\t\t     struct ion_buffer *buffer,\n\t\t\t\t     unsigned long size, unsigned long align,\n\t\t\t\t     unsigned long flags)\n{\n\tstruct ion_system_heap *sys_heap = container_of(heap,\n\t\t\t\t\t\t\tstruct ion_system_heap,\n\t\t\t\t\t\t\theap);\n\tstruct sg_table *table;\n\tstruct sg_table table_sync = {0};\n\tstruct scatterlist *sg;\n\tstruct scatterlist *sg_sync;\n\tint ret;\n\tstruct list_head pages;\n\tstruct list_head pages_from_pool;\n\tstruct page_info *info, *tmp_info;\n\tint i = 0;\n\tunsigned int nents_sync = 0;\n\tunsigned long size_remaining = PAGE_ALIGN(size);\n\tunsigned int max_order = orders[0];\n\tstruct pages_mem data;\n\tunsigned int sz;\n\tint vmid = get_secure_vmid(buffer->flags);\n\tstruct device *dev = heap->priv;\n\n\tif (ion_heap_is_system_heap_type(buffer->heap->type) &&\n\t    is_secure_vmid_valid(vmid)) {\n\t\tpr_info("%s: System heap doesn\'t support secure allocations\\n",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (align > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (size / PAGE_SIZE > totalram_pages / 2)\n\t\treturn -ENOMEM;\n\n\tdata.size = 0;\n\tINIT_LIST_HEAD(&pages);\n\tINIT_LIST_HEAD(&pages_from_pool);\n\n\twhile (size_remaining > 0) {\n\t\tif (is_secure_vmid_valid(vmid))\n\t\t\tinfo = alloc_from_pool_preferred(\n\t\t\t\t\tsys_heap, buffer, size_remaining,\n\t\t\t\t\tmax_order);\n\t\telse\n\t\t\tinfo = alloc_largest_available(\n\t\t\t\t\tsys_heap, buffer, size_remaining,\n\t\t\t\t\tmax_order);\n\n\t\tif (!info)\n\t\t\tgoto err;\n\n\t\tsz = (1 << info->order) * PAGE_SIZE;\n\n\t\tif (info->from_pool) {\n\t\t\tlist_add_tail(&info->list, &pages_from_pool);\n\t\t} else {\n\t\t\tlist_add_tail(&info->list, &pages);\n\t\t\tdata.size += sz;\n\t\t\t++nents_sync;\n\t\t}\n\t\tsize_remaining -= sz;\n\t\tmax_order = info->order;\n\t\ti++;\n\t}\n\n\tret = msm_ion_heap_alloc_pages_mem(&data);\n\n\tif (ret)\n\t\tgoto err;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto err_free_data_pages;\n\n\tret = sg_alloc_table(table, i, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err1;\n\n\tif (nents_sync) {\n\t\tret = sg_alloc_table(&table_sync, nents_sync, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto err_free_sg;\n\t}\n\n\ti = 0;\n\tsg = table->sgl;\n\tsg_sync = table_sync.sgl;\n\n\t/*\n\t * We now have two separate lists. One list contains pages from the\n\t * pool and the other pages from buddy. We want to merge these\n\t * together while preserving the ordering of the pages (higher order\n\t * first).\n\t */\n\tdo {\n\t\tinfo = list_first_entry_or_null(&pages, struct page_info, list);\n\t\ttmp_info = list_first_entry_or_null(&pages_from_pool,\n\t\t\t\t\t\t    struct page_info, list);\n\t\tif (info && tmp_info) {\n\t\t\tif (info->order >= tmp_info->order) {\n\t\t\t\ti = process_info(info, sg, sg_sync, &data, i);\n\t\t\t\tsg_sync = sg_next(sg_sync);\n\t\t\t} else {\n\t\t\t\ti = process_info(tmp_info, sg, 0, 0, i);\n\t\t\t}\n\t\t} else if (info) {\n\t\t\ti = process_info(info, sg, sg_sync, &data, i);\n\t\t\tsg_sync = sg_next(sg_sync);\n\t\t} else if (tmp_info) {\n\t\t\ti = process_info(tmp_info, sg, 0, 0, i);\n\t\t}\n\t\tsg = sg_next(sg);\n\n\t} while (sg);\n\n\tret = msm_ion_heap_pages_zero(data.pages, data.size >> PAGE_SHIFT);\n\tif (ret) {\n\t\tpr_err("Unable to zero pages\\n");\n\t\tgoto err_free_sg2;\n\t}\n\n\tif (nents_sync) {\n\t\tdma_sync_sg_for_device(dev, table_sync.sgl, table_sync.nents,\n\t\t\t\t       DMA_BIDIRECTIONAL);\n\t\tif (vmid > 0) {\n\t\t\tret = ion_system_secure_heap_assign_sg(&table_sync,\n\t\t\t\t\t\t\t       vmid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_sg2;\n\t\t}\n\t}\n\n\tbuffer->priv_virt = table;\n\tif (nents_sync)\n\t\tsg_free_table(&table_sync);\n\tmsm_ion_heap_free_pages_mem(&data);\n\treturn 0;\n\nerr_free_sg2:\n\t/* We failed to zero buffers. Bypass pool */\n\tbuffer->private_flags |= ION_PRIV_FLAG_SHRINKER_FREE;\n\n\tif (vmid > 0)\n\t\tion_system_secure_heap_unassign_sg(table, vmid);\n\n\tfor_each_sg(table->sgl, sg, table->nents, i)\n\t\tfree_buffer_page(sys_heap, buffer, sg_page(sg),\n\t\t\t\t get_order(sg->length));\n\tif (nents_sync)\n\t\tsg_free_table(&table_sync);\nerr_free_sg:\n\tsg_free_table(table);\nerr1:\n\tkfree(table);\nerr_free_data_pages:\n\tmsm_ion_heap_free_pages_mem(&data);\nerr:\n\tlist_for_each_entry_safe(info, tmp_info, &pages, list) {\n\t\tfree_buffer_page(sys_heap, buffer, info->page, info->order);\n\t\tkfree(info);\n\t}\n\tlist_for_each_entry_safe(info, tmp_info, &pages_from_pool, list) {\n\t\tfree_buffer_page(sys_heap, buffer, info->page, info->order);\n\t\tkfree(info);\n\t}\n\treturn -ENOMEM;\n}'
p9877
(dp9878
((g9870
g9874
tp9879
I1
tp9880
(dp9881
g33
(dp9882
(I145
I145
tp9883
(lp9884
S'\tbuffer->flags |= ION_PRIV_FLAG_SHRINKER_FREE;'
p9885
assg14
(dp9886
(I26
I32
tp9887
(lp9888
S'\tif (ion_heap_is_system_heap_type(buffer->heap->type) &&'
p9889
aS'\t    is_secure_vmid_valid(vmid)) {'
p9890
aS'\t\tpr_info("%s: System heap doesn\'t support secure allocations\\n",'
p9891
aS'\t\t\t__func__);'
p9892
aS'\t\treturn -EINVAL;'
p9893
aS'\t}'
p9894
ag59
as(I145
I145
tp9895
(lp9896
S'\tbuffer->private_flags |= ION_PRIV_FLAG_SHRINKER_FREE;'
p9897
assg32
I5
sg12
g13
sg41
(I1
I171
tp9898
sssS'static int ion_system_heap_allocate(struct ion_heap *heap,\n\t\t\t\t     struct ion_buffer *buffer,\n\t\t\t\t     unsigned long size, unsigned long align,\n\t\t\t\t     unsigned long flags)\n{\n\tstruct ion_system_heap *sys_heap = container_of(heap,\n\t\t\t\t\t\t\tstruct ion_system_heap,\n\t\t\t\t\t\t\theap);\n\tstruct sg_table *table;\n\tstruct sg_table table_sync = {0};\n\tstruct scatterlist *sg;\n\tstruct scatterlist *sg_sync;\n\tint ret;\n\tstruct list_head pages;\n\tstruct list_head pages_from_pool;\n\tstruct page_info *info, *tmp_info;\n\tint i = 0;\n\tunsigned int nents_sync = 0;\n\tunsigned long size_remaining = PAGE_ALIGN(size);\n\tunsigned int max_order = orders[0];\n\tstruct pages_mem data;\n\tunsigned int sz;\n\tint vmid = get_secure_vmid(buffer->flags);\n\tstruct device *dev = heap->priv;\n\n\tif (ion_heap_is_system_heap_type(buffer->heap->type) &&\n\t    is_secure_vmid_valid(vmid)) {\n\t\tpr_info("%s: System heap doesn\'t support secure allocations\\n",\n\t\t\t__func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif (align > PAGE_SIZE)\n\t\treturn -EINVAL;\n\n\tif (size / PAGE_SIZE > totalram_pages / 2)\n\t\treturn -ENOMEM;\n\n\tdata.size = 0;\n\tINIT_LIST_HEAD(&pages);\n\tINIT_LIST_HEAD(&pages_from_pool);\n\n\twhile (size_remaining > 0) {\n\t\tif (is_secure_vmid_valid(vmid))\n\t\t\tinfo = alloc_from_pool_preferred(\n\t\t\t\t\tsys_heap, buffer, size_remaining,\n\t\t\t\t\tmax_order);\n\t\telse\n\t\t\tinfo = alloc_largest_available(\n\t\t\t\t\tsys_heap, buffer, size_remaining,\n\t\t\t\t\tmax_order);\n\n\t\tif (!info)\n\t\t\tgoto err;\n\n\t\tsz = (1 << info->order) * PAGE_SIZE;\n\n\t\tif (info->from_pool) {\n\t\t\tlist_add_tail(&info->list, &pages_from_pool);\n\t\t} else {\n\t\t\tlist_add_tail(&info->list, &pages);\n\t\t\tdata.size += sz;\n\t\t\t++nents_sync;\n\t\t}\n\t\tsize_remaining -= sz;\n\t\tmax_order = info->order;\n\t\ti++;\n\t}\n\n\tret = msm_ion_heap_alloc_pages_mem(&data);\n\n\tif (ret)\n\t\tgoto err;\n\n\ttable = kzalloc(sizeof(*table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto err_free_data_pages;\n\n\tret = sg_alloc_table(table, i, GFP_KERNEL);\n\tif (ret)\n\t\tgoto err1;\n\n\tif (nents_sync) {\n\t\tret = sg_alloc_table(&table_sync, nents_sync, GFP_KERNEL);\n\t\tif (ret)\n\t\t\tgoto err_free_sg;\n\t}\n\n\ti = 0;\n\tsg = table->sgl;\n\tsg_sync = table_sync.sgl;\n\n\t/*\n\t * We now have two separate lists. One list contains pages from the\n\t * pool and the other pages from buddy. We want to merge these\n\t * together while preserving the ordering of the pages (higher order\n\t * first).\n\t */\n\tdo {\n\t\tinfo = list_first_entry_or_null(&pages, struct page_info, list);\n\t\ttmp_info = list_first_entry_or_null(&pages_from_pool,\n\t\t\t\t\t\t    struct page_info, list);\n\t\tif (info && tmp_info) {\n\t\t\tif (info->order >= tmp_info->order) {\n\t\t\t\ti = process_info(info, sg, sg_sync, &data, i);\n\t\t\t\tsg_sync = sg_next(sg_sync);\n\t\t\t} else {\n\t\t\t\ti = process_info(tmp_info, sg, 0, 0, i);\n\t\t\t}\n\t\t} else if (info) {\n\t\t\ti = process_info(info, sg, sg_sync, &data, i);\n\t\t\tsg_sync = sg_next(sg_sync);\n\t\t} else if (tmp_info) {\n\t\t\ti = process_info(tmp_info, sg, 0, 0, i);\n\t\t}\n\t\tsg = sg_next(sg);\n\n\t} while (sg);\n\n\tret = msm_ion_heap_pages_zero(data.pages, data.size >> PAGE_SHIFT);\n\tif (ret) {\n\t\tpr_err("Unable to zero pages\\n");\n\t\tgoto err_free_sg2;\n\t}\n\n\tif (nents_sync) {\n\t\tdma_sync_sg_for_device(dev, table_sync.sgl, table_sync.nents,\n\t\t\t\t       DMA_BIDIRECTIONAL);\n\t\tif (vmid > 0) {\n\t\t\tret = ion_system_secure_heap_assign_sg(&table_sync,\n\t\t\t\t\t\t\t       vmid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_free_sg2;\n\t\t}\n\t}\n\n\tbuffer->priv_virt = table;\n\tif (nents_sync)\n\t\tsg_free_table(&table_sync);\n\tmsm_ion_heap_free_pages_mem(&data);\n\treturn 0;\n\nerr_free_sg2:\n\t/* We failed to zero buffers. Bypass pool */\n\tbuffer->flags |= ION_PRIV_FLAG_SHRINKER_FREE;\n\n\tif (vmid > 0)\n\t\tion_system_secure_heap_unassign_sg(table, vmid);\n\n\tfor_each_sg(table->sgl, sg, table->nents, i)\n\t\tfree_buffer_page(sys_heap, buffer, sg_page(sg),\n\t\t\t\t get_order(sg->length));\n\tif (nents_sync)\n\t\tsg_free_table(&table_sync);\nerr_free_sg:\n\tsg_free_table(table);\nerr1:\n\tkfree(table);\nerr_free_data_pages:\n\tmsm_ion_heap_free_pages_mem(&data);\nerr:\n\tlist_for_each_entry_safe(info, tmp_info, &pages, list) {\n\t\tfree_buffer_page(sys_heap, buffer, info->page, info->order);\n\t\tkfree(info);\n\t}\n\tlist_for_each_entry_safe(info, tmp_info, &pages_from_pool, list) {\n\t\tfree_buffer_page(sys_heap, buffer, info->page, info->order);\n\t\tkfree(info);\n\t}\n\treturn -ENOMEM;\n}'
p9899
(dp9900
((g9870
g9874
tp9901
I1
tp9902
(dp9903
g14
(dp9904
(I26
I32
tp9905
(lp9906
S'\tif (ion_heap_is_system_heap_type(buffer->heap->type) &&'
p9907
aS'\t    is_secure_vmid_valid(vmid)) {'
p9908
aS'\t\tpr_info("%s: System heap doesn\'t support secure allocations\\n",'
p9909
aS'\t\t\t__func__);'
p9910
aS'\t\treturn -EINVAL;'
p9911
aS'\t}'
p9912
ag59
assg32
I5
sg12
g13
sg41
(I1
I171
tp9913
ssss(g9866
S'ion_secure_cma_map_kernel'
p9914
tp9915
(dp9916
ssS'CVE-2019-10528'
p9917
(dp9918
(S'drivers/char/diag/diagfwd_peripheral.c'
p9919
S'diagfwd_data_read_done'
p9920
tp9921
(dp9922
S'static void diagfwd_data_read_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   unsigned char *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diagfwd_buf_t *temp_buf = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t\t   __func__, fwd_info->type,\n\t\t\t\t   fwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(fwd_info->peripheral);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (!driver->feature[fwd_info->peripheral].encode_hdlc) {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t\twrite_buf = fwd_info->buf_1->data;\n\t\t} else if (fwd_info->buf_2 && fwd_info->buf_2->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t\twrite_buf = fwd_info->buf_2->data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t} else if (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\twrite_buf = buf;\n\t} else {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = check_bufsize_for_encoding(temp_buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = temp_buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len, buf, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     temp_buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (temp_buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(temp_buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(temp_buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p9923
(dp9924
((g9919
g9920
tp9925
I1
tp9926
(dp9927
g33
(dp9928
(I36
I36
tp9929
(lp9930
g59
assg14
(dp9931
(I36
I36
tp9932
(lp9933
S'\tmutex_unlock(&driver->md_session_lock);'
p9934
as(I30
I30
tp9935
(lp9936
S'\tmutex_lock(&driver->md_session_lock);'
p9937
assg32
I3
sg12
g13
sg41
(I1
I124
tp9938
sssS'static void diagfwd_data_read_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   unsigned char *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diagfwd_buf_t *temp_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t\t   __func__, fwd_info->type,\n\t\t\t\t   fwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\thdlc_disabled = driver->p_hdlc_disabled[fwd_info->peripheral];\n\n\tif (!driver->feature[fwd_info->peripheral].encode_hdlc) {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t\twrite_buf = fwd_info->buf_1->data;\n\t\t} else if (fwd_info->buf_2 && fwd_info->buf_2->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t\twrite_buf = fwd_info->buf_2->data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t} else if (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\twrite_buf = buf;\n\t} else {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = check_bufsize_for_encoding(temp_buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = temp_buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len, buf, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     temp_buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end_write;\n\t\t}\n\t}\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\nend_write:\n\tdiag_ws_release();\n\tif (temp_buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(temp_buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(temp_buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p9939
(dp9940
((g9919
g9920
tp9941
I1
tp9942
(dp9943
g12
g13
sg14
(dp9944
(I29
I30
tp9945
(lp9946
g59
aS'\thdlc_disabled = driver->p_hdlc_disabled[fwd_info->peripheral];'
p9947
as(I110
I111
tp9948
(lp9949
S'end_write:'
p9950
aS'\tdiag_ws_release();'
p9951
as(I92
I94
tp9952
(lp9953
S'\tmutex_unlock(&fwd_info->data_mutex);'
p9954
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p9955
ag59
as(I101
I101
tp9956
(lp9957
S'\t\t\tgoto end_write;'
p9958
assg32
I3
sg33
(dp9959
(I104
I105
tp9960
(lp9961
S'\tmutex_unlock(&fwd_info->data_mutex);'
p9962
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p9963
as(I29
I33
tp9964
(lp9965
S'\tsession_info = diag_md_session_get_peripheral(fwd_info->peripheral);'
p9966
aS'\tif (session_info)'
p9967
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p9968
aS'\telse'
p9969
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p9970
as(I8
I8
tp9971
(lp9972
S'\tstruct diag_md_session_t *session_info = NULL;'
p9973
as(I101
I101
tp9974
(lp9975
S'\t\t\tgoto end;'
p9976
as(I108
I108
tp9977
(lp9978
S'\tdiag_ws_release();'
p9979
assg41
(I1
I121
tp9980
sssS'static void diagfwd_data_read_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   unsigned char *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diagfwd_buf_t *temp_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t\t   __func__, fwd_info->type,\n\t\t\t\t   fwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\thdlc_disabled = driver->p_hdlc_disabled[fwd_info->peripheral];\n\n\tif (!driver->feature[fwd_info->peripheral].encode_hdlc) {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t\twrite_buf = fwd_info->buf_1->data;\n\t\t} else if (fwd_info->buf_2 && fwd_info->buf_2->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t\twrite_buf = fwd_info->buf_2->data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t} else if (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\twrite_buf = buf;\n\t} else {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = check_bufsize_for_encoding(temp_buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = temp_buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len, buf, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     temp_buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (temp_buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(temp_buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(temp_buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p9981
(dp9982
((g9919
g9920
tp9983
I1
tp9984
(dp9985
g12
g13
sg14
(dp9986
(I29
I30
tp9987
(lp9988
g59
aS'\thdlc_disabled = driver->p_hdlc_disabled[fwd_info->peripheral];'
p9989
assg32
I3
sg33
(dp9990
(I29
I33
tp9991
(lp9992
S'\tsession_info = diag_md_session_get_peripheral(fwd_info->peripheral);'
p9993
aS'\tif (session_info)'
p9994
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p9995
aS'\telse'
p9996
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p9997
as(I8
I8
tp9998
(lp9999
S'\tstruct diag_md_session_t *session_info = NULL;'
p10000
assg41
(I1
I119
tp10001
ssss(S'drivers/char/diag/diagfwd.c'
p10002
S'diag_send_error_rsp'
p10003
tp10004
(dp10005
S'void diag_send_error_rsp(unsigned char *buf, int len,\n\t\t\tint pid)\n{\n\t/* -1 to accommodate the first byte 0x13 */\n\tif (len > (DIAG_MAX_RSP_SIZE - 1)) {\n\t\tpr_err("diag: cannot send err rsp, huge length: %d\\n", len);\n\t\treturn;\n\t}\n\n\t*(uint8_t *)driver->apps_rsp_buf = DIAG_CMD_ERROR;\n\tmemcpy((driver->apps_rsp_buf + sizeof(uint8_t)), buf, len);\n\tdiag_send_rsp(driver->apps_rsp_buf, len + 1, pid);\n}'
p10006
(dp10007
((g10002
g10003
tp10008
I1
tp10009
(dp10010
g12
g13
sg14
(dp10011
(I12
I12
tp10012
(lp10013
S'\tdiag_send_rsp(driver->apps_rsp_buf, len + 1, pid);'
p10014
as(I2
I2
tp10015
(lp10016
S'\t\t\tint pid)'
p10017
assg32
I3
sg33
(dp10018
(I12
I12
tp10019
(lp10020
S'\tdiag_send_rsp(driver->apps_rsp_buf, len + 1, info);'
p10021
as(I2
I2
tp10022
(lp10023
S'\t\t\tstruct diag_md_session_t *info)'
p10024
assg41
(I1
I13
tp10025
ssss(S'drivers/char/diag/diag_masks.c'
p10026
S'diag_cmd_get_build_mask'
p10027
tp10028
(dp10029
S'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p10030
(dp10031
((g10026
g10027
tp10032
I1
tp10033
(dp10034
g12
g13
sg14
(dp10035
(I2
I2
tp10036
(lp10037
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10038
assg32
I5
sg33
(dp10039
(I2
I3
tp10040
(lp10041
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p10042
aS'\t\t\t\t   struct diag_md_session_t *info)'
p10043
assg41
(I1
I52
tp10044
sssS'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr)\n\t\t\tcontinue;\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p10045
(dp10046
((g10026
g10027
tp10047
I1
tp10048
(dp10049
g12
g13
sg14
(dp10050
(I30
I31
tp10051
(lp10052
S'\t\tif (!build_mask->ptr)'
p10053
aS'\t\t\tcontinue;'
p10054
as(I2
I2
tp10055
(lp10056
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10057
assg32
I5
sg33
(dp10058
(I2
I3
tp10059
(lp10060
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p10061
aS'\t\t\t\t   struct diag_md_session_t *info)'
p10062
assg41
(I1
I54
tp10063
sssS'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t\tsrc_len < sizeof(struct diag_build_mask_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr)\n\t\t\tcontinue;\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p10064
(dp10065
((g10026
g10027
tp10066
I1
tp10067
(dp10068
g12
g13
sg14
(dp10069
(I12
I13
tp10070
(lp10071
S'\tif (!src_buf || !dest_buf || dest_len <= 0 ||'
p10072
aS'\t\tsrc_len < sizeof(struct diag_build_mask_req_t)) {'
p10073
as(I31
I32
tp10074
(lp10075
S'\t\tif (!build_mask->ptr)'
p10076
aS'\t\t\tcontinue;'
p10077
as(I2
I2
tp10078
(lp10079
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10080
assg32
I5
sg33
(dp10081
(I12
I12
tp10082
(lp10083
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {'
p10084
as(I2
I3
tp10085
(lp10086
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p10087
aS'\t\t\t\t   struct diag_md_session_t *info)'
p10088
assg41
(I1
I55
tp10089
sssS'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t\tsrc_len < sizeof(struct diag_build_mask_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr)\n\t\t\tcontinue;\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p10090
(dp10091
((g10026
g10027
tp10092
I1
tp10093
(dp10094
g12
g13
sg14
(dp10095
(I12
I13
tp10096
(lp10097
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p10098
aS'\t\tsrc_len < sizeof(struct diag_build_mask_req_t)) {'
p10099
as(I31
I32
tp10100
(lp10101
S'\t\tif (!build_mask->ptr)'
p10102
aS'\t\t\tcontinue;'
p10103
as(I2
I2
tp10104
(lp10105
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10106
assg32
I5
sg33
(dp10107
(I12
I12
tp10108
(lp10109
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {'
p10110
as(I2
I3
tp10111
(lp10112
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p10113
aS'\t\t\t\t   struct diag_md_session_t *info)'
p10114
assg41
(I1
I55
tp10115
ssss(S'drivers/char/diag/diagchar_core.c'
p10116
S'diagchar_read'
p10117
tp10118
(dp10119
S'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client)\n\t\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p10120
(dp10121
((g10116
g10117
tp10122
I1
tp10123
(dp10124
g33
(dp10125
(I71
I71
tp10126
(lp10127
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10128
as(I157
I157
tp10129
(lp10130
S'\t\tif (ret == -EFAULT)'
p10131
as(I140
I140
tp10132
(lp10133
S'\t\t\tif (ret == -EFAULT)'
p10134
as(I123
I123
tp10135
(lp10136
S'\t\tif (ret == -EFAULT)'
p10137
as(I258
I258
tp10138
(lp10139
S'\t\t\tif (entry->client->tgid != current->tgid)'
p10140
as(I126
I126
tp10141
(lp10142
g59
as(I49
I49
tp10143
(lp10144
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10145
as(I132
I132
tp10146
(lp10147
S'\t\t\tif (ret == -EFAULT)'
p10148
as(I103
I103
tp10149
(lp10150
S'\t\tif (ret == -EFAULT)'
p10151
as(I75
I75
tp10152
(lp10153
S'\t\t\tif (ret == -EFAULT)'
p10154
assg14
(dp10155
(I80
I80
tp10156
(lp10157
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10158
as(I51
I51
tp10159
(lp10160
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10161
as(I154
I154
tp10162
(lp10163
S'\t\tmutex_lock(&driver->md_session_lock);'
p10164
as(I157
I158
tp10165
(lp10166
S'\t\tif (ret == -EFAULT) {'
p10167
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10168
as(I126
I126
tp10169
(lp10170
S'\t\t}'
p10171
as(I135
I135
tp10172
(lp10173
S'\t\t\t}'
p10174
as(I120
I120
tp10175
(lp10176
S'\t\tmutex_lock(&driver->md_session_lock);'
p10177
as(I258
I259
tp10178
(lp10179
S'\t\t\tpid_struct = find_get_pid(entry->tgid);'
p10180
aS'\t\t\tif (!pid_struct)'
p10181
as(I160
I160
tp10182
(lp10183
S'\t\t}'
p10184
as(I164
I164
tp10185
(lp10186
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10187
as(I75
I76
tp10188
(lp10189
S'\t\t\tif (ret == -EFAULT) {'
p10190
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10191
as(I109
I109
tp10192
(lp10193
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10194
as(I106
I106
tp10195
(lp10196
S'\t\t}'
p10197
as(I12
I13
tp10198
(lp10199
S'\tstruct pid *pid_struct = NULL;'
p10200
aS'\tstruct task_struct *task_s = NULL;'
p10201
as(I103
I104
tp10202
(lp10203
S'\t\tif (ret == -EFAULT) {'
p10204
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10205
as(I100
I100
tp10206
(lp10207
S'\t\tmutex_lock(&driver->md_session_lock);'
p10208
as(I145
I145
tp10209
(lp10210
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10211
as(I261
I270
tp10212
(lp10213
S'\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p10214
aS'\t\t\tif (!task_s) {'
p10215
aS'\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p10216
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p10217
aS'\t\t\t\tentry->tgid);'
p10218
aS'\t\t\t\tcontinue;'
p10219
aS'\t\t\t}'
p10220
aS'\t\t\tif (task_s == entry->client)'
p10221
aS'\t\t\t\tif (entry->client->tgid != current->tgid)'
p10222
aS'\t\t\t\t\tcontinue;'
p10223
as(I132
I133
tp10224
(lp10225
S'\t\t\tif (ret == -EFAULT) {'
p10226
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10227
as(I140
I141
tp10228
(lp10229
S'\t\t\tif (ret == -EFAULT) {'
p10230
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10231
as(I78
I78
tp10232
(lp10233
S'\t\t\t}'
p10234
as(I123
I124
tp10235
(lp10236
S'\t\tif (ret == -EFAULT) {'
p10237
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10238
as(I143
I143
tp10239
(lp10240
S'\t\t\t}'
p10241
assg32
I4
sg12
g13
sg41
(I1
I310
tp10242
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client) {\n\t\t\t\tif (entry->client->tgid != current->tgid) {\n\t\t\t\t\tput_task_struct(task_s);\n\t\t\t\t\tput_pid(pid_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!entry->in_service) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tput_task_struct(task_s);\n\t\t\tput_pid(pid_struct);\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p10243
(dp10244
((g10116
g10117
tp10245
I1
tp10246
(dp10247
g33
(dp10248
(I132
I132
tp10249
(lp10250
S'\t\t\tif (ret == -EFAULT)'
p10251
as(I75
I75
tp10252
(lp10253
S'\t\t\tif (ret == -EFAULT)'
p10254
as(I157
I157
tp10255
(lp10256
S'\t\tif (ret == -EFAULT)'
p10257
as(I103
I103
tp10258
(lp10259
S'\t\tif (ret == -EFAULT)'
p10260
as(I140
I140
tp10261
(lp10262
S'\t\t\tif (ret == -EFAULT)'
p10263
as(I71
I71
tp10264
(lp10265
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10266
as(I49
I49
tp10267
(lp10268
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10269
as(I268
I268
tp10270
(lp10271
S'\t\t\tif (!entry->in_service)'
p10272
as(I258
I258
tp10273
(lp10274
S'\t\t\tif (entry->client->tgid != current->tgid)'
p10275
as(I126
I126
tp10276
(lp10277
g59
as(I123
I123
tp10278
(lp10279
S'\t\tif (ret == -EFAULT)'
p10280
assg14
(dp10281
(I308
I309
tp10282
(lp10283
S'\t\t\tput_task_struct(task_s);'
p10284
aS'\t\t\tput_pid(pid_struct);'
p10285
as(I80
I80
tp10286
(lp10287
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10288
as(I51
I51
tp10289
(lp10290
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10291
as(I154
I154
tp10292
(lp10293
S'\t\tmutex_lock(&driver->md_session_lock);'
p10294
as(I157
I158
tp10295
(lp10296
S'\t\tif (ret == -EFAULT) {'
p10297
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10298
as(I126
I126
tp10299
(lp10300
S'\t\t}'
p10301
as(I135
I135
tp10302
(lp10303
S'\t\t\t}'
p10304
as(I258
I266
tp10305
(lp10306
S'\t\t\tpid_struct = find_get_pid(entry->tgid);'
p10307
aS'\t\t\tif (!pid_struct)'
p10308
aS'\t\t\t\tcontinue;'
p10309
aS'\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);'
p10310
aS'\t\t\tif (!task_s) {'
p10311
aS'\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,'
p10312
aS'\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",'
p10313
aS'\t\t\t\tentry->tgid);'
p10314
aS'\t\t\t\tput_pid(pid_struct);'
p10315
as(I280
I280
tp10316
(lp10317
S'\t\t\t}'
p10318
as(I120
I120
tp10319
(lp10320
S'\t\tmutex_lock(&driver->md_session_lock);'
p10321
as(I290
I291
tp10322
(lp10323
S'\t\t\t\tput_task_struct(task_s);'
p10324
aS'\t\t\t\tput_pid(pid_struct);'
p10325
as(I160
I160
tp10326
(lp10327
S'\t\t}'
p10328
as(I164
I164
tp10329
(lp10330
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10331
as(I75
I76
tp10332
(lp10333
S'\t\t\tif (ret == -EFAULT) {'
p10334
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10335
as(I268
I278
tp10336
(lp10337
S'\t\t\t}'
p10338
aS'\t\t\tif (task_s == entry->client) {'
p10339
aS'\t\t\t\tif (entry->client->tgid != current->tgid) {'
p10340
aS'\t\t\t\t\tput_task_struct(task_s);'
p10341
aS'\t\t\t\t\tput_pid(pid_struct);'
p10342
aS'\t\t\t\t\tcontinue;'
p10343
aS'\t\t\t\t}'
p10344
aS'\t\t\t}'
p10345
aS'\t\t\tif (!entry->in_service) {'
p10346
aS'\t\t\t\tput_task_struct(task_s);'
p10347
aS'\t\t\t\tput_pid(pid_struct);'
p10348
as(I109
I109
tp10349
(lp10350
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10351
as(I282
I283
tp10352
(lp10353
S'\t\t\t\tput_task_struct(task_s);'
p10354
aS'\t\t\t\tput_pid(pid_struct);'
p10355
as(I106
I106
tp10356
(lp10357
S'\t\t}'
p10358
as(I12
I13
tp10359
(lp10360
S'\tstruct pid *pid_struct = NULL;'
p10361
aS'\tstruct task_struct *task_s = NULL;'
p10362
as(I103
I104
tp10363
(lp10364
S'\t\tif (ret == -EFAULT) {'
p10365
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10366
as(I100
I100
tp10367
(lp10368
S'\t\tmutex_lock(&driver->md_session_lock);'
p10369
as(I145
I145
tp10370
(lp10371
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10372
as(I132
I133
tp10373
(lp10374
S'\t\t\tif (ret == -EFAULT) {'
p10375
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10376
as(I140
I141
tp10377
(lp10378
S'\t\t\tif (ret == -EFAULT) {'
p10379
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10380
as(I303
I304
tp10381
(lp10382
S'\t\t\t\tput_task_struct(task_s);'
p10383
aS'\t\t\t\tput_pid(pid_struct);'
p10384
as(I78
I78
tp10385
(lp10386
S'\t\t\t}'
p10387
as(I123
I124
tp10388
(lp10389
S'\t\tif (ret == -EFAULT) {'
p10390
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10391
as(I143
I143
tp10392
(lp10393
S'\t\t\t}'
p10394
assg32
I4
sg12
g13
sg41
(I1
I326
tp10395
sssS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p10396
(dp10397
((g10116
g10117
tp10398
I1
tp10399
(dp10400
g12
g13
sg14
(dp10401
(I121
I122
tp10402
(lp10403
S'\t\tif (ret == -EFAULT) {'
p10404
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10405
as(I76
I76
tp10406
(lp10407
S'\t\t\t}'
p10408
as(I138
I139
tp10409
(lp10410
S'\t\t\tif (ret == -EFAULT) {'
p10411
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10412
as(I107
I107
tp10413
(lp10414
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10415
as(I118
I118
tp10416
(lp10417
S'\t\tmutex_lock(&driver->md_session_lock);'
p10418
as(I101
I102
tp10419
(lp10420
S'\t\tif (ret == -EFAULT) {'
p10421
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10422
as(I98
I98
tp10423
(lp10424
S'\t\tmutex_lock(&driver->md_session_lock);'
p10425
as(I162
I162
tp10426
(lp10427
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10428
as(I143
I143
tp10429
(lp10430
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10431
as(I141
I141
tp10432
(lp10433
S'\t\t\t}'
p10434
as(I73
I74
tp10435
(lp10436
S'\t\t\tif (ret == -EFAULT) {'
p10437
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10438
as(I104
I104
tp10439
(lp10440
S'\t\t}'
p10441
as(I130
I131
tp10442
(lp10443
S'\t\t\tif (ret == -EFAULT) {'
p10444
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p10445
as(I124
I124
tp10446
(lp10447
S'\t\t}'
p10448
as(I78
I78
tp10449
(lp10450
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10451
as(I152
I152
tp10452
(lp10453
S'\t\tmutex_lock(&driver->md_session_lock);'
p10454
as(I158
I158
tp10455
(lp10456
S'\t\t}'
p10457
as(I155
I156
tp10458
(lp10459
S'\t\tif (ret == -EFAULT) {'
p10460
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10461
as(I49
I49
tp10462
(lp10463
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10464
as(I133
I133
tp10465
(lp10466
S'\t\t\t}'
p10467
assg32
I4
sg33
(dp10468
(I47
I47
tp10469
(lp10470
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10471
as(I101
I101
tp10472
(lp10473
S'\t\tif (ret == -EFAULT)'
p10474
as(I69
I69
tp10475
(lp10476
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10477
as(I130
I130
tp10478
(lp10479
S'\t\t\tif (ret == -EFAULT)'
p10480
as(I155
I155
tp10481
(lp10482
S'\t\tif (ret == -EFAULT)'
p10483
as(I138
I138
tp10484
(lp10485
S'\t\t\tif (ret == -EFAULT)'
p10486
as(I124
I124
tp10487
(lp10488
g59
as(I73
I73
tp10489
(lp10490
S'\t\t\tif (ret == -EFAULT)'
p10491
as(I121
I121
tp10492
(lp10493
S'\t\tif (ret == -EFAULT)'
p10494
assg41
(I1
I297
tp10495
ssss(g10026
S'diag_cmd_toggle_events'
p10496
tp10497
(dp10498
S'static int diag_cmd_toggle_events(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0, i, peripheral;\n\tuint8_t toggle = 0;\n\tstruct diag_event_report_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttoggle = *(src_buf + 1);\n\tmutex_lock(&mask_info->lock);\n\tif (toggle) {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_ENABLED;\n\t\tmemset(mask_info->ptr, 0xFF, mask_info->mask_len);\n\t} else {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\t\tmemset(mask_info->ptr, 0, mask_info->mask_len);\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_EVENT_TOGGLE;\n\theader.padding = 0;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\tmemcpy(dest_buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\treturn write_len;\n}'
p10499
(dp10500
((g10026
g10496
tp10501
I1
tp10502
(dp10503
g12
g13
sg14
(dp10504
(I24
I24
tp10505
(lp10506
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10507
as(I10
I11
tp10508
(lp10509
S'\tmutex_lock(&driver->md_session_lock);'
p10510
aS'\tinfo = diag_md_session_get_pid(pid);'
p10511
as(I18
I18
tp10512
(lp10513
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10514
as(I38
I38
tp10515
(lp10516
S'\tmutex_unlock(&driver->md_session_lock);'
p10517
as(I2
I2
tp10518
(lp10519
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10520
as(I8
I8
tp10521
(lp10522
S'\tstruct diag_md_session_t *info = NULL;'
p10523
assg32
I5
sg33
(dp10524
(I2
I3
tp10525
(lp10526
S'\t\t\t\t  unsigned char *dest_buf, int dest_len,'
p10527
aS'\t\t\t\t  struct diag_md_session_t *info)'
p10528
assg41
(I1
I65
tp10529
sssS'static int diag_cmd_toggle_events(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0, i, peripheral;\n\tuint8_t toggle = 0;\n\tstruct diag_event_report_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttoggle = *(src_buf + 1);\n\tmutex_lock(&mask_info->lock);\n\tif (toggle) {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_ENABLED;\n\t\tmemset(mask_info->ptr, 0xFF, mask_info->mask_len);\n\t} else {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\t\tmemset(mask_info->ptr, 0, mask_info->mask_len);\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_EVENT_TOGGLE;\n\theader.padding = 0;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\tmemcpy(dest_buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\treturn write_len;\n}'
p10530
(dp10531
((g10026
g10496
tp10532
I1
tp10533
(dp10534
g12
g13
sg14
(dp10535
(I24
I24
tp10536
(lp10537
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10538
as(I10
I11
tp10539
(lp10540
S'\tmutex_lock(&driver->md_session_lock);'
p10541
aS'\tinfo = diag_md_session_get_pid(pid);'
p10542
as(I51
I51
tp10543
(lp10544
S'\t\tif (!diag_check_update(i, pid))'
p10545
as(I18
I18
tp10546
(lp10547
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10548
as(I38
I39
tp10549
(lp10550
S'\tmutex_unlock(&driver->md_session_lock);'
p10551
aS'\tif (diag_check_update(APPS_DATA, pid))'
p10552
as(I2
I2
tp10553
(lp10554
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10555
as(I8
I8
tp10556
(lp10557
S'\tstruct diag_md_session_t *info = NULL;'
p10558
assg32
I5
sg33
(dp10559
(I2
I3
tp10560
(lp10561
S'\t\t\t\t  unsigned char *dest_buf, int dest_len,'
p10562
aS'\t\t\t\t  struct diag_md_session_t *info)'
p10563
as(I51
I51
tp10564
(lp10565
S'\t\tif (!diag_check_update(i))'
p10566
as(I38
I38
tp10567
(lp10568
S'\tif (diag_check_update(APPS_DATA))'
p10569
assg41
(I1
I65
tp10570
sssS'static int diag_cmd_toggle_events(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0, i, peripheral;\n\tuint8_t toggle = 0;\n\tstruct diag_event_report_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= sizeof(uint8_t) ||\n\t\tdest_len <= 0 || !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttoggle = *(src_buf + 1);\n\tmutex_lock(&mask_info->lock);\n\tif (toggle) {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_ENABLED;\n\t\tmemset(mask_info->ptr, 0xFF, mask_info->mask_len);\n\t} else {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\t\tmemset(mask_info->ptr, 0, mask_info->mask_len);\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_EVENT_TOGGLE;\n\theader.padding = 0;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\tmemcpy(dest_buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\treturn write_len;\n}'
p10571
(dp10572
((g10026
g10496
tp10573
I1
tp10574
(dp10575
g12
g13
sg14
(dp10576
(I24
I24
tp10577
(lp10578
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10579
as(I8
I8
tp10580
(lp10581
S'\tstruct diag_md_session_t *info = NULL;'
p10582
as(I10
I11
tp10583
(lp10584
S'\tmutex_lock(&driver->md_session_lock);'
p10585
aS'\tinfo = diag_md_session_get_pid(pid);'
p10586
as(I51
I51
tp10587
(lp10588
S'\t\tif (!diag_check_update(i, pid))'
p10589
as(I18
I18
tp10590
(lp10591
S'\t\tmutex_unlock(&driver->md_session_lock);'
p10592
as(I13
I14
tp10593
(lp10594
S'\tif (!src_buf || !dest_buf || src_len <= sizeof(uint8_t) ||'
p10595
aS'\t\tdest_len <= 0 || !mask_info) {'
p10596
as(I38
I39
tp10597
(lp10598
S'\tmutex_unlock(&driver->md_session_lock);'
p10599
aS'\tif (diag_check_update(APPS_DATA, pid))'
p10600
as(I2
I2
tp10601
(lp10602
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p10603
assg32
I5
sg33
(dp10604
(I13
I14
tp10605
(lp10606
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p10607
aS'\t    !mask_info) {'
p10608
as(I2
I3
tp10609
(lp10610
S'\t\t\t\t  unsigned char *dest_buf, int dest_len,'
p10611
aS'\t\t\t\t  struct diag_md_session_t *info)'
p10612
as(I51
I51
tp10613
(lp10614
S'\t\tif (!diag_check_update(i))'
p10615
as(I38
I38
tp10616
(lp10617
S'\tif (diag_check_update(APPS_DATA))'
p10618
assg41
(I1
I65
tp10619
ssss(S'drivers/char/diag/diag_usb.c'
p10620
S'usb_disconnect'
p10621
tp10622
(dp10623
S'static void usb_disconnect(struct diag_usb_info *ch)\n{\n\tif (!ch)\n\t\treturn;\n\n\tif (!atomic_read(&ch->connected) &&\n\t\tdriver->usb_connected && diag_mask_param())\n\t\tdiag_clear_masks(0);\n\n\tif (ch && ch->ops && ch->ops->close)\n\t\tch->ops->close(ch->ctxt, DIAG_USB_MODE);\n}'
p10624
(dp10625
((g10620
g10621
tp10626
I1
tp10627
(dp10628
g12
g13
sg14
(dp10629
(I8
I8
tp10630
(lp10631
S'\t\tdiag_clear_masks(0);'
p10632
assg32
I1
sg33
(dp10633
(I8
I8
tp10634
(lp10635
S'\t\tdiag_clear_masks(NULL);'
p10636
assg41
(I1
I12
tp10637
sssS'static void usb_disconnect(struct diag_usb_info *ch)\n{\n\tif (ch && ch->ops && ch->ops->close)\n\t\tch->ops->close(ch->ctxt, DIAG_USB_MODE);\n}'
p10638
(dp10639
((g10620
g10621
tp10640
I1
tp10641
(dp10642
g12
g13
sg41
(I1
I5
tp10643
sg32
I1
sg33
(dp10644
(I3
I9
tp10645
(lp10646
S'\tif (!ch)'
p10647
aS'\t\treturn;'
p10648
ag59
aS'\tif (!atomic_read(&ch->connected) &&'
p10649
aS'\t\tdriver->usb_connected && diag_mask_param())'
p10650
aS'\t\tdiag_clear_masks(NULL);'
p10651
ag59
asssss(g10002
S'diag_process_non_hdlc_pkt'
p10652
tp10653
(dp10654
S'void diag_process_non_hdlc_pkt(unsigned char *buf, int len, int pid)\n{\n\tint err = 0;\n\tuint16_t pkt_len = 0;\n\tuint32_t read_bytes = 0;\n\tconst uint32_t header_len = sizeof(struct diag_pkt_frame_t);\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tunsigned char *data_ptr = NULL;\n\tstruct diag_partial_pkt_t *partial_pkt = NULL;\n\n\tmutex_lock(&driver->hdlc_recovery_mutex);\n\tif (!buf || len <= 0) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\treturn;\n\t}\n\tpartial_pkt = &driver->incoming_pkt;\n\tif (!partial_pkt->processing) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\n\tif (partial_pkt->remaining > len) {\n\t\tif ((partial_pkt->read_len + len) > partial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len, len, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf, len);\n\t\tread_bytes += len;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += len;\n\t\tpartial_pkt->remaining -= len;\n\t} else {\n\t\tif ((partial_pkt->read_len + partial_pkt->remaining) >\n\t\t\t\t\t\tpartial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length during partial read %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len,\n\t\t\t       partial_pkt->remaining, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf,\n\t\t\t\t\t\tpartial_pkt->remaining);\n\t\tread_bytes += partial_pkt->remaining;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += partial_pkt->remaining;\n\t\tpartial_pkt->remaining = 0;\n\t}\n\n\tif (partial_pkt->remaining == 0) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)(partial_pkt->data);\n\t\tdata_ptr = partial_pkt->data + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, unable to process incoming data packet, err: %d\\n",\n\t\t\t       __func__, err);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tpartial_pkt->read_len = 0;\n\t\tpartial_pkt->total_len = 0;\n\t\tpartial_pkt->processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\tgoto end;\n\nstart:\n\twhile (read_bytes < len) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\t\tpkt_len = actual_pkt->length;\n\n\t\tif (actual_pkt->start != CONTROL_CHAR) {\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\tgoto end;\n\t\t}\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tif (pkt_len + header_len > partial_pkt->capacity) {\n\t\t\tpr_err("diag: In %s, incoming data is too large for the request buffer %d\\n",\n\t\t\t       __func__, pkt_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tbreak;\n\t\t}\n\t\tif ((pkt_len + header_len) > (len - read_bytes)) {\n\t\t\tpartial_pkt->read_len = len - read_bytes;\n\t\t\tpartial_pkt->total_len = pkt_len + header_len;\n\t\t\tpartial_pkt->remaining = partial_pkt->total_len -\n\t\t\t\t\t\t partial_pkt->read_len;\n\t\t\tpartial_pkt->processing = 1;\n\t\t\tmemcpy(partial_pkt->data, buf, partial_pkt->read_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tdata_ptr = buf + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\telse\n\t\t\thdlc_reset = 0;\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tread_bytes += header_len + pkt_len + 1;\n\t\tbuf += header_len + pkt_len + 1; /* advance to next pkt */\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t}\nend:\n\treturn;\n}'
p10655
(dp10656
((g10002
g10652
tp10657
I1
tp10658
(dp10659
g12
g13
sg14
(dp10660
(I115
I115
tp10661
(lp10662
S'\t\t\t\t\t    actual_pkt->length, pid);'
p10663
as(I109
I109
tp10664
(lp10665
S'\t\t\tdiag_hdlc_start_recovery(buf, len, pid);'
p10666
as(I61
I61
tp10667
(lp10668
S'\t\t\t\t\t    actual_pkt->length, pid);'
p10669
as(I92
I92
tp10670
(lp10671
S'\t\t\tdiag_hdlc_start_recovery(buf, len, pid);'
p10672
as(I83
I84
tp10673
(lp10674
S'\t\t\tdiag_hdlc_start_recovery(buf, len, pid);'
p10675
aS'\t\t\tdiag_send_error_rsp(buf, len, pid);'
p10676
as(I1
I1
tp10677
(lp10678
S'void diag_process_non_hdlc_pkt(unsigned char *buf, int len, int pid)'
p10679
as(I57
I57
tp10680
(lp10681
S'\t\t\tdiag_hdlc_start_recovery(buf, len, pid);'
p10682
assg32
I3
sg33
(dp10683
(I1
I2
tp10684
(lp10685
S'void diag_process_non_hdlc_pkt(unsigned char *buf, int len,'
p10686
aS'\t\t\t       struct diag_md_session_t *info)'
p10687
as(I61
I61
tp10688
(lp10689
S'\t\t\t\t\t    actual_pkt->length, info);'
p10690
as(I92
I92
tp10691
(lp10692
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10693
as(I83
I84
tp10694
(lp10695
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10696
aS'\t\t\tdiag_send_error_rsp(buf, len, info);'
p10697
as(I57
I57
tp10698
(lp10699
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10700
as(I115
I115
tp10701
(lp10702
S'\t\t\t\t\t    actual_pkt->length, info);'
p10703
as(I109
I109
tp10704
(lp10705
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10706
assg41
(I1
I126
tp10707
sssS'void diag_process_non_hdlc_pkt(unsigned char *buf, int len, int pid)\n{\n\tint err = 0;\n\tuint16_t pkt_len = 0;\n\tuint32_t read_bytes = 0;\n\tconst uint32_t header_len = sizeof(struct diag_pkt_frame_t);\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tunsigned char *data_ptr = NULL;\n\tstruct diag_partial_pkt_t *partial_pkt = NULL;\n\n\tmutex_lock(&driver->hdlc_recovery_mutex);\n\tif (!buf || len <= 0) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\treturn;\n\t}\n\tpartial_pkt = &driver->incoming_pkt;\n\tif (!partial_pkt->processing) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\n\tif (partial_pkt->remaining > len) {\n\t\tif ((partial_pkt->read_len + len) > partial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len, len, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf, len);\n\t\tread_bytes += len;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += len;\n\t\tpartial_pkt->remaining -= len;\n\t} else {\n\t\tif ((partial_pkt->read_len + partial_pkt->remaining) >\n\t\t\t\t\t\tpartial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length during partial read %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len,\n\t\t\t       partial_pkt->remaining, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf,\n\t\t\t\t\t\tpartial_pkt->remaining);\n\t\tread_bytes += partial_pkt->remaining;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += partial_pkt->remaining;\n\t\tpartial_pkt->remaining = 0;\n\t}\n\n\tif (partial_pkt->remaining == 0) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)(partial_pkt->data);\n\t\tdata_ptr = partial_pkt->data + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, unable to process incoming data packet, err: %d\\n",\n\t\t\t       __func__, err);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tpartial_pkt->read_len = 0;\n\t\tpartial_pkt->total_len = 0;\n\t\tpartial_pkt->processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\tgoto end;\n\nstart:\n\twhile (read_bytes < len) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\t\tpkt_len = actual_pkt->length;\n\n\t\tif (actual_pkt->start != CONTROL_CHAR) {\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tdiag_send_error_rsp(buf, (len - read_bytes), pid);\n\t\t\tgoto end;\n\t\t}\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tif (pkt_len + header_len > partial_pkt->capacity) {\n\t\t\tpr_err("diag: In %s, incoming data is too large for the request buffer %d\\n",\n\t\t\t       __func__, pkt_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tbreak;\n\t\t}\n\t\tif ((pkt_len + header_len) > (len - read_bytes)) {\n\t\t\tpartial_pkt->read_len = len - read_bytes;\n\t\t\tpartial_pkt->total_len = pkt_len + header_len;\n\t\t\tpartial_pkt->remaining = partial_pkt->total_len -\n\t\t\t\t\t\t partial_pkt->read_len;\n\t\t\tpartial_pkt->processing = 1;\n\t\t\tmemcpy(partial_pkt->data, buf, partial_pkt->read_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tdata_ptr = buf + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\telse\n\t\t\thdlc_reset = 0;\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tread_bytes += header_len + pkt_len + 1;\n\t\tbuf += header_len + pkt_len + 1; /* advance to next pkt */\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t}\nend:\n\treturn;\n}'
p10708
(dp10709
((g10002
g10652
tp10710
I1
tp10711
(dp10712
g12
g13
sg14
(dp10713
(I115
I115
tp10714
(lp10715
S'\t\t\t\t\t    actual_pkt->length, pid);'
p10716
as(I109
I109
tp10717
(lp10718
S'\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);'
p10719
as(I61
I61
tp10720
(lp10721
S'\t\t\t\t\t    actual_pkt->length, pid);'
p10722
as(I92
I92
tp10723
(lp10724
S'\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);'
p10725
as(I83
I84
tp10726
(lp10727
S'\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);'
p10728
aS'\t\t\tdiag_send_error_rsp(buf, (len - read_bytes), pid);'
p10729
as(I1
I1
tp10730
(lp10731
S'void diag_process_non_hdlc_pkt(unsigned char *buf, int len, int pid)'
p10732
as(I57
I57
tp10733
(lp10734
S'\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);'
p10735
assg32
I3
sg33
(dp10736
(I1
I2
tp10737
(lp10738
S'void diag_process_non_hdlc_pkt(unsigned char *buf, int len,'
p10739
aS'\t\t\t       struct diag_md_session_t *info)'
p10740
as(I61
I61
tp10741
(lp10742
S'\t\t\t\t\t    actual_pkt->length, info);'
p10743
as(I92
I92
tp10744
(lp10745
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10746
as(I83
I84
tp10747
(lp10748
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10749
aS'\t\t\tdiag_send_error_rsp(buf, len, info);'
p10750
as(I57
I57
tp10751
(lp10752
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10753
as(I115
I115
tp10754
(lp10755
S'\t\t\t\t\t    actual_pkt->length, info);'
p10756
as(I109
I109
tp10757
(lp10758
S'\t\t\tdiag_hdlc_start_recovery(buf, len, info);'
p10759
assg41
(I1
I126
tp10760
ssss(g10002
S'pack_rsp_and_send'
p10761
tp10762
(dp10763
S'static void pack_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tint err;\n\tint retry_count = 0, i, rsp_ctxt;\n\tuint32_t write_len = 0;\n\tunsigned long flags;\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tstruct diag_pkt_frame_t header;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tif (info->peripheral_mask == DIAG_CON_ALL ||\n\t\t\t(info->peripheral_mask & (1 << APPS_DATA)) ||\n\t\t\t(info->peripheral_mask & (1 << PERIPHERAL_MODEM))) {\n\t\t\trsp_ctxt = SET_BUF_CTXT(APPS_DATA, TYPE_CMD, 1);\n\t\t} else {\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, 1);\n\t\t}\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till UINT_MAX, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < UINT_MAX) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tdriver->rsp_buf_busy = 1;\n\theader.start = CONTROL_CHAR;\n\theader.version = 1;\n\theader.length = len;\n\tmemcpy(rsp_ptr, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\tmemcpy(rsp_ptr + write_len, buf, len);\n\twrite_len += len;\n\t*(uint8_t *)(rsp_ptr + write_len) = CONTROL_CHAR;\n\twrite_len += sizeof(uint8_t);\n\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, write_len, rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, unable to write to mux, err: %d\\n",\n\t\t       __func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n}'
p10764
(dp10765
((g10002
g10761
tp10766
I1
tp10767
(dp10768
g12
g13
sg14
(dp10769
(I72
I73
tp10770
(lp10771
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10772
aS'\t\t}'
p10773
as(I21
I25
tp10774
(lp10775
S'\tmutex_lock(&driver->md_session_lock);'
p10776
aS'\tsession_info = diag_md_session_get_pid(pid);'
p10777
aS'\tinfo = (session_info) ? session_info :'
p10778
aS'\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);'
p10779
ag59
as(I45
I45
tp10780
(lp10781
S'\tmutex_unlock(&driver->md_session_lock);'
p10782
as(I10
I10
tp10783
(lp10784
S'\tstruct diag_md_session_t *session_info = NULL, *info = NULL;'
p10785
as(I69
I70
tp10786
(lp10787
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {'
p10788
aS'\t\t\tmutex_lock(&driver->md_session_lock);'
p10789
as(I2
I2
tp10790
(lp10791
S'\t\t\t\tint pid)'
p10792
assg32
I3
sg33
(dp10793
(I69
I69
tp10794
(lp10795
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE)'
p10796
as(I2
I2
tp10797
(lp10798
S'\t\t\t\tstruct diag_md_session_t *info)'
p10799
assg41
(I1
I99
tp10800
sssS'static void pack_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tint err;\n\tint retry_count = 0, i, rsp_ctxt;\n\tuint32_t write_len = 0;\n\tunsigned long flags;\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tstruct diag_pkt_frame_t header;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\tbreak;\n\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, TYPE_CMD);\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till RETRY_MAX_COUNT, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < RETRY_MAX_COUNT) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tdriver->rsp_buf_busy = 1;\n\theader.start = CONTROL_CHAR;\n\theader.version = 1;\n\theader.length = len;\n\tmemcpy(rsp_ptr, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\tmemcpy(rsp_ptr + write_len, buf, len);\n\twrite_len += len;\n\t*(uint8_t *)(rsp_ptr + write_len) = CONTROL_CHAR;\n\twrite_len += sizeof(uint8_t);\n\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, write_len, rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, unable to write to mux, err: %d\\n",\n\t\t       __func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n}'
p10801
(dp10802
((g10002
g10761
tp10803
I1
tp10804
(dp10805
g12
g13
sg14
(dp10806
(I21
I25
tp10807
(lp10808
S'\tmutex_lock(&driver->md_session_lock);'
p10809
aS'\tsession_info = diag_md_session_get_pid(pid);'
p10810
aS'\tinfo = (session_info) ? session_info :'
p10811
aS'\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);'
p10812
ag59
as(I47
I47
tp10813
(lp10814
S'\twhile (retry_count < RETRY_MAX_COUNT) {'
p10815
as(I43
I43
tp10816
(lp10817
S'\t * take one or two iterations. When this loops till RETRY_MAX_COUNT, it'
p10818
as(I66
I67
tp10819
(lp10820
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10821
aS'\t\t}'
p10822
as(I10
I10
tp10823
(lp10824
S'\tstruct diag_md_session_t *session_info = NULL, *info = NULL;'
p10825
as(I2
I2
tp10826
(lp10827
S'\t\t\t\tint pid)'
p10828
as(I36
I36
tp10829
(lp10830
S'\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, TYPE_CMD);'
p10831
as(I63
I64
tp10832
(lp10833
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {'
p10834
aS'\t\t\tmutex_lock(&driver->md_session_lock);'
p10835
as(I32
I34
tp10836
(lp10837
S'\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p10838
aS'\t\t\tif (info->peripheral_mask & (1 << i))'
p10839
aS'\t\t\t\tbreak;'
p10840
as(I39
I39
tp10841
(lp10842
S'\tmutex_unlock(&driver->md_session_lock);'
p10843
assg32
I3
sg33
(dp10844
(I32
I41
tp10845
(lp10846
S'\t\tif (info->peripheral_mask == DIAG_CON_ALL ||'
p10847
aS'\t\t\t(info->peripheral_mask & (1 << APPS_DATA)) ||'
p10848
aS'\t\t\t(info->peripheral_mask & (1 << PERIPHERAL_MODEM))) {'
p10849
aS'\t\t\trsp_ctxt = SET_BUF_CTXT(APPS_DATA, TYPE_CMD, 1);'
p10850
aS'\t\t} else {'
p10851
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p10852
aS'\t\t\t\tif (info->peripheral_mask & (1 << i))'
p10853
aS'\t\t\t\t\tbreak;'
p10854
aS'\t\t\t}'
p10855
aS'\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, 1);'
p10856
as(I63
I63
tp10857
(lp10858
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE)'
p10859
as(I47
I47
tp10860
(lp10861
S'\twhile (retry_count < UINT_MAX) {'
p10862
as(I43
I43
tp10863
(lp10864
S'\t * take one or two iterations. When this loops till UINT_MAX, it'
p10865
as(I2
I2
tp10866
(lp10867
S'\t\t\t\tstruct diag_md_session_t *info)'
p10868
assg41
(I1
I93
tp10869
ssss(g10002
S'encode_rsp_and_send'
p10870
tp10871
(dp10872
S'static void encode_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tint err, i, rsp_ctxt, retry_count = 0;\n\tunsigned long flags;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\tbreak;\n\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, TYPE_CMD);\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till RETRY_MAX_COUNT, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < RETRY_MAX_COUNT) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\tdriver->rsp_buf_busy = 1;\n\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = buf;\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\tenc.dest = rsp_ptr;\n\tenc.dest_last = (void *)(rsp_ptr + DIAG_MAX_HDLC_BUF_SIZE - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->encoded_rsp_len = (int)(enc.dest - (void *)rsp_ptr);\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, driver->encoded_rsp_len,\n\t\t\t     rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to write to device, err: %d\\n",\n\t\t\t__func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n\tmemset(buf, \'\\0\', DIAG_MAX_RSP_SIZE);\n}'
p10873
(dp10874
((g10002
g10870
tp10875
I1
tp10876
(dp10877
g12
g13
sg14
(dp10878
(I64
I65
tp10879
(lp10880
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10881
aS'\t\t}'
p10882
as(I41
I41
tp10883
(lp10884
S'\t * take one or two iterations. When this loops till RETRY_MAX_COUNT, it'
p10885
as(I35
I35
tp10886
(lp10887
S'\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, TYPE_CMD);'
p10888
as(I20
I24
tp10889
(lp10890
S'\tmutex_lock(&driver->md_session_lock);'
p10891
aS'\tsession_info = diag_md_session_get_pid(pid);'
p10892
aS'\tinfo = (session_info) ? session_info :'
p10893
aS'\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);'
p10894
ag59
as(I61
I62
tp10895
(lp10896
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {'
p10897
aS'\t\t\tmutex_lock(&driver->md_session_lock);'
p10898
as(I38
I38
tp10899
(lp10900
S'\tmutex_unlock(&driver->md_session_lock);'
p10901
as(I2
I2
tp10902
(lp10903
S'\t\t\t\tint pid)'
p10904
as(I45
I45
tp10905
(lp10906
S'\twhile (retry_count < RETRY_MAX_COUNT) {'
p10907
as(I9
I9
tp10908
(lp10909
S'\tstruct diag_md_session_t *session_info = NULL, *info = NULL;'
p10910
as(I31
I33
tp10911
(lp10912
S'\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p10913
aS'\t\t\tif (info->peripheral_mask & (1 << i))'
p10914
aS'\t\t\t\tbreak;'
p10915
assg32
I3
sg33
(dp10916
(I31
I40
tp10917
(lp10918
S'\t\tif (info->peripheral_mask == DIAG_CON_ALL ||'
p10919
aS'\t\t\t(info->peripheral_mask & (1 << APPS_DATA)) ||'
p10920
aS'\t\t\t(info->peripheral_mask & (1 << PERIPHERAL_MODEM))) {'
p10921
aS'\t\t\trsp_ctxt = SET_BUF_CTXT(APPS_DATA, TYPE_CMD, 1);'
p10922
aS'\t\t} else {'
p10923
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p10924
aS'\t\t\t\tif (info->peripheral_mask & (1 << i))'
p10925
aS'\t\t\t\t\tbreak;'
p10926
aS'\t\t\t}'
p10927
aS'\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, 1);'
p10928
as(I45
I45
tp10929
(lp10930
S'\twhile (retry_count < UINT_MAX) {'
p10931
as(I38
I38
tp10932
(lp10933
g59
as(I2
I2
tp10934
(lp10935
S'\t\t\t\tstruct diag_md_session_t *info)'
p10936
as(I41
I41
tp10937
(lp10938
S'\t * take one or two iterations. When this loops till UINT_MAX, it'
p10939
as(I61
I61
tp10940
(lp10941
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE)'
p10942
assg41
(I1
I94
tp10943
sssS'static void encode_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tint err, i, rsp_ctxt, retry_count = 0;\n\tunsigned long flags;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tif (info->peripheral_mask == DIAG_CON_ALL ||\n\t\t\t(info->peripheral_mask & (1 << APPS_DATA)) ||\n\t\t\t(info->peripheral_mask & (1 << PERIPHERAL_MODEM))) {\n\t\t\trsp_ctxt = SET_BUF_CTXT(APPS_DATA, TYPE_CMD, 1);\n\t\t} else {\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, 1);\n\t\t}\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till UINT_MAX, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < UINT_MAX) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\tdriver->rsp_buf_busy = 1;\n\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = buf;\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\tenc.dest = rsp_ptr;\n\tenc.dest_last = (void *)(rsp_ptr + DIAG_MAX_HDLC_BUF_SIZE - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->encoded_rsp_len = (int)(enc.dest - (void *)rsp_ptr);\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, driver->encoded_rsp_len,\n\t\t\t     rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to write to device, err: %d\\n",\n\t\t\t__func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n\tmemset(buf, \'\\0\', DIAG_MAX_RSP_SIZE);\n}'
p10944
(dp10945
((g10002
g10870
tp10946
I1
tp10947
(dp10948
g12
g13
sg14
(dp10949
(I70
I71
tp10950
(lp10951
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p10952
aS'\t\t}'
p10953
as(I20
I24
tp10954
(lp10955
S'\tmutex_lock(&driver->md_session_lock);'
p10956
aS'\tsession_info = diag_md_session_get_pid(pid);'
p10957
aS'\tinfo = (session_info) ? session_info :'
p10958
aS'\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);'
p10959
ag59
as(I2
I2
tp10960
(lp10961
S'\t\t\t\tint pid)'
p10962
as(I44
I44
tp10963
(lp10964
S'\tmutex_unlock(&driver->md_session_lock);'
p10965
as(I67
I68
tp10966
(lp10967
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {'
p10968
aS'\t\t\tmutex_lock(&driver->md_session_lock);'
p10969
as(I9
I9
tp10970
(lp10971
S'\tstruct diag_md_session_t *session_info = NULL, *info = NULL;'
p10972
assg32
I3
sg33
(dp10973
(I44
I44
tp10974
(lp10975
g59
as(I67
I67
tp10976
(lp10977
S'\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE)'
p10978
as(I2
I2
tp10979
(lp10980
S'\t\t\t\tstruct diag_md_session_t *info)'
p10981
assg41
(I1
I100
tp10982
ssss(g10116
S'diag_close_logging_process'
p10983
tp10984
(dp10985
S'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn;\n\t}\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tparams.req_mode = USB_MODE;\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p10986
(dp10987
((g10116
g10983
tp10988
I1
tp10989
(dp10990
g33
(dp10991
(I19
I23
tp10992
(lp10993
S'\t\tdiag_clear_masks(session_info);'
p10994
ag59
aS'\tmutex_lock(&driver->diag_maskclear_mutex);'
p10995
aS'\tdriver->mask_clear = 1;'
p10996
aS'\tmutex_unlock(&driver->diag_maskclear_mutex);'
p10997
as(I45
I45
tp10998
(lp10999
g59
as(I11
I11
tp11000
(lp11001
S'\tif (!session_info)'
p11002
as(I22
I24
tp11003
(lp11004
S'\tsession_mask = session_info->peripheral_mask;'
p11005
aS'\tdiag_md_session_close(session_info);'
p11006
ag59
assg14
(dp11007
(I19
I19
tp11008
(lp11009
S'\t\tdiag_clear_masks(pid);'
p11010
as(I45
I47
tp11011
(lp11012
S'\tmutex_lock(&driver->md_session_lock);'
p11013
aS'\tdiag_md_session_close(pid);'
p11014
aS'\tmutex_unlock(&driver->md_session_lock);'
p11015
as(I11
I12
tp11016
(lp11017
S'\tif (!session_info) {'
p11018
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11019
as(I9
I9
tp11020
(lp11021
S'\tmutex_lock(&driver->md_session_lock);'
p11022
as(I14
I16
tp11023
(lp11024
S'\t}'
p11025
aS'\tsession_mask = session_info->peripheral_mask;'
p11026
aS'\tmutex_unlock(&driver->md_session_lock);'
p11027
assg32
I1
sg12
g13
sg41
(I1
I50
tp11028
sssS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn;\n\t}\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diag_maskclear_mutex);\n\tdriver->mask_clear = 1;\n\tmutex_unlock(&driver->diag_maskclear_mutex);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tparams.req_mode = USB_MODE;\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p11029
(dp11030
((g10116
g10983
tp11031
I1
tp11032
(dp11033
g33
(dp11034
(I49
I49
tp11035
(lp11036
g59
as(I26
I28
tp11037
(lp11038
S'\tsession_mask = session_info->peripheral_mask;'
p11039
aS'\tdiag_md_session_close(session_info);'
p11040
ag59
as(I11
I11
tp11041
(lp11042
S'\tif (!session_info)'
p11043
as(I19
I19
tp11044
(lp11045
S'\t\tdiag_clear_masks(session_info);'
p11046
assg14
(dp11047
(I19
I19
tp11048
(lp11049
S'\t\tdiag_clear_masks(pid);'
p11050
as(I49
I51
tp11051
(lp11052
S'\tmutex_lock(&driver->md_session_lock);'
p11053
aS'\tdiag_md_session_close(pid);'
p11054
aS'\tmutex_unlock(&driver->md_session_lock);'
p11055
as(I11
I12
tp11056
(lp11057
S'\tif (!session_info) {'
p11058
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11059
as(I9
I9
tp11060
(lp11061
S'\tmutex_lock(&driver->md_session_lock);'
p11062
as(I14
I16
tp11063
(lp11064
S'\t}'
p11065
aS'\tsession_mask = session_info->peripheral_mask;'
p11066
aS'\tmutex_unlock(&driver->md_session_lock);'
p11067
assg32
I1
sg12
g13
sg41
(I1
I54
tp11068
sssS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn;\n\t}\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\tparams.req_mode = PCIE_MODE;\n\telse\n\t\tparams.req_mode = USB_MODE;\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p11069
(dp11070
((g10116
g10983
tp11071
I1
tp11072
(dp11073
g33
(dp11074
(I28
I29
tp11075
(lp11076
g59
aS'\tparams.req_mode = USB_MODE;'
p11077
as(I19
I23
tp11078
(lp11079
S'\t\tdiag_clear_masks(session_info);'
p11080
ag59
aS'\tmutex_lock(&driver->diag_maskclear_mutex);'
p11081
aS'\tdriver->mask_clear = 1;'
p11082
aS'\tmutex_unlock(&driver->diag_maskclear_mutex);'
p11083
as(I47
I47
tp11084
(lp11085
g59
as(I11
I11
tp11086
(lp11087
S'\tif (!session_info)'
p11088
as(I22
I24
tp11089
(lp11090
S'\tsession_mask = session_info->peripheral_mask;'
p11091
aS'\tdiag_md_session_close(session_info);'
p11092
ag59
assg14
(dp11093
(I28
I31
tp11094
(lp11095
S'\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)'
p11096
aS'\t\tparams.req_mode = PCIE_MODE;'
p11097
aS'\telse'
p11098
aS'\t\tparams.req_mode = USB_MODE;'
p11099
as(I19
I19
tp11100
(lp11101
S'\t\tdiag_clear_masks(pid);'
p11102
as(I47
I49
tp11103
(lp11104
S'\tmutex_lock(&driver->md_session_lock);'
p11105
aS'\tdiag_md_session_close(pid);'
p11106
aS'\tmutex_unlock(&driver->md_session_lock);'
p11107
as(I11
I12
tp11108
(lp11109
S'\tif (!session_info) {'
p11110
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11111
as(I9
I9
tp11112
(lp11113
S'\tmutex_lock(&driver->md_session_lock);'
p11114
as(I14
I16
tp11115
(lp11116
S'\t}'
p11117
aS'\tsession_mask = session_info->peripheral_mask;'
p11118
aS'\tmutex_unlock(&driver->md_session_lock);'
p11119
assg32
I1
sg12
g13
sg41
(I1
I52
tp11120
sssS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)\n\t\t\tparams.req_mode = PCIE_MODE;\n\t\telse\n\t\t\tparams.req_mode = USB_MODE;\n\t\tparams.mode_param = 0;\n\t\tparams.pd_mask = 0;\n\t\tparams.peripheral_mask = DIAG_CON_ALL;\n\t\tmutex_lock(&driver->diagchar_mutex);\n\t\tdiag_switch_logging(&params);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\treturn;\n\t}\n\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\tparams.req_mode = PCIE_MODE;\n\telse\n\t\tparams.req_mode = USB_MODE;\n\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p11121
(dp11122
((g10116
g10983
tp11123
I1
tp11124
(dp11125
g33
(dp11126
(I33
I35
tp11127
(lp11128
S'\tsession_mask = session_info->peripheral_mask;'
p11129
aS'\tdiag_md_session_close(session_info);'
p11130
ag59
as(I26
I27
tp11131
(lp11132
S'\tif (diag_mask_clear_param)'
p11133
aS'\t\tdiag_clear_masks(session_info);'
p11134
as(I11
I11
tp11135
(lp11136
S'\tif (!session_info)'
p11137
as(I40
I40
tp11138
(lp11139
S'\tparams.req_mode = USB_MODE;'
p11140
as(I60
I60
tp11141
(lp11142
g59
as(I29
I31
tp11143
(lp11144
S'\tmutex_lock(&driver->diag_maskclear_mutex);'
p11145
aS'\tdriver->mask_clear = 1;'
p11146
aS'\tmutex_unlock(&driver->diag_maskclear_mutex);'
p11147
assg14
(dp11148
(I24
I24
tp11149
(lp11150
S'\t}'
p11151
as(I26
I27
tp11152
(lp11153
S'\tsession_mask = session_info->peripheral_mask;'
p11154
aS'\tmutex_unlock(&driver->md_session_lock);'
p11155
as(I60
I62
tp11156
(lp11157
S'\tmutex_lock(&driver->md_session_lock);'
p11158
aS'\tdiag_md_session_close(pid);'
p11159
aS'\tmutex_unlock(&driver->md_session_lock);'
p11160
as(I40
I44
tp11161
(lp11162
S'\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)'
p11163
aS'\t\tparams.req_mode = PCIE_MODE;'
p11164
aS'\telse'
p11165
aS'\t\tparams.req_mode = USB_MODE;'
p11166
ag59
as(I29
I30
tp11167
(lp11168
S'\tif (diag_mask_clear_param)'
p11169
aS'\t\tdiag_clear_masks(pid);'
p11170
as(I9
I9
tp11171
(lp11172
S'\tmutex_lock(&driver->md_session_lock);'
p11173
as(I11
I22
tp11174
(lp11175
S'\tif (!session_info) {'
p11176
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11177
aS'\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)'
p11178
aS'\t\t\tparams.req_mode = PCIE_MODE;'
p11179
aS'\t\telse'
p11180
aS'\t\t\tparams.req_mode = USB_MODE;'
p11181
aS'\t\tparams.mode_param = 0;'
p11182
aS'\t\tparams.pd_mask = 0;'
p11183
aS'\t\tparams.peripheral_mask = DIAG_CON_ALL;'
p11184
aS'\t\tmutex_lock(&driver->diagchar_mutex);'
p11185
aS'\t\tdiag_switch_logging(&params);'
p11186
aS'\t\tmutex_unlock(&driver->diagchar_mutex);'
p11187
assg32
I1
sg12
g13
sg41
(I1
I65
tp11188
sssS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tmutex_lock(&driver->diagchar_mutex);\n\t\tif (driver->pcie_switch_pid == pid) {\n\t\t\tif (driver->pcie_transport_def ==\n\t\t\t\tDIAG_ROUTE_TO_PCIE)\n\t\t\t\tparams.req_mode = PCIE_MODE;\n\t\t\telse\n\t\t\t\tparams.req_mode = USB_MODE;\n\t\t\tparams.mode_param = 0;\n\t\t\tparams.pd_mask = 0;\n\t\t\tparams.peripheral_mask = DIAG_CON_ALL;\n\t\t\tdiag_switch_logging(&params);\n\t\t\tdriver->pcie_switch_pid = 0;\n\t\t}\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\treturn;\n\t}\n\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\tparams.req_mode = PCIE_MODE;\n\telse\n\t\tparams.req_mode = USB_MODE;\n\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p11189
(dp11190
((g10116
g10983
tp11191
I1
tp11192
(dp11193
g33
(dp11194
(I33
I35
tp11195
(lp11196
S'\tmutex_lock(&driver->diag_maskclear_mutex);'
p11197
aS'\tdriver->mask_clear = 1;'
p11198
aS'\tmutex_unlock(&driver->diag_maskclear_mutex);'
p11199
as(I30
I31
tp11200
(lp11201
S'\tif (diag_mask_clear_param)'
p11202
aS'\t\tdiag_clear_masks(session_info);'
p11203
as(I11
I11
tp11204
(lp11205
S'\tif (!session_info)'
p11206
as(I64
I64
tp11207
(lp11208
g59
as(I37
I39
tp11209
(lp11210
S'\tsession_mask = session_info->peripheral_mask;'
p11211
aS'\tdiag_md_session_close(session_info);'
p11212
ag59
as(I44
I44
tp11213
(lp11214
S'\tparams.req_mode = USB_MODE;'
p11215
assg14
(dp11216
(I33
I34
tp11217
(lp11218
S'\tif (diag_mask_clear_param)'
p11219
aS'\t\tdiag_clear_masks(pid);'
p11220
as(I11
I26
tp11221
(lp11222
S'\tif (!session_info) {'
p11223
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11224
aS'\t\tmutex_lock(&driver->diagchar_mutex);'
p11225
aS'\t\tif (driver->pcie_switch_pid == pid) {'
p11226
aS'\t\t\tif (driver->pcie_transport_def =='
p11227
aS'\t\t\t\tDIAG_ROUTE_TO_PCIE)'
p11228
aS'\t\t\t\tparams.req_mode = PCIE_MODE;'
p11229
aS'\t\t\telse'
p11230
aS'\t\t\t\tparams.req_mode = USB_MODE;'
p11231
aS'\t\t\tparams.mode_param = 0;'
p11232
aS'\t\t\tparams.pd_mask = 0;'
p11233
aS'\t\t\tparams.peripheral_mask = DIAG_CON_ALL;'
p11234
aS'\t\t\tdiag_switch_logging(&params);'
p11235
aS'\t\t\tdriver->pcie_switch_pid = 0;'
p11236
aS'\t\t}'
p11237
aS'\t\tmutex_unlock(&driver->diagchar_mutex);'
p11238
as(I30
I31
tp11239
(lp11240
S'\tsession_mask = session_info->peripheral_mask;'
p11241
aS'\tmutex_unlock(&driver->md_session_lock);'
p11242
as(I44
I48
tp11243
(lp11244
S'\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)'
p11245
aS'\t\tparams.req_mode = PCIE_MODE;'
p11246
aS'\telse'
p11247
aS'\t\tparams.req_mode = USB_MODE;'
p11248
ag59
as(I28
I28
tp11249
(lp11250
S'\t}'
p11251
as(I9
I9
tp11252
(lp11253
S'\tmutex_lock(&driver->md_session_lock);'
p11254
as(I64
I66
tp11255
(lp11256
S'\tmutex_lock(&driver->md_session_lock);'
p11257
aS'\tdiag_md_session_close(pid);'
p11258
aS'\tmutex_unlock(&driver->md_session_lock);'
p11259
assg32
I1
sg12
g13
sg41
(I1
I69
tp11260
ssss(g10002
S'diag_hdlc_start_recovery'
p11261
tp11262
(dp11263
S'static void diag_hdlc_start_recovery(unsigned char *buf, int len,\n\t\t\t\t     int pid)\n{\n\tint i;\n\tstatic uint32_t bad_byte_counter;\n\tunsigned char *start_ptr = NULL;\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\thdlc_reset = 1;\n\thdlc_reset_timer_start(pid);\n\n\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (actual_pkt->start == CONTROL_CHAR &&\n\t\t\t\tactual_pkt->version == 1 &&\n\t\t\t\tactual_pkt->length < len &&\n\t\t\t\t(*(uint8_t *)(buf +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) +\n\t\t\t\tactual_pkt->length) == CONTROL_CHAR)) {\n\t\t\tstart_ptr = &buf[i];\n\t\t\tbreak;\n\t\t}\n\t\tbad_byte_counter++;\n\t\tif (bad_byte_counter > (DIAG_MAX_REQ_SIZE +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) + 1)) {\n\t\t\tbad_byte_counter = 0;\n\t\t\tpr_err("diag: In %s, re-enabling HDLC encoding\\n",\n\t\t\t\t\t__func__);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tinfo = diag_md_session_get_pid(pid);\n\t\t\tif (info)\n\t\t\t\tinfo->hdlc_disabled = 0;\n\t\t\telse\n\t\t\t\tdriver->hdlc_disabled = 0;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (start_ptr) {\n\t\t/* Discard any partial packet reads */\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tdriver->incoming_pkt.processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, pid);\n\t}\n}'
p11264
(dp11265
((g10002
g11261
tp11266
I1
tp11267
(dp11268
g12
g13
sg14
(dp11269
(I8
I8
tp11270
(lp11271
S'\tstruct diag_md_session_t *info = NULL;'
p11272
as(I37
I37
tp11273
(lp11274
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p11275
as(I2
I2
tp11276
(lp11277
S'\t\t\t\t     int pid)'
p11278
as(I50
I50
tp11279
(lp11280
S'\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, pid);'
p11281
as(I31
I32
tp11282
(lp11283
S'\t\t\tmutex_lock(&driver->md_session_lock);'
p11284
aS'\t\t\tinfo = diag_md_session_get_pid(pid);'
p11285
as(I11
I11
tp11286
(lp11287
S'\thdlc_reset_timer_start(pid);'
p11288
assg32
I3
sg33
(dp11289
(I50
I50
tp11290
(lp11291
S'\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, info);'
p11292
as(I11
I11
tp11293
(lp11294
S'\thdlc_reset_timer_start(info);'
p11295
as(I2
I2
tp11296
(lp11297
S'\t\t\t\t     struct diag_md_session_t *info)'
p11298
assg41
(I1
I52
tp11299
sssS'static void diag_hdlc_start_recovery(unsigned char *buf, int len,\n\t\t\t\t     int pid)\n{\n\tint i, peripheral = -EINVAL;\n\tstatic uint32_t bad_byte_counter;\n\tunsigned char *start_ptr = NULL;\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\thdlc_reset = 1;\n\thdlc_reset_timer_start(pid);\n\n\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (actual_pkt->start == CONTROL_CHAR &&\n\t\t\t\tactual_pkt->version == 1 &&\n\t\t\t\tactual_pkt->length < len &&\n\t\t\t\t(*(uint8_t *)(buf +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) +\n\t\t\t\tactual_pkt->length) == CONTROL_CHAR)) {\n\t\t\tstart_ptr = &buf[i];\n\t\t\tbreak;\n\t\t}\n\t\tbad_byte_counter++;\n\t\tif (bad_byte_counter > (DIAG_MAX_REQ_SIZE +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) + 1)) {\n\t\t\tbad_byte_counter = 0;\n\t\t\tpr_err("diag: In %s, re-enabling HDLC encoding\\n",\n\t\t\t\t\t__func__);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tinfo = diag_md_session_get_pid(pid);\n\t\t\tif (info)\n\t\t\t\tinfo->hdlc_disabled = 0;\n\t\t\telse\n\t\t\t\tdriver->hdlc_disabled = 0;\n\n\t\t\tperipheral =\n\t\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif (peripheral > 0 && info) {\n\t\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\t\telse if (\n\t\t\t\t\t!diag_md_session_get_peripheral(i))\n\t\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t\t} else {\n\t\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (start_ptr) {\n\t\t/* Discard any partial packet reads */\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tdriver->incoming_pkt.processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, pid);\n\t}\n}'
p11300
(dp11301
((g10002
g11261
tp11302
I1
tp11303
(dp11304
g12
g13
sg14
(dp11305
(I8
I8
tp11306
(lp11307
S'\tstruct diag_md_session_t *info = NULL;'
p11308
as(I11
I11
tp11309
(lp11310
S'\thdlc_reset_timer_start(pid);'
p11311
as(I2
I2
tp11312
(lp11313
S'\t\t\t\t     int pid)'
p11314
as(I68
I68
tp11315
(lp11316
S'\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, pid);'
p11317
as(I4
I4
tp11318
(lp11319
S'\tint i, peripheral = -EINVAL;'
p11320
as(I31
I32
tp11321
(lp11322
S'\t\t\tmutex_lock(&driver->md_session_lock);'
p11323
aS'\t\t\tinfo = diag_md_session_get_pid(pid);'
p11324
as(I37
I55
tp11325
(lp11326
g59
aS'\t\t\tperipheral ='
p11327
aS'\t\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);'
p11328
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p11329
aS'\t\t\t\tif (peripheral > 0 && info) {'
p11330
aS'\t\t\t\t\tif (peripheral & (1 << i))'
p11331
aS'\t\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p11332
aS'\t\t\t\t\t\tinfo->hdlc_disabled;'
p11333
aS'\t\t\t\t\telse if ('
p11334
aS'\t\t\t\t\t!diag_md_session_get_peripheral(i))'
p11335
aS'\t\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p11336
aS'\t\t\t\t\t\tdriver->hdlc_disabled;'
p11337
aS'\t\t\t\t} else {'
p11338
aS'\t\t\t\t\tif (!diag_md_session_get_peripheral(i))'
p11339
aS'\t\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p11340
aS'\t\t\t\t\t\tdriver->hdlc_disabled;'
p11341
aS'\t\t\t\t}'
p11342
aS'\t\t\t}'
p11343
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p11344
assg32
I3
sg33
(dp11345
(I68
I68
tp11346
(lp11347
S'\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, info);'
p11348
as(I4
I4
tp11349
(lp11350
S'\tint i;'
p11351
as(I11
I11
tp11352
(lp11353
S'\thdlc_reset_timer_start(info);'
p11354
as(I2
I2
tp11355
(lp11356
S'\t\t\t\t     struct diag_md_session_t *info)'
p11357
assg41
(I1
I70
tp11358
ssss(g10002
S'diag_send_rsp'
p11359
tp11360
(dp11361
S'static void diag_send_rsp(unsigned char *buf, int len,\n\tint pid)\n{\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tsession_info = (info) ? info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (hdlc_disabled)\n\t\tpack_rsp_and_send(buf, len, pid);\n\telse\n\t\tencode_rsp_and_send(buf, len, pid);\n}'
p11362
(dp11363
((g10002
g11359
tp11364
I1
tp11365
(dp11366
g12
g13
sg14
(dp11367
(I20
I20
tp11368
(lp11369
S'\t\tencode_rsp_and_send(buf, len, pid);'
p11370
as(I18
I18
tp11371
(lp11372
S'\t\tpack_rsp_and_send(buf, len, pid);'
p11373
as(I2
I2
tp11374
(lp11375
S'\tint pid)'
p11376
as(I4
I4
tp11377
(lp11378
S'\tstruct diag_md_session_t *session_info = NULL, *info = NULL;'
p11379
as(I7
I8
tp11380
(lp11381
S'\tmutex_lock(&driver->md_session_lock);'
p11382
aS'\tinfo = diag_md_session_get_pid(pid);'
p11383
as(I15
I15
tp11384
(lp11385
S'\tmutex_unlock(&driver->md_session_lock);'
p11386
assg32
I3
sg33
(dp11387
(I18
I18
tp11388
(lp11389
S'\t\tpack_rsp_and_send(buf, len, session_info);'
p11390
as(I4
I4
tp11391
(lp11392
S'\tstruct diag_md_session_t *session_info = NULL;'
p11393
as(I20
I20
tp11394
(lp11395
S'\t\tencode_rsp_and_send(buf, len, session_info);'
p11396
as(I2
I2
tp11397
(lp11398
S'\tstruct diag_md_session_t *info)'
p11399
assg41
(I1
I21
tp11400
sssS'static void diag_send_rsp(unsigned char *buf, int len,\n\tint pid)\n{\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\tuint8_t hdlc_disabled;\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tsession_info = (info) ? info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled)\n\t\tpack_rsp_and_send(buf, len, pid);\n\telse\n\t\tencode_rsp_and_send(buf, len, pid);\n}'
p11401
(dp11402
((g10002
g11359
tp11403
I1
tp11404
(dp11405
g12
g13
sg14
(dp11406
(I16
I16
tp11407
(lp11408
S'\t\tpack_rsp_and_send(buf, len, pid);'
p11409
as(I6
I7
tp11410
(lp11411
S'\tmutex_lock(&driver->md_session_lock);'
p11412
aS'\tinfo = diag_md_session_get_pid(pid);'
p11413
as(I14
I14
tp11414
(lp11415
S'\tmutex_unlock(&driver->md_session_lock);'
p11416
as(I18
I18
tp11417
(lp11418
S'\t\tencode_rsp_and_send(buf, len, pid);'
p11419
as(I4
I4
tp11420
(lp11421
S'\tstruct diag_md_session_t *session_info = NULL, *info = NULL;'
p11422
as(I2
I2
tp11423
(lp11424
S'\tint pid)'
p11425
assg32
I3
sg33
(dp11426
(I16
I16
tp11427
(lp11428
S'\t\tpack_rsp_and_send(buf, len, session_info);'
p11429
as(I14
I14
tp11430
(lp11431
g59
as(I6
I6
tp11432
(lp11433
g59
as(I18
I18
tp11434
(lp11435
S'\t\tencode_rsp_and_send(buf, len, session_info);'
p11436
as(I4
I4
tp11437
(lp11438
S'\tstruct diag_md_session_t *session_info = NULL;'
p11439
as(I2
I2
tp11440
(lp11441
S'\tstruct diag_md_session_t *info)'
p11442
assg41
(I1
I19
tp11443
ssss(g10116
S'diag_ioctl_hdlc_toggle'
p11444
tp11445
(dp11446
S'static int diag_ioctl_hdlc_toggle(unsigned long ioarg)\n{\n\tuint8_t hdlc_support;\n\tstruct diag_md_session_t *session_info = NULL;\n\tif (copy_from_user(&hdlc_support, (void __user *)ioarg,\n\t\t\t\tsizeof(uint8_t)))\n\t\treturn -EFAULT;\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(current->tgid);\n\tif (session_info)\n\t\tsession_info->hdlc_disabled = hdlc_support;\n\telse\n\t\tdriver->hdlc_disabled = hdlc_support;\n\tmutex_unlock(&driver->md_session_lock);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\treturn 0;\n}'
p11447
(dp11448
((g10116
g11444
tp11449
I1
tp11450
(dp11451
g12
g13
sg14
(dp11452
(I9
I11
tp11453
(lp11454
S'\tmutex_lock(&driver->md_session_lock);'
p11455
aS'\tsession_info = diag_md_session_get_pid(current->tgid);'
p11456
aS'\tif (session_info)'
p11457
as(I13
I13
tp11458
(lp11459
S'\telse'
p11460
as(I15
I15
tp11461
(lp11462
S'\tmutex_unlock(&driver->md_session_lock);'
p11463
assg32
I1
sg33
(dp11464
(I9
I10
tp11465
(lp11466
S'\tif (session_info) {'
p11467
aS'\t\tmutex_lock(&driver->md_session_lock);'
p11468
as(I13
I14
tp11469
(lp11470
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11471
aS'\t} else'
p11472
as(I5
I7
tp11473
(lp11474
S'\tmutex_lock(&driver->md_session_lock);'
p11475
aS'\tsession_info = diag_md_session_get_pid(current->tgid);'
p11476
aS'\tmutex_unlock(&driver->md_session_lock);'
p11477
assg41
(I1
I20
tp11478
sssS'static int diag_ioctl_hdlc_toggle(unsigned long ioarg)\n{\n\tuint8_t hdlc_support, i;\n\tint peripheral = -EINVAL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (copy_from_user(&hdlc_support, (void __user *)ioarg,\n\t\t\t\tsizeof(uint8_t)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(current->tgid);\n\tif (session_info)\n\t\tsession_info->hdlc_disabled = hdlc_support;\n\telse\n\t\tdriver->hdlc_disabled = hdlc_support;\n\n\tperipheral =\n\t\tdiag_md_session_match_pid_peripheral(current->tgid,\n\t\t0);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (peripheral > 0 && session_info) {\n\t\t\tif (peripheral & (1 << i))\n\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\tsession_info->hdlc_disabled;\n\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\tdriver->hdlc_disabled;\n\t\t} else {\n\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\tdriver->hdlc_disabled;\n\t\t}\n\t}\n\n\tmutex_unlock(&driver->md_session_lock);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\treturn 0;\n}'
p11479
(dp11480
((g10116
g11444
tp11481
I1
tp11482
(dp11483
g12
g13
sg14
(dp11484
(I16
I16
tp11485
(lp11486
S'\telse'
p11487
as(I12
I14
tp11488
(lp11489
S'\tmutex_lock(&driver->md_session_lock);'
p11490
aS'\tsession_info = diag_md_session_get_pid(current->tgid);'
p11491
aS'\tif (session_info)'
p11492
as(I10
I10
tp11493
(lp11494
g59
as(I18
I37
tp11495
(lp11496
g59
aS'\tperipheral ='
p11497
aS'\t\tdiag_md_session_match_pid_peripheral(current->tgid,'
p11498
aS'\t\t0);'
p11499
aS'\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p11500
aS'\t\tif (peripheral > 0 && session_info) {'
p11501
aS'\t\t\tif (peripheral & (1 << i))'
p11502
aS'\t\t\t\tdriver->p_hdlc_disabled[i] ='
p11503
aS'\t\t\t\tsession_info->hdlc_disabled;'
p11504
aS'\t\t\telse if (!diag_md_session_get_peripheral(i))'
p11505
aS'\t\t\t\tdriver->p_hdlc_disabled[i] ='
p11506
aS'\t\t\t\tdriver->hdlc_disabled;'
p11507
aS'\t\t} else {'
p11508
aS'\t\t\tif (!diag_md_session_get_peripheral(i))'
p11509
aS'\t\t\t\tdriver->p_hdlc_disabled[i] ='
p11510
aS'\t\t\t\tdriver->hdlc_disabled;'
p11511
aS'\t\t}'
p11512
aS'\t}'
p11513
ag59
aS'\tmutex_unlock(&driver->md_session_lock);'
p11514
as(I6
I6
tp11515
(lp11516
g59
as(I3
I4
tp11517
(lp11518
S'\tuint8_t hdlc_support, i;'
p11519
aS'\tint peripheral = -EINVAL;'
p11520
assg32
I1
sg33
(dp11521
(I12
I13
tp11522
(lp11523
S'\tif (session_info) {'
p11524
aS'\t\tmutex_lock(&driver->md_session_lock);'
p11525
as(I16
I17
tp11526
(lp11527
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11528
aS'\t} else'
p11529
as(I3
I3
tp11530
(lp11531
S'\tuint8_t hdlc_support;'
p11532
as(I6
I8
tp11533
(lp11534
S'\tmutex_lock(&driver->md_session_lock);'
p11535
aS'\tsession_info = diag_md_session_get_pid(current->tgid);'
p11536
aS'\tmutex_unlock(&driver->md_session_lock);'
p11537
assg41
(I1
I42
tp11538
ssss(g10002
S'diagfwd_mux_read_done'
p11539
tp11540
(dp11541
S'static int diagfwd_mux_read_done(unsigned char *buf, int len, int ctxt)\n{\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (!driver->hdlc_disabled)\n\t\tdiag_process_hdlc_pkt(buf, len, 0);\n\telse\n\t\tdiag_process_non_hdlc_pkt(buf, len, 0);\n\n\tdiag_mux_queue_read(ctxt);\n\treturn 0;\n}'
p11542
(dp11543
((g10002
g11539
tp11544
I1
tp11545
(dp11546
g12
g13
sg14
(dp11547
(I7
I7
tp11548
(lp11549
S'\t\tdiag_process_hdlc_pkt(buf, len, 0);'
p11550
as(I9
I9
tp11551
(lp11552
S'\t\tdiag_process_non_hdlc_pkt(buf, len, 0);'
p11553
assg32
I3
sg33
(dp11554
(I7
I7
tp11555
(lp11556
S'\t\tdiag_process_hdlc_pkt(buf, len, NULL);'
p11557
as(I9
I9
tp11558
(lp11559
S'\t\tdiag_process_non_hdlc_pkt(buf, len, NULL);'
p11560
assg41
(I1
I13
tp11561
ssss(g10026
S'diag_cmd_get_msg_mask'
p11562
tp11563
(dp11564
S'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p11565
(dp11566
((g10026
g11562
tp11567
I1
tp11568
(dp11569
g12
g13
sg14
(dp11570
(I32
I33
tp11571
(lp11572
S'\tif (!diag_apps_responds()) {'
p11573
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11574
as(I12
I15
tp11575
(lp11576
S'\tstruct diag_md_session_t *info = NULL;'
p11577
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p11578
aS'\tinfo = diag_md_session_get_pid(pid);'
p11579
as(I38
I39
tp11580
(lp11581
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p11582
aS'\t\t\tdriver->msg_mask_tbl_count;'
p11583
as(I35
I35
tp11584
(lp11585
S'\t}'
p11586
as(I74
I74
tp11587
(lp11588
S'\tmutex_unlock(&driver->md_session_lock);'
p11589
as(I52
I52
tp11590
(lp11591
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11592
as(I23
I23
tp11593
(lp11594
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11595
as(I7
I7
tp11596
(lp11597
S'\tuint8_t msg_mask_tbl_count = 0;'
p11598
as(I2
I2
tp11599
(lp11600
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11601
as(I55
I57
tp11602
(lp11603
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p11604
aS'\t\tif (!mask->ptr)'
p11605
aS'\t\t\tcontinue;'
p11606
as(I29
I29
tp11607
(lp11608
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11609
assg32
I5
sg33
(dp11610
(I32
I32
tp11611
(lp11612
S'\tif (!diag_apps_responds())'
p11613
as(I2
I3
tp11614
(lp11615
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p11616
aS'\t\t\t\t struct diag_md_session_t *info)'
p11617
as(I55
I55
tp11618
(lp11619
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p11620
assg41
(I1
I76
tp11621
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p11622
(dp11623
((g10026
g11562
tp11624
I1
tp11625
(dp11626
g12
g13
sg14
(dp11627
(I32
I33
tp11628
(lp11629
S'\tif (!diag_apps_responds()) {'
p11630
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11631
as(I12
I15
tp11632
(lp11633
S'\tstruct diag_md_session_t *info = NULL;'
p11634
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p11635
aS'\tinfo = diag_md_session_get_pid(pid);'
p11636
as(I38
I39
tp11637
(lp11638
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p11639
aS'\t\t\tdriver->msg_mask_tbl_count;'
p11640
as(I35
I35
tp11641
(lp11642
S'\t}'
p11643
as(I74
I74
tp11644
(lp11645
S'\tmutex_unlock(&driver->md_session_lock);'
p11646
as(I52
I52
tp11647
(lp11648
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11649
as(I23
I23
tp11650
(lp11651
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11652
as(I7
I7
tp11653
(lp11654
S'\tuint8_t msg_mask_tbl_count = 0;'
p11655
as(I18
I19
tp11656
(lp11657
S'\tif (!src_buf || !dest_buf || dest_len <= 0 ||'
p11658
aS'\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {'
p11659
as(I2
I2
tp11660
(lp11661
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11662
as(I55
I57
tp11663
(lp11664
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p11665
aS'\t\tif (!mask->ptr)'
p11666
aS'\t\t\tcontinue;'
p11667
as(I29
I29
tp11668
(lp11669
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11670
assg32
I5
sg33
(dp11671
(I18
I19
tp11672
(lp11673
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p11674
aS'\t    !mask_info) {'
p11675
as(I32
I32
tp11676
(lp11677
S'\tif (!diag_apps_responds())'
p11678
as(I2
I3
tp11679
(lp11680
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p11681
aS'\t\t\t\t struct diag_md_session_t *info)'
p11682
as(I55
I55
tp11683
(lp11684
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p11685
assg41
(I1
I76
tp11686
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p11687
(dp11688
((g10026
g11562
tp11689
I1
tp11690
(dp11691
g12
g13
sg14
(dp11692
(I34
I34
tp11693
(lp11694
S'\t}'
p11695
as(I69
I69
tp11696
(lp11697
S'\tmutex_unlock(&driver->md_session_lock);'
p11698
as(I11
I14
tp11699
(lp11700
S'\tstruct diag_md_session_t *info = NULL;'
p11701
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p11702
aS'\tinfo = diag_md_session_get_pid(pid);'
p11703
as(I22
I22
tp11704
(lp11705
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11706
as(I28
I28
tp11707
(lp11708
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11709
as(I31
I32
tp11710
(lp11711
S'\tif (!diag_apps_responds()) {'
p11712
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11713
as(I2
I2
tp11714
(lp11715
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11716
as(I49
I49
tp11717
(lp11718
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11719
assg32
I5
sg33
(dp11720
(I2
I3
tp11721
(lp11722
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p11723
aS'\t\t\t\t struct diag_md_session_t *info)'
p11724
as(I31
I31
tp11725
(lp11726
S'\tif (!diag_apps_responds())'
p11727
assg41
(I1
I71
tp11728
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p11729
(dp11730
((g10026
g11562
tp11731
I1
tp11732
(dp11733
g12
g13
sg14
(dp11734
(I71
I71
tp11735
(lp11736
S'\tmutex_unlock(&driver->md_session_lock);'
p11737
as(I34
I34
tp11738
(lp11739
S'\t}'
p11740
as(I11
I14
tp11741
(lp11742
S'\tstruct diag_md_session_t *info = NULL;'
p11743
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p11744
aS'\tinfo = diag_md_session_get_pid(pid);'
p11745
as(I22
I22
tp11746
(lp11747
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11748
as(I53
I54
tp11749
(lp11750
S'\t\tif (!mask->ptr)'
p11751
aS'\t\t\tcontinue;'
p11752
as(I28
I28
tp11753
(lp11754
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11755
as(I31
I32
tp11756
(lp11757
S'\tif (!diag_apps_responds()) {'
p11758
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11759
as(I2
I2
tp11760
(lp11761
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11762
as(I49
I49
tp11763
(lp11764
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11765
assg32
I5
sg33
(dp11766
(I2
I3
tp11767
(lp11768
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p11769
aS'\t\t\t\t struct diag_md_session_t *info)'
p11770
as(I31
I31
tp11771
(lp11772
S'\tif (!diag_apps_responds())'
p11773
assg41
(I1
I73
tp11774
sssS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p11775
(dp11776
((g10026
g11562
tp11777
I1
tp11778
(dp11779
g12
g13
sg14
(dp11780
(I32
I33
tp11781
(lp11782
S'\tif (!diag_apps_responds()) {'
p11783
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p11784
as(I12
I15
tp11785
(lp11786
S'\tstruct diag_md_session_t *info = NULL;'
p11787
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p11788
aS'\tinfo = diag_md_session_get_pid(pid);'
p11789
as(I38
I39
tp11790
(lp11791
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p11792
aS'\t\t\tdriver->msg_mask_tbl_count;'
p11793
as(I35
I35
tp11794
(lp11795
S'\t}'
p11796
as(I74
I74
tp11797
(lp11798
S'\tmutex_unlock(&driver->md_session_lock);'
p11799
as(I52
I52
tp11800
(lp11801
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11802
as(I23
I23
tp11803
(lp11804
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11805
as(I7
I7
tp11806
(lp11807
S'\tuint8_t msg_mask_tbl_count = 0;'
p11808
as(I2
I2
tp11809
(lp11810
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11811
as(I55
I57
tp11812
(lp11813
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p11814
aS'\t\tif (!mask->ptr)'
p11815
aS'\t\t\tcontinue;'
p11816
as(I19
I19
tp11817
(lp11818
S'\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {'
p11819
as(I29
I29
tp11820
(lp11821
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11822
assg32
I5
sg33
(dp11823
(I32
I32
tp11824
(lp11825
S'\tif (!diag_apps_responds())'
p11826
as(I2
I3
tp11827
(lp11828
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p11829
aS'\t\t\t\t struct diag_md_session_t *info)'
p11830
as(I19
I19
tp11831
(lp11832
S'\t    !mask_info) {'
p11833
as(I55
I55
tp11834
(lp11835
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p11836
assg41
(I1
I76
tp11837
ssss(g9919
S'diagfwd_data_process_done'
p11838
tp11839
(dp11840
S'static void diagfwd_data_process_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   struct diagfwd_buf_t *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0, peripheral = 0;\n\tunsigned char *write_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t__func__, fwd_info->type,\n\t\t\tfwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\tperipheral =\n\t\tdiag_md_get_peripheral(buf->ctxt);\n\tif (peripheral < 0) {\n\t\tpr_err("diag:%s:%d invalid peripheral = %d\\n",\n\t\t\t__func__, __LINE__, peripheral);\n\t\tmutex_unlock(&fwd_info->data_mutex);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\thdlc_disabled = driver->p_hdlc_disabled[peripheral];\n\n\tif (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\tif (write_len <= 0)\n\t\t\tgoto end;\n\t\twrite_buf = buf->data_raw;\n\t} else {\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\n\t\twrite_len = check_bufsize_for_encoding(buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len,\n\t\t\tbuf->data_raw, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p11841
(dp11842
((g9919
g11838
tp11843
I1
tp11844
(dp11845
g12
g13
sg14
(dp11846
(I40
I40
tp11847
(lp11848
S'\thdlc_disabled = driver->p_hdlc_disabled[peripheral];'
p11849
assg32
I3
sg33
(dp11850
(I40
I45
tp11851
(lp11852
S'\tsession_info ='
p11853
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p11854
aS'\tif (session_info)'
p11855
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p11856
aS'\telse'
p11857
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p11858
as(I7
I7
tp11859
(lp11860
S'\tstruct diag_md_session_t *session_info = NULL;'
p11861
assg41
(I1
I109
tp11862
sssS'static void diagfwd_data_process_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   struct diagfwd_buf_t *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0, peripheral = 0;\n\tunsigned char *write_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t__func__, fwd_info->type,\n\t\t\tfwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\tperipheral =\n\t\tdiag_md_get_peripheral(buf->ctxt);\n\tif (peripheral < 0) {\n\t\tpr_err("diag:%s:%d invalid peripheral = %d\\n",\n\t\t\t__func__, __LINE__, peripheral);\n\t\tmutex_unlock(&fwd_info->data_mutex);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\thdlc_disabled = driver->p_hdlc_disabled[peripheral];\n\n\tif (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\tif (write_len <= 0)\n\t\t\tgoto end;\n\t\twrite_buf = buf->data_raw;\n\t} else {\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\n\t\twrite_len = check_bufsize_for_encoding(buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len,\n\t\t\tbuf->data_raw, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end_write;\n\t\t}\n\t}\n\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\nend_write:\n\tdiag_ws_release();\n\tif (buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p11863
(dp11864
((g9919
g11838
tp11865
I1
tp11866
(dp11867
g12
g13
sg14
(dp11868
(I81
I82
tp11869
(lp11870
S'\tmutex_unlock(&fwd_info->data_mutex);'
p11871
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p11872
as(I100
I101
tp11873
(lp11874
S'end_write:'
p11875
aS'\tdiag_ws_release();'
p11876
as(I40
I40
tp11877
(lp11878
S'\thdlc_disabled = driver->p_hdlc_disabled[peripheral];'
p11879
as(I93
I93
tp11880
(lp11881
g59
as(I90
I90
tp11882
(lp11883
S'\t\t\tgoto end_write;'
p11884
assg32
I3
sg33
(dp11885
(I93
I94
tp11886
(lp11887
S'\tmutex_unlock(&fwd_info->data_mutex);'
p11888
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p11889
as(I98
I98
tp11890
(lp11891
S'\tdiag_ws_release();'
p11892
as(I40
I45
tp11893
(lp11894
S'\tsession_info ='
p11895
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p11896
aS'\tif (session_info)'
p11897
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p11898
aS'\telse'
p11899
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p11900
as(I7
I7
tp11901
(lp11902
S'\tstruct diag_md_session_t *session_info = NULL;'
p11903
as(I90
I90
tp11904
(lp11905
S'\t\t\tgoto end;'
p11906
assg41
(I1
I111
tp11907
sssS'static void diagfwd_data_process_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   struct diagfwd_buf_t *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0, peripheral = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t__func__, fwd_info->type,\n\t\t\tfwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\tperipheral =\n\t\tdiag_md_get_peripheral(buf->ctxt);\n\tif (peripheral < 0) {\n\t\tpr_err("diag:%s:%d invalid peripheral = %d\\n",\n\t\t\t__func__, __LINE__, peripheral);\n\t\tmutex_unlock(&fwd_info->data_mutex);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\tif (write_len <= 0)\n\t\t\tgoto end;\n\t\twrite_buf = buf->data_raw;\n\t} else {\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\n\t\twrite_len = check_bufsize_for_encoding(buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len,\n\t\t\tbuf->data_raw, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p11908
(dp11909
((g9919
g11838
tp11910
I1
tp11911
(dp11912
g12
g13
sg14
(dp11913
(I40
I41
tp11914
(lp11915
S'\tmutex_lock(&driver->md_session_lock);'
p11916
aS'\tsession_info = diag_md_session_get_peripheral(peripheral);'
p11917
as(I46
I46
tp11918
(lp11919
S'\tmutex_unlock(&driver->md_session_lock);'
p11920
assg32
I3
sg33
(dp11921
(I40
I42
tp11922
(lp11923
g59
aS'\tsession_info ='
p11924
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p11925
as(I46
I46
tp11926
(lp11927
g59
assg41
(I1
I114
tp11928
ssss(g10026
S'diag_cmd_get_log_range'
p11929
tp11930
(dp11931
S'static int diag_cmd_get_log_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = (struct diag_log_mask_t *)log_mask.ptr;\n\n\tif (!mask)\n\t\treturn -EINVAL;\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_RANGE;\n\trsp.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\n\tfor (i = 0; i < MAX_EQUIP_ID && write_len < dest_len; i++, mask++) {\n\t\t*(uint32_t *)(dest_buf + write_len) = mask->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t}\n\n\treturn write_len;\n}'
p11932
(dp11933
((g10026
g11929
tp11934
I1
tp11935
(dp11936
g12
g13
sg14
(dp11937
(I9
I11
tp11938
(lp11939
S'\tif (!mask)'
p11940
aS'\t\treturn -EINVAL;'
p11941
ag59
as(I15
I17
tp11942
(lp11943
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {'
p11944
aS'\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",'
p11945
aS'\t\t       __func__, src_buf, src_len, dest_buf, dest_len);'
p11946
as(I2
I2
tp11947
(lp11948
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11949
assg32
I5
sg33
(dp11950
(I15
I20
tp11951
(lp11952
S'\tmask_info = (!info) ? &log_mask : info->log_mask;'
p11953
aS'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p11954
aS'\t    !mask_info) {'
p11955
aS'\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",'
p11956
aS'\t\t       __func__, src_buf, src_len, dest_buf, dest_len,'
p11957
aS'\t\t       mask_info);'
p11958
as(I2
I3
tp11959
(lp11960
S'\t\t\t\t  unsigned char *dest_buf, int dest_len,'
p11961
aS'\t\t\t\t  struct diag_md_session_t *info)'
p11962
as(I7
I7
tp11963
(lp11964
S'\tstruct diag_mask_info *mask_info = NULL;'
p11965
assg41
(I1
I36
tp11966
ssss(g10026
S'diag_cmd_update_event_mask'
p11967
tp11968
(dp11969
S'static int diag_cmd_update_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, mask_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_event_mask_config_t);\n\tstruct diag_event_mask_config_t rsp;\n\tstruct diag_event_mask_config_t *req;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\treq = (struct diag_event_mask_config_t *)src_buf;\n\tmask_len = EVENT_COUNT_TO_BYTES(req->num_bits);\n\tif (mask_len <= 0 || mask_len > event_mask.mask_len) {\n\t\tpr_err("diag: In %s, invalid event mask len: %d\\n", __func__,\n\t\t       mask_len);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);\n\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_SET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tmemcpy(dest_buf + write_len, mask_info->ptr, mask_len);\n\twrite_len += mask_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p11970
(dp11971
((g10026
g11967
tp11972
I1
tp11973
(dp11974
g12
g13
sg14
(dp11975
(I33
I33
tp11976
(lp11977
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11978
as(I19
I19
tp11979
(lp11980
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11981
as(I2
I2
tp11982
(lp11983
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p11984
as(I41
I41
tp11985
(lp11986
S'\tmutex_unlock(&driver->md_session_lock);'
p11987
as(I11
I12
tp11988
(lp11989
S'\tmutex_lock(&driver->md_session_lock);'
p11990
aS'\tinfo = diag_md_session_get_pid(pid);'
p11991
as(I25
I25
tp11992
(lp11993
S'\t\tmutex_unlock(&driver->md_session_lock);'
p11994
as(I9
I9
tp11995
(lp11996
S'\tstruct diag_md_session_t *info = NULL;'
p11997
assg32
I5
sg33
(dp11998
(I2
I3
tp11999
(lp12000
S'\t\t\t\t      unsigned char *dest_buf, int dest_len,'
p12001
aS'\t\t\t\t      struct diag_md_session_t *info)'
p12002
assg41
(I1
I73
tp12003
sssS'static int diag_cmd_update_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, mask_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_event_mask_config_t);\n\tstruct diag_event_mask_config_t rsp;\n\tstruct diag_event_mask_config_t *req;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_event_mask_config_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\treq = (struct diag_event_mask_config_t *)src_buf;\n\tmask_len = EVENT_COUNT_TO_BYTES(req->num_bits);\n\tif (mask_len <= 0 || mask_len > event_mask.mask_len) {\n\t\tpr_err("diag: In %s, invalid event mask len: %d\\n", __func__,\n\t\t       mask_len);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tif (src_len >= header_len + mask_len)\n\t\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);\n\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_SET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tmemcpy(dest_buf + write_len, mask_info->ptr, mask_len);\n\twrite_len += mask_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p12004
(dp12005
((g10026
g11967
tp12006
I1
tp12007
(dp12008
g12
g13
sg14
(dp12009
(I33
I33
tp12010
(lp12011
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12012
as(I14
I15
tp12013
(lp12014
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p12015
aS'\t\tsrc_len < sizeof(struct diag_event_mask_config_t)) {'
p12016
as(I19
I19
tp12017
(lp12018
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12019
as(I42
I43
tp12020
(lp12021
S'\tmutex_unlock(&driver->md_session_lock);'
p12022
aS'\tif (diag_check_update(APPS_DATA, pid))'
p12023
as(I2
I2
tp12024
(lp12025
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p12026
as(I38
I39
tp12027
(lp12028
S'\tif (src_len >= header_len + mask_len)'
p12029
aS'\t\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);'
p12030
as(I62
I62
tp12031
(lp12032
S'\t\tif (!diag_check_update(i, pid))'
p12033
as(I11
I12
tp12034
(lp12035
S'\tmutex_lock(&driver->md_session_lock);'
p12036
aS'\tinfo = diag_md_session_get_pid(pid);'
p12037
as(I9
I9
tp12038
(lp12039
S'\tstruct diag_md_session_t *info = NULL;'
p12040
as(I25
I25
tp12041
(lp12042
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12043
assg32
I5
sg33
(dp12044
(I14
I15
tp12045
(lp12046
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p12047
aS'\t    !mask_info) {'
p12048
as(I42
I42
tp12049
(lp12050
S'\tif (diag_check_update(APPS_DATA))'
p12051
as(I2
I3
tp12052
(lp12053
S'\t\t\t\t      unsigned char *dest_buf, int dest_len,'
p12054
aS'\t\t\t\t      struct diag_md_session_t *info)'
p12055
as(I62
I62
tp12056
(lp12057
S'\t\tif (!diag_check_update(i))'
p12058
as(I38
I38
tp12059
(lp12060
S'\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);'
p12061
assg41
(I1
I74
tp12062
sssS'static int diag_cmd_update_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, mask_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_event_mask_config_t);\n\tstruct diag_event_mask_config_t rsp;\n\tstruct diag_event_mask_config_t *req;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\treq = (struct diag_event_mask_config_t *)src_buf;\n\tmask_len = EVENT_COUNT_TO_BYTES(req->num_bits);\n\tif (mask_len <= 0 || mask_len > event_mask.mask_len) {\n\t\tpr_err("diag: In %s, invalid event mask len: %d\\n", __func__,\n\t\t       mask_len);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);\n\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_SET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tmemcpy(dest_buf + write_len, mask_info->ptr, mask_len);\n\twrite_len += mask_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p12063
(dp12064
((g10026
g11967
tp12065
I1
tp12066
(dp12067
g12
g13
sg14
(dp12068
(I41
I42
tp12069
(lp12070
S'\tmutex_unlock(&driver->md_session_lock);'
p12071
aS'\tif (diag_check_update(APPS_DATA, pid))'
p12072
as(I33
I33
tp12073
(lp12074
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12075
as(I19
I19
tp12076
(lp12077
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12078
as(I2
I2
tp12079
(lp12080
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p12081
as(I61
I61
tp12082
(lp12083
S'\t\tif (!diag_check_update(i, pid))'
p12084
as(I11
I12
tp12085
(lp12086
S'\tmutex_lock(&driver->md_session_lock);'
p12087
aS'\tinfo = diag_md_session_get_pid(pid);'
p12088
as(I25
I25
tp12089
(lp12090
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12091
as(I9
I9
tp12092
(lp12093
S'\tstruct diag_md_session_t *info = NULL;'
p12094
assg32
I5
sg33
(dp12095
(I2
I3
tp12096
(lp12097
S'\t\t\t\t      unsigned char *dest_buf, int dest_len,'
p12098
aS'\t\t\t\t      struct diag_md_session_t *info)'
p12099
as(I41
I41
tp12100
(lp12101
S'\tif (diag_check_update(APPS_DATA))'
p12102
as(I61
I61
tp12103
(lp12104
S'\t\tif (!diag_check_update(i))'
p12105
assg41
(I1
I73
tp12106
ssss(S'drivers/char/diag/diag_memorydevice.c'
p12107
S'diag_md_write'
p12108
tp12109
(dp12110
S'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\n\tch = &diag_md[id];\n\tif (!ch || !ch->md_info_inited) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p12111
(dp12112
((g12107
g12108
tp12113
I1
tp12114
(dp12115
g12
g13
sg14
(dp12116
(I3
I3
tp12117
(lp12118
S'\tint i, peripheral, pid = 0;'
p12119
as(I74
I74
tp12120
(lp12121
S'\t\tif ((driver->client_map[i].pid != pid) ||'
p12122
as(I28
I29
tp12123
(lp12124
S'\tif (!ch || !ch->md_info_inited) {'
p12125
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12126
as(I86
I86
tp12127
(lp12128
S'\tmutex_unlock(&driver->diagchar_mutex);'
p12129
as(I63
I63
tp12130
(lp12131
S'\tmutex_unlock(&driver->md_session_lock);'
p12132
as(I24
I25
tp12133
(lp12134
S'\t}'
p12135
aS'\tpid = session_info->pid;'
p12136
as(I72
I72
tp12137
(lp12138
S'\tmutex_lock(&driver->diagchar_mutex);'
p12139
as(I19
I22
tp12140
(lp12141
S'\tmutex_lock(&driver->md_session_lock);'
p12142
aS'\tsession_info = diag_md_session_get_peripheral(peripheral);'
p12143
aS'\tif (!session_info) {'
p12144
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12145
as(I50
I50
tp12146
(lp12147
S'\t}'
p12148
as(I47
I48
tp12149
(lp12150
S'\tif (found) {'
p12151
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12152
as(I31
I31
tp12153
(lp12154
S'\t}'
p12155
assg32
I4
sg33
(dp12156
(I74
I75
tp12157
(lp12158
S'\t\tif ((driver->client_map[i].pid !='
p12159
aS'\t\t     session_info->pid) ||'
p12160
as(I3
I3
tp12161
(lp12162
S'\tint i;'
p12163
as(I7
I7
tp12164
(lp12165
S'\tint peripheral;'
p12166
as(I28
I28
tp12167
(lp12168
S'\tif (!ch)'
p12169
as(I47
I47
tp12170
(lp12171
S'\tif (found)'
p12172
as(I19
I21
tp12173
(lp12174
S'\tsession_info ='
p12175
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p12176
aS'\tif (!session_info)'
p12177
assg41
(I1
I92
tp12178
sssS'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tch = &diag_md[id];\n\tif (!ch)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p12179
(dp12180
((g12107
g12108
tp12181
I1
tp12182
(dp12183
g12
g13
sg14
(dp12184
(I69
I69
tp12185
(lp12186
S'\t\tif ((driver->client_map[i].pid != pid) ||'
p12187
as(I3
I3
tp12188
(lp12189
S'\tint i, peripheral, pid = 0;'
p12190
as(I19
I22
tp12191
(lp12192
S'\tmutex_lock(&driver->md_session_lock);'
p12193
aS'\tsession_info = diag_md_session_get_peripheral(peripheral);'
p12194
aS'\tif (!session_info) {'
p12195
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12196
as(I24
I26
tp12197
(lp12198
S'\t}'
p12199
aS'\tpid = session_info->pid;'
p12200
aS'\tmutex_unlock(&driver->md_session_lock);'
p12201
assg32
I4
sg33
(dp12202
(I69
I70
tp12203
(lp12204
S'\t\tif ((driver->client_map[i].pid !='
p12205
aS'\t\t     session_info->pid) ||'
p12206
as(I19
I21
tp12207
(lp12208
S'\tsession_info ='
p12209
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p12210
aS'\tif (!session_info)'
p12211
as(I3
I3
tp12212
(lp12213
S'\tint i;'
p12214
as(I7
I7
tp12215
(lp12216
S'\tint peripheral;'
p12217
assg41
(I1
I86
tp12218
sssS'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\n\tch = &diag_md[id];\n\tif (!ch || !ch->md_info_inited) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p12219
(dp12220
((g12107
g12108
tp12221
I1
tp12222
(dp12223
g12
g13
sg14
(dp12224
(I24
I25
tp12225
(lp12226
S'\t}'
p12227
aS'\tpid = session_info->pid;'
p12228
as(I73
I73
tp12229
(lp12230
S'\t\tif ((driver->client_map[i].pid != pid) ||'
p12231
as(I3
I3
tp12232
(lp12233
S'\tint i, peripheral, pid = 0;'
p12234
as(I19
I22
tp12235
(lp12236
S'\tmutex_lock(&driver->md_session_lock);'
p12237
aS'\tsession_info = diag_md_session_get_peripheral(peripheral);'
p12238
aS'\tif (!session_info) {'
p12239
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12240
as(I50
I50
tp12241
(lp12242
S'\t}'
p12243
as(I28
I29
tp12244
(lp12245
S'\tif (!ch || !ch->md_info_inited) {'
p12246
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12247
as(I47
I48
tp12248
(lp12249
S'\tif (found) {'
p12250
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12251
as(I31
I31
tp12252
(lp12253
S'\t}'
p12254
as(I63
I63
tp12255
(lp12256
S'\tmutex_unlock(&driver->md_session_lock);'
p12257
assg32
I4
sg33
(dp12258
(I73
I74
tp12259
(lp12260
S'\t\tif ((driver->client_map[i].pid !='
p12261
aS'\t\t     session_info->pid) ||'
p12262
as(I3
I3
tp12263
(lp12264
S'\tint i;'
p12265
as(I7
I7
tp12266
(lp12267
S'\tint peripheral;'
p12268
as(I28
I28
tp12269
(lp12270
S'\tif (!ch)'
p12271
as(I47
I47
tp12272
(lp12273
S'\tif (found)'
p12274
as(I19
I21
tp12275
(lp12276
S'\tsession_info ='
p12277
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p12278
aS'\tif (!session_info)'
p12279
assg41
(I1
I90
tp12280
sssS'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tch = &diag_md[id];\n\tif (!ch || !ch->md_info_inited)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p12281
(dp12282
((g12107
g12108
tp12283
I1
tp12284
(dp12285
g12
g13
sg14
(dp12286
(I69
I69
tp12287
(lp12288
S'\t\tif ((driver->client_map[i].pid != pid) ||'
p12289
as(I29
I29
tp12290
(lp12291
S'\tif (!ch || !ch->md_info_inited)'
p12292
as(I3
I3
tp12293
(lp12294
S'\tint i, peripheral, pid = 0;'
p12295
as(I19
I22
tp12296
(lp12297
S'\tmutex_lock(&driver->md_session_lock);'
p12298
aS'\tsession_info = diag_md_session_get_peripheral(peripheral);'
p12299
aS'\tif (!session_info) {'
p12300
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12301
as(I24
I26
tp12302
(lp12303
S'\t}'
p12304
aS'\tpid = session_info->pid;'
p12305
aS'\tmutex_unlock(&driver->md_session_lock);'
p12306
assg32
I4
sg33
(dp12307
(I69
I70
tp12308
(lp12309
S'\t\tif ((driver->client_map[i].pid !='
p12310
aS'\t\t     session_info->pid) ||'
p12311
as(I19
I21
tp12312
(lp12313
S'\tsession_info ='
p12314
aS'\t\tdiag_md_session_get_peripheral(peripheral);'
p12315
aS'\tif (!session_info)'
p12316
as(I3
I3
tp12317
(lp12318
S'\tint i;'
p12319
as(I29
I29
tp12320
(lp12321
S'\tif (!ch)'
p12322
as(I7
I7
tp12323
(lp12324
S'\tint peripheral;'
p12325
assg41
(I1
I86
tp12326
ssss(g10116
S'diag_user_process_raw_data'
p12327
tp12328
(dp12329
S'static int diag_user_process_raw_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint ret = 0;\n\tint token_offset = 0;\n\tint remote_proc = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\n\tif (!buf || len <= 0 || len > CALLBACK_BUF_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data)\n\t\treturn -ENOMEM;\n\n\terr = copy_from_user(user_space_data, buf, len);\n\tif (err) {\n\t\tpr_err("diag: copy failed for user space data\\n");\n\t\tgoto fail;\n\t}\n\n\t/* Check for proc_type */\n\tif (len >= sizeof(int))\n\t\tremote_proc = diag_get_remote(*(int *)user_space_data);\n\tif (remote_proc) {\n\t\ttoken_offset = sizeof(int);\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: In %s, possible integer underflow, payload size: %d\\n",\n\t\t       __func__, len);\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tlen -= sizeof(int);\n\t}\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(user_space_data +\n\t\t\t\t\t\ttoken_offset, len)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (remote_proc) {\n\t\tret = diag_send_raw_data_remote(remote_proc,\n\t\t\t\t(void *)(user_space_data + token_offset),\n\t\t\t\tlen, USER_SPACE_RAW_DATA);\n\t\tif (ret) {\n\t\t\tpr_err("diag: Error sending data to remote proc %d, err: %d\\n",\n\t\t\t\tremote_proc, ret);\n\t\t}\n\t} else {\n\t\twait_event_interruptible(driver->wait_q,\n\t\t\t\t\t (driver->in_busy_pktdata == 0));\n\t\tret = diag_process_apps_pkt(user_space_data, len,\n\t\t\tcurrent->tgid);\n\t\tif (ret == 1)\n\t\t\tdiag_send_error_rsp((void *)(user_space_data), len,\n\t\t\t\t\t\tcurrent->tgid);\n\t}\nfail:\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\treturn ret;\n}'
p12330
(dp12331
((g10116
g12327
tp12332
I1
tp12333
(dp12334
g12
g13
sg14
(dp12335
(I60
I61
tp12336
(lp12337
S'\t\tret = diag_process_apps_pkt(user_space_data, len,'
p12338
aS'\t\t\tcurrent->tgid);'
p12339
as(I64
I64
tp12340
(lp12341
S'\t\t\t\t\t\tcurrent->tgid);'
p12342
as(I27
I28
tp12343
(lp12344
S'\tif (len >= sizeof(int))'
p12345
aS'\t\tremote_proc = diag_get_remote(*(int *)user_space_data);'
p12346
as(I42
I42
tp12347
(lp12348
S'\t\t\t\t\t\ttoken_offset, len)) {'
p12349
assg32
I2
sg33
(dp12350
(I60
I63
tp12351
(lp12352
S'\t\tmutex_lock(&driver->md_session_lock);'
p12353
aS'\t\tinfo = diag_md_session_get_pid(current->tgid);'
p12354
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12355
aS'\t\tret = diag_process_apps_pkt(user_space_data, len, info);'
p12356
as(I42
I42
tp12357
(lp12358
S'\t\t\t\t\t\ttoken_offset)) {'
p12359
as(I64
I64
tp12360
(lp12361
S'\t\t\t\t\t\tinfo);'
p12362
as(I9
I9
tp12363
(lp12364
S'\tstruct diag_md_session_t *info = NULL;'
p12365
as(I27
I27
tp12366
(lp12367
S'\tremote_proc = diag_get_remote(*(int *)user_space_data);'
p12368
assg41
(I1
I70
tp12369
sssS'static int diag_user_process_raw_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint ret = 0;\n\tint token_offset = 0;\n\tint remote_proc = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\n\tif (!buf || len <= 0 || len > CALLBACK_BUF_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data)\n\t\treturn -ENOMEM;\n\n\terr = copy_from_user(user_space_data, buf, len);\n\tif (err) {\n\t\tpr_err("diag: copy failed for user space data\\n");\n\t\tgoto fail;\n\t}\n\n\t/* Check for proc_type */\n\tremote_proc = diag_get_remote(*(int *)user_space_data);\n\tif (remote_proc) {\n\t\ttoken_offset = sizeof(int);\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: In %s, possible integer underflow, payload size: %d\\n",\n\t\t       __func__, len);\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tlen -= sizeof(int);\n\t}\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(user_space_data +\n\t\t\t\t\t\ttoken_offset)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (remote_proc) {\n\t\tret = diag_send_raw_data_remote(remote_proc,\n\t\t\t\t(void *)(user_space_data + token_offset),\n\t\t\t\tlen, USER_SPACE_RAW_DATA);\n\t\tif (ret) {\n\t\t\tpr_err("diag: Error sending data to remote proc %d, err: %d\\n",\n\t\t\t\tremote_proc, ret);\n\t\t}\n\t} else {\n\t\twait_event_interruptible(driver->wait_q,\n\t\t\t\t\t (driver->in_busy_pktdata == 0));\n\t\tret = diag_process_apps_pkt(user_space_data, len,\n\t\t\tcurrent->tgid);\n\t\tif (ret == 1)\n\t\t\tdiag_send_error_rsp((void *)(user_space_data), len,\n\t\t\t\t\t\tcurrent->tgid);\n\t}\nfail:\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\treturn ret;\n}'
p12370
(dp12371
((g10116
g12327
tp12372
I1
tp12373
(dp12374
g12
g13
sg14
(dp12375
(I59
I60
tp12376
(lp12377
S'\t\tret = diag_process_apps_pkt(user_space_data, len,'
p12378
aS'\t\t\tcurrent->tgid);'
p12379
as(I63
I63
tp12380
(lp12381
S'\t\t\t\t\t\tcurrent->tgid);'
p12382
assg32
I2
sg33
(dp12383
(I9
I9
tp12384
(lp12385
S'\tstruct diag_md_session_t *info = NULL;'
p12386
as(I59
I62
tp12387
(lp12388
S'\t\tmutex_lock(&driver->md_session_lock);'
p12389
aS'\t\tinfo = diag_md_session_get_pid(current->tgid);'
p12390
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p12391
aS'\t\tret = diag_process_apps_pkt(user_space_data, len, info);'
p12392
as(I63
I63
tp12393
(lp12394
S'\t\t\t\t\t\tinfo);'
p12395
assg41
(I1
I69
tp12396
ssss(g10026
S'diag_process_apps_masks'
p12397
tp12398
(dp12399
S'int diag_process_apps_masks(unsigned char *buf, int len, int pid)\n{\n\tint size = 0, sub_cmd = 0;\n\tint (*hdlr)(unsigned char *src_buf, int src_len,\n\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (*buf == DIAG_CMD_LOG_CONFIG) {\n\t\tsub_cmd = *(int *)(buf + sizeof(int));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_LOG_DISABLE:\n\t\t\thdlr = diag_cmd_disable_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_RANGE:\n\t\t\thdlr = diag_cmd_get_log_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_LOG_MASK:\n\t\t\thdlr = diag_cmd_set_log_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_MASK:\n\t\t\thdlr = diag_cmd_get_log_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_MSG_CONFIG) {\n\t\tsub_cmd = *(uint8_t *)(buf + sizeof(uint8_t));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_GET_SSID_RANGE:\n\t\t\thdlr = diag_cmd_get_ssid_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_BUILD_MASK:\n\t\t\thdlr = diag_cmd_get_build_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_MSG_MASK:\n\t\t\thdlr = diag_cmd_get_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_ALL_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_all_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_GET_EVENT_MASK) {\n\t\thdlr = diag_cmd_get_event_mask;\n\t} else if (*buf == DIAG_CMD_SET_EVENT_MASK) {\n\t\thdlr = diag_cmd_update_event_mask;\n\t\tdriver->set_mask_cmd = 1;\n\t} else if (*buf == DIAG_CMD_EVENT_TOGGLE) {\n\t\thdlr = diag_cmd_toggle_events;\n\t\tdriver->set_mask_cmd = 1;\n\t}\n\n\tif (hdlr)\n\t\tsize = hdlr(buf, len, driver->apps_rsp_buf,\n\t\t\t    DIAG_MAX_RSP_SIZE, pid);\n\n\treturn (size > 0) ? size : 0;\n}'
p12400
(dp12401
((g10026
g12397
tp12402
I1
tp12403
(dp12404
g12
g13
sg14
(dp12405
(I1
I1
tp12406
(lp12407
S'int diag_process_apps_masks(unsigned char *buf, int len, int pid)'
p12408
as(I60
I60
tp12409
(lp12410
S'\t\t\t    DIAG_MAX_RSP_SIZE, pid);'
p12411
as(I21
I21
tp12412
(lp12413
S'\t\t\tdriver->set_mask_cmd = 1;'
p12414
as(I55
I55
tp12415
(lp12416
S'\t\tdriver->set_mask_cmd = 1;'
p12417
as(I5
I5
tp12418
(lp12419
S'\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;'
p12420
as(I52
I52
tp12421
(lp12422
S'\t\tdriver->set_mask_cmd = 1;'
p12423
as(I41
I41
tp12424
(lp12425
S'\t\t\tdriver->set_mask_cmd = 1;'
p12426
as(I45
I45
tp12427
(lp12428
S'\t\t\tdriver->set_mask_cmd = 1;'
p12429
assg32
I3
sg33
(dp12430
(I1
I2
tp12431
(lp12432
S'int diag_process_apps_masks(unsigned char *buf, int len,'
p12433
aS'\t\t\t    struct diag_md_session_t *info)'
p12434
as(I5
I6
tp12435
(lp12436
S'\t\t    unsigned char *dest_buf, int dest_len,'
p12437
aS'\t\t    struct diag_md_session_t *info) = NULL;'
p12438
as(I60
I60
tp12439
(lp12440
S'\t\t\t    DIAG_MAX_RSP_SIZE, info);'
p12441
assg41
(I1
I63
tp12442
sssS'int diag_process_apps_masks(unsigned char *buf, int len, int pid)\n{\n\tint size = 0, sub_cmd = 0;\n\tint (*hdlr)(unsigned char *src_buf, int src_len,\n\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (*buf == DIAG_CMD_LOG_CONFIG) {\n\t\tsub_cmd = *(int *)(buf + sizeof(int));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_LOG_DISABLE:\n\t\t\thdlr = diag_cmd_disable_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_RANGE:\n\t\t\thdlr = diag_cmd_get_log_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_LOG_MASK:\n\t\t\thdlr = diag_cmd_set_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_MASK:\n\t\t\thdlr = diag_cmd_get_log_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_MSG_CONFIG) {\n\t\tsub_cmd = *(uint8_t *)(buf + sizeof(uint8_t));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_GET_SSID_RANGE:\n\t\t\thdlr = diag_cmd_get_ssid_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_BUILD_MASK:\n\t\t\thdlr = diag_cmd_get_build_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_MSG_MASK:\n\t\t\thdlr = diag_cmd_get_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_ALL_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_all_msg_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_GET_EVENT_MASK) {\n\t\thdlr = diag_cmd_get_event_mask;\n\t} else if (*buf == DIAG_CMD_SET_EVENT_MASK) {\n\t\thdlr = diag_cmd_update_event_mask;\n\t} else if (*buf == DIAG_CMD_EVENT_TOGGLE) {\n\t\thdlr = diag_cmd_toggle_events;\n\t}\n\n\tif (hdlr)\n\t\tsize = hdlr(buf, len, driver->apps_rsp_buf,\n\t\t\t    DIAG_MAX_RSP_SIZE, pid);\n\n\treturn (size > 0) ? size : 0;\n}'
p12443
(dp12444
((g10026
g12397
tp12445
I1
tp12446
(dp12447
g12
g13
sg14
(dp12448
(I55
I55
tp12449
(lp12450
S'\t\t\t    DIAG_MAX_RSP_SIZE, pid);'
p12451
as(I1
I1
tp12452
(lp12453
S'int diag_process_apps_masks(unsigned char *buf, int len, int pid)'
p12454
as(I5
I5
tp12455
(lp12456
S'\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;'
p12457
assg32
I3
sg33
(dp12458
(I1
I2
tp12459
(lp12460
S'int diag_process_apps_masks(unsigned char *buf, int len,'
p12461
aS'\t\t\t    struct diag_md_session_t *info)'
p12462
as(I5
I6
tp12463
(lp12464
S'\t\t    unsigned char *dest_buf, int dest_len,'
p12465
aS'\t\t    struct diag_md_session_t *info) = NULL;'
p12466
as(I55
I55
tp12467
(lp12468
S'\t\t\t    DIAG_MAX_RSP_SIZE, info);'
p12469
assg41
(I1
I58
tp12470
sssS'int diag_process_apps_masks(unsigned char *buf, int len, int pid)\n{\n\tint size = 0, sub_cmd = 0;\n\tint (*hdlr)(unsigned char *src_buf, int src_len,\n\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (*buf == DIAG_CMD_LOG_CONFIG) {\n\t\tif (len < (2 * sizeof(int)))\n\t\t\treturn -EINVAL;\n\t\tsub_cmd = *(int *)(buf + sizeof(int));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_LOG_DISABLE:\n\t\t\thdlr = diag_cmd_disable_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_RANGE:\n\t\t\thdlr = diag_cmd_get_log_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_LOG_MASK:\n\t\t\thdlr = diag_cmd_set_log_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_MASK:\n\t\t\thdlr = diag_cmd_get_log_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_MSG_CONFIG) {\n\t\tif (len < (2 * sizeof(uint8_t)))\n\t\t\treturn -EINVAL;\n\t\tsub_cmd = *(uint8_t *)(buf + sizeof(uint8_t));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_GET_SSID_RANGE:\n\t\t\thdlr = diag_cmd_get_ssid_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_BUILD_MASK:\n\t\t\thdlr = diag_cmd_get_build_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_MSG_MASK:\n\t\t\thdlr = diag_cmd_get_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_ALL_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_all_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_GET_EVENT_MASK) {\n\t\thdlr = diag_cmd_get_event_mask;\n\t} else if (*buf == DIAG_CMD_SET_EVENT_MASK) {\n\t\thdlr = diag_cmd_update_event_mask;\n\t\tdriver->set_mask_cmd = 1;\n\t} else if (*buf == DIAG_CMD_EVENT_TOGGLE) {\n\t\thdlr = diag_cmd_toggle_events;\n\t\tdriver->set_mask_cmd = 1;\n\t}\n\n\tif (hdlr)\n\t\tsize = hdlr(buf, len, driver->apps_rsp_buf,\n\t\t\t    DIAG_MAX_RSP_SIZE, pid);\n\n\treturn (size > 0) ? size : 0;\n}'
p12471
(dp12472
((g10026
g12397
tp12473
I1
tp12474
(dp12475
g12
g13
sg14
(dp12476
(I56
I56
tp12477
(lp12478
S'\t\tdriver->set_mask_cmd = 1;'
p12479
as(I30
I31
tp12480
(lp12481
S'\t\tif (len < (2 * sizeof(uint8_t)))'
p12482
aS'\t\t\treturn -EINVAL;'
p12483
as(I5
I5
tp12484
(lp12485
S'\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;'
p12486
as(I45
I45
tp12487
(lp12488
S'\t\t\tdriver->set_mask_cmd = 1;'
p12489
as(I49
I49
tp12490
(lp12491
S'\t\t\tdriver->set_mask_cmd = 1;'
p12492
as(I64
I64
tp12493
(lp12494
S'\t\t\t    DIAG_MAX_RSP_SIZE, pid);'
p12495
as(I59
I59
tp12496
(lp12497
S'\t\tdriver->set_mask_cmd = 1;'
p12498
as(I11
I12
tp12499
(lp12500
S'\t\tif (len < (2 * sizeof(int)))'
p12501
aS'\t\t\treturn -EINVAL;'
p12502
as(I23
I23
tp12503
(lp12504
S'\t\t\tdriver->set_mask_cmd = 1;'
p12505
as(I1
I1
tp12506
(lp12507
S'int diag_process_apps_masks(unsigned char *buf, int len, int pid)'
p12508
assg32
I3
sg33
(dp12509
(I1
I2
tp12510
(lp12511
S'int diag_process_apps_masks(unsigned char *buf, int len,'
p12512
aS'\t\t\t    struct diag_md_session_t *info)'
p12513
as(I5
I6
tp12514
(lp12515
S'\t\t    unsigned char *dest_buf, int dest_len,'
p12516
aS'\t\t    struct diag_md_session_t *info) = NULL;'
p12517
as(I64
I64
tp12518
(lp12519
S'\t\t\t    DIAG_MAX_RSP_SIZE, info);'
p12520
assg41
(I1
I67
tp12521
ssss(g10002
S'diag_update_md_clients'
p12522
tp12523
(dp12524
S'void diag_update_md_clients(unsigned int type)\n{\n\tint i, j;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfor (j = 0; j < driver->num_clients; j++) {\n\t\t\t\tif (driver->client_map[j].pid != 0 &&\n\t\t\t\t\tdriver->client_map[j].pid ==\n\t\t\t\t\tdriver->md_session_map[i]->pid) {\n\t\t\t\t\tif (!(driver->data_ready[j] & type)) {\n\t\t\t\t\t\tdriver->data_ready[j] |= type;\n\t\t\t\t\t\tatomic_inc(\n\t\t\t\t\t\t&driver->data_ready_notif[j]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tmutex_unlock(&driver->md_session_lock);\n\twake_up_interruptible(&driver->wait_q);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p12525
(dp12526
((g10002
g12522
tp12527
I1
tp12528
(dp12529
g14
(dp12530
(I22
I22
tp12531
(lp12532
S'\tmutex_unlock(&driver->md_session_lock);'
p12533
as(I6
I6
tp12534
(lp12535
S'\tmutex_lock(&driver->md_session_lock);'
p12536
assg32
I1
sg12
g13
sg41
(I1
I25
tp12537
ssss(g10002
S'diag_process_hdlc_pkt'
p12538
tp12539
(dp12540
S'void diag_process_hdlc_pkt(void *data, unsigned int len, int pid)\n{\n\tint err = 0;\n\tint ret = 0;\n\n\tif (len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\tpr_err("diag: In %s, invalid length: %d\\n", __func__, len);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->diag_hdlc_mutex);\n\tpr_debug("diag: In %s, received packet of length: %d, req_buf_len: %d\\n",\n\t\t __func__, len, driver->hdlc_buf_len);\n\n\tif (driver->hdlc_buf_len >= DIAG_MAX_REQ_SIZE) {\n\t\tpr_err("diag: In %s, request length is more than supported len. Dropping packet.\\n",\n\t\t       __func__);\n\t\tgoto fail;\n\t}\n\n\thdlc_decode->dest_ptr = driver->hdlc_buf + driver->hdlc_buf_len;\n\thdlc_decode->dest_size = DIAG_MAX_HDLC_BUF_SIZE - driver->hdlc_buf_len;\n\thdlc_decode->src_ptr = data;\n\thdlc_decode->src_size = len;\n\thdlc_decode->src_idx = 0;\n\thdlc_decode->dest_idx = 0;\n\n\tret = diag_hdlc_decode(hdlc_decode);\n\t/*\n\t * driver->hdlc_buf is of size DIAG_MAX_HDLC_BUF_SIZE. But the decoded\n\t * packet should be within DIAG_MAX_REQ_SIZE.\n\t */\n\tif (driver->hdlc_buf_len + hdlc_decode->dest_idx <= DIAG_MAX_REQ_SIZE) {\n\t\tdriver->hdlc_buf_len += hdlc_decode->dest_idx;\n\t} else {\n\t\tpr_err_ratelimited("diag: In %s, Dropping packet. pkt_size: %d, max: %d\\n",\n\t\t\t\t   __func__,\n\t\t\t\t   driver->hdlc_buf_len + hdlc_decode->dest_idx,\n\t\t\t\t   DIAG_MAX_REQ_SIZE);\n\t\tgoto fail;\n\t}\n\n\tif (ret == HDLC_COMPLETE) {\n\t\terr = crc_check(driver->hdlc_buf, driver->hdlc_buf_len);\n\t\tif (err) {\n\t\t\t/* CRC check failed. */\n\t\t\tpr_err_ratelimited("diag: In %s, bad CRC. Dropping packet\\n",\n\t\t\t\t\t   __func__);\n\t\t\tgoto fail;\n\t\t}\n\t\tdriver->hdlc_buf_len -= HDLC_FOOTER_LEN;\n\n\t\tif (driver->hdlc_buf_len < 1) {\n\t\t\tpr_err_ratelimited("diag: In %s, message is too short, len: %d, dest len: %d\\n",\n\t\t\t\t\t   __func__, driver->hdlc_buf_len,\n\t\t\t\t\t   hdlc_decode->dest_idx);\n\t\t\tgoto fail;\n\t\t}\n\n\t\terr = diag_process_apps_pkt(driver->hdlc_buf,\n\t\t\t\t\t    driver->hdlc_buf_len, pid);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tgoto end;\n\t}\n\n\tdriver->hdlc_buf_len = 0;\n\tmutex_unlock(&driver->diag_hdlc_mutex);\n\treturn;\n\nfail:\n\t/*\n\t * Tools needs to get a response in order to start its\n\t * recovery algorithm. Send an error response if the\n\t * packet is not in expected format.\n\t */\n\tdiag_send_error_rsp(driver->hdlc_buf, driver->hdlc_buf_len, pid);\n\tdriver->hdlc_buf_len = 0;\nend:\n\tmutex_unlock(&driver->diag_hdlc_mutex);\n}'
p12541
(dp12542
((g10002
g12538
tp12543
I1
tp12544
(dp12545
g12
g13
sg14
(dp12546
(I78
I78
tp12547
(lp12548
S'\tdiag_send_error_rsp(driver->hdlc_buf, driver->hdlc_buf_len, pid);'
p12549
as(I1
I1
tp12550
(lp12551
S'void diag_process_hdlc_pkt(void *data, unsigned int len, int pid)'
p12552
as(I61
I61
tp12553
(lp12554
S'\t\t\t\t\t    driver->hdlc_buf_len, pid);'
p12555
assg32
I3
sg33
(dp12556
(I1
I2
tp12557
(lp12558
S'void diag_process_hdlc_pkt(void *data, unsigned int len,'
p12559
aS'\t\t\t   struct diag_md_session_t *info)'
p12560
as(I61
I61
tp12561
(lp12562
S'\t\t\t\t\t    driver->hdlc_buf_len, info);'
p12563
as(I78
I78
tp12564
(lp12565
S'\tdiag_send_error_rsp(driver->hdlc_buf, driver->hdlc_buf_len, info);'
p12566
assg41
(I1
I82
tp12567
ssss(g10116
S'diag_user_process_userspace_data'
p12568
tp12569
(dp12570
S'static int diag_user_process_userspace_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint max_retries = 3;\n\tint retry_count = 0;\n\tint remote_proc = 0;\n\tint token_offset = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > USER_SPACE_DATA) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tdo {\n\t\tif (!driver->user_space_data_busy)\n\t\t\tbreak;\n\t\tretry_count++;\n\t\tusleep_range(10000, 10100);\n\t} while (retry_count < max_retries);\n\n\tif (driver->user_space_data_busy)\n\t\treturn -EAGAIN;\n\n\terr = copy_from_user(driver->user_space_data_buf, buf, len);\n\tif (err) {\n\t\tpr_err("diag: In %s, failed to copy data from userspace, err: %d\\n",\n\t\t       __func__, err);\n\t\treturn -EIO;\n\t}\n\n\t/* Check for proc_type */\n\tremote_proc = diag_get_remote(*(int *)driver->user_space_data_buf);\n\tif (remote_proc) {\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: Integer underflow in %s, payload size: %d",\n\t\t\t       __func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\ttoken_offset = sizeof(int);\n\t\tlen -= sizeof(int);\n\t}\n\n\t/* Check masks for On-Device logging */\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(driver->user_space_data_buf +\n\t\t\t\t\t   token_offset)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t/* send masks to local processor now */\n\tif (!remote_proc) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\tpr_err("diag:In %s request came from invalid md session pid:%d",\n\t\t\t\t__func__, current->tgid);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (session_info)\n\t\t\thdlc_disabled = session_info->hdlc_disabled;\n\t\telse\n\t\t\thdlc_disabled = driver->hdlc_disabled;\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (!hdlc_disabled)\n\t\t\tdiag_process_hdlc_pkt((void *)\n\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\tlen, current->tgid);\n\t\telse\n\t\t\tdiag_process_non_hdlc_pkt((char *)\n\t\t\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\t\t\tlen, current->tgid);\n\t\treturn 0;\n\t}\n\n\terr = diag_process_userspace_remote(remote_proc,\n\t\t\t\t\t    driver->user_space_data_buf +\n\t\t\t\t\t    token_offset, len);\n\tif (err) {\n\t\tdriver->user_space_data_busy = 0;\n\t\tpr_err("diag: Error sending mask to remote proc %d, err: %d\\n",\n\t\t       remote_proc, err);\n\t}\n\n\treturn err;\n}'
p12571
(dp12572
((g10116
g12568
tp12573
I1
tp12574
(dp12575
g12
g13
sg14
(dp12576
(I73
I73
tp12577
(lp12578
S'\t\t\t\tlen, current->tgid);'
p12579
as(I77
I77
tp12580
(lp12581
S'\t\t\t\t\t\tlen, current->tgid);'
p12582
as(I69
I69
tp12583
(lp12584
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12585
as(I62
I62
tp12586
(lp12587
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p12588
assg32
I2
sg33
(dp12589
(I77
I77
tp12590
(lp12591
S'\t\t\t\t\t\tlen, session_info);'
p12592
as(I59
I59
tp12593
(lp12594
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12595
as(I73
I73
tp12596
(lp12597
S'\t\t\t\tlen, session_info);'
p12598
assg41
(I1
I91
tp12599
sssS'static int diag_user_process_userspace_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint max_retries = 3;\n\tint retry_count = 0;\n\tint remote_proc = 0;\n\tint token_offset = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > USER_SPACE_DATA) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tdo {\n\t\tif (!driver->user_space_data_busy)\n\t\t\tbreak;\n\t\tretry_count++;\n\t\tusleep_range(10000, 10100);\n\t} while (retry_count < max_retries);\n\n\tif (driver->user_space_data_busy)\n\t\treturn -EAGAIN;\n\n\terr = copy_from_user(driver->user_space_data_buf, buf, len);\n\tif (err) {\n\t\tpr_err("diag: In %s, failed to copy data from userspace, err: %d\\n",\n\t\t       __func__, err);\n\t\treturn -EIO;\n\t}\n\n\t/* Check for proc_type */\n\tremote_proc = diag_get_remote(*(int *)driver->user_space_data_buf);\n\tif (remote_proc) {\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: Integer underflow in %s, payload size: %d",\n\t\t\t       __func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\ttoken_offset = sizeof(int);\n\t\tlen -= sizeof(int);\n\t}\n\n\t/* Check masks for On-Device logging */\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(driver->user_space_data_buf +\n\t\t\t\t\t   token_offset, len)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t/* send masks to local processor now */\n\tif (!remote_proc) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\tpr_err("diag:In %s request came from invalid md session pid:%d",\n\t\t\t\t__func__, current->tgid);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (session_info)\n\t\t\thdlc_disabled = session_info->hdlc_disabled;\n\t\telse\n\t\t\thdlc_disabled = driver->hdlc_disabled;\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (!hdlc_disabled)\n\t\t\tdiag_process_hdlc_pkt((void *)\n\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\tlen, current->tgid);\n\t\telse\n\t\t\tdiag_process_non_hdlc_pkt((char *)\n\t\t\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\t\t\tlen, current->tgid);\n\t\treturn 0;\n\t}\n\n\terr = diag_process_userspace_remote(remote_proc,\n\t\t\t\t\t    driver->user_space_data_buf +\n\t\t\t\t\t    token_offset, len);\n\tif (err) {\n\t\tdriver->user_space_data_busy = 0;\n\t\tpr_err("diag: Error sending mask to remote proc %d, err: %d\\n",\n\t\t       remote_proc, err);\n\t}\n\n\treturn err;\n}'
p12600
(dp12601
((g10116
g12568
tp12602
I1
tp12603
(dp12604
g12
g13
sg14
(dp12605
(I73
I73
tp12606
(lp12607
S'\t\t\t\tlen, current->tgid);'
p12608
as(I77
I77
tp12609
(lp12610
S'\t\t\t\t\t\tlen, current->tgid);'
p12611
as(I49
I49
tp12612
(lp12613
S'\t\t\t\t\t   token_offset, len)) {'
p12614
as(I69
I69
tp12615
(lp12616
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12617
as(I62
I62
tp12618
(lp12619
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p12620
assg32
I2
sg33
(dp12621
(I73
I73
tp12622
(lp12623
S'\t\t\t\tlen, session_info);'
p12624
as(I77
I77
tp12625
(lp12626
S'\t\t\t\t\t\tlen, session_info);'
p12627
as(I49
I49
tp12628
(lp12629
S'\t\t\t\t\t   token_offset)) {'
p12630
as(I59
I59
tp12631
(lp12632
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12633
assg41
(I1
I91
tp12634
ssss(g10002
S'hdlc_reset_timer_start'
p12635
tp12636
(dp12637
S'static void hdlc_reset_timer_start(int pid)\n{\n\tstruct diag_md_session_t *info = NULL;\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tif (!hdlc_timer_in_progress) {\n\t\thdlc_timer_in_progress = 1;\n\t\tif (info)\n\t\t\tmod_timer(&info->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t\telse\n\t\t\tmod_timer(&driver->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t}\n\tmutex_unlock(&driver->md_session_lock);\n}'
p12638
(dp12639
((g10002
g12635
tp12640
I1
tp12641
(dp12642
g12
g13
sg14
(dp12643
(I5
I5
tp12644
(lp12645
S'\tinfo = diag_md_session_get_pid(pid);'
p12646
as(I1
I1
tp12647
(lp12648
S'static void hdlc_reset_timer_start(int pid)'
p12649
as(I3
I3
tp12650
(lp12651
S'\tstruct diag_md_session_t *info = NULL;'
p12652
assg32
I1
sg33
(dp12653
(I1
I1
tp12654
(lp12655
S'static void hdlc_reset_timer_start(struct diag_md_session_t *info)'
p12656
assg41
(I1
I16
tp12657
sssS'static void hdlc_reset_timer_start(int pid)\n{\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tif (!hdlc_timer_in_progress) {\n\t\thdlc_timer_in_progress = 1;\n\t\tif (info)\n\t\t\tmod_timer(&info->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t\telse\n\t\t\tmod_timer(&driver->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t}\n\tmutex_unlock(&driver->md_session_lock);\n}'
p12658
(dp12659
((g10002
g12635
tp12660
I1
tp12661
(dp12662
g12
g13
sg14
(dp12663
(I3
I4
tp12664
(lp12665
S'\tstruct diag_md_session_t *info = NULL;'
p12666
ag59
as(I1
I1
tp12667
(lp12668
S'static void hdlc_reset_timer_start(int pid)'
p12669
as(I6
I6
tp12670
(lp12671
S'\tinfo = diag_md_session_get_pid(pid);'
p12672
assg32
I1
sg33
(dp12673
(I1
I1
tp12674
(lp12675
S'static void hdlc_reset_timer_start(struct diag_md_session_t *info)'
p12676
assg41
(I1
I17
tp12677
ssss(g10116
S'diag_md_peripheral_switch'
p12678
tp12679
(dp12680
S'static int diag_md_peripheral_switch(int pid,\n\t\t\t\tint peripheral_mask, int req_mode) {\n\tint i, bit = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn -EINVAL;\n\tif (req_mode != DIAG_USB_MODE || req_mode != DIAG_MEMORY_DEVICE_MODE ||\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * check that md_session_map for i == session_info,\n\t * if not then race condition occurred and bail\n\t */\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tbit = MD_PERIPHERAL_MASK(i) & peripheral_mask;\n\t\tif (!bit)\n\t\t\tcontinue;\n\t\tif (req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE) {\n\t\t\tif (driver->md_session_map[i] != session_info)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = NULL;\n\t\t\tdriver->md_session_mask &= ~bit;\n\t\t\tsession_info->peripheral_mask &= ~bit;\n\n\t\t} else {\n\t\t\tif (driver->md_session_map[i] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = session_info;\n\t\t\tdriver->md_session_mask |= bit;\n\t\t\tsession_info->peripheral_mask |= bit;\n\n\t\t}\n\t}\n\n\tdriver->md_session_mode = DIAG_MD_PERIPHERAL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "Changed Peripherals:0x%x to mode:%d\\n",\n\t\tperipheral_mask, req_mode);\n}'
p12681
(dp12682
((g10116
g12678
tp12683
I1
tp12684
(dp12685
g12
g13
sg14
(dp12686
(I9
I10
tp12687
(lp12688
S'\tif (req_mode != DIAG_USB_MODE || req_mode != DIAG_MEMORY_DEVICE_MODE ||'
p12689
aS'\t\treq_mode != DIAG_PCIE_MODE)'
p12690
as(I29
I29
tp12691
(lp12692
S'\t\t\tif (driver->md_session_map[i] != NULL)'
p12693
as(I6
I6
tp12694
(lp12695
S'\tsession_info = diag_md_session_get_pid(pid);'
p12696
as(I21
I22
tp12697
(lp12698
S'\t\tif (req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE) {'
p12699
aS'\t\t\tif (driver->md_session_map[i] != session_info)'
p12700
as(I4
I4
tp12701
(lp12702
S'\tstruct diag_md_session_t *session_info = NULL;'
p12703
as(I1
I1
tp12704
(lp12705
S'static int diag_md_peripheral_switch(int pid,'
p12706
assg32
I3
sg33
(dp12707
(I24
I24
tp12708
(lp12709
S'\t\t\t}'
p12710
as(I9
I9
tp12711
(lp12712
S'\tif (req_mode != DIAG_USB_MODE || req_mode != DIAG_MEMORY_DEVICE_MODE)'
p12713
as(I29
I30
tp12714
(lp12715
S'\t\t\tif (driver->md_session_map[i] != NULL) {'
p12716
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12717
as(I31
I31
tp12718
(lp12719
S'\t\t\t}'
p12720
as(I21
I23
tp12721
(lp12722
S'\t\tif (req_mode == DIAG_USB_MODE) {'
p12723
aS'\t\t\tif (driver->md_session_map[i] != session_info) {'
p12724
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12725
as(I17
I17
tp12726
(lp12727
S'\tmutex_lock(&driver->md_session_lock);'
p12728
as(I39
I39
tp12729
(lp12730
S'\tmutex_unlock(&driver->md_session_lock);'
p12731
as(I1
I1
tp12732
(lp12733
S'static int diag_md_peripheral_switch(struct diag_md_session_t *session_info,'
p12734
assg41
(I1
I41
tp12735
sssS'static int diag_md_peripheral_switch(int pid,\n\t\t\t\tint peripheral_mask, int req_mode) {\n\tint i, bit = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn -EINVAL;\n\tif (req_mode != DIAG_USB_MODE || req_mode != DIAG_MEMORY_DEVICE_MODE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * check that md_session_map for i == session_info,\n\t * if not then race condition occurred and bail\n\t */\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tbit = MD_PERIPHERAL_MASK(i) & peripheral_mask;\n\t\tif (!bit)\n\t\t\tcontinue;\n\t\tif (req_mode == DIAG_USB_MODE) {\n\t\t\tif (driver->md_session_map[i] != session_info)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = NULL;\n\t\t\tdriver->md_session_mask &= ~bit;\n\t\t\tsession_info->peripheral_mask &= ~bit;\n\n\t\t} else {\n\t\t\tif (driver->md_session_map[i] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = session_info;\n\t\t\tdriver->md_session_mask |= bit;\n\t\t\tsession_info->peripheral_mask |= bit;\n\n\t\t}\n\t}\n\n\tdriver->md_session_mode = DIAG_MD_PERIPHERAL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "Changed Peripherals:0x%x to mode:%d\\n",\n\t\tperipheral_mask, req_mode);\n}'
p12736
(dp12737
((g10116
g12678
tp12738
I1
tp12739
(dp12740
g12
g13
sg14
(dp12741
(I21
I21
tp12742
(lp12743
S'\t\t\tif (driver->md_session_map[i] != session_info)'
p12744
as(I28
I28
tp12745
(lp12746
S'\t\t\tif (driver->md_session_map[i] != NULL)'
p12747
as(I4
I4
tp12748
(lp12749
S'\tstruct diag_md_session_t *session_info = NULL;'
p12750
as(I1
I1
tp12751
(lp12752
S'static int diag_md_peripheral_switch(int pid,'
p12753
as(I6
I6
tp12754
(lp12755
S'\tsession_info = diag_md_session_get_pid(pid);'
p12756
assg32
I3
sg33
(dp12757
(I28
I29
tp12758
(lp12759
S'\t\t\tif (driver->md_session_map[i] != NULL) {'
p12760
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12761
as(I16
I16
tp12762
(lp12763
S'\tmutex_lock(&driver->md_session_lock);'
p12764
as(I30
I30
tp12765
(lp12766
S'\t\t\t}'
p12767
as(I21
I22
tp12768
(lp12769
S'\t\t\tif (driver->md_session_map[i] != session_info) {'
p12770
aS'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12771
as(I38
I38
tp12772
(lp12773
S'\tmutex_unlock(&driver->md_session_lock);'
p12774
as(I1
I1
tp12775
(lp12776
S'static int diag_md_peripheral_switch(struct diag_md_session_t *session_info,'
p12777
as(I23
I23
tp12778
(lp12779
S'\t\t\t}'
p12780
assg41
(I1
I40
tp12781
ssss(g10116
S'diag_md_session_close'
p12782
tp12783
(dp12784
S'static void diag_md_session_close(int pid)\n{\n\tint i;\n\tuint8_t found = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != session_info)\n\t\t\tcontinue;\n\t\tdriver->md_session_map[i] = NULL;\n\t\tdriver->md_session_mask &= ~session_info->peripheral_mask;\n\t}\n\tdiag_log_mask_free(session_info->log_mask);\n\tkfree(session_info->log_mask);\n\tsession_info->log_mask = NULL;\n\tdiag_msg_mask_free(session_info->msg_mask);\n\tkfree(session_info->msg_mask);\n\tsession_info->msg_mask = NULL;\n\tdiag_event_mask_free(session_info->event_mask);\n\tkfree(session_info->event_mask);\n\tsession_info->event_mask = NULL;\n\tdel_timer(&session_info->hdlc_reset_timer);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS && !found; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfound = 1;\n\t}\n\n\tdriver->md_session_mode = (found) ? DIAG_MD_PERIPHERAL : DIAG_MD_NONE;\n\tkfree(session_info);\n\tsession_info = NULL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "cleared up session\\n");\n}'
p12785
(dp12786
((g10116
g12782
tp12787
I1
tp12788
(dp12789
g12
g13
sg14
(dp12790
(I7
I7
tp12791
(lp12792
S'\tsession_info = diag_md_session_get_pid(pid);'
p12793
as(I1
I1
tp12794
(lp12795
S'static void diag_md_session_close(int pid)'
p12796
as(I5
I5
tp12797
(lp12798
S'\tstruct diag_md_session_t *session_info = NULL;'
p12799
assg32
I1
sg33
(dp12800
(I36
I36
tp12801
(lp12802
S'\tmutex_unlock(&driver->md_session_lock);'
p12803
as(I1
I1
tp12804
(lp12805
S'static void diag_md_session_close(struct diag_md_session_t *session_info)'
p12806
as(I11
I11
tp12807
(lp12808
S'\tmutex_lock(&driver->md_session_lock);'
p12809
assg41
(I1
I37
tp12810
sssS'static void diag_md_session_close(int pid)\n{\n\tint i;\n\tuint8_t found = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != session_info)\n\t\t\tcontinue;\n\t\tdriver->md_session_map[i] = NULL;\n\t\tdriver->md_session_mask &= ~session_info->peripheral_mask;\n\t}\n\tdiag_log_mask_free(session_info->log_mask);\n\tkfree(session_info->log_mask);\n\tsession_info->log_mask = NULL;\n\tdiag_msg_mask_free(session_info->msg_mask,\n\t\tsession_info);\n\tkfree(session_info->msg_mask);\n\tsession_info->msg_mask = NULL;\n\tdiag_event_mask_free(session_info->event_mask);\n\tkfree(session_info->event_mask);\n\tsession_info->event_mask = NULL;\n\tdel_timer(&session_info->hdlc_reset_timer);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS && !found; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfound = 1;\n\t}\n\n\tdriver->md_session_mode = (found) ? DIAG_MD_PERIPHERAL : DIAG_MD_NONE;\n\tkfree(session_info);\n\tsession_info = NULL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "cleared up session\\n");\n}'
p12811
(dp12812
((g10116
g12782
tp12813
I1
tp12814
(dp12815
g12
g13
sg14
(dp12816
(I7
I7
tp12817
(lp12818
S'\tsession_info = diag_md_session_get_pid(pid);'
p12819
as(I20
I21
tp12820
(lp12821
S'\tdiag_msg_mask_free(session_info->msg_mask,'
p12822
aS'\t\tsession_info);'
p12823
as(I1
I1
tp12824
(lp12825
S'static void diag_md_session_close(int pid)'
p12826
as(I5
I5
tp12827
(lp12828
S'\tstruct diag_md_session_t *session_info = NULL;'
p12829
assg32
I1
sg33
(dp12830
(I37
I37
tp12831
(lp12832
S'\tmutex_unlock(&driver->md_session_lock);'
p12833
as(I20
I20
tp12834
(lp12835
S'\tdiag_msg_mask_free(session_info->msg_mask);'
p12836
as(I1
I1
tp12837
(lp12838
S'static void diag_md_session_close(struct diag_md_session_t *session_info)'
p12839
as(I11
I11
tp12840
(lp12841
S'\tmutex_lock(&driver->md_session_lock);'
p12842
assg41
(I1
I38
tp12843
ssss(g10026
S'diag_cmd_set_msg_mask'
p12844
tp12845
(dp12846
S'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (i < (driver->msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p12847
(dp12848
((g10026
g12844
tp12849
I1
tp12850
(dp12851
g12
g13
sg14
(dp12852
(I24
I24
tp12853
(lp12854
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12855
as(I43
I43
tp12856
(lp12857
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12858
as(I132
I132
tp12859
(lp12860
S'\t\tif (!diag_check_update(i, pid))'
p12861
as(I30
I30
tp12862
(lp12863
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12864
as(I86
I86
tp12865
(lp12866
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12867
as(I2
I2
tp12868
(lp12869
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p12870
as(I107
I108
tp12871
(lp12872
S'\tmutex_unlock(&driver->md_session_lock);'
p12873
aS'\tif (diag_check_update(APPS_DATA, pid))'
p12874
as(I13
I16
tp12875
(lp12876
S'\tstruct diag_md_session_t *info = NULL;'
p12877
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p12878
aS'\tinfo = diag_md_session_get_pid(pid);'
p12879
assg32
I5
sg33
(dp12880
(I132
I132
tp12881
(lp12882
S'\t\tif (!diag_check_update(i))'
p12883
as(I2
I3
tp12884
(lp12885
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p12886
aS'\t\t\t\t struct diag_md_session_t *info)'
p12887
as(I107
I107
tp12888
(lp12889
S'\tif (diag_check_update(APPS_DATA))'
p12890
assg41
(I1
I145
tp12891
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tif (mask_size && src_len >= header_len + mask_size)\n\t\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p12892
(dp12893
((g10026
g12844
tp12894
I1
tp12895
(dp12896
g12
g13
sg14
(dp12897
(I140
I140
tp12898
(lp12899
S'\t\tif (!diag_check_update(i, pid))'
p12900
as(I134
I135
tp12901
(lp12902
S'\tif (mask_size && src_len >= header_len + mask_size)'
p12903
aS'\t\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);'
p12904
as(I91
I91
tp12905
(lp12906
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12907
as(I20
I21
tp12908
(lp12909
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p12910
aS'\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {'
p12911
as(I44
I44
tp12912
(lp12913
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12914
as(I47
I52
tp12915
(lp12916
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p12917
aS'\t\t\tdriver->msg_mask_tbl_count;'
p12918
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p12919
aS'\t\tif (!mask->ptr)'
p12920
aS'\t\t\tcontinue;'
p12921
aS'\t\tif (i < (msg_mask_tbl_count - 1)) {'
p12922
as(I25
I25
tp12923
(lp12924
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12925
as(I13
I17
tp12926
(lp12927
S'\tstruct diag_md_session_t *info = NULL;'
p12928
aS'\tuint8_t msg_mask_tbl_count = 0;'
p12929
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p12930
aS'\tinfo = diag_md_session_get_pid(pid);'
p12931
as(I105
I107
tp12932
(lp12933
S'\t\tif (mask_size && src_len >= header_len + mask_size)'
p12934
aS'\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,'
p12935
aS'\t\t\t\tmask_size);'
p12936
as(I114
I115
tp12937
(lp12938
S'\tmutex_unlock(&driver->md_session_lock);'
p12939
aS'\tif (diag_check_update(APPS_DATA, pid))'
p12940
as(I2
I2
tp12941
(lp12942
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p12943
as(I31
I31
tp12944
(lp12945
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12946
assg32
I5
sg33
(dp12947
(I140
I140
tp12948
(lp12949
S'\t\tif (!diag_check_update(i))'
p12950
as(I2
I3
tp12951
(lp12952
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p12953
aS'\t\t\t\t struct diag_md_session_t *info)'
p12954
as(I114
I114
tp12955
(lp12956
S'\tif (diag_check_update(APPS_DATA))'
p12957
as(I20
I21
tp12958
(lp12959
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p12960
aS'\t    !mask_info) {'
p12961
as(I134
I134
tp12962
(lp12963
S'\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);'
p12964
as(I47
I48
tp12965
(lp12966
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p12967
aS'\t\tif (i < (driver->msg_mask_tbl_count - 1)) {'
p12968
as(I105
I105
tp12969
(lp12970
S'\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);'
p12971
assg41
(I1
I153
tp12972
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (driver->msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p12973
(dp12974
((g10026
g12844
tp12975
I1
tp12976
(dp12977
g12
g13
sg14
(dp12978
(I24
I24
tp12979
(lp12980
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12981
as(I134
I134
tp12982
(lp12983
S'\t\tif (!diag_check_update(i, pid))'
p12984
as(I43
I43
tp12985
(lp12986
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12987
as(I30
I30
tp12988
(lp12989
S'\t\tmutex_unlock(&driver->md_session_lock);'
p12990
as(I109
I110
tp12991
(lp12992
S'\tmutex_unlock(&driver->md_session_lock);'
p12993
aS'\tif (diag_check_update(APPS_DATA, pid))'
p12994
as(I88
I88
tp12995
(lp12996
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p12997
as(I2
I2
tp12998
(lp12999
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13000
as(I47
I48
tp13001
(lp13002
S'\t\tif (!mask->ptr)'
p13003
aS'\t\t\tcontinue;'
p13004
as(I13
I16
tp13005
(lp13006
S'\tstruct diag_md_session_t *info = NULL;'
p13007
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13008
aS'\tinfo = diag_md_session_get_pid(pid);'
p13009
assg32
I5
sg33
(dp13010
(I2
I3
tp13011
(lp13012
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13013
aS'\t\t\t\t struct diag_md_session_t *info)'
p13014
as(I109
I109
tp13015
(lp13016
S'\tif (diag_check_update(APPS_DATA))'
p13017
as(I134
I134
tp13018
(lp13019
S'\t\tif (!diag_check_update(i))'
p13020
assg41
(I1
I147
tp13021
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13022
(dp13023
((g10026
g12844
tp13024
I1
tp13025
(dp13026
g12
g13
sg14
(dp13027
(I91
I91
tp13028
(lp13029
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p13030
as(I20
I21
tp13031
(lp13032
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p13033
aS'\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {'
p13034
as(I44
I44
tp13035
(lp13036
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13037
as(I47
I52
tp13038
(lp13039
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p13040
aS'\t\t\tdriver->msg_mask_tbl_count;'
p13041
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p13042
aS'\t\tif (!mask->ptr)'
p13043
aS'\t\t\tcontinue;'
p13044
aS'\t\tif (i < (msg_mask_tbl_count - 1)) {'
p13045
as(I25
I25
tp13046
(lp13047
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13048
as(I13
I17
tp13049
(lp13050
S'\tstruct diag_md_session_t *info = NULL;'
p13051
aS'\tuint8_t msg_mask_tbl_count = 0;'
p13052
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13053
aS'\tinfo = diag_md_session_get_pid(pid);'
p13054
as(I105
I107
tp13055
(lp13056
S'\t\tif (mask_size && src_len >= header_len + mask_size)'
p13057
aS'\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,'
p13058
aS'\t\t\t\tmask_size);'
p13059
as(I114
I115
tp13060
(lp13061
S'\tmutex_unlock(&driver->md_session_lock);'
p13062
aS'\tif (diag_check_update(APPS_DATA, pid))'
p13063
as(I2
I2
tp13064
(lp13065
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13066
as(I31
I31
tp13067
(lp13068
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13069
as(I139
I139
tp13070
(lp13071
S'\t\tif (!diag_check_update(i, pid))'
p13072
assg32
I5
sg33
(dp13073
(I2
I3
tp13074
(lp13075
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13076
aS'\t\t\t\t struct diag_md_session_t *info)'
p13077
as(I139
I139
tp13078
(lp13079
S'\t\tif (!diag_check_update(i))'
p13080
as(I114
I114
tp13081
(lp13082
S'\tif (diag_check_update(APPS_DATA))'
p13083
as(I20
I21
tp13084
(lp13085
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p13086
aS'\t    !mask_info) {'
p13087
as(I47
I48
tp13088
(lp13089
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p13090
aS'\t\tif (i < (driver->msg_mask_tbl_count - 1)) {'
p13091
as(I105
I105
tp13092
(lp13093
S'\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);'
p13094
assg41
(I1
I152
tp13095
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (i < (driver->msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13096
(dp13097
((g10026
g12844
tp13098
I1
tp13099
(dp13100
g12
g13
sg14
(dp13101
(I24
I24
tp13102
(lp13103
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13104
as(I43
I43
tp13105
(lp13106
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13107
as(I30
I30
tp13108
(lp13109
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13110
as(I86
I86
tp13111
(lp13112
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p13113
as(I2
I2
tp13114
(lp13115
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13116
as(I13
I16
tp13117
(lp13118
S'\tstruct diag_md_session_t *info = NULL;'
p13119
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13120
aS'\tinfo = diag_md_session_get_pid(pid);'
p13121
as(I107
I107
tp13122
(lp13123
S'\tmutex_unlock(&driver->md_session_lock);'
p13124
assg32
I5
sg33
(dp13125
(I2
I3
tp13126
(lp13127
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13128
aS'\t\t\t\t struct diag_md_session_t *info)'
p13129
assg41
(I1
I145
tp13130
sssS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13131
(dp13132
((g10026
g12844
tp13133
I1
tp13134
(dp13135
g12
g13
sg14
(dp13136
(I112
I113
tp13137
(lp13138
S'\tmutex_unlock(&driver->md_session_lock);'
p13139
aS'\tif (diag_check_update(APPS_DATA, pid))'
p13140
as(I13
I17
tp13141
(lp13142
S'\tstruct diag_md_session_t *info = NULL;'
p13143
aS'\tuint8_t msg_mask_tbl_count = 0;'
p13144
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13145
aS'\tinfo = diag_md_session_get_pid(pid);'
p13146
as(I91
I91
tp13147
(lp13148
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p13149
as(I2
I2
tp13150
(lp13151
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13152
as(I47
I52
tp13153
(lp13154
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p13155
aS'\t\t\tdriver->msg_mask_tbl_count;'
p13156
aS'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p13157
aS'\t\tif (!mask->ptr)'
p13158
aS'\t\t\tcontinue;'
p13159
aS'\t\tif (i < (msg_mask_tbl_count - 1)) {'
p13160
as(I137
I137
tp13161
(lp13162
S'\t\tif (!diag_check_update(i, pid))'
p13163
as(I44
I44
tp13164
(lp13165
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13166
as(I31
I31
tp13167
(lp13168
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13169
as(I25
I25
tp13170
(lp13171
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13172
assg32
I5
sg33
(dp13173
(I47
I48
tp13174
(lp13175
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p13176
aS'\t\tif (i < (driver->msg_mask_tbl_count - 1)) {'
p13177
as(I112
I112
tp13178
(lp13179
S'\tif (diag_check_update(APPS_DATA))'
p13180
as(I2
I3
tp13181
(lp13182
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13183
aS'\t\t\t\t struct diag_md_session_t *info)'
p13184
as(I137
I137
tp13185
(lp13186
S'\t\tif (!diag_check_update(i))'
p13187
assg41
(I1
I150
tp13188
ssss(g10026
S'diag_cmd_get_log_mask'
p13189
tp13190
(dp13191
S'static int diag_cmd_get_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint status = LOG_STATUS_INVALID;\n\tint write_len = 0;\n\tint read_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_mask_t *log_item = NULL;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_MASK;\n\t/*\n\t * Don\'t copy the response header now. Copy at the end after\n\t * calculating the status field value\n\t */\n\twrite_len += rsp_header_len;\n\n\tlog_item = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!log_item->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask: %pK\\n",\n\t\t\t__func__, log_item);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, log_item++) {\n\t\tif (log_item->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&log_item->lock);\n\t\tmask_size = LOG_ITEMS_TO_SIZE(log_item->num_items_tools);\n\t\t/*\n\t\t * Make sure we have space to fill the response in the buffer.\n\t\t * Destination buffer should atleast be able to hold equip_id\n\t\t * (uint32_t), num_items(uint32_t), mask (mask_size) and the\n\t\t * response header.\n\t\t */\n\t\tif ((mask_size + (2 * sizeof(uint32_t)) + rsp_header_len) >\n\t\t\t\t\t\t\t\tdest_len) {\n\t\t\tpr_err("diag: In %s, invalid length: %d, max rsp_len: %d\\n",\n\t\t\t\t__func__, mask_size, dest_len);\n\t\t\tstatus = LOG_STATUS_FAIL;\n\t\t\tmutex_unlock(&log_item->lock);\n\t\t\tbreak;\n\t\t}\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->equip_id;\n\t\twrite_len += sizeof(uint32_t);\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t\tif (mask_size > 0) {\n\t\t\tmemcpy(dest_buf + write_len, log_item->ptr, mask_size);\n\t\t\twrite_len += mask_size;\n\t\t}\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending log e %d num_items %d size %d\\n",\n\t\t\t log_item->equip_id, log_item->num_items_tools,\n\t\t\t log_item->range_tools);\n\t\tmutex_unlock(&log_item->lock);\n\t\tstatus = LOG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\trsp.status = status;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p13192
(dp13193
((g10026
g13189
tp13194
I1
tp13195
(dp13196
g12
g13
sg14
(dp13197
(I36
I37
tp13198
(lp13199
S'\tif (!diag_apps_responds()) {'
p13200
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13201
as(I32
I32
tp13202
(lp13203
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13204
as(I59
I59
tp13205
(lp13206
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13207
as(I15
I18
tp13208
(lp13209
S'\tstruct diag_md_session_t *info = NULL;'
p13210
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13211
aS'\tinfo = diag_md_session_get_pid(pid);'
p13212
as(I26
I26
tp13213
(lp13214
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13215
as(I21
I22
tp13216
(lp13217
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p13218
aS'\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {'
p13219
as(I2
I2
tp13220
(lp13221
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13222
as(I39
I39
tp13223
(lp13224
S'\t}'
p13225
as(I101
I101
tp13226
(lp13227
S'\tmutex_unlock(&driver->md_session_lock);'
p13228
assg32
I5
sg33
(dp13229
(I21
I22
tp13230
(lp13231
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p13232
aS'\t    !mask_info) {'
p13233
as(I36
I36
tp13234
(lp13235
S'\tif (!diag_apps_responds())'
p13236
as(I2
I3
tp13237
(lp13238
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13239
aS'\t\t\t\t struct diag_md_session_t *info)'
p13240
assg41
(I1
I103
tp13241
sssS'static int diag_cmd_get_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint status = LOG_STATUS_INVALID;\n\tint write_len = 0;\n\tint read_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_mask_t *log_item = NULL;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_MASK;\n\t/*\n\t * Don\'t copy the response header now. Copy at the end after\n\t * calculating the status field value\n\t */\n\twrite_len += rsp_header_len;\n\n\tlog_item = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!log_item->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask: %pK\\n",\n\t\t\t__func__, log_item);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, log_item++) {\n\t\tif (log_item->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&log_item->lock);\n\t\tmask_size = LOG_ITEMS_TO_SIZE(log_item->num_items_tools);\n\t\t/*\n\t\t * Make sure we have space to fill the response in the buffer.\n\t\t * Destination buffer should atleast be able to hold equip_id\n\t\t * (uint32_t), num_items(uint32_t), mask (mask_size) and the\n\t\t * response header.\n\t\t */\n\t\tif ((mask_size + (2 * sizeof(uint32_t)) + rsp_header_len) >\n\t\t\t\t\t\t\t\tdest_len) {\n\t\t\tpr_err("diag: In %s, invalid length: %d, max rsp_len: %d\\n",\n\t\t\t\t__func__, mask_size, dest_len);\n\t\t\tstatus = LOG_STATUS_FAIL;\n\t\t\tmutex_unlock(&log_item->lock);\n\t\t\tbreak;\n\t\t}\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->equip_id;\n\t\twrite_len += sizeof(uint32_t);\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t\tif (mask_size > 0) {\n\t\t\tmemcpy(dest_buf + write_len, log_item->ptr, mask_size);\n\t\t\twrite_len += mask_size;\n\t\t}\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending log e %d num_items %d size %d\\n",\n\t\t\t log_item->equip_id, log_item->num_items_tools,\n\t\t\t log_item->range_tools);\n\t\tmutex_unlock(&log_item->lock);\n\t\tstatus = LOG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\trsp.status = status;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p13242
(dp13243
((g10026
g13189
tp13244
I1
tp13245
(dp13246
g12
g13
sg14
(dp13247
(I32
I32
tp13248
(lp13249
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13250
as(I59
I59
tp13251
(lp13252
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13253
as(I15
I18
tp13254
(lp13255
S'\tstruct diag_md_session_t *info = NULL;'
p13256
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13257
aS'\tinfo = diag_md_session_get_pid(pid);'
p13258
as(I26
I26
tp13259
(lp13260
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13261
as(I36
I37
tp13262
(lp13263
S'\tif (!diag_apps_responds()) {'
p13264
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13265
as(I2
I2
tp13266
(lp13267
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13268
as(I39
I39
tp13269
(lp13270
S'\t}'
p13271
as(I101
I101
tp13272
(lp13273
S'\tmutex_unlock(&driver->md_session_lock);'
p13274
assg32
I5
sg33
(dp13275
(I36
I36
tp13276
(lp13277
S'\tif (!diag_apps_responds())'
p13278
as(I2
I3
tp13279
(lp13280
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13281
aS'\t\t\t\t struct diag_md_session_t *info)'
p13282
assg41
(I1
I103
tp13283
sssS'static int diag_cmd_get_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint status = LOG_STATUS_INVALID;\n\tint write_len = 0;\n\tint read_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_mask_t *log_item = NULL;\n\tstruct diag_log_config_get_req_t *req;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_get_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\treq = (struct diag_log_config_get_req_t *)src_buf;\n\tread_len += req_header_len;\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_MASK;\n\t/*\n\t * Don\'t copy the response header now. Copy at the end after\n\t * calculating the status field value\n\t */\n\twrite_len += rsp_header_len;\n\n\tlog_item = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!log_item->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask: %pK\\n",\n\t\t\t__func__, log_item);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, log_item++) {\n\t\tif (log_item->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&log_item->lock);\n\t\tmask_size = LOG_ITEMS_TO_SIZE(log_item->num_items_tools);\n\t\t/*\n\t\t * Make sure we have space to fill the response in the buffer.\n\t\t * Destination buffer should atleast be able to hold equip_id\n\t\t * (uint32_t), num_items(uint32_t), mask (mask_size) and the\n\t\t * response header.\n\t\t */\n\t\tif ((mask_size + (2 * sizeof(uint32_t)) + rsp_header_len) >\n\t\t\t\t\t\t\t\tdest_len) {\n\t\t\tpr_err("diag: In %s, invalid length: %d, max rsp_len: %d\\n",\n\t\t\t\t__func__, mask_size, dest_len);\n\t\t\tstatus = LOG_STATUS_FAIL;\n\t\t\tmutex_unlock(&log_item->lock);\n\t\t\tbreak;\n\t\t}\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->equip_id;\n\t\twrite_len += sizeof(uint32_t);\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t\tif (mask_size > 0) {\n\t\t\tmemcpy(dest_buf + write_len, log_item->ptr, mask_size);\n\t\t\twrite_len += mask_size;\n\t\t}\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending log e %d num_items %d size %d\\n",\n\t\t\t log_item->equip_id, log_item->num_items_tools,\n\t\t\t log_item->range_tools);\n\t\tmutex_unlock(&log_item->lock);\n\t\tstatus = LOG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\trsp.status = status;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p13284
(dp13285
((g10026
g13189
tp13286
I1
tp13287
(dp13288
g12
g13
sg14
(dp13289
(I32
I32
tp13290
(lp13291
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13292
as(I59
I59
tp13293
(lp13294
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13295
as(I26
I26
tp13296
(lp13297
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13298
as(I36
I37
tp13299
(lp13300
S'\tif (!diag_apps_responds()) {'
p13301
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13302
as(I12
I12
tp13303
(lp13304
S'\tstruct diag_log_config_get_req_t *req;'
p13305
as(I41
I41
tp13306
(lp13307
S'\treq = (struct diag_log_config_get_req_t *)src_buf;'
p13308
as(I39
I39
tp13309
(lp13310
S'\t}'
p13311
as(I21
I22
tp13312
(lp13313
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p13314
aS'\t\tsrc_len < sizeof(struct diag_log_config_get_req_t)) {'
p13315
as(I15
I18
tp13316
(lp13317
S'\tstruct diag_md_session_t *info = NULL;'
p13318
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13319
aS'\tinfo = diag_md_session_get_pid(pid);'
p13320
as(I2
I2
tp13321
(lp13322
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13323
as(I101
I101
tp13324
(lp13325
S'\tmutex_unlock(&driver->md_session_lock);'
p13326
assg32
I5
sg33
(dp13327
(I21
I22
tp13328
(lp13329
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p13330
aS'\t    !mask_info) {'
p13331
as(I36
I36
tp13332
(lp13333
S'\tif (!diag_apps_responds())'
p13334
as(I12
I12
tp13335
(lp13336
S'\tstruct diag_log_config_req_t *req;'
p13337
as(I2
I3
tp13338
(lp13339
S'\t\t\t\t unsigned char *dest_buf, int dest_len,'
p13340
aS'\t\t\t\t struct diag_md_session_t *info)'
p13341
as(I41
I41
tp13342
(lp13343
S'\treq = (struct diag_log_config_req_t *)src_buf;'
p13344
assg41
(I1
I103
tp13345
ssss(g10026
S'diag_cmd_set_log_mask'
p13346
tp13347
(dp13348
S'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13349
(dp13350
((g10026
g13346
tp13351
I1
tp13352
(dp13353
g12
g13
sg14
(dp13354
(I27
I27
tp13355
(lp13356
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13357
as(I43
I43
tp13358
(lp13359
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13360
as(I106
I106
tp13361
(lp13362
S'\tmutex_unlock(&driver->md_session_lock);'
p13363
as(I16
I19
tp13364
(lp13365
S'\tstruct diag_md_session_t *info = NULL;'
p13366
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13367
aS'\tinfo = diag_md_session_get_pid(pid);'
p13368
as(I33
I33
tp13369
(lp13370
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13371
as(I3
I3
tp13372
(lp13373
S'\t\t\t\t int pid)'
p13374
assg32
I5
sg33
(dp13375
(I3
I3
tp13376
(lp13377
S'\t\t\t\t struct diag_md_session_t *info)'
p13378
assg41
(I1
I150
tp13379
sssS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13380
(dp13381
((g10026
g13346
tp13382
I1
tp13383
(dp13384
g12
g13
sg14
(dp13385
(I27
I27
tp13386
(lp13387
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13388
as(I108
I109
tp13389
(lp13390
S'\tmutex_unlock(&driver->md_session_lock);'
p13391
aS'\tif (diag_check_update(APPS_DATA, pid))'
p13392
as(I43
I43
tp13393
(lp13394
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13395
as(I60
I61
tp13396
(lp13397
S'\t\tif (!mask || !mask->ptr)'
p13398
aS'\t\t\tcontinue;'
p13399
as(I16
I19
tp13400
(lp13401
S'\tstruct diag_md_session_t *info = NULL;'
p13402
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13403
aS'\tinfo = diag_md_session_get_pid(pid);'
p13404
as(I140
I140
tp13405
(lp13406
S'\t\tif (!diag_check_update(i, pid))'
p13407
as(I33
I33
tp13408
(lp13409
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13410
as(I3
I3
tp13411
(lp13412
S'\t\t\t\t int pid)'
p13413
assg32
I5
sg33
(dp13414
(I140
I140
tp13415
(lp13416
S'\t\tif (!diag_check_update(i))'
p13417
as(I108
I108
tp13418
(lp13419
S'\tif (diag_check_update(APPS_DATA))'
p13420
as(I3
I3
tp13421
(lp13422
S'\t\t\t\t struct diag_md_session_t *info)'
p13423
assg41
(I1
I152
tp13424
sssS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13425
(dp13426
((g10026
g13346
tp13427
I1
tp13428
(dp13429
g12
g13
sg14
(dp13430
(I27
I27
tp13431
(lp13432
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13433
as(I106
I107
tp13434
(lp13435
S'\tmutex_unlock(&driver->md_session_lock);'
p13436
aS'\tif (diag_check_update(APPS_DATA, pid))'
p13437
as(I43
I43
tp13438
(lp13439
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13440
as(I138
I138
tp13441
(lp13442
S'\t\tif (!diag_check_update(i, pid))'
p13443
as(I16
I19
tp13444
(lp13445
S'\tstruct diag_md_session_t *info = NULL;'
p13446
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13447
aS'\tinfo = diag_md_session_get_pid(pid);'
p13448
as(I33
I33
tp13449
(lp13450
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13451
as(I3
I3
tp13452
(lp13453
S'\t\t\t\t int pid)'
p13454
assg32
I5
sg33
(dp13455
(I138
I138
tp13456
(lp13457
S'\t\tif (!diag_check_update(i))'
p13458
as(I3
I3
tp13459
(lp13460
S'\t\t\t\t struct diag_md_session_t *info)'
p13461
as(I106
I106
tp13462
(lp13463
S'\tif (diag_check_update(APPS_DATA))'
p13464
assg41
(I1
I150
tp13465
sssS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0 && src_len >= read_len + mask_size)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p13466
(dp13467
((g10026
g13346
tp13468
I1
tp13469
(dp13470
g12
g13
sg14
(dp13471
(I60
I61
tp13472
(lp13473
S'\t\tif (!mask || !mask->ptr)'
p13474
aS'\t\t\tcontinue;'
p13475
as(I97
I97
tp13476
(lp13477
S'\t\tif (mask_size > 0 && src_len >= read_len + mask_size)'
p13478
as(I22
I23
tp13479
(lp13480
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p13481
aS'\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {'
p13482
as(I3
I3
tp13483
(lp13484
S'\t\t\t\t int pid)'
p13485
as(I108
I109
tp13486
(lp13487
S'\tmutex_unlock(&driver->md_session_lock);'
p13488
aS'\tif (diag_check_update(APPS_DATA, pid))'
p13489
as(I43
I43
tp13490
(lp13491
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13492
as(I16
I19
tp13493
(lp13494
S'\tstruct diag_md_session_t *info = NULL;'
p13495
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p13496
aS'\tinfo = diag_md_session_get_pid(pid);'
p13497
as(I140
I140
tp13498
(lp13499
S'\t\tif (!diag_check_update(i, pid))'
p13500
as(I33
I33
tp13501
(lp13502
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13503
as(I27
I27
tp13504
(lp13505
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13506
assg32
I5
sg33
(dp13507
(I140
I140
tp13508
(lp13509
S'\t\tif (!diag_check_update(i))'
p13510
as(I108
I108
tp13511
(lp13512
S'\tif (diag_check_update(APPS_DATA))'
p13513
as(I22
I23
tp13514
(lp13515
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p13516
aS'\t    !mask_info) {'
p13517
as(I3
I3
tp13518
(lp13519
S'\t\t\t\t struct diag_md_session_t *info)'
p13520
as(I97
I97
tp13521
(lp13522
S'\t\tif (mask_size > 0)'
p13523
assg41
(I1
I152
tp13524
ssss(g10026
S'diag_cmd_get_ssid_range'
p13525
tp13526
(dp13527
S'static int diag_cmd_get_ssid_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tstruct diag_msg_ssid_query_t rsp;\n\tstruct diag_ssid_range_t ssid_range;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\tdriver->msg_mask_tbl_count;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_SSID_RANGE;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.count = msg_mask_tbl_count;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmask_ptr = (struct diag_msg_mask_t *)mask_info->ptr;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask_ptr++) {\n\t\tif (write_len + sizeof(ssid_range) > dest_len) {\n\t\t\tpr_err("diag: In %s, Truncating response due to size limitations of rsp buffer\\n",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tssid_range.ssid_first = mask_ptr->ssid_first;\n\t\tssid_range.ssid_last = mask_ptr->ssid_last_tools;\n\t\tmemcpy(dest_buf + write_len, &ssid_range, sizeof(ssid_range));\n\t\twrite_len += sizeof(ssid_range);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p13528
(dp13529
((g10026
g13525
tp13530
I1
tp13531
(dp13532
g12
g13
sg14
(dp13533
(I27
I27
tp13534
(lp13535
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13536
as(I6
I6
tp13537
(lp13538
S'\tuint8_t msg_mask_tbl_count = 0;'
p13539
as(I13
I14
tp13540
(lp13541
S'\tmutex_lock(&driver->md_session_lock);'
p13542
aS'\tinfo = diag_md_session_get_pid(pid);'
p13543
as(I46
I46
tp13544
(lp13545
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask_ptr++) {'
p13546
as(I2
I2
tp13547
(lp13548
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13549
as(I21
I21
tp13550
(lp13551
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13552
as(I36
I37
tp13553
(lp13554
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p13555
aS'\t\tdriver->msg_mask_tbl_count;'
p13556
as(I34
I34
tp13557
(lp13558
S'\t}'
p13559
as(I58
I58
tp13560
(lp13561
S'\tmutex_unlock(&driver->md_session_lock);'
p13562
as(I42
I42
tp13563
(lp13564
S'\trsp.count = msg_mask_tbl_count;'
p13565
as(I31
I32
tp13566
(lp13567
S'\tif (!diag_apps_responds()) {'
p13568
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13569
as(I11
I11
tp13570
(lp13571
S'\tstruct diag_md_session_t *info = NULL;'
p13572
assg32
I5
sg33
(dp13573
(I46
I46
tp13574
(lp13575
S'\tfor (i = 0; i <  driver->msg_mask_tbl_count; i++, mask_ptr++) {'
p13576
as(I2
I3
tp13577
(lp13578
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p13579
aS'\t\t\t\t   struct diag_md_session_t *info)'
p13580
as(I31
I31
tp13581
(lp13582
S'\tif (!diag_apps_responds())'
p13583
as(I42
I42
tp13584
(lp13585
S'\trsp.count = driver->msg_mask_tbl_count;'
p13586
assg41
(I1
I60
tp13587
sssS'static int diag_cmd_get_ssid_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tstruct diag_msg_ssid_query_t rsp;\n\tstruct diag_ssid_range_t ssid_range;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_SSID_RANGE;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.count = driver->msg_mask_tbl_count;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmask_ptr = (struct diag_msg_mask_t *)mask_info->ptr;\n\tfor (i = 0; i <  driver->msg_mask_tbl_count; i++, mask_ptr++) {\n\t\tif (write_len + sizeof(ssid_range) > dest_len) {\n\t\t\tpr_err("diag: In %s, Truncating response due to size limitations of rsp buffer\\n",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tssid_range.ssid_first = mask_ptr->ssid_first;\n\t\tssid_range.ssid_last = mask_ptr->ssid_last_tools;\n\t\tmemcpy(dest_buf + write_len, &ssid_range, sizeof(ssid_range));\n\t\twrite_len += sizeof(ssid_range);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p13588
(dp13589
((g10026
g13525
tp13590
I1
tp13591
(dp13592
g12
g13
sg14
(dp13593
(I20
I20
tp13594
(lp13595
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13596
as(I30
I31
tp13597
(lp13598
S'\tif (!diag_apps_responds()) {'
p13599
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13600
as(I26
I26
tp13601
(lp13602
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13603
as(I12
I13
tp13604
(lp13605
S'\tmutex_lock(&driver->md_session_lock);'
p13606
aS'\tinfo = diag_md_session_get_pid(pid);'
p13607
as(I55
I55
tp13608
(lp13609
S'\tmutex_unlock(&driver->md_session_lock);'
p13610
as(I10
I10
tp13611
(lp13612
S'\tstruct diag_md_session_t *info = NULL;'
p13613
as(I2
I2
tp13614
(lp13615
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p13616
as(I33
I33
tp13617
(lp13618
S'\t}'
p13619
assg32
I5
sg33
(dp13620
(I2
I3
tp13621
(lp13622
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p13623
aS'\t\t\t\t   struct diag_md_session_t *info)'
p13624
as(I30
I30
tp13625
(lp13626
S'\tif (!diag_apps_responds())'
p13627
assg41
(I1
I57
tp13628
ssss(g10116
S'diag_clear_masks'
p13629
tp13630
(dp13631
S'void diag_clear_masks(int pid)\n{\n\tint ret;\n\tchar cmd_disable_log_mask[] = { 0x73, 0, 0, 0, 0, 0, 0, 0};\n\tchar cmd_disable_msg_mask[] = { 0x7D, 0x05, 0, 0, 0, 0, 0, 0};\n\tchar cmd_disable_event_mask[] = { 0x60, 0};\n\n\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t"diag: %s: masks clear request upon %s\\n", __func__,\n\t((pid) ? "ODL exit" : "USB Disconnection"));\n\n\tret = diag_process_apps_masks(cmd_disable_log_mask,\n\t\t\tsizeof(cmd_disable_log_mask), pid);\n\tret = diag_process_apps_masks(cmd_disable_msg_mask,\n\t\t\tsizeof(cmd_disable_msg_mask), pid);\n\tret = diag_process_apps_masks(cmd_disable_event_mask,\n\t\t\tsizeof(cmd_disable_event_mask), pid);\n\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t"diag:%s: masks cleared successfully\\n", __func__);\n}'
p13632
(dp13633
((g10116
g13629
tp13634
I1
tp13635
(dp13636
g12
g13
sg14
(dp13637
(I13
I13
tp13638
(lp13639
S'\t\t\tsizeof(cmd_disable_log_mask), pid);'
p13640
as(I15
I15
tp13641
(lp13642
S'\t\t\tsizeof(cmd_disable_msg_mask), pid);'
p13643
as(I17
I17
tp13644
(lp13645
S'\t\t\tsizeof(cmd_disable_event_mask), pid);'
p13646
as(I1
I1
tp13647
(lp13648
S'void diag_clear_masks(int pid)'
p13649
as(I10
I10
tp13650
(lp13651
S'\t((pid) ? "ODL exit" : "USB Disconnection"));'
p13652
assg32
I1
sg33
(dp13653
(I13
I13
tp13654
(lp13655
S'\t\t\tsizeof(cmd_disable_log_mask), info);'
p13656
as(I15
I15
tp13657
(lp13658
S'\t\t\tsizeof(cmd_disable_msg_mask), info);'
p13659
as(I17
I17
tp13660
(lp13661
S'\t\t\tsizeof(cmd_disable_event_mask), info);'
p13662
as(I1
I1
tp13663
(lp13664
S'void diag_clear_masks(struct diag_md_session_t *info)'
p13665
as(I10
I10
tp13666
(lp13667
S'\t((info) ? "ODL exit" : "USB Disconnection"));'
p13668
assg41
(I1
I20
tp13669
ssss(g10116
S'diag_md_session_check'
p13670
tp13671
(dp13672
S'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)\n\t\treturn -EINVAL;\n\n\tif (req_mode == DIAG_USB_MODE) {\n\t\tif (curr_mode == DIAG_USB_MODE)\n\t\t\treturn 0;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p13673
(dp13674
((g10116
g13670
tp13675
I1
tp13676
(dp13677
g12
g13
sg14
(dp13678
(I65
I66
tp13679
(lp13680
S'\t\tperipheral_mask = session_info->peripheral_mask;'
p13681
aS'\t\tif ((change_mask & peripheral_mask)'
p13682
as(I80
I81
tp13683
(lp13684
S'\t\t\tdiag_md_session_close(current->tgid);'
p13685
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13686
as(I102
I102
tp13687
(lp13688
S'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13689
as(I5
I5
tp13690
(lp13691
S'\tint i, bit = 0, err = 0, peripheral_mask = 0;'
p13692
as(I70
I70
tp13693
(lp13694
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13695
as(I76
I77
tp13696
(lp13697
S'\t\tif (~change_mask & peripheral_mask) {'
p13698
aS'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13699
as(I62
I62
tp13700
(lp13701
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13702
as(I106
I106
tp13703
(lp13704
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13705
as(I99
I99
tp13706
(lp13707
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p13708
as(I50
I50
tp13709
(lp13710
S'\t\t}'
p13711
as(I104
I104
tp13712
(lp13713
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13714
as(I91
I91
tp13715
(lp13716
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p13717
as(I47
I48
tp13718
(lp13719
S'\t\tif (!change_mask) {'
p13720
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13721
as(I33
I33
tp13722
(lp13723
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13724
as(I29
I29
tp13725
(lp13726
S'\t\tmutex_lock(&driver->md_session_lock);'
p13727
assg32
I4
sg33
(dp13728
(I80
I81
tp13729
(lp13730
S'\t\t\tdiag_md_session_close(session_info);'
p13731
ag59
as(I102
I102
tp13732
(lp13733
S'\t\t\terr = diag_md_peripheral_switch(session_info,'
p13734
as(I59
I59
tp13735
(lp13736
S'\t\tmutex_lock(&driver->md_session_lock);'
p13737
as(I90
I90
tp13738
(lp13739
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p13740
as(I76
I77
tp13741
(lp13742
S'\t\tif (~change_mask & session_info->peripheral_mask) {'
p13743
aS'\t\t\terr = diag_md_peripheral_switch(session_info,'
p13744
as(I36
I36
tp13745
(lp13746
g59
as(I5
I5
tp13747
(lp13748
S'\tint i, bit = 0, err = 0;'
p13749
as(I47
I47
tp13750
(lp13751
S'\t\tif (!change_mask)'
p13752
as(I60
I61
tp13753
(lp13754
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13755
ag59
as(I65
I65
tp13756
(lp13757
S'\t\tif ((change_mask & session_info->peripheral_mask)'
p13758
as(I93
I93
tp13759
(lp13760
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13761
assg41
(I1
I119
tp13762
sssS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)\n\t\treturn -EINVAL;\n\n\tif (req_mode == DIAG_USB_MODE) {\n\t\tif (curr_mode == DIAG_USB_MODE)\n\t\t\treturn 0;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p13763
(dp13764
((g10116
g13670
tp13765
I1
tp13766
(dp13767
g12
g13
sg14
(dp13768
(I65
I66
tp13769
(lp13770
S'\t\tperipheral_mask = session_info->peripheral_mask;'
p13771
aS'\t\tif ((change_mask & peripheral_mask)'
p13772
as(I80
I81
tp13773
(lp13774
S'\t\t\tdiag_md_session_close(current->tgid);'
p13775
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13776
as(I102
I102
tp13777
(lp13778
S'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13779
as(I5
I5
tp13780
(lp13781
S'\tint i, bit = 0, err = 0, peripheral_mask = 0;'
p13782
as(I70
I70
tp13783
(lp13784
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13785
as(I76
I77
tp13786
(lp13787
S'\t\tif (~change_mask & peripheral_mask) {'
p13788
aS'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13789
as(I114
I120
tp13790
(lp13791
S'\t\t\tmutex_lock(&driver->hdlc_disable_mutex);'
p13792
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p13793
aS'\t\t\t\tif ((param->peripheral_mask > 0) &&'
p13794
aS'\t\t\t\t\t(param->peripheral_mask & (1 << i)))'
p13795
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;'
p13796
aS'\t\t\t}'
p13797
aS'\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);'
p13798
as(I62
I62
tp13799
(lp13800
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13801
as(I106
I106
tp13802
(lp13803
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13804
as(I99
I99
tp13805
(lp13806
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p13807
as(I50
I50
tp13808
(lp13809
S'\t\t}'
p13810
as(I104
I104
tp13811
(lp13812
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13813
as(I91
I91
tp13814
(lp13815
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p13816
as(I47
I48
tp13817
(lp13818
S'\t\tif (!change_mask) {'
p13819
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13820
as(I33
I33
tp13821
(lp13822
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13823
as(I29
I29
tp13824
(lp13825
S'\t\tmutex_lock(&driver->md_session_lock);'
p13826
assg32
I4
sg33
(dp13827
(I80
I81
tp13828
(lp13829
S'\t\t\tdiag_md_session_close(session_info);'
p13830
ag59
as(I102
I102
tp13831
(lp13832
S'\t\t\terr = diag_md_peripheral_switch(session_info,'
p13833
as(I59
I59
tp13834
(lp13835
S'\t\tmutex_lock(&driver->md_session_lock);'
p13836
as(I90
I90
tp13837
(lp13838
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p13839
as(I76
I77
tp13840
(lp13841
S'\t\tif (~change_mask & session_info->peripheral_mask) {'
p13842
aS'\t\t\terr = diag_md_peripheral_switch(session_info,'
p13843
as(I36
I36
tp13844
(lp13845
g59
as(I5
I5
tp13846
(lp13847
S'\tint i, bit = 0, err = 0;'
p13848
as(I47
I47
tp13849
(lp13850
S'\t\tif (!change_mask)'
p13851
as(I60
I61
tp13852
(lp13853
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13854
ag59
as(I65
I65
tp13855
(lp13856
S'\t\tif ((change_mask & session_info->peripheral_mask)'
p13857
as(I93
I93
tp13858
(lp13859
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13860
assg41
(I1
I126
tp13861
sssS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_PCIE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\tif (req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE) {\n\t\tif (curr_mode == req_mode)\n\t\t\treturn 0;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);\n\t\t\telse\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p13862
(dp13863
((g10116
g13670
tp13864
I1
tp13865
(dp13866
g12
g13
sg14
(dp13867
(I105
I109
tp13868
(lp13869
S'\t\t\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)'
p13870
aS'\t\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13871
aS'\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);'
p13872
aS'\t\t\telse'
p13873
aS'\t\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13874
as(I5
I5
tp13875
(lp13876
S'\tint i, bit = 0, err = 0, peripheral_mask = 0;'
p13877
as(I121
I127
tp13878
(lp13879
S'\t\t\tmutex_lock(&driver->hdlc_disable_mutex);'
p13880
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p13881
aS'\t\t\t\tif ((param->peripheral_mask > 0) &&'
p13882
aS'\t\t\t\t\t(param->peripheral_mask & (1 << i)))'
p13883
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;'
p13884
aS'\t\t\t}'
p13885
aS'\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);'
p13886
as(I102
I102
tp13887
(lp13888
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p13889
as(I68
I69
tp13890
(lp13891
S'\t\tperipheral_mask = session_info->peripheral_mask;'
p13892
aS'\t\tif ((change_mask & peripheral_mask)'
p13893
as(I79
I80
tp13894
(lp13895
S'\t\tif (~change_mask & peripheral_mask) {'
p13896
aS'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p13897
as(I36
I36
tp13898
(lp13899
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13900
as(I111
I111
tp13901
(lp13902
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13903
as(I73
I73
tp13904
(lp13905
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13906
as(I17
I17
tp13907
(lp13908
S'\tcase DIAG_PCIE_MODE:'
p13909
as(I24
I25
tp13910
(lp13911
S'\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&'
p13912
aS'\t\treq_mode != DIAG_PCIE_MODE)'
p13913
as(I28
I29
tp13914
(lp13915
S'\tif (req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE) {'
p13916
aS'\t\tif (curr_mode == req_mode)'
p13917
as(I50
I51
tp13918
(lp13919
S'\t\tif (!change_mask) {'
p13920
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13921
as(I113
I113
tp13922
(lp13923
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13924
as(I94
I94
tp13925
(lp13926
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p13927
as(I83
I84
tp13928
(lp13929
S'\t\t\tdiag_md_session_close(current->tgid);'
p13930
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p13931
as(I31
I32
tp13932
(lp13933
g59
aS'\t\tmutex_lock(&driver->md_session_lock);'
p13934
as(I65
I65
tp13935
(lp13936
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p13937
as(I53
I53
tp13938
(lp13939
S'\t\t}'
p13940
assg32
I4
sg33
(dp13941
(I96
I96
tp13942
(lp13943
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13944
as(I5
I5
tp13945
(lp13946
S'\tint i, bit = 0, err = 0;'
p13947
as(I28
I29
tp13948
(lp13949
S'\tif (req_mode == DIAG_USB_MODE) {'
p13950
aS'\t\tif (curr_mode == DIAG_USB_MODE)'
p13951
as(I79
I80
tp13952
(lp13953
S'\t\tif (~change_mask & session_info->peripheral_mask) {'
p13954
aS'\t\t\terr = diag_md_peripheral_switch(session_info,'
p13955
as(I68
I68
tp13956
(lp13957
S'\t\tif ((change_mask & session_info->peripheral_mask)'
p13958
as(I39
I39
tp13959
(lp13960
g59
as(I105
I105
tp13961
(lp13962
S'\t\t\terr = diag_md_peripheral_switch(session_info,'
p13963
as(I62
I62
tp13964
(lp13965
S'\t\tmutex_lock(&driver->md_session_lock);'
p13966
as(I24
I24
tp13967
(lp13968
S'\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)'
p13969
as(I50
I50
tp13970
(lp13971
S'\t\tif (!change_mask)'
p13972
as(I63
I64
tp13973
(lp13974
S'\t\tmutex_unlock(&driver->md_session_lock);'
p13975
ag59
as(I83
I84
tp13976
(lp13977
S'\t\t\tdiag_md_session_close(session_info);'
p13978
ag59
as(I93
I93
tp13979
(lp13980
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p13981
assg41
(I1
I133
tp13982
sssS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_PCIE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\tif (curr_mode == req_mode)\n\t\treturn 0;\n\n\tif ((req_mode ==  DIAG_USB_MODE && curr_mode == DIAG_PCIE_MODE) ||\n\t\t(req_mode == DIAG_PCIE_MODE && curr_mode == DIAG_USB_MODE)) {\n\t\t*change_mode = 1;\n\t\treturn 0;\n\t} else if ((req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE)\n\t\t&& curr_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, req_mode);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);\n\t\t\telse\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p13983
(dp13984
((g10116
g13670
tp13985
I1
tp13986
(dp13987
g12
g13
sg14
(dp13988
(I28
I37
tp13989
(lp13990
S'\tif (curr_mode == req_mode)'
p13991
aS'\t\treturn 0;'
p13992
ag59
aS'\tif ((req_mode ==  DIAG_USB_MODE && curr_mode == DIAG_PCIE_MODE) ||'
p13993
aS'\t\t(req_mode == DIAG_PCIE_MODE && curr_mode == DIAG_USB_MODE)) {'
p13994
aS'\t\t*change_mode = 1;'
p13995
aS'\t\treturn 0;'
p13996
aS'\t} else if ((req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE)'
p13997
aS'\t\t&& curr_mode == DIAG_MEMORY_DEVICE_MODE) {'
p13998
aS'\t\tmutex_lock(&driver->md_session_lock);'
p13999
as(I73
I74
tp14000
(lp14001
S'\t\tperipheral_mask = session_info->peripheral_mask;'
p14002
aS'\t\tif ((change_mask & peripheral_mask)'
p14003
as(I107
I107
tp14004
(lp14005
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p14006
as(I110
I114
tp14007
(lp14008
S'\t\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)'
p14009
aS'\t\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p14010
aS'\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);'
p14011
aS'\t\t\telse'
p14012
aS'\t\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p14013
as(I5
I5
tp14014
(lp14015
S'\tint i, bit = 0, err = 0, peripheral_mask = 0;'
p14016
as(I58
I58
tp14017
(lp14018
S'\t\t}'
p14019
as(I116
I116
tp14020
(lp14021
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14022
as(I70
I70
tp14023
(lp14024
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14025
as(I41
I41
tp14026
(lp14027
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14028
as(I24
I25
tp14029
(lp14030
S'\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&'
p14031
aS'\t\treq_mode != DIAG_PCIE_MODE)'
p14032
as(I99
I99
tp14033
(lp14034
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p14035
as(I88
I89
tp14036
(lp14037
S'\t\t\tdiag_md_session_close(current->tgid);'
p14038
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p14039
as(I78
I78
tp14040
(lp14041
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14042
as(I126
I132
tp14043
(lp14044
S'\t\t\tmutex_lock(&driver->hdlc_disable_mutex);'
p14045
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p14046
aS'\t\t\t\tif ((param->peripheral_mask > 0) &&'
p14047
aS'\t\t\t\t\t(param->peripheral_mask & (1 << i)))'
p14048
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;'
p14049
aS'\t\t\t}'
p14050
aS'\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);'
p14051
as(I118
I118
tp14052
(lp14053
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14054
as(I55
I56
tp14055
(lp14056
S'\t\tif (!change_mask) {'
p14057
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14058
as(I17
I17
tp14059
(lp14060
S'\tcase DIAG_PCIE_MODE:'
p14061
as(I84
I86
tp14062
(lp14063
S'\t\tif (~change_mask & peripheral_mask) {'
p14064
aS'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p14065
aS'\t\t\t\t\tchange_mask, req_mode);'
p14066
assg32
I4
sg33
(dp14067
(I110
I110
tp14068
(lp14069
S'\t\t\terr = diag_md_peripheral_switch(session_info,'
p14070
as(I67
I67
tp14071
(lp14072
S'\t\tmutex_lock(&driver->md_session_lock);'
p14073
as(I55
I55
tp14074
(lp14075
S'\t\tif (!change_mask)'
p14076
as(I68
I69
tp14077
(lp14078
S'\t\tmutex_unlock(&driver->md_session_lock);'
p14079
ag59
as(I44
I44
tp14080
(lp14081
g59
as(I101
I101
tp14082
(lp14083
S'\t\tmutex_unlock(&driver->md_session_lock);'
p14084
as(I5
I5
tp14085
(lp14086
S'\tint i, bit = 0, err = 0;'
p14087
as(I73
I73
tp14088
(lp14089
S'\t\tif ((change_mask & session_info->peripheral_mask)'
p14090
as(I88
I89
tp14091
(lp14092
S'\t\t\tdiag_md_session_close(session_info);'
p14093
ag59
as(I24
I24
tp14094
(lp14095
S'\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)'
p14096
as(I98
I98
tp14097
(lp14098
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p14099
as(I28
I30
tp14100
(lp14101
S'\tif (req_mode == DIAG_USB_MODE) {'
p14102
aS'\t\tif (curr_mode == DIAG_USB_MODE)'
p14103
aS'\t\t\treturn 0;'
p14104
as(I84
I86
tp14105
(lp14106
S'\t\tif (~change_mask & session_info->peripheral_mask) {'
p14107
aS'\t\t\terr = diag_md_peripheral_switch(session_info,'
p14108
aS'\t\t\t\t\tchange_mask, DIAG_USB_MODE);'
p14109
assg41
(I1
I138
tp14110
sssS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_PCIE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\tif (curr_mode == req_mode)\n\t\treturn 0;\n\n\tif ((req_mode ==  DIAG_USB_MODE && curr_mode == DIAG_PCIE_MODE) ||\n\t\t(req_mode == DIAG_PCIE_MODE && curr_mode == DIAG_USB_MODE)) {\n\t\t*change_mode = 1;\n\t\treturn 0;\n\t} else if ((req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE)\n\t\t&& (curr_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\tcurr_mode == DIAG_MULTI_MODE)) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, req_mode);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);\n\t\t\telse\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p14111
(dp14112
((g10116
g13670
tp14113
I1
tp14114
(dp14115
g12
g13
sg14
(dp14116
(I56
I57
tp14117
(lp14118
S'\t\tif (!change_mask) {'
p14119
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14120
as(I100
I100
tp14121
(lp14122
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p14123
as(I74
I75
tp14124
(lp14125
S'\t\tperipheral_mask = session_info->peripheral_mask;'
p14126
aS'\t\tif ((change_mask & peripheral_mask)'
p14127
as(I5
I5
tp14128
(lp14129
S'\tint i, bit = 0, err = 0, peripheral_mask = 0;'
p14130
as(I42
I42
tp14131
(lp14132
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14133
as(I127
I133
tp14134
(lp14135
S'\t\t\tmutex_lock(&driver->hdlc_disable_mutex);'
p14136
aS'\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p14137
aS'\t\t\t\tif ((param->peripheral_mask > 0) &&'
p14138
aS'\t\t\t\t\t(param->peripheral_mask & (1 << i)))'
p14139
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;'
p14140
aS'\t\t\t}'
p14141
aS'\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);'
p14142
as(I85
I87
tp14143
(lp14144
S'\t\tif (~change_mask & peripheral_mask) {'
p14145
aS'\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p14146
aS'\t\t\t\t\tchange_mask, req_mode);'
p14147
as(I71
I71
tp14148
(lp14149
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14150
as(I79
I79
tp14151
(lp14152
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14153
as(I24
I25
tp14154
(lp14155
S'\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&'
p14156
aS'\t\treq_mode != DIAG_PCIE_MODE)'
p14157
as(I17
I17
tp14158
(lp14159
S'\tcase DIAG_PCIE_MODE:'
p14160
as(I117
I117
tp14161
(lp14162
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14163
as(I89
I90
tp14164
(lp14165
S'\t\t\tdiag_md_session_close(current->tgid);'
p14166
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p14167
as(I108
I108
tp14168
(lp14169
S'\t\t\t\tmutex_unlock(&driver->md_session_lock);'
p14170
as(I111
I115
tp14171
(lp14172
S'\t\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)'
p14173
aS'\t\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p14174
aS'\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);'
p14175
aS'\t\t\telse'
p14176
aS'\t\t\t\terr = diag_md_peripheral_switch(current->tgid,'
p14177
as(I119
I119
tp14178
(lp14179
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14180
as(I28
I38
tp14181
(lp14182
S'\tif (curr_mode == req_mode)'
p14183
aS'\t\treturn 0;'
p14184
ag59
aS'\tif ((req_mode ==  DIAG_USB_MODE && curr_mode == DIAG_PCIE_MODE) ||'
p14185
aS'\t\t(req_mode == DIAG_PCIE_MODE && curr_mode == DIAG_USB_MODE)) {'
p14186
aS'\t\t*change_mode = 1;'
p14187
aS'\t\treturn 0;'
p14188
aS'\t} else if ((req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE)'
p14189
aS'\t\t&& (curr_mode == DIAG_MEMORY_DEVICE_MODE ||'
p14190
aS'\t\tcurr_mode == DIAG_MULTI_MODE)) {'
p14191
aS'\t\tmutex_lock(&driver->md_session_lock);'
p14192
as(I59
I59
tp14193
(lp14194
S'\t\t}'
p14195
assg32
I4
sg33
(dp14196
(I99
I99
tp14197
(lp14198
S'\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;'
p14199
as(I102
I102
tp14200
(lp14201
S'\t\tmutex_unlock(&driver->md_session_lock);'
p14202
as(I68
I68
tp14203
(lp14204
S'\t\tmutex_lock(&driver->md_session_lock);'
p14205
as(I45
I45
tp14206
(lp14207
g59
as(I74
I74
tp14208
(lp14209
S'\t\tif ((change_mask & session_info->peripheral_mask)'
p14210
as(I69
I70
tp14211
(lp14212
S'\t\tmutex_unlock(&driver->md_session_lock);'
p14213
ag59
as(I85
I87
tp14214
(lp14215
S'\t\tif (~change_mask & session_info->peripheral_mask) {'
p14216
aS'\t\t\terr = diag_md_peripheral_switch(session_info,'
p14217
aS'\t\t\t\t\tchange_mask, DIAG_USB_MODE);'
p14218
as(I5
I5
tp14219
(lp14220
S'\tint i, bit = 0, err = 0;'
p14221
as(I89
I90
tp14222
(lp14223
S'\t\t\tdiag_md_session_close(session_info);'
p14224
ag59
as(I24
I24
tp14225
(lp14226
S'\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)'
p14227
as(I56
I56
tp14228
(lp14229
S'\t\tif (!change_mask)'
p14230
as(I111
I111
tp14231
(lp14232
S'\t\t\terr = diag_md_peripheral_switch(session_info,'
p14233
as(I28
I30
tp14234
(lp14235
S'\tif (req_mode == DIAG_USB_MODE) {'
p14236
aS'\t\tif (curr_mode == DIAG_USB_MODE)'
p14237
aS'\t\t\treturn 0;'
p14238
assg41
(I1
I139
tp14239
ssss(g10002
S'diag_process_apps_pkt'
p14240
tp14241
(dp14242
S'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret, peripheral = -EINVAL;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\ttemp += sizeof(uint16_t);\n\n\tpr_debug("diag: In %s, received cmd %02x %02x %02x\\n",\n\t\t __func__, entry.cmd_code, entry.subsys_id, entry.cmd_code_hi);\n\n\tif (*buf == DIAG_CMD_LOG_ON_DMND && driver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);\n\t\tif (len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((chk_apps_master()) && (*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif (*buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if (*buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tperipheral =\n\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (peripheral > 0 && info) {\n\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t} else {\n\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p14243
(dp14244
((g10002
g14240
tp14245
I1
tp14246
(dp14247
g12
g13
sg14
(dp14248
(I12
I12
tp14249
(lp14250
S'\tstruct diag_md_session_t *info = NULL;'
p14251
as(I54
I55
tp14252
(lp14253
S'\t\t\tp_mask = info->peripheral_mask;'
p14254
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14255
as(I181
I181
tp14256
(lp14257
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14258
as(I90
I90
tp14259
(lp14260
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);'
p14261
as(I20
I20
tp14262
(lp14263
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);'
p14264
as(I103
I103
tp14265
(lp14266
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14267
as(I233
I233
tp14268
(lp14269
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14270
as(I152
I152
tp14271
(lp14272
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);'
p14273
as(I132
I132
tp14274
(lp14275
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);'
p14276
as(I114
I114
tp14277
(lp14278
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14279
as(I84
I84
tp14280
(lp14281
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);'
p14282
as(I51
I52
tp14283
(lp14284
S'\t\tmutex_lock(&driver->md_session_lock);'
p14285
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p14286
as(I125
I125
tp14287
(lp14288
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14289
as(I241
I242
tp14290
(lp14291
S'\t\tmutex_lock(&driver->md_session_lock);'
p14292
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p14293
as(I59
I59
tp14294
(lp14295
S'\t\t\t\tp_mask) || (pd_mask & p_mask))'
p14296
as(I42
I42
tp14297
(lp14298
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14299
as(I170
I170
tp14300
(lp14301
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);'
p14302
as(I201
I201
tp14303
(lp14304
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);'
p14305
as(I1
I1
tp14306
(lp14307
S'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)'
p14308
as(I62
I62
tp14309
(lp14310
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14311
as(I272
I272
tp14312
(lp14313
S'\t\tdiag_send_error_rsp(buf, len, pid);'
p14314
as(I18
I18
tp14315
(lp14316
S'\tmask_ret = diag_process_apps_masks(buf, len, pid);'
p14317
as(I66
I66
tp14318
(lp14319
S'\t\t\t\tdiag_send_error_rsp(buf, len, pid);'
p14320
as(I214
I214
tp14321
(lp14322
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);'
p14323
as(I3
I4
tp14324
(lp14325
S'\tint i, p_mask = 0;'
p14326
aS'\tint mask_ret, peripheral = -EINVAL;'
p14327
as(I161
I161
tp14328
(lp14329
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);'
p14330
as(I247
I263
tp14331
(lp14332
S'\t\tperipheral ='
p14333
aS'\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);'
p14334
aS'\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p14335
aS'\t\t\tif (peripheral > 0 && info) {'
p14336
aS'\t\t\t\tif (peripheral & (1 << i))'
p14337
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14338
aS'\t\t\t\t\tinfo->hdlc_disabled;'
p14339
aS'\t\t\t\telse if (!diag_md_session_get_peripheral(i))'
p14340
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14341
aS'\t\t\t\t\tdriver->hdlc_disabled;'
p14342
aS'\t\t\t} else {'
p14343
aS'\t\t\t\tif (!diag_md_session_get_peripheral(i))'
p14344
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14345
aS'\t\t\t\t\tdriver->hdlc_disabled;'
p14346
aS'\t\t\t}'
p14347
aS'\t\t}'
p14348
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p14349
as(I221
I221
tp14350
(lp14351
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14352
assg32
I3
sg33
(dp14353
(I84
I84
tp14354
(lp14355
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, info);'
p14356
as(I181
I181
tp14357
(lp14358
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14359
as(I90
I90
tp14360
(lp14361
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, info);'
p14362
as(I20
I20
tp14363
(lp14364
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, info);'
p14365
as(I103
I103
tp14366
(lp14367
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14368
as(I201
I201
tp14369
(lp14370
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, info);'
p14371
as(I152
I152
tp14372
(lp14373
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, info);'
p14374
as(I132
I132
tp14375
(lp14376
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, info);'
p14377
as(I125
I125
tp14378
(lp14379
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14380
as(I1
I2
tp14381
(lp14382
S'int diag_process_apps_pkt(unsigned char *buf, int len,'
p14383
aS'\t\t\tstruct diag_md_session_t *info)'
p14384
as(I221
I221
tp14385
(lp14386
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14387
as(I42
I42
tp14388
(lp14389
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14390
as(I59
I60
tp14391
(lp14392
S'\t\t\t\tinfo->peripheral_mask) ||'
p14393
aS'\t\t\t\t(pd_mask & info->peripheral_mask))'
p14394
as(I170
I170
tp14395
(lp14396
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, info);'
p14397
as(I233
I233
tp14398
(lp14399
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14400
as(I272
I272
tp14401
(lp14402
S'\t\tdiag_send_error_rsp(buf, len, info);'
p14403
as(I114
I114
tp14404
(lp14405
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14406
as(I18
I18
tp14407
(lp14408
S'\tmask_ret = diag_process_apps_masks(buf, len, info);'
p14409
as(I66
I66
tp14410
(lp14411
S'\t\t\t\tdiag_send_error_rsp(buf, len, info);'
p14412
as(I214
I214
tp14413
(lp14414
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, info);'
p14415
as(I3
I4
tp14416
(lp14417
S'\tint i;'
p14418
aS'\tint mask_ret;'
p14419
as(I161
I161
tp14420
(lp14421
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, info);'
p14422
assg41
(I1
I275
tp14423
sssS'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\ttemp += sizeof(uint16_t);\n\n\tpr_debug("diag: In %s, received cmd %02x %02x %02x\\n",\n\t\t __func__, entry.cmd_code, entry.subsys_id, entry.cmd_code_hi);\n\n\tif (*buf == DIAG_CMD_LOG_ON_DMND && driver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);\n\t\tif (len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((chk_apps_master()) && (*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif (*buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if (*buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p14424
(dp14425
((g10002
g14240
tp14426
I1
tp14427
(dp14428
g12
g13
sg14
(dp14429
(I20
I20
tp14430
(lp14431
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);'
p14432
as(I54
I55
tp14433
(lp14434
S'\t\t\tp_mask = info->peripheral_mask;'
p14435
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14436
as(I181
I181
tp14437
(lp14438
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14439
as(I90
I90
tp14440
(lp14441
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);'
p14442
as(I12
I12
tp14443
(lp14444
S'\tstruct diag_md_session_t *info = NULL;'
p14445
as(I103
I103
tp14446
(lp14447
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14448
as(I256
I256
tp14449
(lp14450
S'\t\tdiag_send_error_rsp(buf, len, pid);'
p14451
as(I233
I233
tp14452
(lp14453
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14454
as(I152
I152
tp14455
(lp14456
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);'
p14457
as(I132
I132
tp14458
(lp14459
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);'
p14460
as(I114
I114
tp14461
(lp14462
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14463
as(I59
I59
tp14464
(lp14465
S'\t\t\t\tp_mask) || (pd_mask & p_mask))'
p14466
as(I51
I52
tp14467
(lp14468
S'\t\tmutex_lock(&driver->md_session_lock);'
p14469
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p14470
as(I3
I3
tp14471
(lp14472
S'\tint i, p_mask = 0;'
p14473
as(I241
I242
tp14474
(lp14475
S'\t\tmutex_lock(&driver->md_session_lock);'
p14476
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p14477
as(I247
I247
tp14478
(lp14479
S'\t\tmutex_unlock(&driver->md_session_lock);'
p14480
as(I125
I125
tp14481
(lp14482
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14483
as(I42
I42
tp14484
(lp14485
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14486
as(I170
I170
tp14487
(lp14488
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);'
p14489
as(I201
I201
tp14490
(lp14491
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);'
p14492
as(I1
I1
tp14493
(lp14494
S'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)'
p14495
as(I62
I62
tp14496
(lp14497
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14498
as(I18
I18
tp14499
(lp14500
S'\tmask_ret = diag_process_apps_masks(buf, len, pid);'
p14501
as(I66
I66
tp14502
(lp14503
S'\t\t\t\tdiag_send_error_rsp(buf, len, pid);'
p14504
as(I214
I214
tp14505
(lp14506
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);'
p14507
as(I84
I84
tp14508
(lp14509
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);'
p14510
as(I161
I161
tp14511
(lp14512
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);'
p14513
as(I221
I221
tp14514
(lp14515
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14516
assg32
I3
sg33
(dp14517
(I125
I125
tp14518
(lp14519
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14520
as(I84
I84
tp14521
(lp14522
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, info);'
p14523
as(I181
I181
tp14524
(lp14525
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14526
as(I90
I90
tp14527
(lp14528
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, info);'
p14529
as(I20
I20
tp14530
(lp14531
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, info);'
p14532
as(I103
I103
tp14533
(lp14534
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14535
as(I256
I256
tp14536
(lp14537
S'\t\tdiag_send_error_rsp(buf, len, info);'
p14538
as(I201
I201
tp14539
(lp14540
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, info);'
p14541
as(I152
I152
tp14542
(lp14543
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, info);'
p14544
as(I132
I132
tp14545
(lp14546
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, info);'
p14547
as(I114
I114
tp14548
(lp14549
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14550
as(I3
I3
tp14551
(lp14552
S'\tint i;'
p14553
as(I1
I2
tp14554
(lp14555
S'int diag_process_apps_pkt(unsigned char *buf, int len,'
p14556
aS'\t\t\tstruct diag_md_session_t *info)'
p14557
as(I221
I221
tp14558
(lp14559
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14560
as(I42
I42
tp14561
(lp14562
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14563
as(I170
I170
tp14564
(lp14565
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, info);'
p14566
as(I233
I233
tp14567
(lp14568
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14569
as(I18
I18
tp14570
(lp14571
S'\tmask_ret = diag_process_apps_masks(buf, len, info);'
p14572
as(I66
I66
tp14573
(lp14574
S'\t\t\t\tdiag_send_error_rsp(buf, len, info);'
p14575
as(I214
I214
tp14576
(lp14577
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, info);'
p14578
as(I59
I60
tp14579
(lp14580
S'\t\t\t\tinfo->peripheral_mask) ||'
p14581
aS'\t\t\t\t(pd_mask & info->peripheral_mask))'
p14582
as(I161
I161
tp14583
(lp14584
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, info);'
p14585
assg41
(I1
I259
tp14586
sssS'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret, peripheral = -EINVAL;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tif (len >= sizeof(uint8_t)) {\n\t\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code %02x\\n", entry.cmd_code);\n\t}\n\tif (len >= (2 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received subsys_id %02x\\n", entry.subsys_id);\n\t}\n\tif (len == (3 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint8_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t} else if (len >= (2 * sizeof(uint8_t)) + sizeof(uint16_t)) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t}\n\n\tif ((len >= sizeof(uint8_t)) && *buf == DIAG_CMD_LOG_ON_DMND &&\n\t\tdriver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);\n\t\tif (len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((len >= sizeof(uint8_t)) && (chk_apps_master()) &&\n\t\t(*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((len >= (3 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) && (*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif ((len >= sizeof(uint8_t)) && *buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if ((len >= sizeof(uint8_t)) && *buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tperipheral =\n\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (peripheral > 0 && info) {\n\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t} else {\n\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p14587
(dp14588
((g10002
g14240
tp14589
I1
tp14590
(dp14591
g12
g13
sg14
(dp14592
(I203
I203
tp14593
(lp14594
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14595
as(I55
I55
tp14596
(lp14597
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14598
as(I92
I93
tp14599
(lp14600
S'\tif ((len >= (4 * sizeof(uint8_t))) &&'
p14601
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p14602
as(I20
I20
tp14603
(lp14604
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);'
p14605
as(I161
I162
tp14606
(lp14607
S'\telse if ((len >= (3 * sizeof(uint8_t))) &&'
p14608
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) && (*(buf+2) == 0x03)) {'
p14609
as(I119
I119
tp14610
(lp14611
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14612
as(I181
I181
tp14613
(lp14614
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);'
p14615
as(I143
I143
tp14616
(lp14617
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14618
as(I151
I151
tp14619
(lp14620
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);'
p14621
as(I75
I75
tp14622
(lp14623
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14624
as(I131
I131
tp14625
(lp14626
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14627
as(I171
I171
tp14628
(lp14629
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);'
p14630
as(I263
I264
tp14631
(lp14632
S'\t\tmutex_lock(&driver->md_session_lock);'
p14633
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p14634
as(I100
I101
tp14635
(lp14636
S'\t} else if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14637
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p14638
as(I25
I46
tp14639
(lp14640
S'\tif (len >= sizeof(uint8_t)) {'
p14641
aS'\t\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);'
p14642
aS'\t\tpr_debug("diag: received cmd_code %02x\\n", entry.cmd_code);'
p14643
aS'\t}'
p14644
aS'\tif (len >= (2 * sizeof(uint8_t))) {'
p14645
aS'\t\ttemp += sizeof(uint8_t);'
p14646
aS'\t\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);'
p14647
aS'\t\tpr_debug("diag: received subsys_id %02x\\n", entry.subsys_id);'
p14648
aS'\t}'
p14649
aS'\tif (len == (3 * sizeof(uint8_t))) {'
p14650
aS'\t\ttemp += sizeof(uint8_t);'
p14651
aS'\t\tentry.cmd_code_hi = (uint16_t)(*(uint8_t *)temp);'
p14652
aS'\t\tentry.cmd_code_lo = (uint16_t)(*(uint8_t *)temp);'
p14653
aS'\t\tpr_debug("diag: received cmd_code_hi %02x\\n",'
p14654
aS'\t\t\tentry.cmd_code_hi);'
p14655
aS'\t} else if (len >= (2 * sizeof(uint8_t)) + sizeof(uint16_t)) {'
p14656
aS'\t\ttemp += sizeof(uint8_t);'
p14657
aS'\t\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);'
p14658
aS'\t\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);'
p14659
aS'\t\tpr_debug("diag: received cmd_code_hi %02x\\n",'
p14660
aS'\t\t\tentry.cmd_code_hi);'
p14661
aS'\t}'
p14662
as(I176
I177
tp14663
(lp14664
S'\telse if ((len >= (4 * sizeof(uint8_t))) &&'
p14665
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14666
as(I14
I14
tp14667
(lp14668
S'\tif (!buf || len <= 0)'
p14669
as(I243
I243
tp14670
(lp14671
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14672
as(I111
I112
tp14673
(lp14674
S'\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14675
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14676
as(I255
I255
tp14677
(lp14678
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14679
as(I269
I285
tp14680
(lp14681
S'\t\tperipheral ='
p14682
aS'\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);'
p14683
aS'\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p14684
aS'\t\t\tif (peripheral > 0 && info) {'
p14685
aS'\t\t\t\tif (peripheral & (1 << i))'
p14686
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14687
aS'\t\t\t\t\tinfo->hdlc_disabled;'
p14688
aS'\t\t\t\telse if (!diag_md_session_get_peripheral(i))'
p14689
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14690
aS'\t\t\t\t\tdriver->hdlc_disabled;'
p14691
aS'\t\t\t} else {'
p14692
aS'\t\t\t\tif (!diag_md_session_get_peripheral(i))'
p14693
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14694
aS'\t\t\t\t\tdriver->hdlc_disabled;'
p14695
aS'\t\t\t}'
p14696
aS'\t\t}'
p14697
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p14698
as(I236
I236
tp14699
(lp14700
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);'
p14701
as(I48
I49
tp14702
(lp14703
S'\tif ((len >= sizeof(uint8_t)) && *buf == DIAG_CMD_LOG_ON_DMND &&'
p14704
aS'\t\tdriver->log_on_demand_support &&'
p14705
as(I12
I12
tp14706
(lp14707
S'\tstruct diag_md_session_t *info = NULL;'
p14708
as(I294
I294
tp14709
(lp14710
S'\t\tdiag_send_error_rsp(buf, len, pid);'
p14711
as(I98
I98
tp14712
(lp14713
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);'
p14714
as(I1
I1
tp14715
(lp14716
S'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)'
p14717
as(I79
I79
tp14718
(lp14719
S'\t\t\t\tdiag_send_error_rsp(buf, len, pid);'
p14720
as(I3
I4
tp14721
(lp14722
S'\tint i, p_mask = 0;'
p14723
aS'\tint mask_ret, peripheral = -EINVAL;'
p14724
as(I147
I148
tp14725
(lp14726
S'\telse if ((len >= sizeof(uint8_t)) && (chk_apps_master()) &&'
p14727
aS'\t\t(*buf == 0x3A)) {'
p14728
as(I227
I227
tp14729
(lp14730
S'\t\telse if ((len >= sizeof(uint8_t)) && *buf == 0x7c) {'
p14731
as(I64
I65
tp14732
(lp14733
S'\t\tmutex_lock(&driver->md_session_lock);'
p14734
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p14735
as(I219
I219
tp14736
(lp14737
S'\t\tif ((len >= sizeof(uint8_t)) && *buf == 0x00) {'
p14738
as(I123
I124
tp14739
(lp14740
S'\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14741
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14742
as(I105
I105
tp14743
(lp14744
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);'
p14745
as(I191
I191
tp14746
(lp14747
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);'
p14748
as(I185
I186
tp14749
(lp14750
S'\telse if ((len >= (4 * sizeof(uint8_t))) &&'
p14751
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14752
as(I67
I68
tp14753
(lp14754
S'\t\t\tp_mask = info->peripheral_mask;'
p14755
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14756
as(I72
I72
tp14757
(lp14758
S'\t\t\t\tp_mask) || (pd_mask & p_mask))'
p14759
as(I18
I18
tp14760
(lp14761
S'\tmask_ret = diag_process_apps_masks(buf, len, pid);'
p14762
as(I135
I136
tp14763
(lp14764
S'\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14765
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14766
as(I195
I196
tp14767
(lp14768
S'\telse if ((len >= (4 * sizeof(uint8_t))) &&'
p14769
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14770
as(I223
I223
tp14771
(lp14772
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);'
p14773
assg32
I3
sg33
(dp14774
(I185
I185
tp14775
(lp14776
S'\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14777
as(I161
I162
tp14778
(lp14779
S'\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14780
aS'\t\t(*(buf+2) == 0x03)) {'
p14781
as(I48
I48
tp14782
(lp14783
S'\tif (*buf == DIAG_CMD_LOG_ON_DMND && driver->log_on_demand_support &&'
p14784
as(I181
I181
tp14785
(lp14786
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, info);'
p14787
as(I147
I147
tp14788
(lp14789
S'\telse if ((chk_apps_master()) && (*buf == 0x3A)) {'
p14790
as(I255
I255
tp14791
(lp14792
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14793
as(I223
I223
tp14794
(lp14795
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, info);'
p14796
as(I20
I20
tp14797
(lp14798
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, info);'
p14799
as(I203
I203
tp14800
(lp14801
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14802
as(I135
I135
tp14803
(lp14804
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14805
as(I105
I105
tp14806
(lp14807
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, info);'
p14808
as(I98
I98
tp14809
(lp14810
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, info);'
p14811
as(I79
I79
tp14812
(lp14813
S'\t\t\t\tdiag_send_error_rsp(buf, len, info);'
p14814
as(I176
I176
tp14815
(lp14816
S'\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14817
as(I236
I236
tp14818
(lp14819
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, info);'
p14820
as(I219
I219
tp14821
(lp14822
S'\t\tif (*buf == 0x00) {'
p14823
as(I25
I34
tp14824
(lp14825
S'\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);'
p14826
aS'\ttemp += sizeof(uint8_t);'
p14827
aS'\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);'
p14828
aS'\ttemp += sizeof(uint8_t);'
p14829
aS'\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);'
p14830
aS'\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);'
p14831
aS'\ttemp += sizeof(uint16_t);'
p14832
ag59
aS'\tpr_debug("diag: In %s, received cmd %02x %02x %02x\\n",'
p14833
aS'\t\t __func__, entry.cmd_code, entry.subsys_id, entry.cmd_code_hi);'
p14834
as(I119
I119
tp14835
(lp14836
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14837
as(I92
I92
tp14838
(lp14839
S'\tif ((*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p14840
as(I14
I14
tp14841
(lp14842
S'\tif (!buf)'
p14843
as(I123
I123
tp14844
(lp14845
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14846
as(I1
I2
tp14847
(lp14848
S'int diag_process_apps_pkt(unsigned char *buf, int len,'
p14849
aS'\t\t\tstruct diag_md_session_t *info)'
p14850
as(I72
I73
tp14851
(lp14852
S'\t\t\t\tinfo->peripheral_mask) ||'
p14853
aS'\t\t\t\t(pd_mask & info->peripheral_mask))'
p14854
as(I151
I151
tp14855
(lp14856
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, info);'
p14857
as(I131
I131
tp14858
(lp14859
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14860
as(I171
I171
tp14861
(lp14862
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, info);'
p14863
as(I294
I294
tp14864
(lp14865
S'\t\tdiag_send_error_rsp(buf, len, info);'
p14866
as(I100
I100
tp14867
(lp14868
S'\t} else if ((*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p14869
as(I55
I55
tp14870
(lp14871
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14872
as(I143
I143
tp14873
(lp14874
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14875
as(I243
I243
tp14876
(lp14877
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p14878
as(I227
I227
tp14879
(lp14880
S'\t\telse if (*buf == 0x7c) {'
p14881
as(I191
I191
tp14882
(lp14883
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, info);'
p14884
as(I18
I18
tp14885
(lp14886
S'\tmask_ret = diag_process_apps_masks(buf, len, info);'
p14887
as(I195
I195
tp14888
(lp14889
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14890
as(I3
I4
tp14891
(lp14892
S'\tint i;'
p14893
aS'\tint mask_ret;'
p14894
as(I111
I111
tp14895
(lp14896
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14897
assg41
(I1
I297
tp14898
sssS'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret, peripheral = -EINVAL;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tif (len >= sizeof(uint8_t)) {\n\t\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code %02x\\n", entry.cmd_code);\n\t}\n\tif (len >= (2 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received subsys_id %02x\\n", entry.subsys_id);\n\t}\n\tif (len == (3 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint8_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t} else if (len >= (2 * sizeof(uint8_t)) + sizeof(uint16_t)) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t}\n\n\tif ((len >= sizeof(uint8_t)) && *buf == DIAG_CMD_LOG_ON_DMND &&\n\t\tdriver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\twrite_len = diag_process_stm_cmd(buf, len,\n\t\t\tdriver->apps_rsp_buf);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn write_len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((len >= sizeof(uint8_t)) && (chk_apps_master()) &&\n\t\t(*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((len >= (3 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) && (*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif ((len >= sizeof(uint8_t)) && *buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if ((len >= sizeof(uint8_t)) && *buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tperipheral =\n\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (peripheral > 0 && info) {\n\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t} else {\n\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p14899
(dp14900
((g10002
g14240
tp14901
I1
tp14902
(dp14903
g12
g13
sg14
(dp14904
(I12
I12
tp14905
(lp14906
S'\tstruct diag_md_session_t *info = NULL;'
p14907
as(I228
I228
tp14908
(lp14909
S'\t\telse if ((len >= sizeof(uint8_t)) && *buf == 0x7c) {'
p14910
as(I75
I75
tp14911
(lp14912
S'\t\t\tmutex_unlock(&driver->md_session_lock);'
p14913
as(I270
I286
tp14914
(lp14915
S'\t\tperipheral ='
p14916
aS'\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);'
p14917
aS'\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {'
p14918
aS'\t\t\tif (peripheral > 0 && info) {'
p14919
aS'\t\t\t\tif (peripheral & (1 << i))'
p14920
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14921
aS'\t\t\t\t\tinfo->hdlc_disabled;'
p14922
aS'\t\t\t\telse if (!diag_md_session_get_peripheral(i))'
p14923
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14924
aS'\t\t\t\t\tdriver->hdlc_disabled;'
p14925
aS'\t\t\t} else {'
p14926
aS'\t\t\t\tif (!diag_md_session_get_peripheral(i))'
p14927
aS'\t\t\t\t\tdriver->p_hdlc_disabled[i] ='
p14928
aS'\t\t\t\t\tdriver->hdlc_disabled;'
p14929
aS'\t\t\t}'
p14930
aS'\t\t}'
p14931
aS'\t\tmutex_unlock(&driver->md_session_lock);'
p14932
as(I92
I93
tp14933
(lp14934
S'\tif ((len >= (4 * sizeof(uint8_t))) &&'
p14935
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p14936
as(I20
I20
tp14937
(lp14938
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);'
p14939
as(I136
I137
tp14940
(lp14941
S'\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14942
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14943
as(I256
I256
tp14944
(lp14945
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14946
as(I162
I163
tp14947
(lp14948
S'\telse if ((len >= (3 * sizeof(uint8_t))) &&'
p14949
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) && (*(buf+2) == 0x03)) {'
p14950
as(I224
I224
tp14951
(lp14952
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);'
p14953
as(I172
I172
tp14954
(lp14955
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);'
p14956
as(I109
I109
tp14957
(lp14958
S'\t\treturn write_len;'
p14959
as(I177
I178
tp14960
(lp14961
S'\telse if ((len >= (4 * sizeof(uint8_t))) &&'
p14962
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14963
as(I186
I187
tp14964
(lp14965
S'\telse if ((len >= (4 * sizeof(uint8_t))) &&'
p14966
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p14967
as(I148
I149
tp14968
(lp14969
S'\telse if ((len >= sizeof(uint8_t)) && (chk_apps_master()) &&'
p14970
aS'\t\t(*buf == 0x3A)) {'
p14971
as(I132
I132
tp14972
(lp14973
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p14974
as(I100
I101
tp14975
(lp14976
S'\t} else if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14977
aS'\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p14978
as(I124
I125
tp14979
(lp14980
S'\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p14981
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p14982
as(I72
I72
tp14983
(lp14984
S'\t\t\t\tp_mask) || (pd_mask & p_mask))'
p14985
as(I25
I46
tp14986
(lp14987
S'\tif (len >= sizeof(uint8_t)) {'
p14988
aS'\t\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);'
p14989
aS'\t\tpr_debug("diag: received cmd_code %02x\\n", entry.cmd_code);'
p14990
aS'\t}'
p14991
aS'\tif (len >= (2 * sizeof(uint8_t))) {'
p14992
aS'\t\ttemp += sizeof(uint8_t);'
p14993
aS'\t\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);'
p14994
aS'\t\tpr_debug("diag: received subsys_id %02x\\n", entry.subsys_id);'
p14995
aS'\t}'
p14996
aS'\tif (len == (3 * sizeof(uint8_t))) {'
p14997
aS'\t\ttemp += sizeof(uint8_t);'
p14998
aS'\t\tentry.cmd_code_hi = (uint16_t)(*(uint8_t *)temp);'
p14999
aS'\t\tentry.cmd_code_lo = (uint16_t)(*(uint8_t *)temp);'
p15000
aS'\t\tpr_debug("diag: received cmd_code_hi %02x\\n",'
p15001
aS'\t\t\tentry.cmd_code_hi);'
p15002
aS'\t} else if (len >= (2 * sizeof(uint8_t)) + sizeof(uint16_t)) {'
p15003
aS'\t\ttemp += sizeof(uint8_t);'
p15004
aS'\t\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);'
p15005
aS'\t\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);'
p15006
aS'\t\tpr_debug("diag: received cmd_code_hi %02x\\n",'
p15007
aS'\t\t\tentry.cmd_code_hi);'
p15008
aS'\t}'
p15009
as(I14
I14
tp15010
(lp15011
S'\tif (!buf || len <= 0)'
p15012
as(I144
I144
tp15013
(lp15014
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p15015
as(I1
I1
tp15016
(lp15017
S'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)'
p15018
as(I48
I49
tp15019
(lp15020
S'\tif ((len >= sizeof(uint8_t)) && *buf == DIAG_CMD_LOG_ON_DMND &&'
p15021
aS'\t\tdriver->log_on_demand_support &&'
p15022
as(I192
I192
tp15023
(lp15024
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);'
p15025
as(I196
I197
tp15026
(lp15027
S'\telse if ((len >= (4 * sizeof(uint8_t))) &&'
p15028
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p15029
as(I18
I18
tp15030
(lp15031
S'\tmask_ret = diag_process_apps_masks(buf, len, pid);'
p15032
as(I295
I295
tp15033
(lp15034
S'\t\tdiag_send_error_rsp(buf, len, pid);'
p15035
as(I152
I152
tp15036
(lp15037
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);'
p15038
as(I204
I204
tp15039
(lp15040
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p15041
as(I64
I65
tp15042
(lp15043
S'\t\tmutex_lock(&driver->md_session_lock);'
p15044
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p15045
as(I264
I265
tp15046
(lp15047
S'\t\tmutex_lock(&driver->md_session_lock);'
p15048
aS'\t\tinfo = diag_md_session_get_pid(pid);'
p15049
as(I182
I182
tp15050
(lp15051
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);'
p15052
as(I67
I68
tp15053
(lp15054
S'\t\t\tp_mask = info->peripheral_mask;'
p15055
aS'\t\t\tmutex_unlock(&driver->md_session_lock);'
p15056
as(I220
I220
tp15057
(lp15058
S'\t\tif ((len >= sizeof(uint8_t)) && *buf == 0x00) {'
p15059
as(I237
I237
tp15060
(lp15061
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);'
p15062
as(I55
I55
tp15063
(lp15064
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p15065
as(I79
I79
tp15066
(lp15067
S'\t\t\t\tdiag_send_error_rsp(buf, len, pid);'
p15068
as(I244
I244
tp15069
(lp15070
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p15071
as(I112
I113
tp15072
(lp15073
S'\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&'
p15074
aS'\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p15075
as(I120
I120
tp15076
(lp15077
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p15078
as(I103
I106
tp15079
(lp15080
S'\t\twrite_len = diag_process_stm_cmd(buf, len,'
p15081
aS'\t\t\tdriver->apps_rsp_buf);'
p15082
aS'\t\tif (write_len > 0) {'
p15083
aS'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);'
p15084
as(I98
I98
tp15085
(lp15086
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);'
p15087
as(I3
I4
tp15088
(lp15089
S'\tint i, p_mask = 0;'
p15090
aS'\tint mask_ret, peripheral = -EINVAL;'
p15091
assg32
I3
sg33
(dp15092
(I48
I48
tp15093
(lp15094
S'\tif (*buf == DIAG_CMD_LOG_ON_DMND && driver->log_on_demand_support &&'
p15095
as(I14
I14
tp15096
(lp15097
S'\tif (!buf)'
p15098
as(I186
I186
tp15099
(lp15100
S'\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p15101
as(I196
I196
tp15102
(lp15103
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p15104
as(I192
I192
tp15105
(lp15106
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, info);'
p15107
as(I20
I20
tp15108
(lp15109
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, info);'
p15110
as(I295
I295
tp15111
(lp15112
S'\t\tdiag_send_error_rsp(buf, len, info);'
p15113
as(I256
I256
tp15114
(lp15115
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15116
as(I220
I220
tp15117
(lp15118
S'\t\tif (*buf == 0x00) {'
p15119
as(I98
I98
tp15120
(lp15121
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, info);'
p15122
as(I120
I120
tp15123
(lp15124
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15125
as(I162
I163
tp15126
(lp15127
S'\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p15128
aS'\t\t(*(buf+2) == 0x03)) {'
p15129
as(I124
I124
tp15130
(lp15131
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p15132
as(I25
I34
tp15133
(lp15134
S'\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);'
p15135
aS'\ttemp += sizeof(uint8_t);'
p15136
aS'\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);'
p15137
aS'\ttemp += sizeof(uint8_t);'
p15138
aS'\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);'
p15139
aS'\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);'
p15140
aS'\ttemp += sizeof(uint16_t);'
p15141
ag59
aS'\tpr_debug("diag: In %s, received cmd %02x %02x %02x\\n",'
p15142
aS'\t\t __func__, entry.cmd_code, entry.subsys_id, entry.cmd_code_hi);'
p15143
as(I152
I152
tp15144
(lp15145
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, info);'
p15146
as(I92
I92
tp15147
(lp15148
S'\tif ((*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p15149
as(I172
I172
tp15150
(lp15151
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, info);'
p15152
as(I109
I109
tp15153
(lp15154
S'\t\treturn len;'
p15155
as(I1
I2
tp15156
(lp15157
S'int diag_process_apps_pkt(unsigned char *buf, int len,'
p15158
aS'\t\t\tstruct diag_md_session_t *info)'
p15159
as(I72
I73
tp15160
(lp15161
S'\t\t\t\tinfo->peripheral_mask) ||'
p15162
aS'\t\t\t\t(pd_mask & info->peripheral_mask))'
p15163
as(I112
I112
tp15164
(lp15165
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p15166
as(I182
I182
tp15167
(lp15168
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, info);'
p15169
as(I3
I4
tp15170
(lp15171
S'\tint i;'
p15172
aS'\tint mask_ret;'
p15173
as(I100
I100
tp15174
(lp15175
S'\t} else if ((*buf == 0x4b) && (*(buf+1) == 0x12) &&'
p15176
as(I237
I237
tp15177
(lp15178
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, info);'
p15179
as(I55
I55
tp15180
(lp15181
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15182
as(I177
I177
tp15183
(lp15184
S'\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&'
p15185
as(I244
I244
tp15186
(lp15187
S'\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15188
as(I204
I204
tp15189
(lp15190
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15191
as(I136
I136
tp15192
(lp15193
S'\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&'
p15194
as(I224
I224
tp15195
(lp15196
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, info);'
p15197
as(I148
I148
tp15198
(lp15199
S'\telse if ((chk_apps_master()) && (*buf == 0x3A)) {'
p15200
as(I132
I132
tp15201
(lp15202
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15203
as(I18
I18
tp15204
(lp15205
S'\tmask_ret = diag_process_apps_masks(buf, len, info);'
p15206
as(I228
I228
tp15207
(lp15208
S'\t\telse if (*buf == 0x7c) {'
p15209
as(I103
I105
tp15210
(lp15211
S'\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);'
p15212
aS'\t\tif (len > 0) {'
p15213
aS'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, info);'
p15214
as(I144
I144
tp15215
(lp15216
S'\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, info);'
p15217
as(I79
I79
tp15218
(lp15219
S'\t\t\t\tdiag_send_error_rsp(buf, len, info);'
p15220
assg41
(I1
I298
tp15221
ssss(g10116
S'diag_drain_work_fn'
p15222
tp15223
(dp15224
S'void diag_drain_work_fn(struct work_struct *work)\n{\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\ttimer_in_progress = 0;\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (!hdlc_disabled)\n\t\tdiag_drain_apps_data(&hdlc_data);\n\telse\n\t\tdiag_drain_apps_data(&non_hdlc_data);\n\tmutex_unlock(&apps_data_mutex);\n}'
p15225
(dp15226
((g10116
g15222
tp15227
I1
tp15228
(dp15229
g33
(dp15230
(I14
I14
tp15231
(lp15232
g59
assg14
(dp15233
(I8
I8
tp15234
(lp15235
S'\tmutex_lock(&driver->md_session_lock);'
p15236
as(I14
I14
tp15237
(lp15238
S'\tmutex_unlock(&driver->md_session_lock);'
p15239
assg32
I1
sg12
g13
sg41
(I1
I20
tp15240
sssS'void diag_drain_work_fn(struct work_struct *work)\n{\n\tuint8_t hdlc_disabled = 0;\n\n\ttimer_in_progress = 0;\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (!hdlc_disabled)\n\t\tdiag_drain_apps_data(&hdlc_data);\n\telse\n\t\tdiag_drain_apps_data(&non_hdlc_data);\n\tmutex_unlock(&apps_data_mutex);\n}'
p15241
(dp15242
((g10116
g15222
tp15243
I1
tp15244
(dp15245
g12
g13
sg14
(dp15246
(I7
I9
tp15247
(lp15248
S'\tmutex_lock(&driver->hdlc_disable_mutex);'
p15249
aS'\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];'
p15250
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p15251
assg32
I1
sg33
(dp15252
(I7
I12
tp15253
(lp15254
S'\tsession_info = diag_md_session_get_peripheral(APPS_DATA);'
p15255
aS'\tif (session_info)'
p15256
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p15257
aS'\telse'
p15258
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p15259
ag59
as(I3
I3
tp15260
(lp15261
S'\tstruct diag_md_session_t *session_info = NULL;'
p15262
assg41
(I1
I15
tp15263
ssss(g10026
S'diag_cmd_get_event_mask'
p15264
tp15265
(dp15266
S'static int diag_cmd_get_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0;\n\tuint32_t mask_size;\n\tstruct diag_event_mask_config_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\n\tmask_size = EVENT_COUNT_TO_BYTES(driver->last_event_id);\n\tif (mask_size + sizeof(rsp) > dest_len) {\n\t\tpr_err("diag: In %s, invalid mask size: %d\\n", __func__,\n\t\t       mask_size);\n\t\treturn -ENOMEM;\n\t}\n\n\trsp.cmd_code = DIAG_CMD_GET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmemcpy(dest_buf + write_len, event_mask.ptr, mask_size);\n\twrite_len += mask_size;\n\n\treturn write_len;\n}'
p15267
(dp15268
((g10026
g15264
tp15269
I1
tp15270
(dp15271
g12
g13
sg14
(dp15272
(I2
I2
tp15273
(lp15274
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15275
assg32
I5
sg33
(dp15276
(I2
I3
tp15277
(lp15278
S'\t\t\t\t   unsigned char *dest_buf, int dest_len,'
p15279
aS'\t\t\t\t   struct diag_md_session_t *info)'
p15280
assg41
(I1
I34
tp15281
ssss(g10026
S'diag_cmd_set_all_msg_mask'
p15282
tp15283
(dp15284
S'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15285
(dp15286
((g10026
g15282
tp15287
I1
tp15288
(dp15289
g12
g13
sg14
(dp15290
(I17
I18
tp15291
(lp15292
S'\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||'
p15293
aS'\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {'
p15294
as(I10
I14
tp15295
(lp15296
S'\tstruct diag_md_session_t *info = NULL;'
p15297
aS'\tuint8_t msg_mask_tbl_count = 0;'
p15298
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15299
aS'\tinfo = diag_md_session_get_pid(pid);'
p15300
as(I46
I47
tp15301
(lp15302
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p15303
aS'\t\t\tdriver->msg_mask_tbl_count;'
p15304
as(I43
I43
tp15305
(lp15306
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15307
as(I22
I22
tp15308
(lp15309
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15310
as(I60
I61
tp15311
(lp15312
S'\tmutex_unlock(&driver->md_session_lock);'
p15313
aS'\tif (diag_check_update(APPS_DATA, pid))'
p15314
as(I50
I56
tp15315
(lp15316
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p15317
aS'\t\tif (mask && mask->ptr) {'
p15318
aS'\t\t\tmutex_lock(&mask->lock);'
p15319
aS'\t\t\tmemset(mask->ptr, req->rt_mask,'
p15320
aS'\t\t\t       mask->range * sizeof(uint32_t));'
p15321
aS'\t\t\tmutex_unlock(&mask->lock);'
p15322
aS'\t\t}'
p15323
as(I28
I28
tp15324
(lp15325
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15326
as(I2
I2
tp15327
(lp15328
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15329
as(I79
I79
tp15330
(lp15331
S'\t\tif (!diag_check_update(i, pid))'
p15332
assg32
I5
sg33
(dp15333
(I17
I18
tp15334
(lp15335
S'\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||'
p15336
aS'\t    !mask_info) {'
p15337
as(I60
I61
tp15338
(lp15339
g59
aS'\tif (diag_check_update(APPS_DATA))'
p15340
as(I50
I54
tp15341
(lp15342
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p15343
aS'\t\tmutex_lock(&mask->lock);'
p15344
aS'\t\tmemset(mask->ptr, req->rt_mask,'
p15345
aS'\t\t       mask->range * sizeof(uint32_t));'
p15346
aS'\t\tmutex_unlock(&mask->lock);'
p15347
as(I2
I3
tp15348
(lp15349
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15350
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15351
as(I79
I79
tp15352
(lp15353
S'\t\tif (!diag_check_update(i))'
p15354
assg41
(I1
I91
tp15355
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15356
(dp15357
((g10026
g15282
tp15358
I1
tp15359
(dp15360
g12
g13
sg14
(dp15361
(I57
I58
tp15362
(lp15363
S'\tmutex_unlock(&driver->md_session_lock);'
p15364
aS'\tif (diag_check_update(APPS_DATA, pid))'
p15365
as(I76
I76
tp15366
(lp15367
S'\t\tif (!diag_check_update(i, pid))'
p15368
as(I48
I53
tp15369
(lp15370
S'\t\tif (mask && mask->ptr) {'
p15371
aS'\t\t\tmutex_lock(&mask->lock);'
p15372
aS'\t\t\tmemset(mask->ptr, req->rt_mask,'
p15373
aS'\t\t\t       mask->range * sizeof(uint32_t));'
p15374
aS'\t\t\tmutex_unlock(&mask->lock);'
p15375
aS'\t\t}'
p15376
as(I27
I27
tp15377
(lp15378
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15379
as(I42
I42
tp15380
(lp15381
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15382
as(I10
I13
tp15383
(lp15384
S'\tstruct diag_md_session_t *info = NULL;'
p15385
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15386
aS'\tinfo = diag_md_session_get_pid(pid);'
p15387
as(I2
I2
tp15388
(lp15389
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15390
as(I21
I21
tp15391
(lp15392
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15393
assg32
I5
sg33
(dp15394
(I57
I58
tp15395
(lp15396
g59
aS'\tif (diag_check_update(APPS_DATA))'
p15397
as(I48
I51
tp15398
(lp15399
S'\t\tmutex_lock(&mask->lock);'
p15400
aS'\t\tmemset(mask->ptr, req->rt_mask,'
p15401
aS'\t\t       mask->range * sizeof(uint32_t));'
p15402
aS'\t\tmutex_unlock(&mask->lock);'
p15403
as(I76
I76
tp15404
(lp15405
S'\t\tif (!diag_check_update(i))'
p15406
as(I2
I3
tp15407
(lp15408
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15409
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15410
assg41
(I1
I88
tp15411
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, req->rt_mask,\n\t\t       mask->range * sizeof(uint32_t));\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15412
(dp15413
((g10026
g15282
tp15414
I1
tp15415
(dp15416
g12
g13
sg14
(dp15417
(I74
I74
tp15418
(lp15419
S'\t\tif (!diag_check_update(i, pid))'
p15420
as(I27
I27
tp15421
(lp15422
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15423
as(I42
I42
tp15424
(lp15425
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15426
as(I10
I13
tp15427
(lp15428
S'\tstruct diag_md_session_t *info = NULL;'
p15429
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15430
aS'\tinfo = diag_md_session_get_pid(pid);'
p15431
as(I2
I2
tp15432
(lp15433
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15434
as(I55
I56
tp15435
(lp15436
S'\tmutex_unlock(&driver->md_session_lock);'
p15437
aS'\tif (diag_check_update(APPS_DATA, pid))'
p15438
as(I21
I21
tp15439
(lp15440
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15441
assg32
I5
sg33
(dp15442
(I55
I56
tp15443
(lp15444
g59
aS'\tif (diag_check_update(APPS_DATA))'
p15445
as(I2
I3
tp15446
(lp15447
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15448
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15449
as(I74
I74
tp15450
(lp15451
S'\t\tif (!diag_check_update(i))'
p15452
assg41
(I1
I86
tp15453
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15454
(dp15455
((g10026
g15282
tp15456
I1
tp15457
(dp15458
g12
g13
sg14
(dp15459
(I10
I14
tp15460
(lp15461
S'\tstruct diag_md_session_t *info = NULL;'
p15462
aS'\tuint8_t msg_mask_tbl_count = 0;'
p15463
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15464
aS'\tinfo = diag_md_session_get_pid(pid);'
p15465
as(I46
I47
tp15466
(lp15467
S'\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :'
p15468
aS'\t\t\tdriver->msg_mask_tbl_count;'
p15469
as(I43
I43
tp15470
(lp15471
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15472
as(I22
I22
tp15473
(lp15474
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15475
as(I60
I61
tp15476
(lp15477
S'\tmutex_unlock(&driver->md_session_lock);'
p15478
aS'\tif (diag_check_update(APPS_DATA, pid))'
p15479
as(I50
I56
tp15480
(lp15481
S'\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {'
p15482
aS'\t\tif (mask && mask->ptr) {'
p15483
aS'\t\t\tmutex_lock(&mask->lock);'
p15484
aS'\t\t\tmemset(mask->ptr, req->rt_mask,'
p15485
aS'\t\t\t       mask->range * sizeof(uint32_t));'
p15486
aS'\t\t\tmutex_unlock(&mask->lock);'
p15487
aS'\t\t}'
p15488
as(I28
I28
tp15489
(lp15490
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15491
as(I2
I2
tp15492
(lp15493
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15494
as(I79
I79
tp15495
(lp15496
S'\t\tif (!diag_check_update(i, pid))'
p15497
assg32
I5
sg33
(dp15498
(I60
I61
tp15499
(lp15500
g59
aS'\tif (diag_check_update(APPS_DATA))'
p15501
as(I50
I54
tp15502
(lp15503
S'\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {'
p15504
aS'\t\tmutex_lock(&mask->lock);'
p15505
aS'\t\tmemset(mask->ptr, req->rt_mask,'
p15506
aS'\t\t       mask->range * sizeof(uint32_t));'
p15507
aS'\t\tmutex_unlock(&mask->lock);'
p15508
as(I2
I3
tp15509
(lp15510
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15511
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15512
as(I79
I79
tp15513
(lp15514
S'\t\tif (!diag_check_update(i))'
p15515
assg41
(I1
I91
tp15516
sssS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, req->rt_mask,\n\t\t       mask->range * sizeof(uint32_t));\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15517
(dp15518
((g10026
g15282
tp15519
I1
tp15520
(dp15521
g12
g13
sg14
(dp15522
(I27
I27
tp15523
(lp15524
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15525
as(I42
I42
tp15526
(lp15527
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15528
as(I10
I13
tp15529
(lp15530
S'\tstruct diag_md_session_t *info = NULL;'
p15531
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15532
aS'\tinfo = diag_md_session_get_pid(pid);'
p15533
as(I2
I2
tp15534
(lp15535
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15536
as(I55
I55
tp15537
(lp15538
S'\tmutex_unlock(&driver->md_session_lock);'
p15539
as(I21
I21
tp15540
(lp15541
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15542
assg32
I5
sg33
(dp15543
(I2
I3
tp15544
(lp15545
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15546
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15547
as(I55
I55
tp15548
(lp15549
g59
assg41
(I1
I86
tp15550
ssss(g10116
S'diag_send_raw_data_remote'
p15551
tp15552
(dp15553
S'static int diag_send_raw_data_remote(int proc, void *buf, int len,\n\t\t\t\t    uint8_t hdlc_flag)\n{\n\tint err = 0;\n\tint max_len = 0;\n\tuint8_t retry_count = 0;\n\tuint8_t max_retries = 3;\n\tuint16_t payload = 0;\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tint bridge_index = proc - 1;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (len <= 0) {\n\t\tpr_err("diag: In %s, invalid len: %d", __func__, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (bridge_index < 0 || bridge_index > NUM_REMOTE_DEV) {\n\t\tpr_err("diag: In %s, invalid bridge index: %d\\n", __func__,\n\t\t\tbridge_index);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tif (driver->hdlc_encode_buf_len == 0)\n\t\t\tbreak;\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\t} while (retry_count < max_retries);\n\n\tif (driver->hdlc_encode_buf_len != 0)\n\t\treturn -EAGAIN;\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled) {\n\t\tif (len < 4) {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tpayload = *(uint16_t *)(buf + 2);\n\t\tif (payload > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, payload size is %d\\n",\n\t\t\t\tpayload);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = payload;\n\t\t/*\n\t\t * Adding 5 bytes for start (1 byte), version (1 byte),\n\t\t * payload (2 bytes) and end (1 byte)\n\t\t */\n\t\tif (len == (payload + 5)) {\n\t\t\t/*\n\t\t\t * Adding 4 bytes for start (1 byte), version (1 byte)\n\t\t\t * and payload (2 bytes)\n\t\t\t */\n\t\t\tmemcpy(driver->hdlc_encode_buf, buf + 4, payload);\n\t\t\tgoto send_data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\tif (hdlc_flag) {\n\t\tif (len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t\t       len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = len;\n\t\tmemcpy(driver->hdlc_encode_buf, buf, len);\n\t\tgoto send_data;\n\t}\n\n\t/*\n\t * The worst case length will be twice as the incoming packet length.\n\t * Add 3 bytes for CRC bytes (2 bytes) and delimiter (1 byte)\n\t */\n\tmax_len = (2 * len) + 3;\n\tif (max_len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t       max_len);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* Perform HDLC encoding on incoming data */\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = (void *)(buf);\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\n\tenc.dest = driver->hdlc_encode_buf;\n\tenc.dest_last = (void *)(driver->hdlc_encode_buf + max_len - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->hdlc_encode_buf_len = (int)(enc.dest -\n\t\t\t\t\t(void *)driver->hdlc_encode_buf);\n\nsend_data:\n\terr = diagfwd_bridge_write(bridge_index, driver->hdlc_encode_buf,\n\t\t\t\t   driver->hdlc_encode_buf_len);\n\tif (err) {\n\t\tpr_err_ratelimited("diag: Error writing Callback packet to proc: %d, err: %d\\n",\n\t\t\t\t   proc, err);\n\t\tdriver->hdlc_encode_buf_len = 0;\n\t}\n\n\treturn err;\n}'
p15554
(dp15555
((g10116
g15551
tp15556
I1
tp15557
(dp15558
g14
(dp15559
(I44
I44
tp15560
(lp15561
S'\tmutex_unlock(&driver->md_session_lock);'
p15562
as(I38
I38
tp15563
(lp15564
S'\tmutex_lock(&driver->md_session_lock);'
p15565
assg32
I4
sg12
g13
sg41
(I1
I120
tp15566
sssS'static int diag_send_raw_data_remote(int proc, void *buf, int len,\n\t\t\t\t    uint8_t hdlc_flag)\n{\n\tint err = 0;\n\tint max_len = 0;\n\tuint8_t retry_count = 0;\n\tuint8_t max_retries = 3;\n\tuint16_t payload = 0;\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tint bridge_index = proc - 1;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (len <= 0) {\n\t\tpr_err("diag: In %s, invalid len: %d", __func__, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (bridge_index < 0 || bridge_index > NUM_REMOTE_DEV) {\n\t\tpr_err("diag: In %s, invalid bridge index: %d\\n", __func__,\n\t\t\tbridge_index);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tif (driver->hdlc_encode_buf_len == 0)\n\t\t\tbreak;\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\t} while (retry_count < max_retries);\n\n\tif (driver->hdlc_encode_buf_len != 0)\n\t\treturn -EAGAIN;\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (hdlc_disabled) {\n\t\tif (len < 4) {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tpayload = *(uint16_t *)(buf + 2);\n\t\tif (payload > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, payload size is %d\\n",\n\t\t\t\tpayload);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = payload;\n\t\t/*\n\t\t * Adding 5 bytes for start (1 byte), version (1 byte),\n\t\t * payload (2 bytes) and end (1 byte)\n\t\t */\n\t\tif (len == (payload + 5)) {\n\t\t\t/*\n\t\t\t * Adding 4 bytes for start (1 byte), version (1 byte)\n\t\t\t * and payload (2 bytes)\n\t\t\t */\n\t\t\tmemcpy(driver->hdlc_encode_buf, buf + 4, payload);\n\t\t\tgoto send_data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\tif (hdlc_flag) {\n\t\tif (len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t\t       len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = len;\n\t\tmemcpy(driver->hdlc_encode_buf, buf, len);\n\t\tgoto send_data;\n\t}\n\n\t/*\n\t * The worst case length will be twice as the incoming packet length.\n\t * Add 3 bytes for CRC bytes (2 bytes) and delimiter (1 byte)\n\t */\n\tmax_len = (2 * len) + 3;\n\tif (max_len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t       max_len);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* Perform HDLC encoding on incoming data */\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = (void *)(buf);\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\n\tenc.dest = driver->hdlc_encode_buf;\n\tenc.dest_last = (void *)(driver->hdlc_encode_buf + max_len - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->hdlc_encode_buf_len = (int)(enc.dest -\n\t\t\t\t\t(void *)driver->hdlc_encode_buf);\n\nsend_data:\n\terr = diagfwd_bridge_write(bridge_index, driver->hdlc_encode_buf,\n\t\t\t\t   driver->hdlc_encode_buf_len);\n\tif (err) {\n\t\tpr_err_ratelimited("diag: Error writing Callback packet to proc: %d, err: %d\\n",\n\t\t\t\t   proc, err);\n\t\tdriver->hdlc_encode_buf_len = 0;\n\t}\n\n\treturn err;\n}'
p15567
(dp15568
((g10116
g15551
tp15569
I1
tp15570
(dp15571
g12
g13
sg14
(dp15572
(I37
I39
tp15573
(lp15574
S'\tmutex_lock(&driver->hdlc_disable_mutex);'
p15575
aS'\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];'
p15576
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p15577
assg32
I4
sg33
(dp15578
(I37
I41
tp15579
(lp15580
S'\tsession_info = diag_md_session_get_peripheral(APPS_DATA);'
p15581
aS'\tif (session_info)'
p15582
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p15583
aS'\telse'
p15584
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p15585
as(I12
I12
tp15586
(lp15587
S'\tstruct diag_md_session_t *session_info = NULL;'
p15588
assg41
(I1
I115
tp15589
ssss(g10116
S'diag_user_process_apps_data'
p15590
tp15591
(dp15592
S'static int diag_user_process_apps_data(const char __user *buf, int len,\n\t\t\t\t       int pkt_type)\n{\n\tint ret = 0;\n\tint stm_size = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > DIAG_MAX_RSP_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tswitch (pkt_type) {\n\tcase DATA_TYPE_EVENT:\n\tcase DATA_TYPE_F3:\n\tcase DATA_TYPE_LOG:\n\tcase DATA_TYPE_RESPONSE:\n\tcase DATA_TYPE_DELAYED_RESPONSE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid pkt_type: %d\\n",\n\t\t\t\t   __func__, pkt_type);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data) {\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_from_user(user_space_data, buf, len);\n\tif (ret) {\n\t\tpr_alert("diag: In %s, unable to copy data from userspace, err: %d\\n",\n\t\t\t __func__, ret);\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (driver->stm_state[APPS_DATA] &&\n\t    (pkt_type >= DATA_TYPE_EVENT) && (pkt_type <= DATA_TYPE_LOG)) {\n\t\tstm_size = stm_log_inv_ts(OST_ENTITY_DIAG, 0, user_space_data,\n\t\t\t\t\t  len);\n\t\tif (stm_size == 0) {\n\t\t\tpr_debug("diag: In %s, stm_log_inv_ts returned size of 0\\n",\n\t\t\t\t __func__);\n\t\t}\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled)\n\t\tret = diag_process_apps_data_non_hdlc(user_space_data, len,\n\t\t\t\t\t\t      pkt_type);\n\telse\n\t\tret = diag_process_apps_data_hdlc(user_space_data, len,\n\t\t\t\t\t\t  pkt_type);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tmutex_unlock(&apps_data_mutex);\n\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\n\tcheck_drain_timer();\n\n\tif (ret == PKT_DROP)\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\telse if (ret == PKT_ALLOC)\n\t\tdiag_record_stats(pkt_type, PKT_ALLOC);\n\telse\n\t\treturn ret;\n\n\treturn 0;\n}'
p15593
(dp15594
((g10116
g15590
tp15595
I1
tp15596
(dp15597
g14
(dp15598
(I68
I68
tp15599
(lp15600
S'\tmutex_unlock(&driver->md_session_lock);'
p15601
as(I62
I62
tp15602
(lp15603
S'\tmutex_lock(&driver->md_session_lock);'
p15604
assg32
I3
sg12
g13
sg41
(I1
I91
tp15605
sssS'static int diag_user_process_apps_data(const char __user *buf, int len,\n\t\t\t\t       int pkt_type)\n{\n\tint ret = 0;\n\tint stm_size = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > DIAG_MAX_RSP_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tswitch (pkt_type) {\n\tcase DATA_TYPE_EVENT:\n\tcase DATA_TYPE_F3:\n\tcase DATA_TYPE_LOG:\n\tcase DATA_TYPE_RESPONSE:\n\tcase DATA_TYPE_DELAYED_RESPONSE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid pkt_type: %d\\n",\n\t\t\t\t   __func__, pkt_type);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data) {\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_from_user(user_space_data, buf, len);\n\tif (ret) {\n\t\tpr_alert("diag: In %s, unable to copy data from userspace, err: %d\\n",\n\t\t\t __func__, ret);\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (driver->stm_state[APPS_DATA] &&\n\t    (pkt_type >= DATA_TYPE_EVENT) && (pkt_type <= DATA_TYPE_LOG)) {\n\t\tstm_size = stm_log_inv_ts(OST_ENTITY_DIAG, 0, user_space_data,\n\t\t\t\t\t  len);\n\t\tif (stm_size == 0) {\n\t\t\tpr_debug("diag: In %s, stm_log_inv_ts returned size of 0\\n",\n\t\t\t\t __func__);\n\t\t}\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tif (hdlc_disabled)\n\t\tret = diag_process_apps_data_non_hdlc(user_space_data, len,\n\t\t\t\t\t\t      pkt_type);\n\telse\n\t\tret = diag_process_apps_data_hdlc(user_space_data, len,\n\t\t\t\t\t\t  pkt_type);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tmutex_unlock(&apps_data_mutex);\n\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\n\tcheck_drain_timer();\n\n\tif (ret == PKT_DROP)\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\telse if (ret == PKT_ALLOC)\n\t\tdiag_record_stats(pkt_type, PKT_ALLOC);\n\telse\n\t\treturn ret;\n\n\treturn 0;\n}'
p15606
(dp15607
((g10116
g15590
tp15608
I1
tp15609
(dp15610
g12
g13
sg14
(dp15611
(I61
I61
tp15612
(lp15613
S'\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];'
p15614
assg32
I3
sg33
(dp15615
(I61
I65
tp15616
(lp15617
S'\tsession_info = diag_md_session_get_peripheral(APPS_DATA);'
p15618
aS'\tif (session_info)'
p15619
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p15620
aS'\telse'
p15621
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p15622
as(I8
I8
tp15623
(lp15624
S'\tstruct diag_md_session_t *session_info = NULL;'
p15625
assg41
(I1
I84
tp15626
sssS'static int diag_user_process_apps_data(const char __user *buf, int len,\n\t\t\t\t       int pkt_type)\n{\n\tint ret = 0;\n\tint stm_size = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > DIAG_MAX_RSP_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tswitch (pkt_type) {\n\tcase DATA_TYPE_EVENT:\n\tcase DATA_TYPE_F3:\n\tcase DATA_TYPE_LOG:\n\tcase DATA_TYPE_RESPONSE:\n\tcase DATA_TYPE_DELAYED_RESPONSE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid pkt_type: %d\\n",\n\t\t\t\t   __func__, pkt_type);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data) {\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_from_user(user_space_data, buf, len);\n\tif (ret) {\n\t\tpr_alert("diag: In %s, unable to copy data from userspace, err: %d\\n",\n\t\t\t __func__, ret);\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (driver->stm_state[APPS_DATA] &&\n\t    (pkt_type >= DATA_TYPE_EVENT) && (pkt_type <= DATA_TYPE_LOG)) {\n\t\tstm_size = stm_log_inv_ts(OST_ENTITY_DIAG, 0, user_space_data,\n\t\t\t\t\t  len);\n\t\tif (stm_size == 0) {\n\t\t\tpr_debug("diag: In %s, stm_log_inv_ts returned size of 0\\n",\n\t\t\t\t __func__);\n\t\t}\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (hdlc_disabled)\n\t\tret = diag_process_apps_data_non_hdlc(user_space_data, len,\n\t\t\t\t\t\t      pkt_type);\n\telse\n\t\tret = diag_process_apps_data_hdlc(user_space_data, len,\n\t\t\t\t\t\t  pkt_type);\n\tmutex_unlock(&apps_data_mutex);\n\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\n\tcheck_drain_timer();\n\n\tif (ret == PKT_DROP)\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\telse if (ret == PKT_ALLOC)\n\t\tdiag_record_stats(pkt_type, PKT_ALLOC);\n\telse\n\t\treturn ret;\n\n\treturn 0;\n}'
p15627
(dp15628
((g10116
g15590
tp15629
I1
tp15630
(dp15631
g12
g13
sg14
(dp15632
(I61
I62
tp15633
(lp15634
S'\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];'
p15635
aS'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p15636
assg32
I3
sg33
(dp15637
(I61
I65
tp15638
(lp15639
S'\tsession_info = diag_md_session_get_peripheral(APPS_DATA);'
p15640
aS'\tif (session_info)'
p15641
aS'\t\thdlc_disabled = session_info->hdlc_disabled;'
p15642
aS'\telse'
p15643
aS'\t\thdlc_disabled = driver->hdlc_disabled;'
p15644
as(I8
I8
tp15645
(lp15646
S'\tstruct diag_md_session_t *session_info = NULL;'
p15647
as(I69
I69
tp15648
(lp15649
S'\tmutex_unlock(&driver->hdlc_disable_mutex);'
p15650
assg41
(I1
I84
tp15651
ssss(g10026
S'diag_cmd_disable_log_mask'
p15652
tp15653
(dp15654
S'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, 0, mask->range);\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15655
(dp15656
((g10026
g15652
tp15657
I1
tp15658
(dp15659
g12
g13
sg14
(dp15660
(I32
I32
tp15661
(lp15662
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15663
as(I19
I19
tp15664
(lp15665
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15666
as(I2
I2
tp15667
(lp15668
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15669
as(I8
I11
tp15670
(lp15671
S'\tstruct diag_md_session_t *info = NULL;'
p15672
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15673
aS'\tinfo = diag_md_session_get_pid(pid);'
p15674
as(I25
I25
tp15675
(lp15676
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15677
as(I41
I41
tp15678
(lp15679
S'\tmutex_unlock(&driver->md_session_lock);'
p15680
assg32
I5
sg33
(dp15681
(I2
I3
tp15682
(lp15683
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15684
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15685
assg41
(I1
I72
tp15686
sssS'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, 0, mask->range);\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15687
(dp15688
((g10026
g15652
tp15689
I1
tp15690
(dp15691
g12
g13
sg14
(dp15692
(I41
I42
tp15693
(lp15694
S'\tmutex_unlock(&driver->md_session_lock);'
p15695
aS'\tif (diag_check_update(APPS_DATA, pid))'
p15696
as(I32
I32
tp15697
(lp15698
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15699
as(I19
I19
tp15700
(lp15701
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15702
as(I2
I2
tp15703
(lp15704
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15705
as(I8
I11
tp15706
(lp15707
S'\tstruct diag_md_session_t *info = NULL;'
p15708
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15709
aS'\tinfo = diag_md_session_get_pid(pid);'
p15710
as(I60
I60
tp15711
(lp15712
S'\t\tif (!diag_check_update(i, pid))'
p15713
as(I25
I25
tp15714
(lp15715
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15716
assg32
I5
sg33
(dp15717
(I60
I60
tp15718
(lp15719
S'\t\tif (!diag_check_update(i))'
p15720
as(I2
I3
tp15721
(lp15722
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15723
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15724
as(I41
I41
tp15725
(lp15726
S'\tif (diag_check_update(APPS_DATA))'
p15727
assg41
(I1
I72
tp15728
sssS'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, 0, mask->range);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p15729
(dp15730
((g10026
g15652
tp15731
I1
tp15732
(dp15733
g12
g13
sg14
(dp15734
(I62
I62
tp15735
(lp15736
S'\t\tif (!diag_check_update(i, pid))'
p15737
as(I32
I32
tp15738
(lp15739
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15740
as(I19
I19
tp15741
(lp15742
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15743
as(I2
I2
tp15744
(lp15745
S'\t\t\tunsigned char *dest_buf, int dest_len, int pid)'
p15746
as(I8
I11
tp15747
(lp15748
S'\tstruct diag_md_session_t *info = NULL;'
p15749
ag59
aS'\tmutex_lock(&driver->md_session_lock);'
p15750
aS'\tinfo = diag_md_session_get_pid(pid);'
p15751
as(I36
I40
tp15752
(lp15753
S'\t\tif (mask && mask->ptr) {'
p15754
aS'\t\t\tmutex_lock(&mask->lock);'
p15755
aS'\t\t\tmemset(mask->ptr, 0, mask->range);'
p15756
aS'\t\t\tmutex_unlock(&mask->lock);'
p15757
aS'\t\t}'
p15758
as(I43
I44
tp15759
(lp15760
S'\tmutex_unlock(&driver->md_session_lock);'
p15761
aS'\tif (diag_check_update(APPS_DATA, pid))'
p15762
as(I25
I25
tp15763
(lp15764
S'\t\tmutex_unlock(&driver->md_session_lock);'
p15765
assg32
I5
sg33
(dp15766
(I62
I62
tp15767
(lp15768
S'\t\tif (!diag_check_update(i))'
p15769
as(I2
I3
tp15770
(lp15771
S'\t\t\t\t     unsigned char *dest_buf, int dest_len,'
p15772
aS'\t\t\t\t     struct diag_md_session_t *info)'
p15773
as(I36
I38
tp15774
(lp15775
S'\t\tmutex_lock(&mask->lock);'
p15776
aS'\t\tmemset(mask->ptr, 0, mask->range);'
p15777
aS'\t\tmutex_unlock(&mask->lock);'
p15778
as(I43
I43
tp15779
(lp15780
S'\tif (diag_check_update(APPS_DATA))'
p15781
assg41
(I1
I74
tp15782
ssss(g10116
S'diag_md_session_get_pid'
p15783
tp15784
(dp15785
S'struct diag_md_session_t *diag_md_session_get_pid(int pid)\n{\n\tint i;\n\tif (pid <= 0)\n\t\treturn NULL;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] &&\n\t\t    driver->md_session_map[i]->pid == pid)\n\t\t\treturn driver->md_session_map[i];\n\t}\n\treturn NULL;\n}'
p15786
(dp15787
((g10116
g15783
tp15788
I1
tp15789
(dp15790
g14
(dp15791
(I4
I5
tp15792
(lp15793
S'\tif (pid <= 0)'
p15794
aS'\t\treturn NULL;'
p15795
assg32
I1
sg12
g13
sg41
(I1
I12
tp15796
sssssS'CVE-2019-10529'
p15797
(dp15798
(S'drivers/gpu/msm/kgsl.c'
p15799
S'kgsl_mem_entry_destroy'
p15800
tp15801
(dp15802
S"kgsl_mem_entry_destroy(struct kref *kref)\n{\n\tstruct kgsl_mem_entry *entry = container_of(kref,\n\t\t\t\t\t\t    struct kgsl_mem_entry,\n\t\t\t\t\t\t    refcount);\n\tunsigned int memtype;\n\n\tif (entry == NULL)\n\t\treturn;\n\n\t/* pull out the memtype before the flags get cleared */\n\tmemtype = kgsl_memdesc_usermem_type(&entry->memdesc);\n\n\t/* Detach from process list */\n\tkgsl_mem_entry_detach_process(entry);\n\n\tif (memtype != KGSL_MEM_ENTRY_KERNEL)\n\t\tatomic_long_sub(entry->memdesc.size,\n\t\t\t&kgsl_driver.stats.mapped);\n\n\t/*\n\t * Ion takes care of freeing the sg_table for us so\n\t * clear the sg table before freeing the sharedmem\n\t * so kgsl_sharedmem_free doesn't try to free it again\n\t */\n\tif (memtype == KGSL_MEM_ENTRY_ION)\n\t\tentry->memdesc.sgt = NULL;\n\n\tif ((memtype == KGSL_MEM_ENTRY_USER)\n\t\t&& !(entry->memdesc.flags & KGSL_MEMFLAGS_GPUREADONLY)) {\n\t\tint i = 0, j;\n\t\tstruct scatterlist *sg;\n\t\tstruct page *page;\n\t\t/*\n\t\t * Mark all of pages in the scatterlist as dirty since they\n\t\t * were writable by the GPU.\n\t\t */\n\t\tfor_each_sg(entry->memdesc.sgt->sgl, sg,\n\t\t\t    entry->memdesc.sgt->nents, i) {\n\t\t\tpage = sg_page(sg);\n\t\t\tfor (j = 0; j < (sg->length >> PAGE_SHIFT); j++)\n\t\t\t\tset_page_dirty_lock(nth_page(page, j));\n\t\t}\n\t}\n\n\tkgsl_sharedmem_free(&entry->memdesc);\n\n\tswitch (memtype) {\n\tcase KGSL_MEM_ENTRY_ION:\n\t\tkgsl_destroy_ion(entry->priv_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(entry);\n}"
p15803
(dp15804
((g15799
g15800
tp15805
I1
tp15806
(dp15807
g12
g13
sg14
(dp15808
(I42
I42
tp15809
(lp15810
S'\t\t\t\tset_page_dirty_lock(nth_page(page, j));'
p15811
assg32
I1
sg33
(dp15812
(I42
I42
tp15813
(lp15814
S'\t\t\t\tset_page_dirty(nth_page(page, j));'
p15815
assg41
(I1
I57
tp15816
sssssS'CVE-2019-10614'
p15817
(dp15818
(S'drivers/media/platform/msm/vidc/hfi_response_handler.c'
p15819
S'hfi_process_sess_evt_seq_changed'
p15820
tp15821
(dp15822
S'static int hfi_process_sess_evt_seq_changed(u32 device_id,\n\t\tstruct hfi_msg_event_notify_packet *pkt,\n\t\tstruct msm_vidc_cb_info *info)\n{\n\tstruct msm_vidc_cb_event event_notify = {0};\n\tu32 num_properties_changed;\n\tstruct hfi_frame_size *frame_sz;\n\tstruct hfi_profile_level *profile_level;\n\tstruct hfi_bit_depth *pixel_depth;\n\tstruct hfi_pic_struct *pic_struct;\n\tstruct hfi_buffer_requirements *buf_req;\n\tstruct hfi_index_extradata_input_crop_payload *crop_info;\n\tstruct hfi_dpb_counts *dpb_counts;\n\tu32 rem_size, entropy_mode = 0;\n\tu8 *data_ptr;\n\tint prop_id;\n\tenum msm_vidc_pixel_depth luma_bit_depth, chroma_bit_depth;\n\tstruct hfi_colour_space *colour_info;\n\n\tif (!validate_pkt_size(pkt->size,\n\t\t\t       sizeof(struct hfi_msg_event_notify_packet)))\n\t\treturn -E2BIG;\n\n\tevent_notify.device_id = device_id;\n\tevent_notify.session_id = (void *)(uintptr_t)pkt->session_id;\n\tevent_notify.status = VIDC_ERR_NONE;\n\tnum_properties_changed = pkt->event_data2;\n\tswitch (pkt->event_data1) {\n\tcase HFI_EVENT_DATA_SEQUENCE_CHANGED_SUFFICIENT_BUFFER_RESOURCES:\n\t\tevent_notify.hal_event_type =\n\t\t\tHAL_EVENT_SEQ_CHANGED_SUFFICIENT_RESOURCES;\n\t\tbreak;\n\tcase HFI_EVENT_DATA_SEQUENCE_CHANGED_INSUFFICIENT_BUFFER_RESOURCES:\n\t\tevent_notify.hal_event_type =\n\t\t\tHAL_EVENT_SEQ_CHANGED_INSUFFICIENT_RESOURCES;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (num_properties_changed) {\n\t\tdata_ptr = (u8 *) &pkt->rg_ext_event_data[0];\n\t\trem_size = pkt->size - sizeof(struct\n\t\t\t\thfi_msg_event_notify_packet) + sizeof(u32);\n\t\tdo {\n\t\t\tif (!validate_pkt_size(rem_size, sizeof(u32)))\n\t\t\t\treturn -E2BIG;\n\t\t\tprop_id = (int) *((u32 *)data_ptr);\n\t\t\trem_size -= sizeof(u32);\n\t\t\tswitch (prop_id) {\n\t\t\tcase HFI_PROPERTY_PARAM_FRAME_SIZE:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_frame_size)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tframe_sz =\n\t\t\t\t\t(struct hfi_frame_size *) data_ptr;\n\t\t\t\tevent_notify.width = frame_sz->width;\n\t\t\t\tevent_notify.height = frame_sz->height;\n\t\t\t\tdprintk(VIDC_DBG, "height: %d width: %d\\n",\n\t\t\t\t\tframe_sz->height, frame_sz->width);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct hfi_frame_size);\n\t\t\t\trem_size -= sizeof(struct hfi_frame_size);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_PARAM_PROFILE_LEVEL_CURRENT:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_profile_level)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tprofile_level =\n\t\t\t\t\t(struct hfi_profile_level *) data_ptr;\n\t\t\t\tevent_notify.profile = profile_level->profile;\n\t\t\t\tevent_notify.level = profile_level->level;\n\t\t\t\tdprintk(VIDC_DBG, "profile: %d level: %d\\n",\n\t\t\t\t\tprofile_level->profile,\n\t\t\t\t\tprofile_level->level);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct hfi_profile_level);\n\t\t\t\trem_size -= sizeof(struct hfi_profile_level);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_PARAM_VDEC_PIXEL_BITDEPTH:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_bit_depth)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tpixel_depth = (struct hfi_bit_depth *) data_ptr;\n\t\t\t\t/*\n\t\t\t\t * Luma and chroma can have different bitdepths.\n\t\t\t\t * Driver should rely on luma and chroma\n\t\t\t\t * bitdepth for determining output bitdepth\n\t\t\t\t * type.\n\t\t\t\t *\n\t\t\t\t * pixel_depth->bitdepth will include luma\n\t\t\t\t * bitdepth info in bits 0..15 and chroma\n\t\t\t\t * bitdept in bits 16..31.\n\t\t\t\t */\n\t\t\t\tluma_bit_depth = get_hal_pixel_depth(\n\t\t\t\t\tpixel_depth->bit_depth &\n\t\t\t\t\tGENMASK(15, 0));\n\t\t\t\tchroma_bit_depth = get_hal_pixel_depth(\n\t\t\t\t\t(pixel_depth->bit_depth &\n\t\t\t\t\tGENMASK(31, 16)) >> 16);\n\t\t\t\tif (luma_bit_depth == MSM_VIDC_BIT_DEPTH_10 ||\n\t\t\t\t\tchroma_bit_depth ==\n\t\t\t\t\t\tMSM_VIDC_BIT_DEPTH_10)\n\t\t\t\t\tevent_notify.bit_depth =\n\t\t\t\t\t\tMSM_VIDC_BIT_DEPTH_10;\n\t\t\t\telse\n\t\t\t\t\tevent_notify.bit_depth = luma_bit_depth;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"bitdepth(%d), luma_bit_depth(%d), chroma_bit_depth(%d)\\n",\n\t\t\t\t\tevent_notify.bit_depth, luma_bit_depth,\n\t\t\t\t\tchroma_bit_depth);\n\t\t\t\tdata_ptr += sizeof(struct hfi_bit_depth);\n\t\t\t\trem_size -= sizeof(struct hfi_bit_depth);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_PARAM_VDEC_PIC_STRUCT:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_pic_struct)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tpic_struct = (struct hfi_pic_struct *) data_ptr;\n\t\t\t\tevent_notify.pic_struct =\n\t\t\t\t\tpic_struct->progressive_only;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"Progressive only flag: %d\\n",\n\t\t\t\t\t\tpic_struct->progressive_only);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct hfi_pic_struct);\n\t\t\t\trem_size -= sizeof(struct hfi_pic_struct);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_PARAM_VDEC_DPB_COUNTS:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_dpb_counts)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tdpb_counts = (struct hfi_dpb_counts *) data_ptr;\n\t\t\t\tevent_notify.max_dpb_count =\n\t\t\t\t\tdpb_counts->max_dpb_count;\n\t\t\t\tevent_notify.max_ref_count =\n\t\t\t\t\tdpb_counts->max_ref_count;\n\t\t\t\tevent_notify.max_dec_buffering =\n\t\t\t\t\tdpb_counts->max_dec_buffering;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"DPB Counts: dpb %d ref %d buff %d\\n",\n\t\t\t\t\t\tdpb_counts->max_dpb_count,\n\t\t\t\t\t\tdpb_counts->max_ref_count,\n\t\t\t\t\t\tdpb_counts->max_dec_buffering);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct hfi_dpb_counts);\n\t\t\t\trem_size -= sizeof(struct hfi_dpb_counts);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_PARAM_VDEC_COLOUR_SPACE:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_colour_space)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tcolour_info =\n\t\t\t\t\t(struct hfi_colour_space *) data_ptr;\n\t\t\t\tevent_notify.colour_space =\n\t\t\t\t\tcolour_info->colour_space;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"Colour space value is: %d\\n",\n\t\t\t\t\t\tcolour_info->colour_space);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct hfi_colour_space);\n\t\t\t\trem_size -= sizeof(struct hfi_colour_space);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_CONFIG_VDEC_ENTROPY:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(u32)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tentropy_mode = *(u32 *)data_ptr;\n\t\t\t\tevent_notify.entropy_mode = entropy_mode;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"Entropy Mode: 0x%x\\n", entropy_mode);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(u32);\n\t\t\t\trem_size -= sizeof(u32);\n\t\t\t\tbreak;\n\t\t\tcase HFI_PROPERTY_CONFIG_BUFFER_REQUIREMENTS:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t\thfi_buffer_requirements)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tbuf_req =\n\t\t\t\t\t(struct hfi_buffer_requirements *)\n\t\t\t\t\t\tdata_ptr;\n\t\t\t\tevent_notify.capture_buf_count =\n\t\t\t\t\tbuf_req->buffer_count_min;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"Capture Count : 0x%x\\n",\n\t\t\t\t\t\tevent_notify.capture_buf_count);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct hfi_buffer_requirements);\n\t\t\t\trem_size -=\n\t\t\t\t\tsizeof(struct hfi_buffer_requirements);\n\t\t\t\tbreak;\n\t\t\tcase HFI_INDEX_EXTRADATA_INPUT_CROP:\n\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct\n\t\t\t\t     hfi_index_extradata_input_crop_payload)))\n\t\t\t\t\treturn -E2BIG;\n\t\t\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\t\t\tcrop_info = (struct\n\t\t\t\thfi_index_extradata_input_crop_payload *)\n\t\t\t\t\t\tdata_ptr;\n\t\t\t\tevent_notify.crop_data.left = crop_info->left;\n\t\t\t\tevent_notify.crop_data.top = crop_info->top;\n\t\t\t\tevent_notify.crop_data.width = crop_info->width;\n\t\t\t\tevent_notify.crop_data.height =\n\t\t\t\t\tcrop_info->height;\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"CROP info : Left = %d Top = %d\\n",\n\t\t\t\t\t\tcrop_info->left,\n\t\t\t\t\t\tcrop_info->top);\n\t\t\t\tdprintk(VIDC_DBG,\n\t\t\t\t\t"CROP info : Width = %d Height = %d\\n",\n\t\t\t\t\t\tcrop_info->width,\n\t\t\t\t\t\tcrop_info->height);\n\t\t\t\tdata_ptr +=\n\t\t\t\t\tsizeof(struct\n\t\t\t\t\thfi_index_extradata_input_crop_payload);\n\t\t\t\trem_size -= sizeof(struct\n\t\t\t\t\thfi_index_extradata_input_crop_payload);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"%s cmd: %#x not supported\\n",\n\t\t\t\t\t__func__, prop_id);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnum_properties_changed--;\n\t\t} while (num_properties_changed > 0);\n\t}\n\n\tinfo->response_type = HAL_SESSION_EVENT_CHANGE;\n\tinfo->response.event = event_notify;\n\n\treturn 0;\n}'
p15823
(dp15824
((g15819
g15820
tp15825
I1
tp15826
(dp15827
g12
g13
sg14
(dp15828
(I80
I80
tp15829
(lp15830
S'\t\t\t\trem_size -= sizeof(struct hfi_profile_level);'
p15831
as(I52
I54
tp15832
(lp15833
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15834
aS'\t\t\t\t\thfi_frame_size)))'
p15835
aS'\t\t\t\t\treturn -E2BIG;'
p15836
as(I6
I6
tp15837
(lp15838
S'\tu32 num_properties_changed;'
p15839
as(I171
I172
tp15840
(lp15841
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(u32)))'
p15842
aS'\t\t\t\t\treturn -E2BIG;'
p15843
as(I116
I116
tp15844
(lp15845
S'\t\t\t\trem_size -= sizeof(struct hfi_bit_depth);'
p15846
as(I180
I180
tp15847
(lp15848
S'\t\t\t\trem_size -= sizeof(u32);'
p15849
as(I64
I64
tp15850
(lp15851
S'\t\t\t\trem_size -= sizeof(struct hfi_frame_size);'
p15852
as(I46
I47
tp15853
(lp15854
S'\t\t\tif (!validate_pkt_size(rem_size, sizeof(u32)))'
p15855
aS'\t\t\t\treturn -E2BIG;'
p15856
as(I151
I152
tp15857
(lp15858
S'\t\t\t\t\tsizeof(struct hfi_dpb_counts);'
p15859
aS'\t\t\t\trem_size -= sizeof(struct hfi_dpb_counts);'
p15860
as(I134
I136
tp15861
(lp15862
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15863
aS'\t\t\t\t\thfi_dpb_counts)))'
p15864
aS'\t\t\t\t\treturn -E2BIG;'
p15865
as(I224
I225
tp15866
(lp15867
S'\t\t\t\trem_size -= sizeof(struct'
p15868
aS'\t\t\t\t\thfi_index_extradata_input_crop_payload);'
p15869
as(I201
I203
tp15870
(lp15871
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15872
aS'\t\t\t\t     hfi_index_extradata_input_crop_payload)))'
p15873
aS'\t\t\t\t\treturn -E2BIG;'
p15874
as(I131
I131
tp15875
(lp15876
S'\t\t\t\trem_size -= sizeof(struct hfi_pic_struct);'
p15877
as(I67
I69
tp15878
(lp15879
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15880
aS'\t\t\t\t\thfi_profile_level)))'
p15881
aS'\t\t\t\t\treturn -E2BIG;'
p15882
as(I20
I21
tp15883
(lp15884
S'\tif (!validate_pkt_size(pkt->size,'
p15885
aS'\t\t\t       sizeof(struct hfi_msg_event_notify_packet)))'
p15886
as(I83
I85
tp15887
(lp15888
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15889
aS'\t\t\t\t\thfi_bit_depth)))'
p15890
aS'\t\t\t\t\treturn -E2BIG;'
p15891
as(I197
I198
tp15892
(lp15893
S'\t\t\t\trem_size -='
p15894
aS'\t\t\t\t\tsizeof(struct hfi_buffer_requirements);'
p15895
as(I168
I168
tp15896
(lp15897
S'\t\t\t\trem_size -= sizeof(struct hfi_colour_space);'
p15898
as(I155
I157
tp15899
(lp15900
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15901
aS'\t\t\t\t\thfi_colour_space)))'
p15902
aS'\t\t\t\t\treturn -E2BIG;'
p15903
as(I14
I14
tp15904
(lp15905
S'\tu32 rem_size, entropy_mode = 0;'
p15906
as(I43
I44
tp15907
(lp15908
S'\t\trem_size = pkt->size - sizeof(struct'
p15909
aS'\t\t\t\thfi_msg_event_notify_packet) + sizeof(u32);'
p15910
as(I183
I185
tp15911
(lp15912
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15913
aS'\t\t\t\t\thfi_buffer_requirements)))'
p15914
aS'\t\t\t\t\treturn -E2BIG;'
p15915
as(I49
I49
tp15916
(lp15917
S'\t\t\trem_size -= sizeof(u32);'
p15918
as(I119
I121
tp15919
(lp15920
S'\t\t\t\tif (!validate_pkt_size(rem_size, sizeof(struct'
p15921
aS'\t\t\t\t\thfi_pic_struct)))'
p15922
aS'\t\t\t\t\treturn -E2BIG;'
p15923
assg32
I3
sg33
(dp15924
(I14
I14
tp15925
(lp15926
S'\tu32 entropy_mode = 0;'
p15927
as(I23
I23
tp15928
(lp15929
S'\t}'
p15930
as(I20
I22
tp15931
(lp15932
S'\tif (sizeof(struct hfi_msg_event_notify_packet) > pkt->size) {'
p15933
aS'\t\tdprintk(VIDC_ERR,'
p15934
aS'\t\t\t\t"hal_process_session_init_done: bad_pkt_size\\n");'
p15935
as(I151
I151
tp15936
(lp15937
S'\t\t\t\t\tsizeof(struct hfi_pic_struct);'
p15938
as(I6
I6
tp15939
(lp15940
S'\tint num_properties_changed;'
p15941
assg41
(I1
I241
tp15942
ssss(g15819
S'validate_pkt_size'
p15943
tp15944
(dp15945
s(g15819
S'hfi_fill_codec_info'
p15946
tp15947
(dp15948
S'static int hfi_fill_codec_info(u8 *data_ptr,\n\t\tstruct vidc_hal_sys_init_done *sys_init_done, u32 rem_size) {\n\tu32 i;\n\tu32 codecs = 0, codec_count = 0, size = 0;\n\tstruct msm_vidc_capability *capability;\n\tu32 prop_id = *((u32 *)data_ptr);\n\tu8 *orig_data_ptr = data_ptr;\n\n\tif (prop_id ==  HFI_PROPERTY_PARAM_CODEC_SUPPORTED) {\n\t\tstruct hfi_codec_supported *prop;\n\n\t\tif (!validate_pkt_size(rem_size - sizeof(u32),\n\t\t\t\t       sizeof(struct hfi_codec_supported)))\n\t\t\treturn -E2BIG;\n\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\tprop = (struct hfi_codec_supported *) data_ptr;\n\t\tsys_init_done->dec_codec_supported =\n\t\t\tprop->decoder_codec_supported;\n\t\tsys_init_done->enc_codec_supported =\n\t\t\tprop->encoder_codec_supported;\n\t\tsize = sizeof(struct hfi_codec_supported) + sizeof(u32);\n\t\trem_size -=\n\t\t\tsizeof(struct hfi_codec_supported) + sizeof(u32);\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"%s: prop_id %#x, expected codec_supported property\\n",\n\t\t\t__func__, prop_id);\n\t}\n\n\tcodecs = sys_init_done->dec_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_DECODER);\n\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported decoder sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcodecs = sys_init_done->enc_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_ENCODER);\n\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsys_init_done->codec_count = codec_count;\n\n\tif (!validate_pkt_size(rem_size, sizeof(u32)))\n\t\treturn -E2BIG;\n\tprop_id = *((u32 *)(orig_data_ptr + size));\n\tif (prop_id == HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED) {\n\t\tstruct hfi_max_sessions_supported *prop;\n\n\t\tif (!validate_pkt_size(rem_size - sizeof(u32), sizeof(struct\n\t\t\t\thfi_max_sessions_supported)))\n\t\t\treturn -E2BIG;\n\t\tprop = (struct hfi_max_sessions_supported *)\n\t\t\t(orig_data_ptr + size + sizeof(u32));\n\n\t\tsys_init_done->max_sessions_supported = prop->max_sessions;\n\t\tsize += sizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\trem_size -=\n\t\t\tsizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\tdprintk(VIDC_DBG, "max_sessions_supported %d\\n",\n\t\t\t\tprop->max_sessions);\n\t}\n\treturn size;\n}'
p15949
(dp15950
((g15819
g15946
tp15951
I1
tp15952
(dp15953
g12
g13
sg14
(dp15954
(I64
I65
tp15955
(lp15956
S'\tif (!validate_pkt_size(rem_size, sizeof(u32)))'
p15957
aS'\t\treturn -E2BIG;'
p15958
as(I68
I73
tp15959
(lp15960
S'\t\tstruct hfi_max_sessions_supported *prop;'
p15961
ag59
aS'\t\tif (!validate_pkt_size(rem_size - sizeof(u32), sizeof(struct'
p15962
aS'\t\t\t\thfi_max_sessions_supported)))'
p15963
aS'\t\t\treturn -E2BIG;'
p15964
aS'\t\tprop = (struct hfi_max_sessions_supported *)'
p15965
as(I12
I14
tp15966
(lp15967
S'\t\tif (!validate_pkt_size(rem_size - sizeof(u32),'
p15968
aS'\t\t\t\t       sizeof(struct hfi_codec_supported)))'
p15969
aS'\t\t\treturn -E2BIG;'
p15970
as(I2
I2
tp15971
(lp15972
S'\t\tstruct vidc_hal_sys_init_done *sys_init_done, u32 rem_size) {'
p15973
as(I22
I23
tp15974
(lp15975
S'\t\trem_size -='
p15976
aS'\t\t\tsizeof(struct hfi_codec_supported) + sizeof(u32);'
p15977
as(I78
I79
tp15978
(lp15979
S'\t\trem_size -='
p15980
aS'\t\t\tsizeof(struct hfi_max_sessions_supported) + sizeof(u32);'
p15981
assg32
I3
sg33
(dp15982
(I68
I69
tp15983
(lp15984
S'\t\tstruct hfi_max_sessions_supported *prop ='
p15985
aS'\t\t\t(struct hfi_max_sessions_supported *)'
p15986
as(I2
I2
tp15987
(lp15988
S'\t\tstruct vidc_hal_sys_init_done *sys_init_done) {'
p15989
assg41
(I1
I84
tp15990
ssss(g15819
S'hfi_process_sys_init_done_prop_read'
p15991
tp15992
(dp15993
S'enum vidc_status hfi_process_sys_init_done_prop_read(\n\tstruct hfi_msg_sys_init_done_packet *pkt,\n\tstruct vidc_hal_sys_init_done *sys_init_done)\n{\n\tenum vidc_status status = VIDC_ERR_NONE;\n\tint bytes_read;\n\tu32 rem_bytes, num_properties;\n\tu8 *data_ptr;\n\n\tif (!pkt || !sys_init_done) {\n\t\tdprintk(VIDC_ERR,\n\t\t\t"hfi_msg_sys_init_done: Invalid input\\n");\n\t\treturn VIDC_ERR_FAIL;\n\t}\n\tif (pkt->size < sizeof(struct hfi_msg_sys_init_done_packet)) {\n\t\tdprintk(VIDC_ERR, "%s: bad_packet_size: %d\\n",\n\t\t\t__func__, pkt->size);\n\t\treturn VIDC_ERR_FAIL;\n\t}\n\n\trem_bytes = pkt->size - sizeof(struct\n\t\t\thfi_msg_sys_init_done_packet) + sizeof(u32);\n\n\tif (!rem_bytes) {\n\t\tdprintk(VIDC_ERR,\n\t\t\t"hfi_msg_sys_init_done: missing_prop_info\\n");\n\t\treturn VIDC_ERR_FAIL;\n\t}\n\n\tstatus = hfi_map_err_status(pkt->error_type);\n\tif (status) {\n\t\tdprintk(VIDC_ERR, "%s: status %#x\\n", __func__, status);\n\t\treturn status;\n\t}\n\n\tdata_ptr = (u8 *) &pkt->rg_property_data[0];\n\tnum_properties = pkt->num_properties;\n\tdprintk(VIDC_DBG,\n\t\t"%s: data_start %pK, num_properties %#x\\n",\n\t\t__func__, data_ptr, num_properties);\n\tif (!num_properties) {\n\t\tsys_init_done->capabilities = NULL;\n\t\tdprintk(VIDC_DBG,\n\t\t\t"Venus didn\'t set any properties in SYS_INIT_DONE");\n\t\treturn status;\n\t}\n\tbytes_read = hfi_fill_codec_info(data_ptr, sys_init_done, rem_bytes);\n\tif (bytes_read < 0)\n\t\treturn VIDC_ERR_FAIL;\n\tdata_ptr += bytes_read;\n\trem_bytes -= bytes_read;\n\tnum_properties--;\n\n\tstatus = hfi_parse_init_done_properties(\n\t\t\tsys_init_done->capabilities,\n\t\t\tVIDC_MAX_SESSIONS, data_ptr, num_properties,\n\t\t\trem_bytes);\n\tif (status) {\n\t\tdprintk(VIDC_ERR, "%s: parse status %#x\\n",\n\t\t\t__func__, status);\n\t\treturn status;\n\t}\n\n\treturn status;\n}'
p15994
(dp15995
((g15819
g15991
tp15996
I1
tp15997
(dp15998
g12
g13
sg14
(dp15999
(I15
I19
tp16000
(lp16001
S'\tif (pkt->size < sizeof(struct hfi_msg_sys_init_done_packet)) {'
p16002
aS'\t\tdprintk(VIDC_ERR, "%s: bad_packet_size: %d\\n",'
p16003
aS'\t\t\t__func__, pkt->size);'
p16004
aS'\t\treturn VIDC_ERR_FAIL;'
p16005
aS'\t}'
p16006
as(I6
I7
tp16007
(lp16008
S'\tint bytes_read;'
p16009
aS'\tu32 rem_bytes, num_properties;'
p16010
as(I47
I49
tp16011
(lp16012
S'\tbytes_read = hfi_fill_codec_info(data_ptr, sys_init_done, rem_bytes);'
p16013
aS'\tif (bytes_read < 0)'
p16014
aS'\t\treturn VIDC_ERR_FAIL;'
p16015
assg32
I2
sg33
(dp16016
(I47
I47
tp16017
(lp16018
S'\tbytes_read = hfi_fill_codec_info(data_ptr, sys_init_done);'
p16019
as(I6
I6
tp16020
(lp16021
S'\tu32 rem_bytes, bytes_read, num_properties;'
p16022
assg41
(I1
I65
tp16023
sssssS'CVE-2019-10524'
p16024
(dp16025
(S'drivers/media/platform/msm/camera_v2/common/msm_camera_io_util.c'
p16026
S'msm_cam_clk_enable'
p16027
tp16028
(dp16029
S'int msm_cam_clk_enable(struct device *dev, struct msm_cam_clk_info *clk_info,\n\t\tstruct clk **clk_ptr, int num_clk, int enable)\n{\n\tint i;\n\tint rc = 0;\n\tlong clk_rate;\n\n\tif (enable) {\n\t\tfor (i = 0; i < num_clk; i++) {\n\t\t\tCDBG("%s enable %s\\n", __func__, clk_info[i].clk_name);\n\t\t\tclk_ptr[i] = clk_get(dev, clk_info[i].clk_name);\n\t\t\tif (IS_ERR(clk_ptr[i])) {\n\t\t\t\tpr_err("%s get failed\\n", clk_info[i].clk_name);\n\t\t\t\trc = PTR_ERR(clk_ptr[i]);\n\t\t\t\tgoto cam_clk_get_err;\n\t\t\t}\n\t\t\tif (clk_info[i].clk_rate > 0) {\n\t\t\t\tclk_rate = clk_round_rate(clk_ptr[i],\n\t\t\t\t\tclk_info[i].clk_rate);\n\t\t\t\tif (clk_rate < 0) {\n\t\t\t\t\tpr_err("%s round failed\\n",\n\t\t\t\t\t\t   clk_info[i].clk_name);\n\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t}\n\t\t\t\trc = clk_set_rate(clk_ptr[i],\n\t\t\t\t\tclk_rate);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tpr_err("%s set failed\\n",\n\t\t\t\t\t\tclk_info[i].clk_name);\n\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t}\n\n\t\t\t} else if (clk_info[i].clk_rate == INIT_RATE) {\n\t\t\t\tclk_rate = clk_get_rate(clk_ptr[i]);\n\t\t\t\tif (clk_rate == 0) {\n\t\t\t\t\tclk_rate =\n\t\t\t\t\t\t  clk_round_rate(clk_ptr[i], 0);\n\t\t\t\t\tif (clk_rate < 0) {\n\t\t\t\t\t\tpr_err("%s round rate failed\\n",\n\t\t\t\t\t\t\t  clk_info[i].clk_name);\n\t\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t\t}\n\t\t\t\t\trc = clk_set_rate(clk_ptr[i],\n\t\t\t\t\t\t\t\tclk_rate);\n\t\t\t\t\tif (rc < 0) {\n\t\t\t\t\t\tpr_err("%s set rate failed\\n",\n\t\t\t\t\t\t\t  clk_info[i].clk_name);\n\t\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trc = clk_prepare(clk_ptr[i]);\n\t\t\tif (rc < 0) {\n\t\t\t\tpr_err("%s prepare failed\\n",\n\t\t\t\t\t   clk_info[i].clk_name);\n\t\t\t\tgoto cam_clk_prepare_err;\n\t\t\t}\n\n\t\t\trc = clk_enable(clk_ptr[i]);\n\t\t\tif (rc < 0) {\n\t\t\t\tpr_err("%s enable failed\\n",\n\t\t\t\t\t   clk_info[i].clk_name);\n\t\t\t\tgoto cam_clk_enable_err;\n\t\t\t}\n\t\t\tif (clk_info[i].delay > 20) {\n\t\t\t\tmsleep(clk_info[i].delay);\n\t\t\t} else if (clk_info[i].delay) {\n\t\t\t\tusleep_range(clk_info[i].delay * 1000,\n\t\t\t\t\t(clk_info[i].delay * 1000) + 1000);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = num_clk - 1; i >= 0; i--) {\n\t\t\tif (!IS_ERR_OR_NULL(clk_ptr[i])) {\n\t\t\t\tCDBG("%s disable %s\\n", __func__,\n\t\t\t\t\tclk_info[i].clk_name);\n\t\t\t\tclk_disable(clk_ptr[i]);\n\t\t\t\tclk_unprepare(clk_ptr[i]);\n\t\t\t\tclk_put(clk_ptr[i]);\n\t\t\t\tclk_ptr[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn rc;\n\n\ncam_clk_enable_err:\n\tclk_unprepare(clk_ptr[i]);\ncam_clk_prepare_err:\ncam_clk_set_err:\n\tclk_put(clk_ptr[i]);\ncam_clk_get_err:\n\tfor (i--; i >= 0; i--) {\n\t\tif (!IS_ERR_OR_NULL(clk_ptr[i])) {\n\t\t\tclk_disable(clk_ptr[i]);\n\t\t\tclk_unprepare(clk_ptr[i]);\n\t\t\tclk_put(clk_ptr[i]);\n\t\t\tclk_ptr[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}'
p16030
(dp16031
((g16026
g16027
tp16032
I1
tp16033
(dp16034
g12
g13
sg14
(dp16035
(I98
I98
tp16036
(lp16037
S'\t\t\tclk_ptr[i] = NULL;'
p16038
as(I80
I80
tp16039
(lp16040
S'\t\t\t\tclk_ptr[i] = NULL;'
p16041
as(I94
I94
tp16042
(lp16043
S'\t\tif (!IS_ERR_OR_NULL(clk_ptr[i])) {'
p16044
as(I74
I74
tp16045
(lp16046
S'\t\t\tif (!IS_ERR_OR_NULL(clk_ptr[i])) {'
p16047
assg32
I5
sg33
(dp16048
(I94
I94
tp16049
(lp16050
S'\t\tif (clk_ptr[i] != NULL) {'
p16051
as(I74
I74
tp16052
(lp16053
S'\t\t\tif (clk_ptr[i] != NULL) {'
p16054
assg41
(I1
I102
tp16055
sssssS'CVE-2019-2323'
p16056
(dp16057
(S'drivers/crypto/msm/ice.c'
p16058
S'qcom_ice_setup_ice_hw'
p16059
tp16060
(dp16061
S'int qcom_ice_setup_ice_hw(const char *storage_type, int enable)\n{\n\tint ret = -1;\n\tstruct ice_device *ice_dev = NULL;\n\n\tice_dev = get_ice_device_from_storage_type(storage_type);\n\tif (ice_dev == ERR_PTR(-EPROBE_DEFER))\n\t\treturn -EPROBE_DEFER;\n\n\tif (!ice_dev || (ice_dev->is_ice_enabled == false))\n\t\treturn ret;\n\n\tif (enable)\n\t\treturn enable_ice_setup(ice_dev);\n\telse\n\t\treturn disable_ice_setup(ice_dev);\n}'
p16062
(dp16063
((g16058
g16059
tp16064
I1
tp16065
(dp16066
g12
g13
sg14
(dp16067
(I10
I10
tp16068
(lp16069
S'\tif (!ice_dev || (ice_dev->is_ice_enabled == false))'
p16070
assg32
I2
sg33
(dp16071
(I10
I10
tp16072
(lp16073
S'\tif (!ice_dev)'
p16074
assg41
(I1
I17
tp16075
ssss(g16058
S'get_ice_device_from_storage_type'
p16076
tp16077
(dp16078
ssS'CVE-2019-14055'
p16079
(dp16080
(S'drivers/char/diag/diag_masks.c'
p16081
S'__diag_mask_init'
p16082
tp16083
(dp16084
S'static int __diag_mask_init(struct diag_mask_info *mask_info, int mask_len,\n\t\t\t    int update_buf_len)\n{\n\tif (!mask_info || mask_len < 0 || update_buf_len < 0)\n\t\treturn -EINVAL;\n\n\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\tmask_info->mask_len = mask_len;\n\tmask_info->update_buf_len = update_buf_len;\n\tif (mask_len > 0) {\n\t\tmask_info->ptr = kzalloc(mask_len, GFP_KERNEL);\n\t\tif (!mask_info->ptr)\n\t\t\treturn -ENOMEM;\n\t\tkmemleak_not_leak(mask_info->ptr);\n\t}\n\tif (update_buf_len > 0) {\n\t\tmask_info->update_buf = kzalloc(update_buf_len, GFP_KERNEL);\n\t\tif (!mask_info->update_buf) {\n\t\t\tkfree(mask_info->ptr);\n\t\t\tmask_info->ptr = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkmemleak_not_leak(mask_info->update_buf);\n\t}\n\treturn 0;\n}'
p16085
(dp16086
((g16081
g16082
tp16087
I1
tp16088
(dp16089
g14
(dp16090
(I20
I20
tp16091
(lp16092
S'\t\t\tmask_info->ptr = NULL;'
p16093
assg32
I3
sg12
g13
sg41
(I1
I26
tp16094
sssssS'CVE-2019-11599'
p16095
(dp16096
(S'fs/proc/task_mmu.c'
p16097
S'clear_refs_write'
p16098
tp16099
(dp16100
S'static ssize_t clear_refs_write(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_struct *task;\n\tchar buffer[PROC_NUMBUF];\n\tstruct mm_struct *mm;\n\tstruct vm_area_struct *vma;\n\tenum clear_refs_types type;\n\tint itype;\n\tint rv;\n\n\tmemset(buffer, 0, sizeof(buffer));\n\tif (count > sizeof(buffer) - 1)\n\t\tcount = sizeof(buffer) - 1;\n\tif (copy_from_user(buffer, buf, count))\n\t\treturn -EFAULT;\n\trv = kstrtoint(strstrip(buffer), 10, &itype);\n\tif (rv < 0)\n\t\treturn rv;\n\ttype = (enum clear_refs_types)itype;\n\tif (type < CLEAR_REFS_ALL || type >= CLEAR_REFS_LAST)\n\t\treturn -EINVAL;\n\n\ttask = get_proc_task(file_inode(file));\n\tif (!task)\n\t\treturn -ESRCH;\n\tmm = get_task_mm(task);\n\tif (mm) {\n\t\tstruct clear_refs_private cp = {\n\t\t\t.type = type,\n\t\t};\n\t\tstruct mm_walk clear_refs_walk = {\n\t\t\t.pmd_entry = clear_refs_pte_range,\n\t\t\t.test_walk = clear_refs_test_walk,\n\t\t\t.mm = mm,\n\t\t\t.private = &cp,\n\t\t};\n\n\t\tif (type == CLEAR_REFS_MM_HIWATER_RSS) {\n\t\t\tif (down_write_killable(&mm->mmap_sem)) {\n\t\t\t\tcount = -EINTR;\n\t\t\t\tgoto out_mm;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Writing 5 to /proc/pid/clear_refs resets the peak\n\t\t\t * resident set size to this mm\'s current rss value.\n\t\t\t */\n\t\t\treset_mm_hiwater_rss(mm);\n\t\t\tup_write(&mm->mmap_sem);\n\t\t\tgoto out_mm;\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY) {\n\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\tif (!(vma->vm_flags & VM_SOFTDIRTY))\n\t\t\t\t\tcontinue;\n\t\t\t\tup_read(&mm->mmap_sem);\n\t\t\t\tif (down_write_killable(&mm->mmap_sem)) {\n\t\t\t\t\tcount = -EINTR;\n\t\t\t\t\tgoto out_mm;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t * Avoid to modify vma->vm_flags\n\t\t\t\t * without locked ops while the\n\t\t\t\t * coredump reads the vm_flags.\n\t\t\t\t */\n\t\t\t\tif (!mmget_still_valid(mm)) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Silently return "count"\n\t\t\t\t\t * like if get_task_mm()\n\t\t\t\t\t * failed. FIXME: should this\n\t\t\t\t\t * function have returned\n\t\t\t\t\t * -ESRCH if get_task_mm()\n\t\t\t\t\t * failed like if\n\t\t\t\t\t * get_proc_task() fails?\n\t\t\t\t\t */\n\t\t\t\t\tup_write(&mm->mmap_sem);\n\t\t\t\t\tgoto out_mm;\n\t\t\t\t}\n\t\t\t\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\t\t\t\tvm_write_begin(vma);\n\t\t\t\t\tWRITE_ONCE(vma->vm_flags,\n\t\t\t\t\t\tvma->vm_flags & ~VM_SOFTDIRTY);\n\t\t\t\t\tvma_set_page_prot(vma);\n\t\t\t\t\tvm_write_end(vma);\n\t\t\t\t}\n\t\t\t\tdowngrade_write(&mm->mmap_sem);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmmu_notifier_invalidate_range_start(mm, 0, -1);\n\t\t}\n\t\twalk_page_range(0, mm->highest_vm_end, &clear_refs_walk);\n\t\tif (type == CLEAR_REFS_SOFT_DIRTY)\n\t\t\tmmu_notifier_invalidate_range_end(mm, 0, -1);\n\t\tflush_tlb_mm(mm);\n\t\tup_read(&mm->mmap_sem);\nout_mm:\n\t\tmmput(mm);\n\t}\n\tput_task_struct(task);\n\n\treturn count;\n}'
p16101
(dp16102
((g16097
g16098
tp16103
I1
tp16104
(dp16105
g14
(dp16106
(I64
I81
tp16107
(lp16108
S'\t\t\t\t/*'
p16109
aS'\t\t\t\t * Avoid to modify vma->vm_flags'
p16110
aS'\t\t\t\t * without locked ops while the'
p16111
aS'\t\t\t\t * coredump reads the vm_flags.'
p16112
aS'\t\t\t\t */'
p16113
aS'\t\t\t\tif (!mmget_still_valid(mm)) {'
p16114
aS'\t\t\t\t\t/*'
p16115
aS'\t\t\t\t\t * Silently return "count"'
p16116
aS'\t\t\t\t\t * like if get_task_mm()'
p16117
aS'\t\t\t\t\t * failed. FIXME: should this'
p16118
aS'\t\t\t\t\t * function have returned'
p16119
aS'\t\t\t\t\t * -ESRCH if get_task_mm()'
p16120
aS'\t\t\t\t\t * failed like if'
p16121
aS'\t\t\t\t\t * get_proc_task() fails?'
p16122
aS'\t\t\t\t\t */'
p16123
aS'\t\t\t\t\tup_write(&mm->mmap_sem);'
p16124
aS'\t\t\t\t\tgoto out_mm;'
p16125
aS'\t\t\t\t}'
p16126
assg32
I4
sg12
g13
sg41
(I1
I105
tp16127
ssss(S'fs/userfaultfd.c'
p16128
S'userfaultfd_unregister'
p16129
tp16130
(dp16131
S"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX,\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
p16132
(dp16133
((g16128
g16129
tp16134
I1
tp16135
(dp16136
g14
(dp16137
(I30
I32
tp16138
(lp16139
S'\tif (!mmget_still_valid(mm))'
p16140
aS'\t\tgoto out_unlock;'
p16141
ag59
assg32
I2
sg12
g13
sg41
(I1
I133
tp16142
ssss(g16128
S'userfaultfd_register'
p16143
tp16144
(dp16145
S"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }),\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
p16146
(dp16147
((g16128
g16143
tp16148
I1
tp16149
(dp16150
g14
(dp16151
(I52
I54
tp16152
(lp16153
S'\tif (!mmget_still_valid(mm))'
p16154
aS'\t\tgoto out_unlock;'
p16155
ag59
assg32
I2
sg12
g13
sg41
(I1
I185
tp16156
ssss(g16128
S'userfaultfd_release'
p16157
tp16158
(dp16159
S"static int userfaultfd_release(struct inode *inode, struct file *file)\n{\n\tstruct userfaultfd_ctx *ctx = file->private_data;\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev;\n\t/* len == 0 means wake all */\n\tstruct userfaultfd_wake_range range = { .len = 0, };\n\tunsigned long new_flags;\n\tbool still_valid;\n\n\tACCESS_ONCE(ctx->released) = true;\n\n\tif (!mmget_not_zero(mm))\n\t\tgoto wakeup;\n\n\t/*\n\t * Flush page faults out of all CPUs. NOTE: all page faults\n\t * must be retried without returning VM_FAULT_SIGBUS if\n\t * userfaultfd_ctx_get() succeeds but vma->vma_userfault_ctx\n\t * changes while handle_userfault released the mmap_sem. So\n\t * it's critical that released is set to true (above), before\n\t * taking the mmap_sem for writing.\n\t */\n\tdown_write(&mm->mmap_sem);\n\tstill_valid = mmget_still_valid(mm);\n\tprev = NULL;\n\tfor (vma = mm->mmap; vma; vma = vma->vm_next) {\n\t\tcond_resched();\n\t\tBUG_ON(!!vma->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(vma->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\t\tif (vma->vm_userfaultfd_ctx.ctx != ctx) {\n\t\t\tprev = vma;\n\t\t\tcontinue;\n\t\t}\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tif (still_valid) {\n\t\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,\n\t\t\t\t\t new_flags, vma->anon_vma,\n\t\t\t\t\t vma->vm_file, vma->vm_pgoff,\n\t\t\t\t\t vma_policy(vma),\n\t\t\t\t\t NULL_VM_UFFD_CTX,\n\t\t\t\t\t vma_get_anon_name(vma));\n\t\t\tif (prev)\n\t\t\t\tvma = prev;\n\t\t\telse\n\t\t\t\tprev = vma;\n\t\t}\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvm_write_end(vma);\n\t}\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nwakeup:\n\t/*\n\t * After no new page faults can wait on this fault_*wqh, flush\n\t * the last page faults that may have been already waiting on\n\t * the fault_*wqh.\n\t */\n\tspin_lock(&ctx->fault_pending_wqh.lock);\n\t__wake_up_locked_key(&ctx->fault_pending_wqh, TASK_NORMAL, &range);\n\t__wake_up_locked_key(&ctx->fault_wqh, TASK_NORMAL, &range);\n\tspin_unlock(&ctx->fault_pending_wqh.lock);\n\n\twake_up_poll(&ctx->fd_wqh, POLLHUP);\n\tuserfaultfd_ctx_put(ctx);\n\treturn 0;\n}"
p16160
(dp16161
((g16128
g16157
tp16162
I1
tp16163
(dp16164
g33
(dp16165
(I36
I45
tp16166
(lp16167
S'\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,'
p16168
aS'\t\t\t\t new_flags, vma->anon_vma,'
p16169
aS'\t\t\t\t vma->vm_file, vma->vm_pgoff,'
p16170
aS'\t\t\t\t vma_policy(vma),'
p16171
aS'\t\t\t\t NULL_VM_UFFD_CTX,'
p16172
aS'\t\t\t\t vma_get_anon_name(vma));'
p16173
aS'\t\tif (prev)'
p16174
aS'\t\t\tvma = prev;'
p16175
aS'\t\telse'
p16176
aS'\t\t\tprev = vma;'
p16177
assg14
(dp16178
(I36
I47
tp16179
(lp16180
S'\t\tif (still_valid) {'
p16181
aS'\t\t\tprev = vma_merge(mm, prev, vma->vm_start, vma->vm_end,'
p16182
aS'\t\t\t\t\t new_flags, vma->anon_vma,'
p16183
aS'\t\t\t\t\t vma->vm_file, vma->vm_pgoff,'
p16184
aS'\t\t\t\t\t vma_policy(vma),'
p16185
aS'\t\t\t\t\t NULL_VM_UFFD_CTX,'
p16186
aS'\t\t\t\t\t vma_get_anon_name(vma));'
p16187
aS'\t\t\tif (prev)'
p16188
aS'\t\t\t\tvma = prev;'
p16189
aS'\t\t\telse'
p16190
aS'\t\t\t\tprev = vma;'
p16191
aS'\t\t}'
p16192
as(I9
I9
tp16193
(lp16194
S'\tbool still_valid;'
p16195
as(I25
I25
tp16196
(lp16197
S'\tstill_valid = mmget_still_valid(mm);'
p16198
assg32
I2
sg12
g13
sg41
(I1
I69
tp16199
ssss(S'mm/mmap.c'
p16200
S'find_extend_vma'
p16201
tp16202
(dp16203
S"find_extend_vma(struct mm_struct *mm, unsigned long addr)\n{\n\tstruct vm_area_struct *vma, *prev;\n\n\taddr &= PAGE_MASK;\n\tvma = find_vma_prev(mm, addr, &prev);\n\tif (vma && (vma->vm_start <= addr))\n\t\treturn vma;\n\t/* don't alter vm_end if the coredump is running */\n\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))\n\t\treturn NULL;\n\tif (prev->vm_flags & VM_LOCKED)\n\t\tpopulate_vma_page_range(prev, addr, prev->vm_end, NULL);\n\treturn prev;\n}"
p16204
(dp16205
((g16200
g16201
tp16206
I1
tp16207
(dp16208
g12
g13
sg14
(dp16209
(I9
I10
tp16210
(lp16211
S"\t/* don't alter vm_end if the coredump is running */"
p16212
aS'\tif (!prev || !mmget_still_valid(mm) || expand_stack(prev, addr))'
p16213
assg32
I2
sg33
(dp16214
(I9
I9
tp16215
(lp16216
S'\tif (!prev || expand_stack(prev, addr))'
p16217
assg41
(I1
I15
tp16218
sssssS'CVE-2019-2345'
p16219
(dp16220
(S'drivers/media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c'
p16221
S'msm_jpegdma_streamoff'
p16222
tp16223
(dp16224
S'static int msm_jpegdma_streamoff(struct file *file,\n\tvoid *fh, enum v4l2_buf_type buf_type)\n{\n\tstruct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);\n\tint ret;\n\tmutex_lock(&ctx->lock);\n\tret = v4l2_m2m_streamoff(file, ctx->m2m_ctx, buf_type);\n\tif (ret < 0)\n\t\tdev_err(ctx->jdma_device->dev, "Stream off fails\\n");\n\tmutex_unlock(&ctx->lock);\n\treturn ret;\n}'
p16225
(dp16226
((g16221
g16222
tp16227
I1
tp16228
(dp16229
g12
g13
sg14
(dp16230
(I10
I10
tp16231
(lp16232
S'\tmutex_unlock(&ctx->lock);'
p16233
as(I6
I6
tp16234
(lp16235
S'\tmutex_lock(&ctx->lock);'
p16236
assg32
I3
sg33
(dp16237
(I10
I10
tp16238
(lp16239
g59
as(I6
I6
tp16240
(lp16241
g59
assg41
(I1
I12
tp16242
ssss(g16221
S'msm_jpegdma_reqbufs'
p16243
tp16244
(dp16245
S'static int msm_jpegdma_reqbufs(struct file *file,\n\tvoid *fh, struct v4l2_requestbuffers *req)\n{\n\tint ret = 0;\n\tstruct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);\n\n\tmutex_lock(&ctx->lock);\n\tret = v4l2_m2m_reqbufs(file, ctx->m2m_ctx, req);\n\tmutex_unlock(&ctx->lock);\n\treturn ret;\n}'
p16246
(dp16247
((g16221
g16243
tp16248
I1
tp16249
(dp16250
g33
(dp16251
(I7
I7
tp16252
(lp16253
S'\treturn v4l2_m2m_reqbufs(file, ctx->m2m_ctx, req);'
p16254
assg14
(dp16255
(I4
I4
tp16256
(lp16257
S'\tint ret = 0;'
p16258
as(I7
I10
tp16259
(lp16260
S'\tmutex_lock(&ctx->lock);'
p16261
aS'\tret = v4l2_m2m_reqbufs(file, ctx->m2m_ctx, req);'
p16262
aS'\tmutex_unlock(&ctx->lock);'
p16263
aS'\treturn ret;'
p16264
assg32
I3
sg12
g13
sg41
(I1
I11
tp16265
sssssS'CVE-2019-10538'
p16266
(dp16267
(S'drivers/soc/qcom/icnss.c'
p16268
S'wlfw_msa_mem_info_send_sync_msg'
p16269
tp16270
(dp16271
S'static int wlfw_msa_mem_info_send_sync_msg(void)\n{\n\tint ret;\n\tint i;\n\tstruct wlfw_msa_info_req_msg_v01 req;\n\tstruct wlfw_msa_info_resp_msg_v01 resp;\n\tstruct msg_desc req_desc, resp_desc;\n\tuint64_t max_mapped_addr;\n\n\tif (!penv || !penv->wlfw_clnt)\n\t\treturn -ENODEV;\n\n\ticnss_pr_dbg("Sending MSA mem info, state: 0x%lx\\n", penv->state);\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&resp, 0, sizeof(resp));\n\n\treq.msa_addr = penv->msa_pa;\n\treq.size = penv->msa_mem_size;\n\n\treq_desc.max_msg_len = WLFW_MSA_INFO_REQ_MSG_V01_MAX_MSG_LEN;\n\treq_desc.msg_id = QMI_WLFW_MSA_INFO_REQ_V01;\n\treq_desc.ei_array = wlfw_msa_info_req_msg_v01_ei;\n\n\tresp_desc.max_msg_len = WLFW_MSA_INFO_RESP_MSG_V01_MAX_MSG_LEN;\n\tresp_desc.msg_id = QMI_WLFW_MSA_INFO_RESP_V01;\n\tresp_desc.ei_array = wlfw_msa_info_resp_msg_v01_ei;\n\n\tpenv->stats.msa_info_req++;\n\n\tret = qmi_send_req_wait(penv->wlfw_clnt, &req_desc, &req, sizeof(req),\n\t\t\t&resp_desc, &resp, sizeof(resp), WLFW_TIMEOUT_MS);\n\tif (ret < 0) {\n\t\ticnss_pr_err("Send MSA Mem info req failed %d\\n", ret);\n\t\tgoto out;\n\t}\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\ticnss_pr_err("QMI MSA Mem info request rejected, result:%d error:%d\\n",\n\t\t\tresp.resp.result, resp.resp.error);\n\t\tret = -resp.resp.result;\n\t\tgoto out;\n\t}\n\n\ticnss_pr_dbg("Receive mem_region_info_len: %d\\n",\n\t\t     resp.mem_region_info_len);\n\n\tif (resp.mem_region_info_len > QMI_WLFW_MAX_NUM_MEMORY_REGIONS_V01) {\n\t\ticnss_pr_err("Invalid memory region length received: %d\\n",\n\t\t\t     resp.mem_region_info_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmax_mapped_addr = penv->msa_pa + penv->msa_mem_size;\n\tpenv->stats.msa_info_resp++;\n\tpenv->nr_mem_region = resp.mem_region_info_len;\n\tfor (i = 0; i < resp.mem_region_info_len; i++) {\n\n\t\tif (resp.mem_region_info[i].size > penv->msa_mem_size ||\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr ||\n\t\t    resp.mem_region_info[i].region_addr < penv->msa_pa ||\n\t\t    resp.mem_region_info[i].size +\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {\n\t\t\ticnss_pr_dbg("Received out of range Addr: 0x%llx Size: 0x%x\\n",\n\t\t\t\t\tresp.mem_region_info[i].region_addr,\n\t\t\t\t\tresp.mem_region_info[i].size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_unwind;\n\t\t}\n\n\t\tpenv->mem_region[i].reg_addr =\n\t\t\tresp.mem_region_info[i].region_addr;\n\t\tpenv->mem_region[i].size =\n\t\t\tresp.mem_region_info[i].size;\n\t\tpenv->mem_region[i].secure_flag =\n\t\t\tresp.mem_region_info[i].secure_flag;\n\t\ticnss_pr_dbg("Memory Region: %d Addr: 0x%llx Size: 0x%x Flag: 0x%08x\\n",\n\t\t\t     i, penv->mem_region[i].reg_addr,\n\t\t\t     penv->mem_region[i].size,\n\t\t\t     penv->mem_region[i].secure_flag);\n\t}\n\n\treturn 0;\n\nfail_unwind:\n\tmemset(&penv->mem_region[0], 0, sizeof(penv->mem_region[0]) * i);\nout:\n\tpenv->stats.msa_info_err++;\n\tICNSS_QMI_ASSERT();\n\treturn ret;\n}'
p16272
(dp16273
((g16268
g16269
tp16274
I1
tp16275
(dp16276
g14
(dp16277
(I59
I71
tp16278
(lp16279
g59
aS'\t\tif (resp.mem_region_info[i].size > penv->msa_mem_size ||'
p16280
aS'\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr ||'
p16281
aS'\t\t    resp.mem_region_info[i].region_addr < penv->msa_pa ||'
p16282
aS'\t\t    resp.mem_region_info[i].size +'
p16283
aS'\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {'
p16284
aS'\t\t\ticnss_pr_dbg("Received out of range Addr: 0x%llx Size: 0x%x\\n",'
p16285
aS'\t\t\t\t\tresp.mem_region_info[i].region_addr,'
p16286
aS'\t\t\t\t\tresp.mem_region_info[i].size);'
p16287
aS'\t\t\tret = -EINVAL;'
p16288
aS'\t\t\tgoto fail_unwind;'
p16289
aS'\t\t}'
p16290
ag59
as(I8
I8
tp16291
(lp16292
S'\tuint64_t max_mapped_addr;'
p16293
as(I86
I87
tp16294
(lp16295
S'fail_unwind:'
p16296
aS'\tmemset(&penv->mem_region[0], 0, sizeof(penv->mem_region[0]) * i);'
p16297
as(I55
I55
tp16298
(lp16299
S'\tmax_mapped_addr = penv->msa_pa + penv->msa_mem_size;'
p16300
assg32
I1
sg12
g13
sg41
(I1
I92
tp16301
sssS'static int wlfw_msa_mem_info_send_sync_msg(void)\n{\n\tint ret;\n\tint i;\n\tstruct wlfw_msa_info_req_msg_v01 req;\n\tstruct wlfw_msa_info_resp_msg_v01 resp;\n\tstruct msg_desc req_desc, resp_desc;\n\tuint64_t max_mapped_addr;\n\n\tif (!penv || !penv->wlfw_clnt)\n\t\treturn -ENODEV;\n\n\ticnss_pr_dbg("Sending MSA mem info, state: 0x%lx\\n", penv->state);\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&resp, 0, sizeof(resp));\n\n\treq.msa_addr = penv->msa_pa;\n\treq.size = penv->msa_mem_size;\n\n\treq_desc.max_msg_len = WLFW_MSA_INFO_REQ_MSG_V01_MAX_MSG_LEN;\n\treq_desc.msg_id = QMI_WLFW_MSA_INFO_REQ_V01;\n\treq_desc.ei_array = wlfw_msa_info_req_msg_v01_ei;\n\n\tresp_desc.max_msg_len = WLFW_MSA_INFO_RESP_MSG_V01_MAX_MSG_LEN;\n\tresp_desc.msg_id = QMI_WLFW_MSA_INFO_RESP_V01;\n\tresp_desc.ei_array = wlfw_msa_info_resp_msg_v01_ei;\n\n\tpenv->stats.msa_info_req++;\n\n\tret = qmi_send_req_wait(penv->wlfw_clnt, &req_desc, &req, sizeof(req),\n\t\t\t&resp_desc, &resp, sizeof(resp), WLFW_TIMEOUT_MS);\n\tif (ret < 0) {\n\t\ticnss_pr_err("Send MSA Mem info req failed %d\\n", ret);\n\t\tgoto out;\n\t}\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\ticnss_pr_err("QMI MSA Mem info request rejected, result:%d error:%d\\n",\n\t\t\tresp.resp.result, resp.resp.error);\n\t\tret = -resp.resp.result;\n\t\tgoto out;\n\t}\n\n\ticnss_pr_dbg("Receive mem_region_info_len: %d\\n",\n\t\t     resp.mem_region_info_len);\n\n\tif (resp.mem_region_info_len > QMI_WLFW_MAX_NUM_MEMORY_REGIONS_V01) {\n\t\ticnss_pr_err("Invalid memory region length received: %d\\n",\n\t\t\t     resp.mem_region_info_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmax_mapped_addr = penv->msa_pa + penv->msa_mem_size;\n\tpenv->stats.msa_info_resp++;\n\tpenv->nr_mem_region = resp.mem_region_info_len;\n\tfor (i = 0; i < resp.mem_region_info_len; i++) {\n\n\t\tif (resp.mem_region_info[i].size > penv->msa_mem_size ||\n\t\t    resp.mem_region_info[i].region_addr >= max_mapped_addr ||\n\t\t    resp.mem_region_info[i].region_addr < penv->msa_pa ||\n\t\t    resp.mem_region_info[i].size +\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {\n\t\t\ticnss_pr_dbg("Received out of range Addr: 0x%llx Size: 0x%x\\n",\n\t\t\t\t\tresp.mem_region_info[i].region_addr,\n\t\t\t\t\tresp.mem_region_info[i].size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_unwind;\n\t\t}\n\n\t\tpenv->mem_region[i].reg_addr =\n\t\t\tresp.mem_region_info[i].region_addr;\n\t\tpenv->mem_region[i].size =\n\t\t\tresp.mem_region_info[i].size;\n\t\tpenv->mem_region[i].secure_flag =\n\t\t\tresp.mem_region_info[i].secure_flag;\n\t\ticnss_pr_dbg("Memory Region: %d Addr: 0x%llx Size: 0x%x Flag: 0x%08x\\n",\n\t\t\t     i, penv->mem_region[i].reg_addr,\n\t\t\t     penv->mem_region[i].size,\n\t\t\t     penv->mem_region[i].secure_flag);\n\t}\n\n\treturn 0;\n\nfail_unwind:\n\tmemset(&penv->mem_region[0], 0, sizeof(penv->mem_region[0]) * i);\nout:\n\tpenv->stats.msa_info_err++;\n\tICNSS_QMI_ASSERT();\n\treturn ret;\n}'
p16302
(dp16303
((g16268
g16269
tp16304
I1
tp16305
(dp16306
g14
(dp16307
(I59
I71
tp16308
(lp16309
g59
aS'\t\tif (resp.mem_region_info[i].size > penv->msa_mem_size ||'
p16310
aS'\t\t    resp.mem_region_info[i].region_addr >= max_mapped_addr ||'
p16311
aS'\t\t    resp.mem_region_info[i].region_addr < penv->msa_pa ||'
p16312
aS'\t\t    resp.mem_region_info[i].size +'
p16313
aS'\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {'
p16314
aS'\t\t\ticnss_pr_dbg("Received out of range Addr: 0x%llx Size: 0x%x\\n",'
p16315
aS'\t\t\t\t\tresp.mem_region_info[i].region_addr,'
p16316
aS'\t\t\t\t\tresp.mem_region_info[i].size);'
p16317
aS'\t\t\tret = -EINVAL;'
p16318
aS'\t\t\tgoto fail_unwind;'
p16319
aS'\t\t}'
p16320
ag59
as(I8
I8
tp16321
(lp16322
S'\tuint64_t max_mapped_addr;'
p16323
as(I86
I87
tp16324
(lp16325
S'fail_unwind:'
p16326
aS'\tmemset(&penv->mem_region[0], 0, sizeof(penv->mem_region[0]) * i);'
p16327
as(I55
I55
tp16328
(lp16329
S'\tmax_mapped_addr = penv->msa_pa + penv->msa_mem_size;'
p16330
assg32
I1
sg12
g13
sg41
(I1
I92
tp16331
sssssS'CVE-2019-10530'
p16332
(dp16333
(S'drivers/iommu/dma-mapping-fast.c'
p16334
S'fast_smmu_alloc'
p16335
tp16336
(dp16337
S'static void *fast_smmu_alloc(struct device *dev, size_t size,\n\t\t\t     dma_addr_t *handle, gfp_t gfp,\n\t\t\t     unsigned long attrs)\n{\n\tstruct dma_fast_smmu_mapping *mapping = dev->archdata.mapping->fast;\n\tstruct sg_table sgt;\n\tdma_addr_t dma_addr, iova_iter;\n\tvoid *addr;\n\tav8l_fast_iopte *ptep;\n\tunsigned long flags;\n\tstruct sg_mapping_iter miter;\n\tsize_t count = ALIGN(size, SZ_4K) >> PAGE_SHIFT;\n\tint prot = IOMMU_READ | IOMMU_WRITE; /* TODO: extract from attrs */\n\tbool is_coherent = is_dma_coherent(dev, attrs);\n\tpgprot_t remap_prot = __get_dma_pgprot(attrs, PAGE_KERNEL, is_coherent);\n\tstruct page **pages;\n\n\t/*\n\t * sg_alloc_table_from_pages accepts unsigned int value for count\n\t * so check count doesn\'t exceed UINT_MAX.\n\t */\n\n\tif (count > UINT_MAX) {\n\t\tdev_err(dev, "count: %zx exceeds UNIT_MAX\\n", count);\n\t\treturn NULL;\n\t}\n\n\tprot = __get_iommu_pgprot(attrs, prot, is_coherent);\n\n\t*handle = DMA_ERROR_CODE;\n\n\tpages = __fast_smmu_alloc_pages(count, gfp);\n\tif (!pages) {\n\t\tdev_err(dev, "no pages\\n");\n\t\treturn NULL;\n\t}\n\n\tsize = ALIGN(size, SZ_4K);\n\tif (sg_alloc_table_from_pages(&sgt, pages, count, 0, size, gfp)) {\n\t\tdev_err(dev, "no sg tablen\\n");\n\t\tgoto out_free_pages;\n\t}\n\n\tif (!is_coherent) {\n\t\t/*\n\t\t * The CPU-centric flushing implied by SG_MITER_TO_SG isn\'t\n\t\t * sufficient here, so skip it by using the "wrong" direction.\n\t\t */\n\t\tsg_miter_start(&miter, sgt.sgl, sgt.orig_nents,\n\t\t\t       SG_MITER_FROM_SG);\n\t\twhile (sg_miter_next(&miter))\n\t\t\t__dma_flush_area(miter.addr, miter.length);\n\t\tsg_miter_stop(&miter);\n\t}\n\n\tspin_lock_irqsave(&mapping->lock, flags);\n\tdma_addr = __fast_smmu_alloc_iova(mapping, attrs, size);\n\tif (dma_addr == DMA_ERROR_CODE) {\n\t\tdev_err(dev, "no iova\\n");\n\t\tspin_unlock_irqrestore(&mapping->lock, flags);\n\t\tgoto out_free_sg;\n\t}\n\tiova_iter = dma_addr;\n\tsg_miter_start(&miter, sgt.sgl, sgt.orig_nents,\n\t\t       SG_MITER_FROM_SG | SG_MITER_ATOMIC);\n\twhile (sg_miter_next(&miter)) {\n\t\tint nptes = miter.length >> FAST_PAGE_SHIFT;\n\n\t\tptep = iopte_pmd_offset(mapping->pgtbl_pmds, iova_iter);\n\t\tif (unlikely(av8l_fast_map_public(\n\t\t\t\t     ptep, page_to_phys(miter.page),\n\t\t\t\t     miter.length, prot))) {\n\t\t\tdev_err(dev, "no map public\\n");\n\t\t\t/* TODO: unwind previously successful mappings */\n\t\t\tgoto out_free_iova;\n\t\t}\n\t\tfast_dmac_clean_range(mapping, ptep, ptep + nptes);\n\t\tiova_iter += miter.length;\n\t}\n\tsg_miter_stop(&miter);\n\tspin_unlock_irqrestore(&mapping->lock, flags);\n\n\taddr = dma_common_pages_remap(pages, size, VM_USERMAP, remap_prot,\n\t\t\t\t      __builtin_return_address(0));\n\tif (!addr) {\n\t\tdev_err(dev, "no common pages\\n");\n\t\tgoto out_unmap;\n\t}\n\n\t*handle = dma_addr;\n\tsg_free_table(&sgt);\n\treturn addr;\n\nout_unmap:\n\t/* need to take the lock again for page tables and iova */\n\tspin_lock_irqsave(&mapping->lock, flags);\n\tptep = iopte_pmd_offset(mapping->pgtbl_pmds, dma_addr);\n\tav8l_fast_unmap_public(ptep, size);\n\tfast_dmac_clean_range(mapping, ptep, ptep + count);\nout_free_iova:\n\t__fast_smmu_free_iova(mapping, dma_addr, size);\n\tspin_unlock_irqrestore(&mapping->lock, flags);\nout_free_sg:\n\tsg_free_table(&sgt);\nout_free_pages:\n\t__fast_smmu_free_pages(pages, count);\n\treturn NULL;\n}'
p16338
(dp16339
((g16334
g16335
tp16340
I1
tp16341
(dp16342
g12
g13
sg14
(dp16343
(I12
I12
tp16344
(lp16345
S'\tsize_t count = ALIGN(size, SZ_4K) >> PAGE_SHIFT;'
p16346
as(I18
I27
tp16347
(lp16348
S'\t/*'
p16349
aS'\t * sg_alloc_table_from_pages accepts unsigned int value for count'
p16350
aS"\t * so check count doesn't exceed UINT_MAX."
p16351
aS'\t */'
p16352
ag59
aS'\tif (count > UINT_MAX) {'
p16353
aS'\t\tdev_err(dev, "count: %zx exceeds UNIT_MAX\\n", count);'
p16354
aS'\t\treturn NULL;'
p16355
aS'\t}'
p16356
ag59
assg32
I5
sg33
(dp16357
(I12
I12
tp16358
(lp16359
S'\tunsigned int count = ALIGN(size, SZ_4K) >> PAGE_SHIFT;'
p16360
assg41
(I1
I108
tp16361
sssssS'CVE-2019-11833'
p16362
(dp16363
(S'fs/ext4/extents.c'
p16364
S'ext4_ext_grow_indepth'
p16365
tp16366
(dp16367
S'static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,\n\t\t\t\t unsigned int flags)\n{\n\tstruct ext4_extent_header *neh;\n\tstruct buffer_head *bh;\n\text4_fsblk_t newblock, goal = 0;\n\tstruct ext4_super_block *es = EXT4_SB(inode->i_sb)->s_es;\n\tint err = 0;\n\tsize_t ext_size = 0;\n\n\t/* Try to prepend new index to old one */\n\tif (ext_depth(inode))\n\t\tgoal = ext4_idx_pblock(EXT_FIRST_INDEX(ext_inode_hdr(inode)));\n\tif (goal > le32_to_cpu(es->s_first_data_block)) {\n\t\tflags |= EXT4_MB_HINT_TRY_GOAL;\n\t\tgoal--;\n\t} else\n\t\tgoal = ext4_inode_to_goal_block(inode);\n\tnewblock = ext4_new_meta_blocks(handle, inode, goal, flags,\n\t\t\t\t\tNULL, &err);\n\tif (newblock == 0)\n\t\treturn err;\n\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, bh);\n\tif (err) {\n\t\tunlock_buffer(bh);\n\t\tgoto out;\n\t}\n\n\text_size = sizeof(EXT4_I(inode)->i_data);\n\t/* move top-level index/leaf into new block */\n\tmemmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);\n\t/* zero out unused area in the extent block */\n\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);\n\n\t/* set size of new block */\n\tneh = ext_block_hdr(bh);\n\t/* old root could have indexes or leaves\n\t * so calculate e_max right way */\n\tif (ext_depth(inode))\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\telse\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\text4_extent_block_csum_set(inode, neh);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto out;\n\n\t/* Update top-level index: num,max,pointer */\n\tneh = ext_inode_hdr(inode);\n\tneh->eh_entries = cpu_to_le16(1);\n\text4_idx_store_pblock(EXT_FIRST_INDEX(neh), newblock);\n\tif (neh->eh_depth == 0) {\n\t\t/* Root extent block becomes index block */\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_root_idx(inode, 0));\n\t\tEXT_FIRST_INDEX(neh)->ei_block =\n\t\t\tEXT_FIRST_EXTENT(neh)->ee_block;\n\t}\n\text_debug("new root: num %d(%d), lblock %d, ptr %llu\\n",\n\t\t  le16_to_cpu(neh->eh_entries), le16_to_cpu(neh->eh_max),\n\t\t  le32_to_cpu(EXT_FIRST_INDEX(neh)->ei_block),\n\t\t  ext4_idx_pblock(EXT_FIRST_INDEX(neh)));\n\n\tle16_add_cpu(&neh->eh_depth, 1);\n\text4_mark_inode_dirty(handle, inode);\nout:\n\tbrelse(bh);\n\n\treturn err;\n}'
p16368
(dp16369
((g16364
g16365
tp16370
I1
tp16371
(dp16372
g33
(dp16373
(I37
I38
tp16374
(lp16375
S'\tmemmove(bh->b_data, EXT4_I(inode)->i_data,'
p16376
aS'\t\tsizeof(EXT4_I(inode)->i_data));'
p16377
assg14
(dp16378
(I37
I39
tp16379
(lp16380
S'\tmemmove(bh->b_data, EXT4_I(inode)->i_data, ext_size);'
p16381
aS'\t/* zero out unused area in the extent block */'
p16382
aS'\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);'
p16383
as(I9
I9
tp16384
(lp16385
S'\tsize_t ext_size = 0;'
p16386
as(I35
I35
tp16387
(lp16388
S'\text_size = sizeof(EXT4_I(inode)->i_data);'
p16389
assg32
I3
sg12
g13
sg41
(I1
I79
tp16390
ssss(g16364
S'ext4_ext_split'
p16391
tp16392
(dp16393
S'static int ext4_ext_split(handle_t *handle, struct inode *inode,\n\t\t\t  unsigned int flags,\n\t\t\t  struct ext4_ext_path *path,\n\t\t\t  struct ext4_extent *newext, int at)\n{\n\tstruct buffer_head *bh = NULL;\n\tint depth = ext_depth(inode);\n\tstruct ext4_extent_header *neh;\n\tstruct ext4_extent_idx *fidx;\n\tint i = at, k, m, a;\n\text4_fsblk_t newblock, oldblock;\n\t__le32 border;\n\text4_fsblk_t *ablocks = NULL; /* array of allocated blocks */\n\tint err = 0;\n\tsize_t ext_size = 0;\n\n\t/* make decision: where to split? */\n\t/* FIXME: now decision is simplest: at current extent */\n\n\t/* if current leaf will be split, then we should use\n\t * border from split point */\n\tif (unlikely(path[depth].p_ext > EXT_MAX_EXTENT(path[depth].p_hdr))) {\n\t\tEXT4_ERROR_INODE(inode, "p_ext > EXT_MAX_EXTENT!");\n\t\treturn -EFSCORRUPTED;\n\t}\n\tif (path[depth].p_ext != EXT_MAX_EXTENT(path[depth].p_hdr)) {\n\t\tborder = path[depth].p_ext[1].ee_block;\n\t\text_debug("leaf will be split."\n\t\t\t\t" next leaf starts at %d\\n",\n\t\t\t\t  le32_to_cpu(border));\n\t} else {\n\t\tborder = newext->ee_block;\n\t\text_debug("leaf will be added."\n\t\t\t\t" next leaf starts at %d\\n",\n\t\t\t\tle32_to_cpu(border));\n\t}\n\n\t/*\n\t * If error occurs, then we break processing\n\t * and mark filesystem read-only. index won\'t\n\t * be inserted and tree will be in consistent\n\t * state. Next mount will repair buffers too.\n\t */\n\n\t/*\n\t * Get array to track all allocated blocks.\n\t * We need this to handle errors and free blocks\n\t * upon them.\n\t */\n\tablocks = kzalloc(sizeof(ext4_fsblk_t) * depth, GFP_NOFS);\n\tif (!ablocks)\n\t\treturn -ENOMEM;\n\n\t/* allocate all needed blocks */\n\text_debug("allocate %d blocks for indexes/leaf\\n", depth - at);\n\tfor (a = 0; a < depth - at; a++) {\n\t\tnewblock = ext4_ext_new_meta_block(handle, inode, path,\n\t\t\t\t\t\t   newext, &err, flags);\n\t\tif (newblock == 0)\n\t\t\tgoto cleanup;\n\t\tablocks[a] = newblock;\n\t}\n\n\t/* initialize new leaf */\n\tnewblock = ablocks[--a];\n\tif (unlikely(newblock == 0)) {\n\t\tEXT4_ERROR_INODE(inode, "newblock == 0!");\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tbh = sb_getblk_gfp(inode->i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);\n\tif (unlikely(!bh)) {\n\t\terr = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tlock_buffer(bh);\n\n\terr = ext4_journal_get_create_access(handle, bh);\n\tif (err)\n\t\tgoto cleanup;\n\n\tneh = ext_block_hdr(bh);\n\tneh->eh_entries = 0;\n\tneh->eh_max = cpu_to_le16(ext4_ext_space_block(inode, 0));\n\tneh->eh_magic = EXT4_EXT_MAGIC;\n\tneh->eh_depth = 0;\n\n\t/* move remainder of path[depth] to the new leaf */\n\tif (unlikely(path[depth].p_hdr->eh_entries !=\n\t\t     path[depth].p_hdr->eh_max)) {\n\t\tEXT4_ERROR_INODE(inode, "eh_entries %d != eh_max %d!",\n\t\t\t\t path[depth].p_hdr->eh_entries,\n\t\t\t\t path[depth].p_hdr->eh_max);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\t/* start copy from next extent */\n\tm = EXT_MAX_EXTENT(path[depth].p_hdr) - path[depth].p_ext++;\n\text4_ext_show_move(inode, path, newblock, depth);\n\tif (m) {\n\t\tstruct ext4_extent *ex;\n\t\tex = EXT_FIRST_EXTENT(neh);\n\t\tmemmove(ex, path[depth].p_ext, sizeof(struct ext4_extent) * m);\n\t\tle16_add_cpu(&neh->eh_entries, m);\n\t}\n\n\t/* zero out unused area in the extent block */\n\text_size = sizeof(struct ext4_extent_header) +\n\t\tsizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);\n\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);\n\text4_extent_block_csum_set(inode, neh);\n\tset_buffer_uptodate(bh);\n\tunlock_buffer(bh);\n\n\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\tif (err)\n\t\tgoto cleanup;\n\tbrelse(bh);\n\tbh = NULL;\n\n\t/* correct old leaf */\n\tif (m) {\n\t\terr = ext4_ext_get_access(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tle16_add_cpu(&path[depth].p_hdr->eh_entries, -m);\n\t\terr = ext4_ext_dirty(handle, inode, path + depth);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t}\n\n\t/* create intermediate indexes */\n\tk = depth - at - 1;\n\tif (unlikely(k < 0)) {\n\t\tEXT4_ERROR_INODE(inode, "k %d < 0!", k);\n\t\terr = -EFSCORRUPTED;\n\t\tgoto cleanup;\n\t}\n\tif (k)\n\t\text_debug("create %d intermediate indices\\n", k);\n\t/* insert new index into current index block */\n\t/* current depth stored in i var */\n\ti = depth - 1;\n\twhile (k--) {\n\t\toldblock = newblock;\n\t\tnewblock = ablocks[--a];\n\t\tbh = sb_getblk(inode->i_sb, newblock);\n\t\tif (unlikely(!bh)) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto cleanup;\n\t\t}\n\t\tlock_buffer(bh);\n\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\n\t\tneh = ext_block_hdr(bh);\n\t\tneh->eh_entries = cpu_to_le16(1);\n\t\tneh->eh_magic = EXT4_EXT_MAGIC;\n\t\tneh->eh_max = cpu_to_le16(ext4_ext_space_block_idx(inode, 0));\n\t\tneh->eh_depth = cpu_to_le16(depth - i);\n\t\tfidx = EXT_FIRST_INDEX(neh);\n\t\tfidx->ei_block = border;\n\t\text4_idx_store_pblock(fidx, oldblock);\n\n\t\text_debug("int.index at %d (block %llu): %u -> %llu\\n",\n\t\t\t\ti, newblock, le32_to_cpu(border), oldblock);\n\n\t\t/* move remainder of path[i] to the new index block */\n\t\tif (unlikely(EXT_MAX_INDEX(path[i].p_hdr) !=\n\t\t\t\t\tEXT_LAST_INDEX(path[i].p_hdr))) {\n\t\t\tEXT4_ERROR_INODE(inode,\n\t\t\t\t\t "EXT_MAX_INDEX != EXT_LAST_INDEX ee_block %d!",\n\t\t\t\t\t le32_to_cpu(path[i].p_ext->ee_block));\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tgoto cleanup;\n\t\t}\n\t\t/* start copy indexes */\n\t\tm = EXT_MAX_INDEX(path[i].p_hdr) - path[i].p_idx++;\n\t\text_debug("cur 0x%p, last 0x%p\\n", path[i].p_idx,\n\t\t\t\tEXT_MAX_INDEX(path[i].p_hdr));\n\t\text4_ext_show_move(inode, path, newblock, i);\n\t\tif (m) {\n\t\t\tmemmove(++fidx, path[i].p_idx,\n\t\t\t\tsizeof(struct ext4_extent_idx) * m);\n\t\t\tle16_add_cpu(&neh->eh_entries, m);\n\t\t}\n\t\t/* zero out unused area in the extent block */\n\t\text_size = sizeof(struct ext4_extent_header) +\n\t\t   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));\n\t\tmemset(bh->b_data + ext_size, 0,\n\t\t\tinode->i_sb->s_blocksize - ext_size);\n\t\text4_extent_block_csum_set(inode, neh);\n\t\tset_buffer_uptodate(bh);\n\t\tunlock_buffer(bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (err)\n\t\t\tgoto cleanup;\n\t\tbrelse(bh);\n\t\tbh = NULL;\n\n\t\t/* correct old index */\n\t\tif (m) {\n\t\t\terr = ext4_ext_get_access(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t\tle16_add_cpu(&path[i].p_hdr->eh_entries, -m);\n\t\t\terr = ext4_ext_dirty(handle, inode, path + i);\n\t\t\tif (err)\n\t\t\t\tgoto cleanup;\n\t\t}\n\n\t\ti--;\n\t}\n\n\t/* insert new index */\n\terr = ext4_ext_insert_index(handle, inode, path + at,\n\t\t\t\t    le32_to_cpu(border), newblock);\n\ncleanup:\n\tif (bh) {\n\t\tif (buffer_locked(bh))\n\t\t\tunlock_buffer(bh);\n\t\tbrelse(bh);\n\t}\n\n\tif (err) {\n\t\t/* free all allocated blocks in error case */\n\t\tfor (i = 0; i < depth; i++) {\n\t\t\tif (!ablocks[i])\n\t\t\t\tcontinue;\n\t\t\text4_free_blocks(handle, inode, NULL, ablocks[i], 1,\n\t\t\t\t\t EXT4_FREE_BLOCKS_METADATA);\n\t\t}\n\t}\n\tkfree(ablocks);\n\n\treturn err;\n}'
p16394
(dp16395
((g16364
g16391
tp16396
I1
tp16397
(dp16398
g14
(dp16399
(I190
I194
tp16400
(lp16401
S'\t\t/* zero out unused area in the extent block */'
p16402
aS'\t\text_size = sizeof(struct ext4_extent_header) +'
p16403
aS'\t\t   (sizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries));'
p16404
aS'\t\tmemset(bh->b_data + ext_size, 0,'
p16405
aS'\t\t\tinode->i_sb->s_blocksize - ext_size);'
p16406
as(I15
I15
tp16407
(lp16408
S'\tsize_t ext_size = 0;'
p16409
as(I107
I110
tp16410
(lp16411
S'\t/* zero out unused area in the extent block */'
p16412
aS'\text_size = sizeof(struct ext4_extent_header) +'
p16413
aS'\t\tsizeof(struct ext4_extent) * le16_to_cpu(neh->eh_entries);'
p16414
aS'\tmemset(bh->b_data + ext_size, 0, inode->i_sb->s_blocksize - ext_size);'
p16415
assg32
I6
sg12
g13
sg41
(I1
I242
tp16416
sssssS'CVE-2018-11823'
p16417
(dp16418
(S'drivers/cpuidle/lpm-levels-of.c'
p16419
S'parse_cpu_levels'
p16420
tp16421
(dp16422
S'static int parse_cpu_levels(struct device_node *node, struct lpm_cluster *c)\n{\n\tint ret;\n\tchar *key;\n\tstruct lpm_cpu *cpu;\n\n\tcpu = devm_kzalloc(&lpm_pdev->dev, sizeof(*cpu), GFP_KERNEL);\n\tif (!cpu)\n\t\treturn -ENOMEM;\n\n\tif (get_cpumask_for_node(node, &cpu->related_cpus))\n\t\treturn -EINVAL;\n\n\tcpu->parent = c;\n\n\tkey = "qcom,psci-mode-shift";\n\tret = of_property_read_u32(node, key, &cpu->psci_mode_shift);\n\tif (ret)\n\t\tgoto failed;\n\n\tkey = "qcom,psci-mode-mask";\n\tret = of_property_read_u32(node, key, &cpu->psci_mode_mask);\n\tif (ret)\n\t\tgoto failed;\n\n\tkey = "qcom,disable-prediction";\n\tcpu->lpm_prediction = !(of_property_read_bool(node, key));\n\n\tif (cpu->lpm_prediction) {\n\t\tkey = "qcom,ref-stddev";\n\t\tret = of_property_read_u32(node, key, &cpu->ref_stddev);\n\t\tif (ret || cpu->ref_stddev < STDDEV_LOW ||\n\t\t\t\t\tcpu->ref_stddev > STDDEV_HIGH)\n\t\t\tcpu->ref_stddev = DEFAULT_STDDEV;\n\n\t\tkey = "qcom,tmr-add";\n\t\tret = of_property_read_u32(node, key, &cpu->tmr_add);\n\t\tif (ret || cpu->tmr_add < TIMER_ADD_LOW ||\n\t\t\t\t\tcpu->tmr_add > TIMER_ADD_HIGH)\n\t\t\tcpu->tmr_add = DEFAULT_TIMER_ADD;\n\n\t\tkey = "qcom,ref-premature-cnt";\n\t\tret = of_property_read_u32(node, key, &cpu->ref_premature_cnt);\n\t\tif (ret || cpu->ref_premature_cnt < PREMATURE_CNT_LOW ||\n\t\t\t\tcpu->ref_premature_cnt > PREMATURE_CNT_HIGH)\n\t\t\tcpu->ref_premature_cnt = DEFAULT_PREMATURE_CNT;\n\t}\n\n\tkey = "parse_cpu";\n\tret = parse_cpu(node, cpu);\n\tif (ret)\n\t\tgoto failed;\n\n\tcpumask_or(&c->child_cpus, &c->child_cpus, &cpu->related_cpus);\n\tlist_add(&cpu->list, &c->cpu);\n\n\treturn ret;\n\nfailed:\n\tpr_err("Failed to read key: %s node: %s\\n", key, node->name);\n\treturn ret;\n}'
p16423
(dp16424
((g16419
g16420
tp16425
I1
tp16426
(dp16427
g12
g13
sg14
(dp16428
(I59
I59
tp16429
(lp16430
S'failed:'
p16431
as(I24
I24
tp16432
(lp16433
S'\t\tgoto failed;'
p16434
as(I52
I52
tp16435
(lp16436
S'\t\tgoto failed;'
p16437
as(I3
I3
tp16438
(lp16439
S'\tint ret;'
p16440
as(I19
I19
tp16441
(lp16442
S'\t\tgoto failed;'
p16443
assg32
I2
sg33
(dp16444
(I24
I24
tp16445
(lp16446
S'\t\tgoto failed_parse_params;'
p16447
as(I52
I52
tp16448
(lp16449
S'\t\tgoto failed_parse_cpu;'
p16450
as(I3
I3
tp16451
(lp16452
S'\tint ret, i;'
p16453
as(I59
I65
tp16454
(lp16455
S'failed_parse_cpu:'
p16456
aS'\tfor (i = 0; i < cpu->nlevels; i++) {'
p16457
aS'\t\tkfree(cpu->levels[i].name);'
p16458
aS'\t\tcpu->levels[i].name = NULL;'
p16459
aS'\t}'
p16460
ag59
aS'failed_parse_params:'
p16461
as(I19
I19
tp16462
(lp16463
S'\t\tgoto failed_parse_params;'
p16464
assg41
(I1
I62
tp16465
ssss(g16419
S'free_cluster_node'
p16466
tp16467
(dp16468
S'void free_cluster_node(struct lpm_cluster *cluster)\n{\n\tstruct lpm_cpu *cpu, *n;\n\tstruct lpm_cluster *cl, *m;\n\n\tlist_for_each_entry_safe(cl, m, &cluster->child, list) {\n\t\tlist_del(&cl->list);\n\t\tfree_cluster_node(cl);\n\t};\n\n\tlist_for_each_entry_safe(cpu, n, &cluster->cpu, list)\n\t\tlist_del(&cpu->list);\n}'
p16469
(dp16470
((g16419
g16466
tp16471
I1
tp16472
(dp16473
g12
g13
sg14
(dp16474
(I11
I11
tp16475
(lp16476
S'\tlist_for_each_entry_safe(cpu, n, &cluster->cpu, list)'
p16477
assg32
I1
sg33
(dp16478
(I13
I17
tp16479
(lp16480
S'\t\tfor (i = 0; i < cpu->nlevels; i++) {'
p16481
aS'\t\t\tkfree(cpu->levels[i].name);'
p16482
aS'\t\t\tcpu->levels[i].name = NULL;'
p16483
aS'\t\t}'
p16484
aS'\t}'
p16485
as(I11
I13
tp16486
(lp16487
S'\tlist_for_each_entry_safe(cpu, n, &cluster->cpu, list) {'
p16488
aS'\t\tint i;'
p16489
ag59
assg41
(I1
I13
tp16490
ssss(g16419
S'parse_cluster'
p16491
tp16492
(dp16493
S'struct lpm_cluster *parse_cluster(struct device_node *node,\n\t\tstruct lpm_cluster *parent)\n{\n\tstruct lpm_cluster *c;\n\tstruct device_node *n;\n\tchar *key;\n\tint ret = 0;\n\tint i, j;\n\n\tc = devm_kzalloc(&lpm_pdev->dev, sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = parse_cluster_params(node, c);\n\tif (ret)\n\t\tgoto failed_parse_params;\n\n\tINIT_LIST_HEAD(&c->list);\n\tINIT_LIST_HEAD(&c->child);\n\tINIT_LIST_HEAD(&c->cpu);\n\tc->parent = parent;\n\tspin_lock_init(&c->sync_lock);\n\tc->min_child_level = NR_LPM_LEVELS;\n\n\tfor_each_child_of_node(node, n) {\n\n\t\tif (!n->name)\n\t\t\tcontinue;\n\n\t\tkey = "qcom,pm-cluster-level";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cluster_level(n, c)) {\n\t\t\t\tof_node_put(n);\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\t}\n\t\t\tof_node_put(n);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cluster";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tstruct lpm_cluster *child;\n\n\t\t\tchild = parse_cluster(n, c);\n\t\t\tif (!child) {\n\t\t\t\tof_node_put(n);\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\t}\n\n\t\t\tlist_add(&child->list, &c->child);\n\t\t\tcpumask_or(&c->child_cpus, &c->child_cpus,\n\t\t\t\t\t&child->child_cpus);\n\t\t\tc->aff_level = child->aff_level + 1;\n\t\t\tof_node_put(n);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cpu";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cpu_levels(n, c)) {\n\t\t\t\tof_node_put(n);\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\t}\n\n\t\t\tc->aff_level = 1;\n\t\t\tof_node_put(n);\n\t\t}\n\t}\n\n\tif (cpumask_intersects(&c->child_cpus, cpu_online_mask))\n\t\tc->last_level = c->default_level;\n\telse\n\t\tc->last_level = c->nlevels-1;\n\n\tfor (i = 0; i < c->nlevels; i++) {\n\t\tfor (j = 0; j < c->nlevels; j++) {\n\t\t\tif (i >= j) {\n\t\t\t\tc->levels[i].pwr.residencies[j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc->levels[i].pwr.residencies[j] = calculate_residency(\n\t\t\t\t&c->levels[i].pwr, &c->levels[j].pwr);\n\t\t}\n\t}\n\tset_optimum_cluster_residency(c, true);\n\treturn c;\n\nfailed_parse_cluster:\n\tpr_err("Failed parse cluster:%s\\n", key);\n\tif (parent)\n\t\tlist_del(&c->list);\n\tfree_cluster_node(c);\nfailed_parse_params:\n\tpr_err("Failed parse params\\n");\n\treturn NULL;\n}'
p16494
(dp16495
((g16419
g16491
tp16496
I1
tp16497
(dp16498
g12
g13
sg14
(dp16499
(I32
I33
tp16500
(lp16501
S'\t\t\tif (parse_cluster_level(n, c)) {'
p16502
aS'\t\t\t\tof_node_put(n);'
p16503
as(I60
I61
tp16504
(lp16505
S'\t\t\tif (parse_cpu_levels(n, c)) {'
p16506
aS'\t\t\t\tof_node_put(n);'
p16507
as(I48
I48
tp16508
(lp16509
S'\t\t\t}'
p16510
as(I54
I54
tp16511
(lp16512
S'\t\t\tof_node_put(n);'
p16513
as(I45
I46
tp16514
(lp16515
S'\t\t\tif (!child) {'
p16516
aS'\t\t\t\tof_node_put(n);'
p16517
as(I66
I66
tp16518
(lp16519
S'\t\t\tof_node_put(n);'
p16520
as(I35
I36
tp16521
(lp16522
S'\t\t\t}'
p16523
aS'\t\t\tof_node_put(n);'
p16524
as(I63
I63
tp16525
(lp16526
S'\t\t\t}'
p16527
assg32
I2
sg33
(dp16528
(I60
I60
tp16529
(lp16530
S'\t\t\tif (parse_cpu_levels(n, c))'
p16531
as(I32
I32
tp16532
(lp16533
S'\t\t\tif (parse_cluster_level(n, c))'
p16534
as(I45
I45
tp16535
(lp16536
S'\t\t\tif (!child)'
p16537
as(I94
I94
tp16538
(lp16539
S'\tc->parent = NULL;'
p16540
assg41
(I1
I96
tp16541
sssS'struct lpm_cluster *parse_cluster(struct device_node *node,\n\t\tstruct lpm_cluster *parent)\n{\n\tstruct lpm_cluster *c;\n\tstruct device_node *n;\n\tchar *key;\n\tint ret = 0;\n\tint i, j;\n\n\tc = devm_kzalloc(&lpm_pdev->dev, sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = parse_cluster_params(node, c);\n\tif (ret)\n\t\tgoto failed_parse_params;\n\n\tINIT_LIST_HEAD(&c->list);\n\tINIT_LIST_HEAD(&c->child);\n\tINIT_LIST_HEAD(&c->cpu);\n\tc->parent = parent;\n\tspin_lock_init(&c->sync_lock);\n\tc->min_child_level = NR_LPM_LEVELS;\n\n\tfor_each_child_of_node(node, n) {\n\n\t\tif (!n->name)\n\t\t\tcontinue;\n\n\t\tkey = "qcom,pm-cluster-level";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cluster_level(n, c))\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cluster";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tstruct lpm_cluster *child;\n\n\t\t\tchild = parse_cluster(n, c);\n\t\t\tif (!child)\n\t\t\t\tgoto failed_parse_cluster;\n\n\t\t\tlist_add(&child->list, &c->child);\n\t\t\tcpumask_or(&c->child_cpus, &c->child_cpus,\n\t\t\t\t\t&child->child_cpus);\n\t\t\tc->aff_level = child->aff_level + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cpu";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cpu_levels(n, c))\n\t\t\t\tgoto failed_parse_cluster;\n\n\t\t\tc->aff_level = 1;\n\t\t}\n\t}\n\n\tif (cpumask_intersects(&c->child_cpus, cpu_online_mask))\n\t\tc->last_level = c->default_level;\n\telse\n\t\tc->last_level = c->nlevels-1;\n\n\tfor (i = 0; i < c->nlevels; i++) {\n\t\tfor (j = 0; j < c->nlevels; j++) {\n\t\t\tif (i >= j) {\n\t\t\t\tc->levels[i].pwr.residencies[j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc->levels[i].pwr.residencies[j] = calculate_residency(\n\t\t\t\t&c->levels[i].pwr, &c->levels[j].pwr);\n\t\t}\n\t}\n\tset_optimum_cluster_residency(c, true);\n\treturn c;\n\nfailed_parse_cluster:\n\tpr_err("Failed parse cluster:%s\\n", key);\n\tif (parent)\n\t\tlist_del(&c->list);\n\tfree_cluster_node(c);\nfailed_parse_params:\n\tpr_err("Failed parse params\\n");\n\treturn NULL;\n}'
p16542
(dp16543
((g16419
g16491
tp16544
I1
tp16545
(dp16546
g12
g13
sg41
(I1
I87
tp16547
sg32
I2
sg33
(dp16548
(I85
I85
tp16549
(lp16550
S'\tc->parent = NULL;'
p16551
assssssS'CVE-2019-19537'
p16552
(dp16553
(S'drivers/usb/core/file.c'
p16554
S'usb_deregister_dev'
p16555
tp16556
(dp16557
S'void usb_deregister_dev(struct usb_interface *intf,\n\t\t\tstruct usb_class_driver *class_driver)\n{\n\tif (intf->minor == -1)\n\t\treturn;\n\n\tdev_dbg(&intf->dev, "removing %d minor\\n", intf->minor);\n\tdevice_destroy(usb_class->class, MKDEV(USB_MAJOR, intf->minor));\n\n\tdown_write(&minor_rwsem);\n\tusb_minors[intf->minor] = NULL;\n\tup_write(&minor_rwsem);\n\n\tintf->usb_dev = NULL;\n\tintf->minor = -1;\n\tdestroy_usb_class();\n}'
p16558
(dp16559
((g16554
g16555
tp16560
I1
tp16561
(dp16562
g33
(dp16563
(I14
I14
tp16564
(lp16565
S'\tdevice_destroy(usb_class->class, MKDEV(USB_MAJOR, intf->minor));'
p16566
assg14
(dp16567
(I8
I8
tp16568
(lp16569
S'\tdevice_destroy(usb_class->class, MKDEV(USB_MAJOR, intf->minor));'
p16570
assg32
I2
sg12
g13
sg41
(I1
I17
tp16571
ssss(g16554
S'usb_register_dev'
p16572
tp16573
(dp16574
S'int usb_register_dev(struct usb_interface *intf,\n\t\t     struct usb_class_driver *class_driver)\n{\n\tint retval;\n\tint minor_base = class_driver->minor_base;\n\tint minor;\n\tchar name[20];\n\n#ifdef CONFIG_USB_DYNAMIC_MINORS\n\t/*\n\t * We don\'t care what the device tries to start at, we want to start\n\t * at zero to pack the devices into the smallest available space with\n\t * no holes in the minor range.\n\t */\n\tminor_base = 0;\n#endif\n\n\tif (class_driver->fops == NULL)\n\t\treturn -EINVAL;\n\tif (intf->minor >= 0)\n\t\treturn -EADDRINUSE;\n\n\tmutex_lock(&init_usb_class_mutex);\n\tretval = init_usb_class();\n\tmutex_unlock(&init_usb_class_mutex);\n\n\tif (retval)\n\t\treturn retval;\n\n\tdev_dbg(&intf->dev, "looking for a minor, starting at %d\\n", minor_base);\n\n\tdown_write(&minor_rwsem);\n\tfor (minor = minor_base; minor < MAX_USB_MINORS; ++minor) {\n\t\tif (usb_minors[minor])\n\t\t\tcontinue;\n\n\t\tusb_minors[minor] = class_driver->fops;\n\t\tintf->minor = minor;\n\t\tbreak;\n\t}\n\tif (intf->minor < 0) {\n\t\tup_write(&minor_rwsem);\n\t\treturn -EXFULL;\n\t}\n\n\t/* create a usb class device for this usb interface */\n\tsnprintf(name, sizeof(name), class_driver->name, minor - minor_base);\n\tintf->usb_dev = device_create(usb_class->class, &intf->dev,\n\t\t\t\t      MKDEV(USB_MAJOR, minor), class_driver,\n\t\t\t\t      "%s", kbasename(name));\n\tif (IS_ERR(intf->usb_dev)) {\n\t\tusb_minors[minor] = NULL;\n\t\tintf->minor = -1;\n\t\tretval = PTR_ERR(intf->usb_dev);\n\t}\n\tup_write(&minor_rwsem);\n\treturn retval;\n}'
p16575
(dp16576
((g16554
g16572
tp16577
I1
tp16578
(dp16579
g12
g13
sg14
(dp16580
(I41
I42
tp16581
(lp16582
S'\tif (intf->minor < 0) {'
p16583
aS'\t\tup_write(&minor_rwsem);'
p16584
as(I56
I56
tp16585
(lp16586
S'\tup_write(&minor_rwsem);'
p16587
as(I44
I44
tp16588
(lp16589
S'\t}'
p16590
assg32
I2
sg33
(dp16591
(I41
I42
tp16592
(lp16593
S'\tup_write(&minor_rwsem);'
p16594
aS'\tif (intf->minor < 0)'
p16595
as(I52
I52
tp16596
(lp16597
S'\t\tdown_write(&minor_rwsem);'
p16598
as(I54
I54
tp16599
(lp16600
S'\t\tup_write(&minor_rwsem);'
p16601
assg41
(I1
I58
tp16602
sssssS'CVE-2019-14046'
p16603
(dp16604
(S'drivers/media/platform/msm/camera_v2/isp/msm_isp40.c'
p16605
S'msm_vfe40_init_qos_parms'
p16606
tp16607
(dp16608
S'static int32_t msm_vfe40_init_qos_parms(struct vfe_device *vfe_dev,\n\t\t\t\tstruct msm_vfe_hw_init_parms *qos_parms,\n\t\t\t\tstruct msm_vfe_hw_init_parms *ds_parms)\n{\n\tvoid __iomem *vfebase = vfe_dev->vfe_base;\n\tstruct device_node *of_node;\n\tuint32_t *ds_settings = NULL, *ds_regs = NULL, ds_entries = 0;\n\tint32_t i = 0, rc = 0;\n\tuint32_t *qos_settings = NULL, *qos_regs = NULL, qos_entries = 0;\n\n\tof_node = vfe_dev->pdev->dev.of_node;\n\n\trc = of_property_read_u32(of_node, qos_parms->entries,\n\t\t&qos_entries);\n\tif (rc < 0 || !qos_entries) {\n\t\tpr_err("%s: NO QOS entries found\\n", __func__);\n\t} else {\n\t\tqos_settings = kcalloc(qos_entries, sizeof(uint32_t),\n\t\t\tGFP_KERNEL);\n\t\tif (!qos_settings)\n\t\t\treturn -ENOMEM;\n\t\tqos_regs = kcalloc(qos_entries, sizeof(uint32_t),\n\t\t\tGFP_KERNEL);\n\t\tif (!qos_regs) {\n\t\t\tkfree(qos_settings);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trc = of_property_read_u32_array(of_node, qos_parms->regs,\n\t\t\tqos_regs, qos_entries);\n\t\tif (rc < 0) {\n\t\t\tpr_err("%s: NO QOS BUS BDG info\\n", __func__);\n\t\t\tkfree(qos_settings);\n\t\t\tkfree(qos_regs);\n\t\t} else {\n\t\t\tif (qos_parms->settings) {\n\t\t\t\trc = of_property_read_u32_array(of_node,\n\t\t\t\t\tqos_parms->settings,\n\t\t\t\t\tqos_settings, qos_entries);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tpr_err("%s: NO QOS settings\\n",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tkfree(qos_settings);\n\t\t\t\t\tkfree(qos_regs);\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < qos_entries; i++)\n\t\t\t\t\t\tmsm_camera_io_w(qos_settings[i],\n\t\t\t\t\t\t\tvfebase + qos_regs[i]);\n\t\t\t\t\tkfree(qos_settings);\n\t\t\t\t\tkfree(qos_regs);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkfree(qos_settings);\n\t\t\t\tkfree(qos_regs);\n\t\t\t}\n\t\t}\n\t}\n\trc = of_property_read_u32(of_node, ds_parms->entries,\n\t\t&ds_entries);\n\tif (rc < 0 || !ds_entries) {\n\t\tpr_err("%s: NO D/S entries found\\n", __func__);\n\t} else {\n\t\tds_settings = kcalloc(ds_entries, sizeof(uint32_t),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ds_settings)\n\t\t\treturn -ENOMEM;\n\t\tds_regs = kcalloc(ds_entries, sizeof(uint32_t),\n\t\t\t\tGFP_KERNEL);\n\t\tif (!ds_regs) {\n\t\t\tkfree(ds_settings);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\trc = of_property_read_u32_array(of_node, ds_parms->regs,\n\t\t\tds_regs, ds_entries);\n\t\tif (rc < 0) {\n\t\t\tpr_err("%s: NO D/S register info\\n", __func__);\n\t\t\tkfree(ds_settings);\n\t\t\tkfree(ds_regs);\n\t\t} else {\n\t\t\tif (ds_parms->settings) {\n\t\t\t\trc = of_property_read_u32_array(of_node,\n\t\t\t\t\tds_parms->settings, ds_settings,\n\t\t\t\t\tds_entries);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tpr_err("%s: NO D/S settings\\n",\n\t\t\t\t\t\t__func__);\n\t\t\t\t\tkfree(ds_settings);\n\t\t\t\t\tkfree(ds_regs);\n\t} else {\n\t\t\t\t\tfor (i = 0; i < ds_entries; i++)\n\t\t\t\t\t\tmsm_camera_io_w(ds_settings[i],\n\t\t\t\t\t\t\tvfebase + ds_regs[i]);\n\t\t\t\t\t\tkfree(ds_regs);\n\t\t\t\t\t\tkfree(ds_settings);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkfree(ds_regs);\n\t\t\t\tkfree(ds_settings);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}'
p16609
(dp16610
((g16605
g16606
tp16611
I1
tp16612
(dp16613
g12
g13
sg14
(dp16614
(I62
I62
tp16615
(lp16616
S'\t\tds_settings = kcalloc(ds_entries, sizeof(uint32_t),'
p16617
assg32
I3
sg33
(dp16618
(I62
I62
tp16619
(lp16620
S'\t\tds_settings = kcalloc(qos_entries, sizeof(uint32_t),'
p16621
assg41
(I1
I102
tp16622
sssssS'CVE-2019-14283'
p16623
(dp16624
(S'drivers/block/floppy.c'
p16625
S'set_geometry'
p16626
tp16627
(dp16628
S'static int set_geometry(unsigned int cmd, struct floppy_struct *g,\n\t\t\t       int drive, int type, struct block_device *bdev)\n{\n\tint cnt;\n\n\t/* sanity checking for parameters. */\n\tif ((int)g->sect <= 0 ||\n\t    (int)g->head <= 0 ||\n\t    /* check for overflow in max_sector */\n\t    (int)(g->sect * g->head) <= 0 ||\n\t    /* check for zero in F_SECT_PER_TRACK */\n\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||\n\t    g->track <= 0 || g->track > UDP->tracks >> STRETCH(g) ||\n\t    /* check if reserved bits are set */\n\t    (g->stretch & ~(FD_STRETCH | FD_SWAPSIDES | FD_SECTBASEMASK)) != 0)\n\t\treturn -EINVAL;\n\tif (type) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\tmutex_lock(&open_lock);\n\t\tif (lock_fdc(drive)) {\n\t\t\tmutex_unlock(&open_lock);\n\t\t\treturn -EINTR;\n\t\t}\n\t\tfloppy_type[type] = *g;\n\t\tfloppy_type[type].name = "user format";\n\t\tfor (cnt = type << 2; cnt < (type << 2) + 4; cnt++)\n\t\t\tfloppy_sizes[cnt] = floppy_sizes[cnt + 0x80] =\n\t\t\t    floppy_type[type].size + 1;\n\t\tprocess_fd_request();\n\t\tfor (cnt = 0; cnt < N_DRIVE; cnt++) {\n\t\t\tstruct block_device *bdev = opened_bdev[cnt];\n\t\t\tif (!bdev || ITYPE(drive_state[cnt].fd_device) != type)\n\t\t\t\tcontinue;\n\t\t\t__invalidate_device(bdev, true);\n\t\t}\n\t\tmutex_unlock(&open_lock);\n\t} else {\n\t\tint oldStretch;\n\n\t\tif (lock_fdc(drive))\n\t\t\treturn -EINTR;\n\t\tif (cmd != FDDEFPRM) {\n\t\t\t/* notice a disk change immediately, else\n\t\t\t * we lose our settings immediately*/\n\t\t\tif (poll_drive(true, FD_RAW_NEED_DISK) == -EINTR)\n\t\t\t\treturn -EINTR;\n\t\t}\n\t\toldStretch = g->stretch;\n\t\tuser_params[drive] = *g;\n\t\tif (buffer_drive == drive)\n\t\t\tSUPBOUND(buffer_max, user_params[drive].sect);\n\t\tcurrent_type[drive] = &user_params[drive];\n\t\tfloppy_sizes[drive] = user_params[drive].size;\n\t\tif (cmd == FDDEFPRM)\n\t\t\tDRS->keep_data = -1;\n\t\telse\n\t\t\tDRS->keep_data = 1;\n\t\t/* invalidation. Invalidate only when needed, i.e.\n\t\t * when there are already sectors in the buffer cache\n\t\t * whose number will change. This is useful, because\n\t\t * mtools often changes the geometry of the disk after\n\t\t * looking at the boot block */\n\t\tif (DRS->maxblock > user_params[drive].sect ||\n\t\t    DRS->maxtrack ||\n\t\t    ((user_params[drive].sect ^ oldStretch) &\n\t\t     (FD_SWAPSIDES | FD_SECTBASEMASK)))\n\t\t\tinvalidate_drive(bdev);\n\t\telse\n\t\t\tprocess_fd_request();\n\t}\n\treturn 0;\n}'
p16629
(dp16630
((g16625
g16626
tp16631
I1
tp16632
(dp16633
g12
g13
sg14
(dp16634
(I7
I12
tp16635
(lp16636
S'\tif ((int)g->sect <= 0 ||'
p16637
aS'\t    (int)g->head <= 0 ||'
p16638
aS'\t    /* check for overflow in max_sector */'
p16639
aS'\t    (int)(g->sect * g->head) <= 0 ||'
p16640
aS'\t    /* check for zero in F_SECT_PER_TRACK */'
p16641
aS'\t    (unsigned char)((g->sect << 2) >> FD_SIZECODE(g)) == 0 ||'
p16642
assg32
I5
sg33
(dp16643
(I7
I8
tp16644
(lp16645
S'\tif (g->sect <= 0 ||'
p16646
aS'\t    g->head <= 0 ||'
p16647
assg41
(I1
I73
tp16648
sssssS'CVE-2019-14044'
p16649
(dp16650
(S'drivers/media/platform/msm/camera/cam_icp/icp_hw/icp_hw_mgr/cam_icp_hw_mgr.c'
p16651
S'cam_icp_deinit_idle_clk'
p16652
tp16653
(dp16654
S'static int32_t cam_icp_deinit_idle_clk(void *priv, void *data)\n{\n\tstruct cam_icp_hw_mgr *hw_mgr = (struct cam_icp_hw_mgr *)priv;\n\tstruct clk_work_data *task_data = (struct clk_work_data *)data;\n\tstruct cam_icp_clk_info *clk_info =\n\t\t(struct cam_icp_clk_info *)task_data->data;\n\tuint32_t id;\n\tuint32_t i;\n\tstruct cam_icp_hw_ctx_data *ctx_data;\n\tstruct cam_hw_intf *ipe0_dev_intf = NULL;\n\tstruct cam_hw_intf *ipe1_dev_intf = NULL;\n\tstruct cam_hw_intf *bps_dev_intf = NULL;\n\tstruct cam_hw_intf *dev_intf = NULL;\n\tstruct cam_a5_clk_update_cmd clk_upd_cmd;\n\n\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;\n\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;\n\tbps_dev_intf = hw_mgr->bps_dev_intf;\n\n\tclk_info->base_clk = 0;\n\tclk_info->curr_clk = 0;\n\tclk_info->over_clked = 0;\n\n\tfor (i = 0; i < CAM_ICP_CTX_MAX; i++) {\n\t\tctx_data = &hw_mgr->ctx_data[i];\n\t\tmutex_lock(&ctx_data->ctx_mutex);\n\t\tif ((ctx_data->state != CAM_ICP_CTX_STATE_FREE) &&\n\t\t\t(ICP_DEV_TYPE_TO_CLK_TYPE(ctx_data->\n\t\t\ticp_dev_acquire_info->dev_type) == clk_info->hw_type))\n\t\t\tcam_icp_ctx_clk_info_init(ctx_data);\n\t\tmutex_unlock(&ctx_data->ctx_mutex);\n\t}\n\n\tif ((!ipe0_dev_intf) || (!bps_dev_intf)) {\n\t\tCAM_ERR(CAM_ICP, "dev intfs are wrong, failed to update clk");\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_info->hw_type == ICP_CLK_HW_BPS) {\n\t\tdev_intf = bps_dev_intf;\n\t\tid = CAM_ICP_BPS_CMD_DISABLE_CLK;\n\t} else if (clk_info->hw_type == ICP_CLK_HW_IPE) {\n\t\tdev_intf = ipe0_dev_intf;\n\t\tid = CAM_ICP_IPE_CMD_DISABLE_CLK;\n\t} else {\n\t\tCAM_ERR(CAM_ICP, "Error");\n\t\treturn 0;\n\t}\n\n\tCAM_DBG(CAM_ICP, "Disable %d", clk_info->hw_type);\n\n\tclk_upd_cmd.ipe_bps_pc_enable = icp_hw_mgr.ipe_bps_pc_flag;\n\n\tdev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,\n\t\t&clk_upd_cmd, sizeof(struct cam_a5_clk_update_cmd));\n\n\tif (clk_info->hw_type != ICP_CLK_HW_BPS)\n\t\tif (ipe1_dev_intf)\n\t\t\tipe1_dev_intf->hw_ops.process_cmd(\n\t\t\t\tipe1_dev_intf->hw_priv, id,\n\t\t\t\t&clk_upd_cmd,\n\t\t\t\tsizeof(struct cam_a5_clk_update_cmd));\n\n\treturn 0;\n}'
p16655
(dp16656
((g16651
g16652
tp16657
I1
tp16658
(dp16659
g12
g13
sg14
(dp16660
(I16
I18
tp16661
(lp16662
S'\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;'
p16663
aS'\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;'
p16664
aS'\tbps_dev_intf = hw_mgr->bps_dev_intf;'
p16665
assg32
I2
sg33
(dp16666
(I16
I18
tp16667
(lp16668
S'\tipe0_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][0];'
p16669
aS'\tipe1_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][1];'
p16670
aS'\tbps_dev_intf = hw_mgr->devices[CAM_ICP_DEV_BPS][0];'
p16671
assg41
(I1
I65
tp16672
sssS'static int32_t cam_icp_deinit_idle_clk(void *priv, void *data)\n{\n\tstruct cam_icp_hw_mgr *hw_mgr = (struct cam_icp_hw_mgr *)priv;\n\tstruct clk_work_data *task_data = (struct clk_work_data *)data;\n\tstruct cam_icp_clk_info *clk_info =\n\t\t(struct cam_icp_clk_info *)task_data->data;\n\tuint32_t id;\n\tuint32_t i;\n\tstruct cam_icp_hw_ctx_data *ctx_data;\n\tstruct cam_hw_intf *ipe0_dev_intf = NULL;\n\tstruct cam_hw_intf *ipe1_dev_intf = NULL;\n\tstruct cam_hw_intf *bps_dev_intf = NULL;\n\tstruct cam_hw_intf *dev_intf = NULL;\n\tstruct cam_a5_clk_update_cmd clk_upd_cmd;\n\tint rc = 0;\n\tbool busy = false;\n\n\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;\n\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;\n\tbps_dev_intf = hw_mgr->bps_dev_intf;\n\n\tclk_info->base_clk = 0;\n\tclk_info->curr_clk = 0;\n\tclk_info->over_clked = 0;\n\n\tmutex_lock(&hw_mgr->hw_mgr_mutex);\n\n\tfor (i = 0; i < CAM_ICP_CTX_MAX; i++) {\n\t\tctx_data = &hw_mgr->ctx_data[i];\n\t\tmutex_lock(&ctx_data->ctx_mutex);\n\t\tif ((ctx_data->state == CAM_ICP_CTX_STATE_ACQUIRED) &&\n\t\t\t(ICP_DEV_TYPE_TO_CLK_TYPE(\n\t\t\tctx_data->icp_dev_acquire_info->dev_type)\n\t\t\t== clk_info->hw_type)) {\n\t\t\tbusy = cam_icp_frame_pending(ctx_data);\n\t\t\tif (busy) {\n\t\t\t\tmutex_unlock(&ctx_data->ctx_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcam_icp_ctx_clk_info_init(ctx_data);\n\t\t}\n\t\tmutex_unlock(&ctx_data->ctx_mutex);\n\t}\n\n\tif (busy) {\n\t\tcam_icp_device_timer_reset(hw_mgr, clk_info->hw_type);\n\t\trc = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tif ((!ipe0_dev_intf) || (!bps_dev_intf)) {\n\t\tCAM_ERR(CAM_ICP, "dev intfs are wrong, failed to update clk");\n\t\trc = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (clk_info->hw_type == ICP_CLK_HW_BPS) {\n\t\tdev_intf = bps_dev_intf;\n\t\tid = CAM_ICP_BPS_CMD_DISABLE_CLK;\n\t} else if (clk_info->hw_type == ICP_CLK_HW_IPE) {\n\t\tdev_intf = ipe0_dev_intf;\n\t\tid = CAM_ICP_IPE_CMD_DISABLE_CLK;\n\t} else {\n\t\tCAM_ERR(CAM_ICP, "Error");\n\t\tgoto done;\n\t}\n\n\tCAM_DBG(CAM_ICP, "Disable %d", clk_info->hw_type);\n\n\tclk_upd_cmd.ipe_bps_pc_enable = icp_hw_mgr.ipe_bps_pc_flag;\n\n\tdev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,\n\t\t&clk_upd_cmd, sizeof(struct cam_a5_clk_update_cmd));\n\n\tif (clk_info->hw_type != ICP_CLK_HW_BPS)\n\t\tif (ipe1_dev_intf)\n\t\t\tipe1_dev_intf->hw_ops.process_cmd(\n\t\t\t\tipe1_dev_intf->hw_priv, id,\n\t\t\t\t&clk_upd_cmd,\n\t\t\t\tsizeof(struct cam_a5_clk_update_cmd));\n\ndone:\n\tmutex_unlock(&hw_mgr->hw_mgr_mutex);\n\treturn rc;\n}'
p16673
(dp16674
((g16651
g16652
tp16675
I1
tp16676
(dp16677
g33
(dp16678
(I82
I82
tp16679
(lp16680
S'\treturn 0;'
p16681
as(I65
I65
tp16682
(lp16683
S'\t\treturn 0;'
p16684
as(I53
I53
tp16685
(lp16686
S'\t\treturn -EINVAL;'
p16687
as(I18
I20
tp16688
(lp16689
S'\tipe0_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][0];'
p16690
aS'\tipe1_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][1];'
p16691
aS'\tbps_dev_intf = hw_mgr->devices[CAM_ICP_DEV_BPS][0];'
p16692
as(I31
I33
tp16693
(lp16694
S'\t\tif ((ctx_data->state != CAM_ICP_CTX_STATE_FREE) &&'
p16695
aS'\t\t\t(ICP_DEV_TYPE_TO_CLK_TYPE(ctx_data->'
p16696
aS'\t\t\ticp_dev_acquire_info->dev_type) == clk_info->hw_type))'
p16697
assg14
(dp16698
(I26
I27
tp16699
(lp16700
S'\tmutex_lock(&hw_mgr->hw_mgr_mutex);'
p16701
ag59
as(I31
I39
tp16702
(lp16703
S'\t\tif ((ctx_data->state == CAM_ICP_CTX_STATE_ACQUIRED) &&'
p16704
aS'\t\t\t(ICP_DEV_TYPE_TO_CLK_TYPE('
p16705
aS'\t\t\tctx_data->icp_dev_acquire_info->dev_type)'
p16706
aS'\t\t\t== clk_info->hw_type)) {'
p16707
aS'\t\t\tbusy = cam_icp_frame_pending(ctx_data);'
p16708
aS'\t\t\tif (busy) {'
p16709
aS'\t\t\t\tmutex_unlock(&ctx_data->ctx_mutex);'
p16710
aS'\t\t\t\tbreak;'
p16711
aS'\t\t\t}'
p16712
as(I53
I54
tp16713
(lp16714
S'\t\trc = -EINVAL;'
p16715
aS'\t\tgoto done;'
p16716
as(I45
I50
tp16717
(lp16718
S'\tif (busy) {'
p16719
aS'\t\tcam_icp_device_timer_reset(hw_mgr, clk_info->hw_type);'
p16720
aS'\t\trc = -EBUSY;'
p16721
aS'\t\tgoto done;'
p16722
aS'\t}'
p16723
ag59
as(I65
I65
tp16724
(lp16725
S'\t\tgoto done;'
p16726
as(I15
I16
tp16727
(lp16728
S'\tint rc = 0;'
p16729
aS'\tbool busy = false;'
p16730
as(I41
I41
tp16731
(lp16732
S'\t\t}'
p16733
as(I82
I84
tp16734
(lp16735
S'done:'
p16736
aS'\tmutex_unlock(&hw_mgr->hw_mgr_mutex);'
p16737
aS'\treturn rc;'
p16738
as(I18
I20
tp16739
(lp16740
S'\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;'
p16741
aS'\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;'
p16742
aS'\tbps_dev_intf = hw_mgr->bps_dev_intf;'
p16743
assg32
I2
sg12
g13
sg41
(I1
I85
tp16744
sssS'static int32_t cam_icp_deinit_idle_clk(void *priv, void *data)\n{\n\tstruct cam_icp_hw_mgr *hw_mgr = (struct cam_icp_hw_mgr *)priv;\n\tstruct clk_work_data *task_data = (struct clk_work_data *)data;\n\tstruct cam_icp_clk_info *clk_info =\n\t\t(struct cam_icp_clk_info *)task_data->data;\n\tuint32_t id;\n\tuint32_t i;\n\tstruct cam_icp_hw_ctx_data *ctx_data;\n\tstruct cam_hw_intf *ipe0_dev_intf = NULL;\n\tstruct cam_hw_intf *ipe1_dev_intf = NULL;\n\tstruct cam_hw_intf *bps_dev_intf = NULL;\n\tstruct cam_hw_intf *dev_intf = NULL;\n\tstruct cam_a5_clk_update_cmd clk_upd_cmd;\n\tint rc = 0;\n\tbool busy = false;\n\n\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;\n\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;\n\tbps_dev_intf = hw_mgr->bps_dev_intf;\n\n\tclk_info->base_clk = 0;\n\tclk_info->curr_clk = 0;\n\tclk_info->over_clked = 0;\n\n\tmutex_lock(&hw_mgr->hw_mgr_mutex);\n\n\tfor (i = 0; i < CAM_ICP_CTX_MAX; i++) {\n\t\tctx_data = &hw_mgr->ctx_data[i];\n\t\tmutex_lock(&ctx_data->ctx_mutex);\n\t\tif ((ctx_data->state == CAM_ICP_CTX_STATE_ACQUIRED) &&\n\t\t\t(ICP_DEV_TYPE_TO_CLK_TYPE(ctx_data->\n\t\t\ticp_dev_acquire_info->dev_type) == clk_info->hw_type)) {\n\t\t\tbusy = cam_icp_frame_pending(ctx_data);\n\t\t\tif (busy) {\n\t\t\t\tmutex_unlock(&ctx_data->ctx_mutex);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcam_icp_ctx_clk_info_init(ctx_data);\n\t\t}\n\t\tmutex_unlock(&ctx_data->ctx_mutex);\n\t}\n\n\tif (busy) {\n\t\tcam_icp_device_timer_reset(hw_mgr, clk_info->hw_type);\n\t\trc = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tif ((!ipe0_dev_intf) || (!bps_dev_intf)) {\n\t\tCAM_ERR(CAM_ICP, "dev intfs are wrong, failed to update clk");\n\t\trc = -EINVAL;\n\t\tgoto done;\n\t}\n\n\tif (clk_info->hw_type == ICP_CLK_HW_BPS) {\n\t\tdev_intf = bps_dev_intf;\n\t\tid = CAM_ICP_BPS_CMD_DISABLE_CLK;\n\t} else if (clk_info->hw_type == ICP_CLK_HW_IPE) {\n\t\tdev_intf = ipe0_dev_intf;\n\t\tid = CAM_ICP_IPE_CMD_DISABLE_CLK;\n\t} else {\n\t\tCAM_ERR(CAM_ICP, "Error");\n\t\tgoto done;\n\t}\n\n\tCAM_DBG(CAM_ICP, "Disable %d", clk_info->hw_type);\n\n\tclk_upd_cmd.ipe_bps_pc_enable = icp_hw_mgr.ipe_bps_pc_flag;\n\n\tdev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,\n\t\t&clk_upd_cmd, sizeof(struct cam_a5_clk_update_cmd));\n\n\tif (clk_info->hw_type != ICP_CLK_HW_BPS)\n\t\tif (ipe1_dev_intf)\n\t\t\tipe1_dev_intf->hw_ops.process_cmd(\n\t\t\t\tipe1_dev_intf->hw_priv, id,\n\t\t\t\t&clk_upd_cmd,\n\t\t\t\tsizeof(struct cam_a5_clk_update_cmd));\n\ndone:\n\tmutex_unlock(&hw_mgr->hw_mgr_mutex);\n\treturn rc;\n}'
p16745
(dp16746
((g16651
g16652
tp16747
I1
tp16748
(dp16749
g33
(dp16750
(I81
I81
tp16751
(lp16752
S'\treturn 0;'
p16753
as(I64
I64
tp16754
(lp16755
S'\t\treturn 0;'
p16756
as(I31
I31
tp16757
(lp16758
S'\t\tif ((ctx_data->state != CAM_ICP_CTX_STATE_FREE) &&'
p16759
as(I52
I52
tp16760
(lp16761
S'\t\treturn -EINVAL;'
p16762
as(I33
I33
tp16763
(lp16764
S'\t\t\ticp_dev_acquire_info->dev_type) == clk_info->hw_type))'
p16765
as(I18
I20
tp16766
(lp16767
S'\tipe0_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][0];'
p16768
aS'\tipe1_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][1];'
p16769
aS'\tbps_dev_intf = hw_mgr->devices[CAM_ICP_DEV_BPS][0];'
p16770
assg14
(dp16771
(I40
I40
tp16772
(lp16773
S'\t\t}'
p16774
as(I26
I27
tp16775
(lp16776
S'\tmutex_lock(&hw_mgr->hw_mgr_mutex);'
p16777
ag59
as(I81
I83
tp16778
(lp16779
S'done:'
p16780
aS'\tmutex_unlock(&hw_mgr->hw_mgr_mutex);'
p16781
aS'\treturn rc;'
p16782
as(I52
I53
tp16783
(lp16784
S'\t\trc = -EINVAL;'
p16785
aS'\t\tgoto done;'
p16786
as(I33
I38
tp16787
(lp16788
S'\t\t\ticp_dev_acquire_info->dev_type) == clk_info->hw_type)) {'
p16789
aS'\t\t\tbusy = cam_icp_frame_pending(ctx_data);'
p16790
aS'\t\t\tif (busy) {'
p16791
aS'\t\t\t\tmutex_unlock(&ctx_data->ctx_mutex);'
p16792
aS'\t\t\t\tbreak;'
p16793
aS'\t\t\t}'
p16794
as(I64
I64
tp16795
(lp16796
S'\t\tgoto done;'
p16797
as(I44
I49
tp16798
(lp16799
S'\tif (busy) {'
p16800
aS'\t\tcam_icp_device_timer_reset(hw_mgr, clk_info->hw_type);'
p16801
aS'\t\trc = -EBUSY;'
p16802
aS'\t\tgoto done;'
p16803
aS'\t}'
p16804
ag59
as(I15
I16
tp16805
(lp16806
S'\tint rc = 0;'
p16807
aS'\tbool busy = false;'
p16808
as(I18
I20
tp16809
(lp16810
S'\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;'
p16811
aS'\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;'
p16812
aS'\tbps_dev_intf = hw_mgr->bps_dev_intf;'
p16813
as(I31
I31
tp16814
(lp16815
S'\t\tif ((ctx_data->state == CAM_ICP_CTX_STATE_ACQUIRED) &&'
p16816
assg32
I2
sg12
g13
sg41
(I1
I84
tp16817
sssS'static int32_t cam_icp_deinit_idle_clk(void *priv, void *data)\n{\n\tstruct cam_icp_hw_mgr *hw_mgr = (struct cam_icp_hw_mgr *)priv;\n\tstruct clk_work_data *task_data = (struct clk_work_data *)data;\n\tstruct cam_icp_clk_info *clk_info =\n\t\t(struct cam_icp_clk_info *)task_data->data;\n\tuint32_t id;\n\tuint32_t i;\n\tstruct cam_icp_hw_ctx_data *ctx_data;\n\tstruct cam_hw_intf *ipe0_dev_intf = NULL;\n\tstruct cam_hw_intf *ipe1_dev_intf = NULL;\n\tstruct cam_hw_intf *bps_dev_intf = NULL;\n\tstruct cam_hw_intf *dev_intf = NULL;\n\tstruct cam_a5_clk_update_cmd clk_upd_cmd;\n\n\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;\n\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;\n\tbps_dev_intf = hw_mgr->bps_dev_intf;\n\n\tclk_info->base_clk = 0;\n\tclk_info->curr_clk = 0;\n\tclk_info->over_clked = 0;\n\n\tfor (i = 0; i < CAM_ICP_CTX_MAX; i++) {\n\t\tctx_data = &hw_mgr->ctx_data[i];\n\t\tmutex_lock(&ctx_data->ctx_mutex);\n\t\tif ((ctx_data->state == CAM_ICP_CTX_STATE_ACQUIRED) &&\n\t\t\t(ICP_DEV_TYPE_TO_CLK_TYPE(ctx_data->\n\t\t\ticp_dev_acquire_info->dev_type) == clk_info->hw_type))\n\t\t\tcam_icp_ctx_clk_info_init(ctx_data);\n\t\tmutex_unlock(&ctx_data->ctx_mutex);\n\t}\n\n\tif ((!ipe0_dev_intf) || (!bps_dev_intf)) {\n\t\tCAM_ERR(CAM_ICP, "dev intfs are wrong, failed to update clk");\n\t\treturn -EINVAL;\n\t}\n\n\tif (clk_info->hw_type == ICP_CLK_HW_BPS) {\n\t\tdev_intf = bps_dev_intf;\n\t\tid = CAM_ICP_BPS_CMD_DISABLE_CLK;\n\t} else if (clk_info->hw_type == ICP_CLK_HW_IPE) {\n\t\tdev_intf = ipe0_dev_intf;\n\t\tid = CAM_ICP_IPE_CMD_DISABLE_CLK;\n\t} else {\n\t\tCAM_ERR(CAM_ICP, "Error");\n\t\treturn 0;\n\t}\n\n\tCAM_DBG(CAM_ICP, "Disable %d", clk_info->hw_type);\n\n\tclk_upd_cmd.ipe_bps_pc_enable = icp_hw_mgr.ipe_bps_pc_flag;\n\n\tdev_intf->hw_ops.process_cmd(dev_intf->hw_priv, id,\n\t\t&clk_upd_cmd, sizeof(struct cam_a5_clk_update_cmd));\n\n\tif (clk_info->hw_type != ICP_CLK_HW_BPS)\n\t\tif (ipe1_dev_intf)\n\t\t\tipe1_dev_intf->hw_ops.process_cmd(\n\t\t\t\tipe1_dev_intf->hw_priv, id,\n\t\t\t\t&clk_upd_cmd,\n\t\t\t\tsizeof(struct cam_a5_clk_update_cmd));\n\n\treturn 0;\n}'
p16818
(dp16819
((g16651
g16652
tp16820
I1
tp16821
(dp16822
g12
g13
sg14
(dp16823
(I16
I18
tp16824
(lp16825
S'\tipe0_dev_intf = hw_mgr->ipe0_dev_intf;'
p16826
aS'\tipe1_dev_intf = hw_mgr->ipe1_dev_intf;'
p16827
aS'\tbps_dev_intf = hw_mgr->bps_dev_intf;'
p16828
as(I27
I27
tp16829
(lp16830
S'\t\tif ((ctx_data->state == CAM_ICP_CTX_STATE_ACQUIRED) &&'
p16831
assg32
I2
sg33
(dp16832
(I16
I18
tp16833
(lp16834
S'\tipe0_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][0];'
p16835
aS'\tipe1_dev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][1];'
p16836
aS'\tbps_dev_intf = hw_mgr->devices[CAM_ICP_DEV_BPS][0];'
p16837
as(I27
I27
tp16838
(lp16839
S'\t\tif ((ctx_data->state != CAM_ICP_CTX_STATE_FREE) &&'
p16840
assg41
(I1
I65
tp16841
ssss(g16651
S'cam_icp_supported_clk_rates'
p16842
tp16843
(dp16844
S'static int cam_icp_supported_clk_rates(struct cam_icp_hw_mgr *hw_mgr,\n\tstruct cam_icp_hw_ctx_data *ctx_data)\n{\n\tint i;\n\tstruct cam_hw_soc_info *soc_info;\n\tstruct cam_hw_intf *dev_intf = NULL;\n\tstruct cam_hw_info *dev = NULL;\n\n\tif (ctx_data->icp_dev_acquire_info->dev_type == CAM_ICP_RES_TYPE_BPS)\n\t\tdev_intf = hw_mgr->bps_dev_intf;\n\telse\n\t\tdev_intf = hw_mgr->ipe0_dev_intf;\n\n\tif (!dev_intf) {\n\t\tCAM_ERR(CAM_ICP, "dev_intf is invalid");\n\t\treturn -EINVAL;\n\t}\n\tdev = (struct cam_hw_info *)dev_intf->hw_priv;\n\tsoc_info = &dev->soc_info;\n\n\tfor (i = 0; i < CAM_MAX_VOTE; i++) {\n\t\tctx_data->clk_info.clk_rate[i] =\n\t\t\tsoc_info->clk_rate[i][soc_info->num_clk - 1];\n\t\tCAM_DBG(CAM_ICP, "clk_info = %d",\n\t\t\tctx_data->clk_info.clk_rate[i]);\n\t}\n\n\treturn 0;\n}'
p16845
(dp16846
((g16651
g16842
tp16847
I1
tp16848
(dp16849
g12
g13
sg14
(dp16850
(I12
I12
tp16851
(lp16852
S'\t\tdev_intf = hw_mgr->ipe0_dev_intf;'
p16853
as(I10
I10
tp16854
(lp16855
S'\t\tdev_intf = hw_mgr->bps_dev_intf;'
p16856
assg32
I2
sg33
(dp16857
(I12
I12
tp16858
(lp16859
S'\t\tdev_intf = hw_mgr->devices[CAM_ICP_DEV_IPE][0];'
p16860
as(I10
I10
tp16861
(lp16862
S'\t\tdev_intf = hw_mgr->devices[CAM_ICP_DEV_BPS][0];'
p16863
assg41
(I1
I29
tp16864
sssssS'CVE-2019-10638'
p16865
(dp16866
(S'include/net/netns/hash.h'
p16867
S'net_hash_mix'
p16868
tp16869
(dp16870
S'static inline u32 net_hash_mix(const struct net *net)\n{\n\treturn net->hash_mix;\n}'
p16871
(dp16872
((g16867
g16868
tp16873
I1
tp16874
(dp16875
g12
g13
sg14
(dp16876
(I3
I3
tp16877
(lp16878
S'\treturn net->hash_mix;'
p16879
assg32
I1
sg33
(dp16880
(I3
I12
tp16881
(lp16882
S'#ifdef CONFIG_NET_NS'
p16883
aS'\t/*'
p16884
aS'\t * shift this right to eliminate bits, that are'
p16885
aS'\t * always zeroed'
p16886
aS'\t */'
p16887
ag59
aS'\treturn (u32)(((unsigned long)net) >> L1_CACHE_SHIFT);'
p16888
aS'#else'
p16889
aS'\treturn 0;'
p16890
aS'#endif'
p16891
assg41
(I1
I4
tp16892
ssss(S'net/core/net_namespace.c'
p16893
S'setup_net'
p16894
tp16895
(dp16896
S'static __net_init int setup_net(struct net *net, struct user_namespace *user_ns)\n{\n\t/* Must be called with net_mutex held */\n\tconst struct pernet_operations *ops, *saved_ops;\n\tint error = 0;\n\tLIST_HEAD(net_exit_list);\n\n\tatomic_set(&net->count, 1);\n\tatomic_set(&net->passive, 1);\n\tget_random_bytes(&net->hash_mix, sizeof(u32));\n\tnet->dev_base_seq = 1;\n\tnet->user_ns = user_ns;\n\tidr_init(&net->netns_ids);\n\tspin_lock_init(&net->nsid_lock);\n\n\tlist_for_each_entry(ops, &pernet_list, list) {\n\t\terror = ops_init(ops, net);\n\t\tif (error < 0)\n\t\t\tgoto out_undo;\n\t}\nout:\n\treturn error;\n\nout_undo:\n\t/* Walk through the list backwards calling the exit functions\n\t * for the pernet modules whose init functions did not fail.\n\t */\n\tlist_add(&net->exit_list, &net_exit_list);\n\tsaved_ops = ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_exit_list(ops, &net_exit_list);\n\n\tops = saved_ops;\n\tlist_for_each_entry_continue_reverse(ops, &pernet_list, list)\n\t\tops_free_list(ops, &net_exit_list);\n\n\trcu_barrier();\n\tgoto out;\n}'
p16897
(dp16898
((g16893
g16894
tp16899
I1
tp16900
(dp16901
g14
(dp16902
(I10
I10
tp16903
(lp16904
S'\tget_random_bytes(&net->hash_mix, sizeof(u32));'
p16905
assg32
I2
sg12
g13
sg41
(I1
I39
tp16906
sssssS'CVE-2019-2213'
p16907
(dp16908
(S'drivers/android/binder.c'
p16909
S'binder_free_transaction'
p16910
tp16911
(dp16912
S'static void binder_free_transaction(struct binder_transaction *t)\n{\n\tstruct binder_proc *target_proc;\n\n\tspin_lock(&t->lock);\n\ttarget_proc = t->to_proc;\n\tif (target_proc) {\n\t\tatomic_inc(&target_proc->tmp_ref);\n\t\tspin_unlock(&t->lock);\n\n\t\tbinder_inner_proc_lock(target_proc);\n\t\tif (t->buffer)\n\t\t\tt->buffer->transaction = NULL;\n\t\tbinder_inner_proc_unlock(target_proc);\n\t\tbinder_proc_dec_tmpref(target_proc);\n\t} else {\n\t\t/*\n\t\t * If the transaction has no target_proc, then\n\t\t * t->buffer->transaction * has already been cleared.\n\t\t */\n\t\tspin_unlock(&t->lock);\n\t}\n\tkfree(t);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\n}'
p16913
(dp16914
((g16909
g16910
tp16915
I1
tp16916
(dp16917
g12
g13
sg14
(dp16918
(I3
I22
tp16919
(lp16920
S'\tstruct binder_proc *target_proc;'
p16921
ag59
aS'\tspin_lock(&t->lock);'
p16922
aS'\ttarget_proc = t->to_proc;'
p16923
aS'\tif (target_proc) {'
p16924
aS'\t\tatomic_inc(&target_proc->tmp_ref);'
p16925
aS'\t\tspin_unlock(&t->lock);'
p16926
ag59
aS'\t\tbinder_inner_proc_lock(target_proc);'
p16927
aS'\t\tif (t->buffer)'
p16928
aS'\t\t\tt->buffer->transaction = NULL;'
p16929
aS'\t\tbinder_inner_proc_unlock(target_proc);'
p16930
aS'\t\tbinder_proc_dec_tmpref(target_proc);'
p16931
aS'\t} else {'
p16932
aS'\t\t/*'
p16933
aS'\t\t * If the transaction has no target_proc, then'
p16934
aS'\t\t * t->buffer->transaction * has already been cleared.'
p16935
aS'\t\t */'
p16936
aS'\t\tspin_unlock(&t->lock);'
p16937
aS'\t}'
p16938
assg32
I1
sg33
(dp16939
(I3
I4
tp16940
(lp16941
S'\tif (t->buffer)'
p16942
aS'\t\tt->buffer->transaction = NULL;'
p16943
assg41
(I1
I25
tp16944
sssss.