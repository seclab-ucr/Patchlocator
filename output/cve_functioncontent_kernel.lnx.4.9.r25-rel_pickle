(dp0
S'CVE-2018-20511'
p1
(dp2
(S'drivers/net/appletalk/ipddp.c'
p3
S'ipddp_ioctl'
p4
tp5
(dp6
S'static int ipddp_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)\n{\n        struct ipddp_route __user *rt = ifr->ifr_data;\n        struct ipddp_route rcp, rcp2, *rp;\n\n        if(!capable(CAP_NET_ADMIN))\n                return -EPERM;\n\n\tif(copy_from_user(&rcp, rt, sizeof(rcp)))\n\t\treturn -EFAULT;\n\n        switch(cmd)\n        {\n\t\tcase SIOCADDIPDDPRT:\n                        return ipddp_create(&rcp);\n\n                case SIOCFINDIPDDPRT:\n\t\t\tspin_lock_bh(&ipddp_route_lock);\n\t\t\trp = __ipddp_find_route(&rcp);\n\t\t\tif (rp) {\n\t\t\t\tmemset(&rcp2, 0, sizeof(rcp2));\n\t\t\t\trcp2.ip    = rp->ip;\n\t\t\t\trcp2.at    = rp->at;\n\t\t\t\trcp2.flags = rp->flags;\n\t\t\t}\n\t\t\tspin_unlock_bh(&ipddp_route_lock);\n\n\t\t\tif (rp) {\n\t\t\t\tif (copy_to_user(rt, &rcp2,\n\t\t\t\t\t\t sizeof(struct ipddp_route)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -ENOENT;\n\n                case SIOCDELIPDDPRT:\n                        return ipddp_delete(&rcp);\n\n                default:\n                        return -EINVAL;\n        }\n}'
p7
S'f332617ebb03'
p8
sssS'CVE-2018-12011'
p9
(dp10
(S'net/ipc_router/ipc_router_socket.c'
p11
S'msm_ipc_router_extract_msg'
p12
tp13
(dp14
S'static int msm_ipc_router_extract_msg(struct msghdr *m,\n\t\t\t\t      struct rr_packet *pkt)\n{\n\tstruct sockaddr_msm_ipc *addr;\n\tstruct rr_header_v1 *hdr;\n\tstruct sk_buff *temp;\n\tunion rr_control_msg *ctl_msg;\n\tint offset = 0, data_len = 0, copy_len, copied_len;\n\n\tif (!m || !pkt) {\n\t\tIPC_RTR_ERR("%s: Invalid pointers passed\\n", __func__);\n\t\treturn -EINVAL;\n\t}\n\taddr = (struct sockaddr_msm_ipc *)m->msg_name;\n\n\thdr = &pkt->hdr;\n\tif (addr && (hdr->type == IPC_ROUTER_CTRL_CMD_RESUME_TX)) {\n\t\ttemp = skb_peek(pkt->pkt_fragment_q);\n\t\tif (!temp || !temp->data) {\n\t\t\tIPC_RTR_ERR("%s: Invalid skb\\n", __func__);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tctl_msg = (union rr_control_msg *)(temp->data);\n\t\tmemset(addr, 0x0, sizeof(*addr));\n\t\taddr->family = AF_MSM_IPC;\n\t\taddr->address.addrtype = MSM_IPC_ADDR_ID;\n\t\taddr->address.addr.port_addr.node_id = ctl_msg->cli.node_id;\n\t\taddr->address.addr.port_addr.port_id = ctl_msg->cli.port_id;\n\t\tm->msg_namelen = sizeof(struct sockaddr_msm_ipc);\n\t\treturn offset;\n\t}\n\tif (addr && (hdr->type == IPC_ROUTER_CTRL_CMD_DATA)) {\n\t\tmemset(addr, 0x0, sizeof(*addr));\n\t\taddr->family = AF_MSM_IPC;\n\t\taddr->address.addrtype = MSM_IPC_ADDR_ID;\n\t\taddr->address.addr.port_addr.node_id = hdr->src_node_id;\n\t\taddr->address.addr.port_addr.port_id = hdr->src_port_id;\n\t\tm->msg_namelen = sizeof(struct sockaddr_msm_ipc);\n\t}\n\n\tdata_len = hdr->size;\n\tskb_queue_walk(pkt->pkt_fragment_q, temp) {\n\t\tcopy_len = data_len < temp->len ? data_len : temp->len;\n\t\tcopied_len = copy_to_iter(temp->data, copy_len, &m->msg_iter);\n\t\tif (copy_len != copied_len) {\n\t\t\tIPC_RTR_ERR("%s: Copy to user failed\\n", __func__);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\toffset += copy_len;\n\t\tdata_len -= copy_len;\n\t}\n\treturn offset;\n}'
p15
S'9e72d10cef9b'
p16
sssS'CVE-2018-20961'
p17
(dp18
(S'drivers/usb/gadget/function/f_midi.c'
p19
S'f_midi_set_alt'
p20
tp21
(dp22
S'static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen,\n\t\t\t\t\t\tmidi->gadget->extra_buf_alloc);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen, 0);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, "%s: couldn\'t enqueue request: %d\\n",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tif (req->buf != NULL)\n\t\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}'
p23
S'e7da47f2cfe8'
p24
ss(S'drivers/usb/gadget/u_f.h'
p25
S'free_ep_req'
p26
tp27
(dp28
S'static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}'
p29
S'e7da47f2cfe8'
p30
sssS'CVE-2018-19985'
p31
(dp32
(S'drivers/net/usb/hso.c'
p33
S'hso_probe'
p34
tp35
(dp36
S'static int hso_probe(struct usb_interface *interface,\n\t\t     const struct usb_device_id *id)\n{\n\tint mux, i, if_num, port_spec;\n\tunsigned char port_mask;\n\tstruct hso_device *hso_dev = NULL;\n\tstruct hso_shared_int *shared_int;\n\tstruct hso_device *tmp_dev = NULL;\n\n\tif (interface->cur_altsetting->desc.bInterfaceClass != 0xFF) {\n\t\tdev_err(&interface->dev, "Not our interface\\n");\n\t\treturn -ENODEV;\n\t}\n\n\tif_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\n\t/* Get the interface/port specification from either driver_info or from\n\t * the device itself */\n\tif (id->driver_info) {\n\t\t/* if_num is controlled by the device, driver_info is a 0 terminated\n\t\t * array. Make sure, the access is in bounds! */\n\t\tfor (i = 0; i <= if_num; ++i)\n\t\t\tif (((u32 *)(id->driver_info))[i] == 0)\n\t\t\t\tgoto exit;\n\t\tport_spec = ((u32 *)(id->driver_info))[if_num];\n\t} else {\n\t\tport_spec = hso_get_config_data(interface);\n\t\tif (port_spec < 0)\n\t\t\tgoto exit;\n\t}\n\n\t/* Check if we need to switch to alt interfaces prior to port\n\t * configuration */\n\tif (interface->num_altsetting > 1)\n\t\tusb_set_interface(interface_to_usbdev(interface), if_num, 1);\n\tinterface->needs_remote_wakeup = 1;\n\n\t/* Allocate new hso device(s) */\n\tswitch (port_spec & HSO_INTF_MASK) {\n\tcase HSO_INTF_MUX:\n\t\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\t\t/* Create the network device */\n\t\t\tif (!disable_net) {\n\t\t\t\thso_dev = hso_create_net_device(interface,\n\t\t\t\t\t\t\t\tport_spec);\n\t\t\t\tif (!hso_dev)\n\t\t\t\t\tgoto exit;\n\t\t\t\ttmp_dev = hso_dev;\n\t\t\t}\n\t\t}\n\n\t\tif (hso_get_mux_ports(interface, &port_mask))\n\t\t\t/* TODO: de-allocate everything */\n\t\t\tgoto exit;\n\n\t\tshared_int = hso_create_shared_int(interface);\n\t\tif (!shared_int)\n\t\t\tgoto exit;\n\n\t\tfor (i = 1, mux = 0; i < 0x100; i = i << 1, mux++) {\n\t\t\tif (port_mask & i) {\n\t\t\t\thso_dev = hso_create_mux_serial_device(\n\t\t\t\t\t\tinterface, i, shared_int);\n\t\t\t\tif (!hso_dev)\n\t\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\n\t\tif (tmp_dev)\n\t\t\thso_dev = tmp_dev;\n\t\tbreak;\n\n\tcase HSO_INTF_BULK:\n\t\t/* It\'s a regular bulk interface */\n\t\tif ((port_spec & HSO_PORT_MASK) == HSO_PORT_NETWORK) {\n\t\t\tif (!disable_net)\n\t\t\t\thso_dev =\n\t\t\t\t    hso_create_net_device(interface, port_spec);\n\t\t} else {\n\t\t\thso_dev =\n\t\t\t    hso_create_bulk_serial_device(interface, port_spec);\n\t\t}\n\t\tif (!hso_dev)\n\t\t\tgoto exit;\n\t\tbreak;\n\tdefault:\n\t\tgoto exit;\n\t}\n\n\t/* save our data pointer in this device */\n\tusb_set_intfdata(interface, hso_dev);\n\n\t/* done */\n\treturn 0;\nexit:\n\thso_free_interface(interface);\n\treturn -ENODEV;\n}'
p37
S'de6abb23dc05'
p38
ss(g33
S'hso_get_config_data'
p39
tp40
(dp41
S'static int hso_get_config_data(struct usb_interface *interface)\n{\n\tstruct usb_device *usbdev = interface_to_usbdev(interface);\n\tu8 *config_data = kmalloc(17, GFP_KERNEL);\n\tu32 if_num = interface->cur_altsetting->desc.bInterfaceNumber;\n\ts32 result;\n\n\tif (!config_data)\n\t\treturn -ENOMEM;\n\tif (usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t    0x86, 0xC0, 0, 0, config_data, 17,\n\t\t\t    USB_CTRL_SET_TIMEOUT) != 0x11) {\n\t\tkfree(config_data);\n\t\treturn -EIO;\n\t}\n\n\t/* check if we have a valid interface */\n\tif (if_num > 16) {\n\t\tkfree(config_data);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (config_data[if_num]) {\n\tcase 0x0:\n\t\tresult = 0;\n\t\tbreak;\n\tcase 0x1:\n\t\tresult = HSO_PORT_DIAG;\n\t\tbreak;\n\tcase 0x2:\n\t\tresult = HSO_PORT_GPS;\n\t\tbreak;\n\tcase 0x3:\n\t\tresult = HSO_PORT_GPS_CONTROL;\n\t\tbreak;\n\tcase 0x4:\n\t\tresult = HSO_PORT_APP;\n\t\tbreak;\n\tcase 0x5:\n\t\tresult = HSO_PORT_APP2;\n\t\tbreak;\n\tcase 0x6:\n\t\tresult = HSO_PORT_CONTROL;\n\t\tbreak;\n\tcase 0x7:\n\t\tresult = HSO_PORT_NETWORK;\n\t\tbreak;\n\tcase 0x8:\n\t\tresult = HSO_PORT_MODEM;\n\t\tbreak;\n\tcase 0x9:\n\t\tresult = HSO_PORT_MSD;\n\t\tbreak;\n\tcase 0xa:\n\t\tresult = HSO_PORT_PCSC;\n\t\tbreak;\n\tcase 0xb:\n\t\tresult = HSO_PORT_VOICE;\n\t\tbreak;\n\tdefault:\n\t\tresult = 0;\n\t}\n\n\tif (result)\n\t\tresult |= HSO_INTF_BULK;\n\n\tif (config_data[16] & 0x1)\n\t\tresult |= HSO_INFO_CRC_BUG;\n\n\tkfree(config_data);\n\treturn result;\n}'
p42
g38
sssS'CVE-2018-5803'
p43
(dp44
(S'net/sctp/sm_make_chunk.c'
p45
S'_sctp_make_chunk'
p46
tp47
(dp48
S'static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,\n\t\t\t\t\t    __u8 type, __u8 flags, int paylen,\n\t\t\t\t\t    gfp_t gfp)\n{\n\tstruct sctp_chunk *retval;\n\tsctp_chunkhdr_t *chunk_hdr;\n\tstruct sk_buff *skb;\n\tstruct sock *sk;\n\tint chunklen;\n\n\tchunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);\n\tif (chunklen > SCTP_MAX_CHUNK_LEN)\n\t\tgoto nodata;\n\n\t/* No need to allocate LL here, as this is only a chunk. */\n\tskb = alloc_skb(chunklen, gfp);\n\tif (!skb)\n\t\tgoto nodata;\n\n\t/* Make room for the chunk header.  */\n\tchunk_hdr = (sctp_chunkhdr_t *)skb_put(skb, sizeof(sctp_chunkhdr_t));\n\tchunk_hdr->type\t  = type;\n\tchunk_hdr->flags  = flags;\n\tchunk_hdr->length = htons(sizeof(sctp_chunkhdr_t));\n\n\tsk = asoc ? asoc->base.sk : NULL;\n\tretval = sctp_chunkify(skb, asoc, sk, gfp);\n\tif (!retval) {\n\t\tkfree_skb(skb);\n\t\tgoto nodata;\n\t}\n\n\tretval->chunk_hdr = chunk_hdr;\n\tretval->chunk_end = ((__u8 *)chunk_hdr) + sizeof(struct sctp_chunkhdr);\n\n\t/* Determine if the chunk needs to be authenticated */\n\tif (sctp_auth_send_cid(type, asoc))\n\t\tretval->auth = 1;\n\n\treturn retval;\nnodata:\n\treturn NULL;\n}'
p49
S'78667dedc643'
p50
sssS'CVE-2018-13913'
p51
(dp52
(S'drivers/video/fbdev/msm/mdss_debug.c'
p53
S'mdss_debug_base_is_valid_range'
p54
tp55
(dp56
S'static bool mdss_debug_base_is_valid_range(u32 off, u32 cnt)\n{\n\tstruct mdss_data_type *mdata = mdss_mdp_get_mdata();\n\tstruct mdss_debug_data *mdd = mdata->debug_inf.debug_data;\n\tstruct range_dump_node *node;\n\tstruct mdss_debug_base *base;\n\n\tpr_debug("check offset=0x%x cnt=0x%x\\n", off, cnt);\n\n\tlist_for_each_entry(base, &mdd->base_list, head) {\n\t\tlist_for_each_entry(node, &base->dump_list, head) {\n\t\t\tpr_debug("%s: start=0x%x end=0x%x\\n", node->range_name,\n\t\t\t\t\tnode->offset.start, node->offset.end);\n\n\t\t\tif (node->offset.start <= off\n\t\t\t\t\t&& off <= node->offset.end\n\t\t\t\t\t&& off + cnt <= node->offset.end) {\n\t\t\t\tpr_debug("valid range requested\\n");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\tpr_err("invalid range requested\\n");\n\treturn false;\n}'
p57
S'0a6ff72374f8'
p58
ss(g53
S'mdss_debug_base_offset_write'
p59
tp60
(dp61
S'static ssize_t mdss_debug_base_offset_write(struct file *file,\n\t\t    const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tstruct mdss_debug_base *dbg = file->private_data;\n\tu32 off = 0;\n\tu32 cnt = DEFAULT_BASE_REG_CNT;\n\tchar buf[24];\n\n\tif (!dbg)\n\t\treturn -ENODEV;\n\n\tif (count >= sizeof(buf))\n\t\treturn -EFAULT;\n\n\tif (copy_from_user(buf, user_buf, count))\n\t\treturn -EFAULT;\n\n\tbuf[count] = 0;\t/* end of string */\n\n\tif (off % sizeof(u32))\n\t\treturn -EINVAL;\n\n\tif (sscanf(buf, "%5x %x", &off, &cnt) != 2)\n\t\treturn -EFAULT;\n\n\tif (off > dbg->max_offset)\n\t\treturn -EINVAL;\n\n\tif (cnt > (dbg->max_offset - off))\n\t\tcnt = dbg->max_offset - off;\n\n\tif (!mdss_debug_base_is_valid_range(off, cnt))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&mdss_debug_lock);\n\tdbg->off = off;\n\tdbg->cnt = cnt;\n\tmutex_unlock(&mdss_debug_lock);\n\n\tpr_debug("offset=%x cnt=%x\\n", off, cnt);\n\n\treturn count;\n}'
p62
g58
sssS'CVE-2018-13912'
p63
(dp64
(S'drivers/media/platform/msm/camera_v2/msm_buf_mgr/msm_generic_buf_mgr.c'
p65
S'msm_buf_mngr_subdev_ioctl'
p66
tp67
(dp68
S'static long msm_buf_mngr_subdev_ioctl(struct v4l2_subdev *sd,\n\tunsigned int cmd, void *arg)\n{\n\tint32_t rc = 0;\n\tstruct msm_buf_mngr_device *buf_mngr_dev = v4l2_get_subdevdata(sd);\n\tvoid *argp = arg;\n\n\tif (!buf_mngr_dev) {\n\t\tpr_err("%s buf manager device NULL\\n", __func__);\n\t\trc = -ENOMEM;\n\t\treturn rc;\n\t}\n\tswitch (cmd) {\n\tcase VIDIOC_MSM_BUF_MNGR_IOCTL_CMD: {\n\t\tstruct msm_camera_private_ioctl_arg k_ioctl, *ptr;\n\n\t\tif (!arg)\n\t\t\treturn -EINVAL;\n\t\tptr = arg;\n\t\tk_ioctl = *ptr;\n\t\tswitch (k_ioctl.id) {\n\t\tcase MSM_CAMERA_BUF_MNGR_IOCTL_ID_GET_BUF_BY_IDX: {\n\t\t\tstruct msm_buf_mngr_info buf_info, *tmp = NULL;\n\n\t\t\tif (k_ioctl.size != sizeof(struct msm_buf_mngr_info))\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!k_ioctl.ioctl_ptr)\n\t\t\t\treturn -EINVAL;\n\t\t\tif (!is_compat_task()) {\n\t\t\t\tMSM_CAM_GET_IOCTL_ARG_PTR(&tmp,\n\t\t\t\t\t&k_ioctl.ioctl_ptr, sizeof(tmp));\n\t\t\t\tif (copy_from_user(&buf_info, tmp,\n\t\t\t\t\tsizeof(struct msm_buf_mngr_info))) {\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tk_ioctl.ioctl_ptr = (uintptr_t)&buf_info;\n\t\t\t}\n\n\t\t\targp = &k_ioctl;\n\t\t\trc = msm_cam_buf_mgr_ops(cmd, argp);\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tpr_debug("unimplemented id %d", k_ioctl.id);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbreak;\n\t}\n\tcase VIDIOC_MSM_BUF_MNGR_GET_BUF:\n\tcase VIDIOC_MSM_BUF_MNGR_BUF_DONE:\n\tcase VIDIOC_MSM_BUF_MNGR_PUT_BUF:\n\tcase VIDIOC_MSM_BUF_MNGR_BUF_ERROR:\n\t\trc = msm_cam_buf_mgr_ops(cmd, argp);\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_INIT:\n\t\trc = msm_generic_buf_mngr_open(sd, NULL);\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_DEINIT:\n\t\trc = msm_generic_buf_mngr_close(sd, NULL);\n\t\tbreak;\n\tcase MSM_SD_NOTIFY_FREEZE:\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_FLUSH:\n\t\trc = msm_generic_buf_mngr_flush(buf_mngr_dev, argp);\n\t\tbreak;\n\tcase MSM_SD_UNNOTIFY_FREEZE:\n\t\tbreak;\n\tcase MSM_SD_SHUTDOWN:\n\t\tmsm_buf_mngr_sd_shutdown(buf_mngr_dev, argp);\n\t\tbreak;\n\tcase VIDIOC_MSM_BUF_MNGR_CONT_CMD:\n\t\trc = msm_buf_mngr_handle_cont_cmd(buf_mngr_dev, argp);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOIOCTLCMD;\n\t}\n\treturn rc;\n}'
p69
S'd634f74a5dc2'
p70
sssS'CVE-2019-15239'
p71
(dp72
(S'net/ipv4/tcp_output.c'
p73
S'__tcp_retransmit_skb'
p74
tp75
(dp76
S"int __tcp_retransmit_skb(struct sock *sk, struct sk_buff *skb, int segs)\n{\n\tstruct inet_connection_sock *icsk = inet_csk(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\tunsigned int cur_mss;\n\tint diff, len, err;\n\n\n\t/* Inconclusive MTU probe */\n\tif (icsk->icsk_mtup.probe_size)\n\t\ticsk->icsk_mtup.probe_size = 0;\n\n\t/* Do not sent more than we queued. 1/4 is reserved for possible\n\t * copying overhead: fragmentation, tunneling, mangling etc.\n\t */\n\tif (atomic_read(&sk->sk_wmem_alloc) >\n\t    min_t(u32, sk->sk_wmem_queued + (sk->sk_wmem_queued >> 2),\n\t\t  sk->sk_sndbuf))\n\t\treturn -EAGAIN;\n\n\tif (skb_still_in_host_queue(sk, skb))\n\t\treturn -EBUSY;\n\n\tif (before(TCP_SKB_CB(skb)->seq, tp->snd_una)) {\n\t\tif (unlikely(before(TCP_SKB_CB(skb)->end_seq, tp->snd_una))) {\n\t\t\tWARN_ON_ONCE(1);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (tcp_trim_head(sk, skb, tp->snd_una - TCP_SKB_CB(skb)->seq))\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (inet_csk(sk)->icsk_af_ops->rebuild_header(sk))\n\t\treturn -EHOSTUNREACH; /* Routing failure or similar. */\n\n\tcur_mss = tcp_current_mss(sk);\n\n\t/* If receiver has shrunk his window, and skb is out of\n\t * new window, do not retransmit it. The exception is the\n\t * case, when window is shrunk to zero. In this case\n\t * our retransmit serves as a zero window probe.\n\t */\n\tif (!before(TCP_SKB_CB(skb)->seq, tcp_wnd_end(tp)) &&\n\t    TCP_SKB_CB(skb)->seq != tp->snd_una)\n\t\treturn -EAGAIN;\n\n\tlen = cur_mss * segs;\n\tif (skb->len > len) {\n\t\tif (tcp_fragment(sk, skb, len, cur_mss, GFP_ATOMIC))\n\t\t\treturn -ENOMEM; /* We'll try again later. */\n\t} else {\n\t\tif (skb_unclone(skb, GFP_ATOMIC))\n\t\t\treturn -ENOMEM;\n\n\t\tdiff = tcp_skb_pcount(skb);\n\t\ttcp_set_skb_tso_segs(skb, cur_mss);\n\t\tdiff -= tcp_skb_pcount(skb);\n\t\tif (diff)\n\t\t\ttcp_adjust_pcount(sk, skb, diff);\n\t\tif (skb->len < cur_mss)\n\t\t\ttcp_retrans_try_collapse(sk, skb, cur_mss);\n\t}\n\n\t/* RFC3168, section 6.1.1.1. ECN fallback */\n\tif ((TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN_ECN) == TCPHDR_SYN_ECN)\n\t\ttcp_ecn_clear_syn(sk, skb);\n\n\t/* make sure skb->data is aligned on arches that require it\n\t * and check if ack-trimming & collapsing extended the headroom\n\t * beyond what csum_start can cover.\n\t */\n\tif (unlikely((NET_IP_ALIGN && ((unsigned long)skb->data & 3)) ||\n\t\t     skb_headroom(skb) >= 0xFFFF)) {\n\t\tstruct sk_buff *nskb;\n\n\t\tnskb = __pskb_copy(skb, MAX_TCP_HEADER, GFP_ATOMIC);\n\t\terr = nskb ? tcp_transmit_skb(sk, nskb, 0, GFP_ATOMIC) :\n\t\t\t     -ENOBUFS;\n\t\tif (!err)\n\t\t\tskb_mstamp_get(&skb->skb_mstamp);\n\t} else {\n\t\terr = tcp_transmit_skb(sk, skb, 1, GFP_ATOMIC);\n\t}\n\n\tif (likely(!err)) {\n\t\tsegs = tcp_skb_pcount(skb);\n\n\t\tTCP_SKB_CB(skb)->sacked |= TCPCB_EVER_RETRANS;\n\t\t/* Update global TCP statistics. */\n\t\tTCP_ADD_STATS(sock_net(sk), TCP_MIB_RETRANSSEGS, segs);\n\t\tif (TCP_SKB_CB(skb)->tcp_flags & TCPHDR_SYN)\n\t\t\t__NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPSYNRETRANS);\n\t\ttp->total_retrans += segs;\n\t}\n\treturn err;\n}"
p77
S'98ae89537923'
p78
ss(g73
S'tcp_connect_init'
p79
tp80
(dp81
S"static void tcp_connect_init(struct sock *sk)\n{\n\tconst struct dst_entry *dst = __sk_dst_get(sk);\n\tstruct tcp_sock *tp = tcp_sk(sk);\n\t__u8 rcv_wscale;\n\n\t/* We'll fix this up when we get a response from the other end.\n\t * See tcp_input.c:tcp_rcv_state_process case TCP_SYN_SENT.\n\t */\n\ttp->tcp_header_len = sizeof(struct tcphdr) +\n\t\t(sysctl_tcp_timestamps ? TCPOLEN_TSTAMP_ALIGNED : 0);\n\n#ifdef CONFIG_TCP_MD5SIG\n\tif (tp->af_specific->md5_lookup(sk, sk))\n\t\ttp->tcp_header_len += TCPOLEN_MD5SIG_ALIGNED;\n#endif\n\n\t/* If user gave his TCP_MAXSEG, record it to clamp */\n\tif (tp->rx_opt.user_mss)\n\t\ttp->rx_opt.mss_clamp = tp->rx_opt.user_mss;\n\ttp->max_window = 0;\n\ttcp_mtup_init(sk);\n\ttcp_sync_mss(sk, dst_mtu(dst));\n\n\ttcp_ca_dst_init(sk, dst);\n\n\tif (!tp->window_clamp)\n\t\ttp->window_clamp = dst_metric(dst, RTAX_WINDOW);\n\ttp->advmss = dst_metric_advmss(dst);\n\tif (tp->rx_opt.user_mss && tp->rx_opt.user_mss < tp->advmss)\n\t\ttp->advmss = tp->rx_opt.user_mss;\n\n\ttcp_initialize_rcv_mss(sk);\n\n\t/* limit the window selection if the user enforce a smaller rx buffer */\n\tif (sk->sk_userlocks & SOCK_RCVBUF_LOCK &&\n\t    (tp->window_clamp > tcp_full_space(sk) || tp->window_clamp == 0))\n\t\ttp->window_clamp = tcp_full_space(sk);\n\n\ttcp_select_initial_window(tcp_full_space(sk),\n\t\t\t\t  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),\n\t\t\t\t  &tp->rcv_wnd,\n\t\t\t\t  &tp->window_clamp,\n\t\t\t\t  sysctl_tcp_window_scaling,\n\t\t\t\t  &rcv_wscale,\n\t\t\t\t  dst_metric(dst, RTAX_INITRWND));\n\n\ttp->rx_opt.rcv_wscale = rcv_wscale;\n\ttp->rcv_ssthresh = tp->rcv_wnd;\n\n\tsk->sk_err = 0;\n\tsock_reset_flag(sk, SOCK_DONE);\n\ttp->snd_wnd = 0;\n\ttcp_init_wl(tp, 0);\n\ttcp_write_queue_purge(sk);\n\ttp->snd_una = tp->write_seq;\n\ttp->snd_sml = tp->write_seq;\n\ttp->snd_up = tp->write_seq;\n\ttp->snd_nxt = tp->write_seq;\n\n\tif (likely(!tp->repair))\n\t\ttp->rcv_nxt = 0;\n\telse\n\t\ttp->rcv_tstamp = tcp_time_stamp;\n\ttp->rcv_wup = tp->rcv_nxt;\n\ttp->copied_seq = tp->rcv_nxt;\n\n\tinet_csk(sk)->icsk_rto = TCP_TIMEOUT_INIT;\n\tinet_csk(sk)->icsk_retransmits = 0;\n\ttcp_clear_retrans(tp);\n}"
p82
g78
sssS'CVE-2018-3574'
p83
(dp84
(S'drivers/staging/android/ion/ion.c'
p85
S'ion_sync_for_device'
p86
tp87
(dp88
S'static int ion_sync_for_device(struct ion_client *client, int fd)\n{\n\tstruct dma_buf *dmabuf;\n\tstruct ion_buffer *buffer;\n\n\tdmabuf = dma_buf_get(fd);\n\tif (IS_ERR(dmabuf))\n\t\treturn PTR_ERR(dmabuf);\n\n\t/* if this memory came from ion */\n\tif (dmabuf->ops != &dma_buf_ops) {\n\t\tpr_err("%s: can not sync dmabuf from another exporter\\n",\n\t\t       __func__);\n\t\tdma_buf_put(dmabuf);\n\t\treturn -EINVAL;\n\t}\n\tbuffer = dmabuf->priv;\n\n\tif (!is_buffer_hlos_assigned(buffer)) {\n\t\tpr_err("%s: cannot sync a secure dmabuf\\n", __func__);\n\t\tdma_buf_put(dmabuf);\n\t\treturn -EINVAL;\n\t}\n\tdma_sync_sg_for_device(NULL, buffer->sg_table->sgl,\n\t\t\t       buffer->sg_table->nents, DMA_BIDIRECTIONAL);\n\tdma_buf_put(dmabuf);\n\treturn 0;\n}'
p89
S'd9534cd84408'
p90
ss(S'drivers/staging/android/ion/msm/msm_ion.c'
p91
S'MAKE_HEAP_TYPE_MAPPING'
p92
tp93
(dp94
S''
p95
S'd9534cd84408'
p96
ss(g91
S'msm_ion_custom_ioctl'
p97
tp98
(dp99
S'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tlock_client(client);\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id_nolock(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd_nolock(client,\n\t\t\t\t\t\t\t   data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (start && check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free_nolock(client, handle);\n\n\t\tunlock_client(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p100
S'19a8101c2309'
p101
sS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd(client,\n\t\t\t\t\t\t       data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free(client, handle);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\tION_HEAP_TYPE_SECURE_DMA,\n\t\t\t(void *)data.prefetch_data.len,\n\t\t\tion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p102
S'ac5f536e7f5e'
p103
sS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd(client,\n\t\t\t\t\t\t       data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free(client, handle);\n\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p104
g96
sS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tlock_client(client);\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id_nolock(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd_nolock(client,\n\t\t\t\t\t\t\t   data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free_nolock(client, handle);\n\n\t\tunlock_client(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\tION_HEAP_TYPE_SECURE_DMA,\n\t\t\t(void *)data.prefetch_data.len,\n\t\t\tion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p105
S'f332617ebb03'
p106
sS'long msm_ion_custom_ioctl(struct ion_client *client,\n\t\t\t  unsigned int cmd,\n\t\t\t  unsigned long arg)\n{\n\tunsigned int dir;\n\tunion {\n\t\tstruct ion_flush_data flush_data;\n\t\tstruct ion_prefetch_data prefetch_data;\n\t} data;\n\n\tdir = msm_ion_ioctl_dir(cmd);\n\n\tif (_IOC_SIZE(cmd) > sizeof(data))\n\t\treturn -EINVAL;\n\n\tif (dir & _IOC_WRITE)\n\t\tif (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))\n\t\t\treturn -EFAULT;\n\n\tswitch (cmd) {\n\tcase ION_IOC_CLEAN_CACHES:\n\tcase ION_IOC_INV_CACHES:\n\tcase ION_IOC_CLEAN_INV_CACHES:\n\t{\n\t\tunsigned long start, end;\n\t\tstruct ion_handle *handle = NULL;\n\t\tint ret;\n\t\tstruct mm_struct *mm = current->active_mm;\n\n\t\tlock_client(client);\n\t\tif (data.flush_data.handle > 0) {\n\t\t\thandle = ion_handle_get_by_id_nolock(\n\t\t\t\t\tclient, (int)data.flush_data.handle);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not find handle: %d\\n",\n\t\t\t\t\t__func__, (int)data.flush_data.handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn PTR_ERR(handle);\n\t\t\t}\n\t\t} else {\n\t\t\thandle = ion_import_dma_buf_fd_nolock(client,\n\t\t\t\t\t\t\t   data.flush_data.fd);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\tpr_info("%s: Could not import handle: %pK\\n",\n\t\t\t\t\t__func__, handle);\n\t\t\t\tunlock_client(client);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t}\n\n\t\tdown_read(&mm->mmap_sem);\n\n\t\tstart = (unsigned long)data.flush_data.vaddr +\n\t\t\tdata.flush_data.offset;\n\t\tend = start + data.flush_data.length;\n\n\t\tif (check_vaddr_bounds(start, end)) {\n\t\t\tpr_err("%s: virtual address %pK is out of bounds\\n",\n\t\t\t       __func__, data.flush_data.vaddr);\n\t\t\tret = -EINVAL;\n\t\t} else {\n\t\t\tret = ion_do_cache_op(\n\t\t\t\tclient, handle, data.flush_data.vaddr,\n\t\t\t\tdata.flush_data.offset,\n\t\t\t\tdata.flush_data.length, cmd);\n\t\t}\n\t\tup_read(&mm->mmap_sem);\n\n\t\tion_free_nolock(client, handle);\n\n\t\tunlock_client(client);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_PREFETCH:\n\t{\n\t\tint ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_prefetch);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\tcase ION_IOC_DRAIN:\n\t{\n\t\tint ret;\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SECURE_DMA,\n\t\t\t\t     (void *)data.prefetch_data.len,\n\t\t\t\t     ion_secure_cma_drain_pool);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tret = ion_walk_heaps(client, data.prefetch_data.heap_id,\n\t\t\t\t     (enum ion_heap_type)\n\t\t\t\t     ION_HEAP_TYPE_SYSTEM_SECURE,\n\t\t\t\t     (void *)&data.prefetch_data,\n\t\t\t\t     ion_system_secure_heap_drain);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\t}\n\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n\treturn 0;\n}'
p107
S'058ddcee4c12'
p108
ss(g91
S'ion_do_cache_op'
p109
tp110
(dp111
S'static int ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,\n\t\t\t   void *uaddr, unsigned long offset, unsigned long len,\n\t\t\t   unsigned int cmd)\n{\n\tint ret = -EINVAL;\n\tunsigned long flags;\n\tstruct sg_table *table;\n\tstruct page *page;\n\tstruct ion_buffer *buffer;\n\n\tif (!ion_handle_validate(client, handle)) {\n\t\tpr_err("%s: invalid handle passed to %s.\\n",\n\t\t       __func__, __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tbuffer = get_buffer(handle);\n\tmutex_lock(&buffer->lock);\n\tflags = buffer->flags;\n\tmutex_unlock(&buffer->lock);\n\n\tif (!ION_IS_CACHED(flags))\n\t\treturn 0;\n\n\tif (!is_buffer_hlos_assigned(ion_handle_buffer(handle)))\n\t\treturn 0;\n\n\ttable = buffer->sg_table;\n\n\tif (IS_ERR_OR_NULL(table))\n\t\treturn PTR_ERR(table);\n\n\tpage = sg_page(table->sgl);\n\n\tif (page)\n\t\tret = ion_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t  offset, len, cmd);\n\telse\n\t\tret = ion_no_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t     offset, len, cmd);\n\n\treturn ret;\n}'
p112
g106
sS'static int ion_do_cache_op(struct ion_client *client, struct ion_handle *handle,\n\t\t\t   void *uaddr, unsigned long offset, unsigned long len,\n\t\t\t   unsigned int cmd)\n{\n\tint ret = -EINVAL;\n\tunsigned long flags;\n\tstruct sg_table *table;\n\tstruct page *page;\n\n\tret = ion_handle_get_flags(client, handle, &flags);\n\tif (ret)\n\t\treturn -EINVAL;\n\n\tif (!ION_IS_CACHED(flags))\n\t\treturn 0;\n\n\tif (!is_buffer_hlos_assigned(ion_handle_buffer(handle)))\n\t\treturn 0;\n\n\ttable = ion_sg_table(client, handle);\n\n\tif (IS_ERR_OR_NULL(table))\n\t\treturn PTR_ERR(table);\n\n\tpage = sg_page(table->sgl);\n\n\tif (page)\n\t\tret = ion_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t  offset, len, cmd);\n\telse\n\t\tret = ion_no_pages_cache_ops(client, handle, uaddr,\n\t\t\t\t\t     offset, len, cmd);\n\n\treturn ret;\n}'
p113
g96
sssS'CVE-2019-10528'
p114
(dp115
(S'drivers/char/diag/diagfwd_peripheral.c'
p116
S'diagfwd_data_read_done'
p117
tp118
(dp119
S'static void diagfwd_data_read_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   unsigned char *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diagfwd_buf_t *temp_buf = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t\t   __func__, fwd_info->type,\n\t\t\t\t   fwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(fwd_info->peripheral);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (!driver->feature[fwd_info->peripheral].encode_hdlc) {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t\twrite_buf = fwd_info->buf_1->data;\n\t\t} else if (fwd_info->buf_2 && fwd_info->buf_2->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t\twrite_buf = fwd_info->buf_2->data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t} else if (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\twrite_buf = buf;\n\t} else {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = check_bufsize_for_encoding(temp_buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = temp_buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len, buf, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     temp_buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (temp_buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(temp_buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(temp_buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p120
S'4ab88a87a831'
p121
sS'static void diagfwd_data_read_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   unsigned char *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diagfwd_buf_t *temp_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t\t   __func__, fwd_info->type,\n\t\t\t\t   fwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\thdlc_disabled = driver->p_hdlc_disabled[fwd_info->peripheral];\n\n\tif (!driver->feature[fwd_info->peripheral].encode_hdlc) {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t\twrite_buf = fwd_info->buf_1->data;\n\t\t} else if (fwd_info->buf_2 && fwd_info->buf_2->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t\twrite_buf = fwd_info->buf_2->data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t} else if (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\twrite_buf = buf;\n\t} else {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = check_bufsize_for_encoding(temp_buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = temp_buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len, buf, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     temp_buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end_write;\n\t\t}\n\t}\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\nend_write:\n\tdiag_ws_release();\n\tif (temp_buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(temp_buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(temp_buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p122
S'5bed7228b299'
p123
sS'static void diagfwd_data_read_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   unsigned char *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diagfwd_buf_t *temp_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t\t   __func__, fwd_info->type,\n\t\t\t\t   fwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\thdlc_disabled = driver->p_hdlc_disabled[fwd_info->peripheral];\n\n\tif (!driver->feature[fwd_info->peripheral].encode_hdlc) {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t\twrite_buf = fwd_info->buf_1->data;\n\t\t} else if (fwd_info->buf_2 && fwd_info->buf_2->data == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t\twrite_buf = fwd_info->buf_2->data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t} else if (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\twrite_buf = buf;\n\t} else {\n\t\tif (fwd_info->buf_1 && fwd_info->buf_1->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_1;\n\t\t} else if (fwd_info->buf_2 &&\n\t\t\t   fwd_info->buf_2->data_raw == buf) {\n\t\t\ttemp_buf = fwd_info->buf_2;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = check_bufsize_for_encoding(temp_buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = temp_buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len, buf, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     temp_buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (temp_buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(temp_buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(temp_buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p124
S'aef5910fdda8'
p125
ss(S'drivers/char/diag/diagfwd.c'
p126
S'diag_send_error_rsp'
p127
tp128
(dp129
S'void diag_send_error_rsp(unsigned char *buf, int len,\n\t\t\tint pid)\n{\n\t/* -1 to accommodate the first byte 0x13 */\n\tif (len > (DIAG_MAX_RSP_SIZE - 1)) {\n\t\tpr_err("diag: cannot send err rsp, huge length: %d\\n", len);\n\t\treturn;\n\t}\n\n\t*(uint8_t *)driver->apps_rsp_buf = DIAG_CMD_ERROR;\n\tmemcpy((driver->apps_rsp_buf + sizeof(uint8_t)), buf, len);\n\tdiag_send_rsp(driver->apps_rsp_buf, len + 1, pid);\n}'
p130
S'4ab88a87a831'
p131
ss(S'drivers/char/diag/diag_masks.c'
p132
S'diag_cmd_get_build_mask'
p133
tp134
(dp135
S'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p136
S'4ab88a87a831'
p137
sS'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr)\n\t\t\tcontinue;\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p138
S'38a1d53987e4'
p139
sS'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t\tsrc_len < sizeof(struct diag_build_mask_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr)\n\t\t\tcontinue;\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p140
S'a77c16d4981b'
p141
sS'static int diag_cmd_get_build_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i = 0;\n\tint write_len = 0;\n\tint num_entries = 0;\n\tint copy_len = 0;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t\tsrc_len < sizeof(struct diag_build_mask_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_BUILD_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tbuild_mask = (struct diag_msg_mask_t *)msg_bt_mask.ptr;\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr)\n\t\t\tcontinue;\n\t\tif (build_mask->ssid_first != req->ssid_first)\n\t\t\tcontinue;\n\t\tnum_entries = req->ssid_last - req->ssid_first + 1;\n\t\tif (num_entries > build_mask->range) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range for ssid_first: %d ssid_last %d\\n",\n\t\t\t\t__func__, req->ssid_first, req->ssid_last);\n\t\t\tnum_entries = build_mask->range;\n\t\t\treq->ssid_last = req->ssid_first + build_mask->range;\n\t\t}\n\t\tcopy_len = num_entries * sizeof(uint32_t);\n\t\tif (copy_len + sizeof(rsp) > dest_len)\n\t\t\tcopy_len = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), build_mask->ptr, copy_len);\n\t\twrite_len += copy_len;\n\t\trsp.ssid_last = build_mask->ssid_last;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn write_len;\n}'
p142
S'9393739f2aa4'
p143
ss(S'drivers/char/diag/diagchar_core.c'
p144
S'diagchar_read'
p145
tp146
(dp147
S'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client)\n\t\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p148
S'f332617ebb03'
p149
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client) {\n\t\t\t\tif (entry->client->tgid != current->tgid) {\n\t\t\t\t\tput_task_struct(task_s);\n\t\t\t\t\tput_pid(pid_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!entry->in_service) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tput_task_struct(task_s);\n\t\t\tput_pid(pid_struct);\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p150
S'6c6aaf4e8330'
p151
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p152
S'4ab88a87a831'
p153
ss(g132
S'diag_cmd_toggle_events'
p154
tp155
(dp156
S'static int diag_cmd_toggle_events(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0, i, peripheral;\n\tuint8_t toggle = 0;\n\tstruct diag_event_report_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttoggle = *(src_buf + 1);\n\tmutex_lock(&mask_info->lock);\n\tif (toggle) {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_ENABLED;\n\t\tmemset(mask_info->ptr, 0xFF, mask_info->mask_len);\n\t} else {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\t\tmemset(mask_info->ptr, 0, mask_info->mask_len);\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_EVENT_TOGGLE;\n\theader.padding = 0;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\tmemcpy(dest_buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\treturn write_len;\n}'
p157
g137
sS'static int diag_cmd_toggle_events(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0, i, peripheral;\n\tuint8_t toggle = 0;\n\tstruct diag_event_report_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttoggle = *(src_buf + 1);\n\tmutex_lock(&mask_info->lock);\n\tif (toggle) {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_ENABLED;\n\t\tmemset(mask_info->ptr, 0xFF, mask_info->mask_len);\n\t} else {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\t\tmemset(mask_info->ptr, 0, mask_info->mask_len);\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_EVENT_TOGGLE;\n\theader.padding = 0;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\tmemcpy(dest_buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\treturn write_len;\n}'
p158
S'd441912ad6fd'
p159
sS'static int diag_cmd_toggle_events(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0, i, peripheral;\n\tuint8_t toggle = 0;\n\tstruct diag_event_report_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= sizeof(uint8_t) ||\n\t\tdest_len <= 0 || !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\ttoggle = *(src_buf + 1);\n\tmutex_lock(&mask_info->lock);\n\tif (toggle) {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_ENABLED;\n\t\tmemset(mask_info->ptr, 0xFF, mask_info->mask_len);\n\t} else {\n\t\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\t\tmemset(mask_info->ptr, 0, mask_info->mask_len);\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_EVENT_TOGGLE;\n\theader.padding = 0;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\tmemcpy(dest_buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\treturn write_len;\n}'
p160
g141
ss(S'drivers/char/diag/diag_usb.c'
p161
S'usb_disconnect'
p162
tp163
(dp164
S'static void usb_disconnect(struct diag_usb_info *ch)\n{\n\tif (!ch)\n\t\treturn;\n\n\tif (!atomic_read(&ch->connected) &&\n\t\tdriver->usb_connected && diag_mask_param())\n\t\tdiag_clear_masks(0);\n\n\tif (ch && ch->ops && ch->ops->close)\n\t\tch->ops->close(ch->ctxt, DIAG_USB_MODE);\n}'
p165
S'4ab88a87a831'
p166
sS'static void usb_disconnect(struct diag_usb_info *ch)\n{\n\tif (ch && ch->ops && ch->ops->close)\n\t\tch->ops->close(ch->ctxt, DIAG_USB_MODE);\n}'
p167
S'f332617ebb03'
p168
ss(g126
S'diag_process_non_hdlc_pkt'
p169
tp170
(dp171
S'void diag_process_non_hdlc_pkt(unsigned char *buf, int len, int pid)\n{\n\tint err = 0;\n\tuint16_t pkt_len = 0;\n\tuint32_t read_bytes = 0;\n\tconst uint32_t header_len = sizeof(struct diag_pkt_frame_t);\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tunsigned char *data_ptr = NULL;\n\tstruct diag_partial_pkt_t *partial_pkt = NULL;\n\n\tmutex_lock(&driver->hdlc_recovery_mutex);\n\tif (!buf || len <= 0) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\treturn;\n\t}\n\tpartial_pkt = &driver->incoming_pkt;\n\tif (!partial_pkt->processing) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\n\tif (partial_pkt->remaining > len) {\n\t\tif ((partial_pkt->read_len + len) > partial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len, len, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf, len);\n\t\tread_bytes += len;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += len;\n\t\tpartial_pkt->remaining -= len;\n\t} else {\n\t\tif ((partial_pkt->read_len + partial_pkt->remaining) >\n\t\t\t\t\t\tpartial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length during partial read %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len,\n\t\t\t       partial_pkt->remaining, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf,\n\t\t\t\t\t\tpartial_pkt->remaining);\n\t\tread_bytes += partial_pkt->remaining;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += partial_pkt->remaining;\n\t\tpartial_pkt->remaining = 0;\n\t}\n\n\tif (partial_pkt->remaining == 0) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)(partial_pkt->data);\n\t\tdata_ptr = partial_pkt->data + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, unable to process incoming data packet, err: %d\\n",\n\t\t\t       __func__, err);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tpartial_pkt->read_len = 0;\n\t\tpartial_pkt->total_len = 0;\n\t\tpartial_pkt->processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\tgoto end;\n\nstart:\n\twhile (read_bytes < len) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\t\tpkt_len = actual_pkt->length;\n\n\t\tif (actual_pkt->start != CONTROL_CHAR) {\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\tgoto end;\n\t\t}\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tif (pkt_len + header_len > partial_pkt->capacity) {\n\t\t\tpr_err("diag: In %s, incoming data is too large for the request buffer %d\\n",\n\t\t\t       __func__, pkt_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tbreak;\n\t\t}\n\t\tif ((pkt_len + header_len) > (len - read_bytes)) {\n\t\t\tpartial_pkt->read_len = len - read_bytes;\n\t\t\tpartial_pkt->total_len = pkt_len + header_len;\n\t\t\tpartial_pkt->remaining = partial_pkt->total_len -\n\t\t\t\t\t\t partial_pkt->read_len;\n\t\t\tpartial_pkt->processing = 1;\n\t\t\tmemcpy(partial_pkt->data, buf, partial_pkt->read_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tdata_ptr = buf + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, len, pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\telse\n\t\t\thdlc_reset = 0;\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tread_bytes += header_len + pkt_len + 1;\n\t\tbuf += header_len + pkt_len + 1; /* advance to next pkt */\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t}\nend:\n\treturn;\n}'
p172
g131
sS'void diag_process_non_hdlc_pkt(unsigned char *buf, int len, int pid)\n{\n\tint err = 0;\n\tuint16_t pkt_len = 0;\n\tuint32_t read_bytes = 0;\n\tconst uint32_t header_len = sizeof(struct diag_pkt_frame_t);\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tunsigned char *data_ptr = NULL;\n\tstruct diag_partial_pkt_t *partial_pkt = NULL;\n\n\tmutex_lock(&driver->hdlc_recovery_mutex);\n\tif (!buf || len <= 0) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\treturn;\n\t}\n\tpartial_pkt = &driver->incoming_pkt;\n\tif (!partial_pkt->processing) {\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\n\tif (partial_pkt->remaining > len) {\n\t\tif ((partial_pkt->read_len + len) > partial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len, len, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf, len);\n\t\tread_bytes += len;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += len;\n\t\tpartial_pkt->remaining -= len;\n\t} else {\n\t\tif ((partial_pkt->read_len + partial_pkt->remaining) >\n\t\t\t\t\t\tpartial_pkt->capacity) {\n\t\t\tpr_err("diag: Invalid length during partial read %d, %d received in %s\\n",\n\t\t\t       partial_pkt->read_len,\n\t\t\t       partial_pkt->remaining, __func__);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(partial_pkt->data + partial_pkt->read_len, buf,\n\t\t\t\t\t\tpartial_pkt->remaining);\n\t\tread_bytes += partial_pkt->remaining;\n\t\tbuf += read_bytes;\n\t\tpartial_pkt->read_len += partial_pkt->remaining;\n\t\tpartial_pkt->remaining = 0;\n\t}\n\n\tif (partial_pkt->remaining == 0) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)(partial_pkt->data);\n\t\tdata_ptr = partial_pkt->data + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, unable to process incoming data packet, err: %d\\n",\n\t\t\t       __func__, err);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tgoto end;\n\t\t}\n\t\tpartial_pkt->read_len = 0;\n\t\tpartial_pkt->total_len = 0;\n\t\tpartial_pkt->processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tgoto start;\n\t}\n\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\tgoto end;\n\nstart:\n\twhile (read_bytes < len) {\n\t\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\t\tpkt_len = actual_pkt->length;\n\n\t\tif (actual_pkt->start != CONTROL_CHAR) {\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tdiag_send_error_rsp(buf, (len - read_bytes), pid);\n\t\t\tgoto end;\n\t\t}\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tif (pkt_len + header_len > partial_pkt->capacity) {\n\t\t\tpr_err("diag: In %s, incoming data is too large for the request buffer %d\\n",\n\t\t\t       __func__, pkt_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tbreak;\n\t\t}\n\t\tif ((pkt_len + header_len) > (len - read_bytes)) {\n\t\t\tpartial_pkt->read_len = len - read_bytes;\n\t\t\tpartial_pkt->total_len = pkt_len + header_len;\n\t\t\tpartial_pkt->remaining = partial_pkt->total_len -\n\t\t\t\t\t\t partial_pkt->read_len;\n\t\t\tpartial_pkt->processing = 1;\n\t\t\tmemcpy(partial_pkt->data, buf, partial_pkt->read_len);\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tdata_ptr = buf + header_len;\n\t\tif (*(uint8_t *)(data_ptr + actual_pkt->length) !=\n\t\t\t\t\t\tCONTROL_CHAR) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tdiag_hdlc_start_recovery(buf, (len - read_bytes), pid);\n\t\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\t}\n\t\telse\n\t\t\thdlc_reset = 0;\n\t\terr = diag_process_apps_pkt(data_ptr,\n\t\t\t\t\t    actual_pkt->length, pid);\n\t\tif (err) {\n\t\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tread_bytes += header_len + pkt_len + 1;\n\t\tbuf += header_len + pkt_len + 1; /* advance to next pkt */\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t}\nend:\n\treturn;\n}'
p173
S'a77c16d4981b'
p174
ss(g126
S'pack_rsp_and_send'
p175
tp176
(dp177
S'static void pack_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tint err;\n\tint retry_count = 0, i, rsp_ctxt;\n\tuint32_t write_len = 0;\n\tunsigned long flags;\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tstruct diag_pkt_frame_t header;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tif (info->peripheral_mask == DIAG_CON_ALL ||\n\t\t\t(info->peripheral_mask & (1 << APPS_DATA)) ||\n\t\t\t(info->peripheral_mask & (1 << PERIPHERAL_MODEM))) {\n\t\t\trsp_ctxt = SET_BUF_CTXT(APPS_DATA, TYPE_CMD, 1);\n\t\t} else {\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, 1);\n\t\t}\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till UINT_MAX, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < UINT_MAX) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tdriver->rsp_buf_busy = 1;\n\theader.start = CONTROL_CHAR;\n\theader.version = 1;\n\theader.length = len;\n\tmemcpy(rsp_ptr, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\tmemcpy(rsp_ptr + write_len, buf, len);\n\twrite_len += len;\n\t*(uint8_t *)(rsp_ptr + write_len) = CONTROL_CHAR;\n\twrite_len += sizeof(uint8_t);\n\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, write_len, rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, unable to write to mux, err: %d\\n",\n\t\t       __func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n}'
p178
g131
sS'static void pack_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tint err;\n\tint retry_count = 0, i, rsp_ctxt;\n\tuint32_t write_len = 0;\n\tunsigned long flags;\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tstruct diag_pkt_frame_t header;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\tbreak;\n\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, TYPE_CMD);\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till RETRY_MAX_COUNT, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < RETRY_MAX_COUNT) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tdriver->rsp_buf_busy = 1;\n\theader.start = CONTROL_CHAR;\n\theader.version = 1;\n\theader.length = len;\n\tmemcpy(rsp_ptr, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\tmemcpy(rsp_ptr + write_len, buf, len);\n\twrite_len += len;\n\t*(uint8_t *)(rsp_ptr + write_len) = CONTROL_CHAR;\n\twrite_len += sizeof(uint8_t);\n\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, write_len, rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, unable to write to mux, err: %d\\n",\n\t\t       __func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n}'
p179
S'1d2497b161fa'
p180
ss(g126
S'encode_rsp_and_send'
p181
tp182
(dp183
S'static void encode_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tint err, i, rsp_ctxt, retry_count = 0;\n\tunsigned long flags;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\tbreak;\n\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, TYPE_CMD);\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till RETRY_MAX_COUNT, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < RETRY_MAX_COUNT) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\tdriver->rsp_buf_busy = 1;\n\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = buf;\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\tenc.dest = rsp_ptr;\n\tenc.dest_last = (void *)(rsp_ptr + DIAG_MAX_HDLC_BUF_SIZE - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->encoded_rsp_len = (int)(enc.dest - (void *)rsp_ptr);\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, driver->encoded_rsp_len,\n\t\t\t     rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to write to device, err: %d\\n",\n\t\t\t__func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n\tmemset(buf, \'\\0\', DIAG_MAX_RSP_SIZE);\n}'
p184
g180
sS'static void encode_rsp_and_send(unsigned char *buf, int len,\n\t\t\t\tint pid)\n{\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tunsigned char *rsp_ptr = driver->encoded_rsp_buf;\n\tint err, i, rsp_ctxt, retry_count = 0;\n\tunsigned long flags;\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\n\tif (!rsp_ptr || !buf)\n\t\treturn;\n\n\tif (len > DIAG_MAX_RSP_SIZE || len < 0) {\n\t\tpr_err("diag: In %s, invalid len %d, permissible len %d\\n",\n\t\t       __func__, len, DIAG_MAX_RSP_SIZE);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tinfo = (session_info) ? session_info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\n\t/*\n\t * Explicitly check for the Peripheral Modem here\n\t * is necessary till a way to identify a peripheral\n\t * if its supporting qshrink4 feature.\n\t */\n\tif (info && info->peripheral_mask) {\n\t\tif (info->peripheral_mask == DIAG_CON_ALL ||\n\t\t\t(info->peripheral_mask & (1 << APPS_DATA)) ||\n\t\t\t(info->peripheral_mask & (1 << PERIPHERAL_MODEM))) {\n\t\t\trsp_ctxt = SET_BUF_CTXT(APPS_DATA, TYPE_CMD, 1);\n\t\t} else {\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif (info->peripheral_mask & (1 << i))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\trsp_ctxt = SET_BUF_CTXT(i, TYPE_CMD, 1);\n\t\t}\n\t} else\n\t\trsp_ctxt = driver->rsp_buf_ctxt;\n\tmutex_unlock(&driver->md_session_lock);\n\t/*\n\t * Keep trying till we get the buffer back. It should probably\n\t * take one or two iterations. When this loops till UINT_MAX, it\n\t * means we did not get a write complete for the previous\n\t * response.\n\t */\n\twhile (retry_count < UINT_MAX) {\n\t\tif (!driver->rsp_buf_busy)\n\t\t\tbreak;\n\t\t/*\n\t\t * Wait for sometime and try again. The value 10000 was chosen\n\t\t * empirically as an optimum value for USB to complete a write\n\t\t */\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\n\t\t/*\n\t\t * There can be a race conditon that clears the data ready flag\n\t\t * for responses. Make sure we don\'t miss previous wakeups for\n\t\t * draining responses when we are in Memory Device Mode.\n\t\t */\n\t\tif (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\t\t\tdriver->logging_mode == DIAG_MULTI_MODE) {\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tchk_logging_wakeup();\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t}\n\t}\n\n\tif (driver->rsp_buf_busy) {\n\t\tpr_err("diag: unable to get hold of response buffer\\n");\n\t\treturn;\n\t}\n\n\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\tdriver->rsp_buf_busy = 1;\n\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = buf;\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\tenc.dest = rsp_ptr;\n\tenc.dest_last = (void *)(rsp_ptr + DIAG_MAX_HDLC_BUF_SIZE - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->encoded_rsp_len = (int)(enc.dest - (void *)rsp_ptr);\n\terr = diag_mux_write(DIAG_LOCAL_PROC, rsp_ptr, driver->encoded_rsp_len,\n\t\t\t     rsp_ctxt);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to write to device, err: %d\\n",\n\t\t\t__func__, err);\n\t\tspin_lock_irqsave(&driver->rsp_buf_busy_lock, flags);\n\t\tdriver->rsp_buf_busy = 0;\n\t\tspin_unlock_irqrestore(&driver->rsp_buf_busy_lock, flags);\n\t}\n\tmemset(buf, \'\\0\', DIAG_MAX_RSP_SIZE);\n}'
p185
g131
ss(g144
S'diag_close_logging_process'
p186
tp187
(dp188
S'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn;\n\t}\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tparams.req_mode = USB_MODE;\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p189
S'a93976ff1455'
p190
sS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn;\n\t}\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\tparams.req_mode = PCIE_MODE;\n\telse\n\t\tparams.req_mode = USB_MODE;\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p191
S'a5bdc9ebe5cf'
p192
sS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)\n\t\t\tparams.req_mode = PCIE_MODE;\n\t\telse\n\t\t\tparams.req_mode = USB_MODE;\n\t\tparams.mode_param = 0;\n\t\tparams.pd_mask = 0;\n\t\tparams.peripheral_mask = DIAG_CON_ALL;\n\t\tmutex_lock(&driver->diagchar_mutex);\n\t\tdiag_switch_logging(&params);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\treturn;\n\t}\n\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\tparams.req_mode = PCIE_MODE;\n\telse\n\t\tparams.req_mode = USB_MODE;\n\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p193
S'c36d54c34fef'
p194
sS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn;\n\t}\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diag_maskclear_mutex);\n\tdriver->mask_clear = 1;\n\tmutex_unlock(&driver->diag_maskclear_mutex);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tparams.req_mode = USB_MODE;\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p195
g153
sS'static void diag_close_logging_process(const int pid)\n{\n\tint i, j;\n\tint session_mask;\n\tuint32_t p_mask;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct diag_logging_mode_param_t params;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tmutex_lock(&driver->diagchar_mutex);\n\t\tif (driver->pcie_switch_pid == pid) {\n\t\t\tif (driver->pcie_transport_def ==\n\t\t\t\tDIAG_ROUTE_TO_PCIE)\n\t\t\t\tparams.req_mode = PCIE_MODE;\n\t\t\telse\n\t\t\t\tparams.req_mode = USB_MODE;\n\t\t\tparams.mode_param = 0;\n\t\t\tparams.pd_mask = 0;\n\t\t\tparams.peripheral_mask = DIAG_CON_ALL;\n\t\t\tdiag_switch_logging(&params);\n\t\t\tdriver->pcie_switch_pid = 0;\n\t\t}\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\treturn;\n\t}\n\n\tsession_mask = session_info->peripheral_mask;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (diag_mask_clear_param)\n\t\tdiag_clear_masks(pid);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tp_mask =\n\tdiag_translate_kernel_to_user_mask(session_mask);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++)\n\t\tif (MD_PERIPHERAL_MASK(i) & session_mask)\n\t\t\tdiag_mux_close_peripheral(DIAG_LOCAL_PROC, i);\n\n\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\tparams.req_mode = PCIE_MODE;\n\telse\n\t\tparams.req_mode = USB_MODE;\n\n\tparams.mode_param = 0;\n\tparams.pd_mask = 0;\n\tparams.peripheral_mask = p_mask;\n\n\tif (driver->num_pd_session > 0) {\n\t\tfor (i = UPD_WLAN; (i < NUM_MD_SESSIONS); i++) {\n\t\t\tif (session_mask & MD_PERIPHERAL_MASK(i)) {\n\t\t\t\tj = i - UPD_WLAN;\n\t\t\t\tdriver->pd_session_clear[j] = 1;\n\t\t\t\tdriver->pd_logging_mode[j] = 0;\n\t\t\t\tdriver->num_pd_session -= 1;\n\t\t\t\tparams.pd_mask = p_mask;\n\t\t\t}\n\t\t}\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tdiag_md_session_close(pid);\n\tmutex_unlock(&driver->md_session_lock);\n\tdiag_switch_logging(&params);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p196
S'61fe509b8406'
p197
ss(g126
S'diag_hdlc_start_recovery'
p198
tp199
(dp200
S'static void diag_hdlc_start_recovery(unsigned char *buf, int len,\n\t\t\t\t     int pid)\n{\n\tint i;\n\tstatic uint32_t bad_byte_counter;\n\tunsigned char *start_ptr = NULL;\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\thdlc_reset = 1;\n\thdlc_reset_timer_start(pid);\n\n\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (actual_pkt->start == CONTROL_CHAR &&\n\t\t\t\tactual_pkt->version == 1 &&\n\t\t\t\tactual_pkt->length < len &&\n\t\t\t\t(*(uint8_t *)(buf +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) +\n\t\t\t\tactual_pkt->length) == CONTROL_CHAR)) {\n\t\t\tstart_ptr = &buf[i];\n\t\t\tbreak;\n\t\t}\n\t\tbad_byte_counter++;\n\t\tif (bad_byte_counter > (DIAG_MAX_REQ_SIZE +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) + 1)) {\n\t\t\tbad_byte_counter = 0;\n\t\t\tpr_err("diag: In %s, re-enabling HDLC encoding\\n",\n\t\t\t\t\t__func__);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tinfo = diag_md_session_get_pid(pid);\n\t\t\tif (info)\n\t\t\t\tinfo->hdlc_disabled = 0;\n\t\t\telse\n\t\t\t\tdriver->hdlc_disabled = 0;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (start_ptr) {\n\t\t/* Discard any partial packet reads */\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tdriver->incoming_pkt.processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, pid);\n\t}\n}'
p201
g131
sS'static void diag_hdlc_start_recovery(unsigned char *buf, int len,\n\t\t\t\t     int pid)\n{\n\tint i, peripheral = -EINVAL;\n\tstatic uint32_t bad_byte_counter;\n\tunsigned char *start_ptr = NULL;\n\tstruct diag_pkt_frame_t *actual_pkt = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\thdlc_reset = 1;\n\thdlc_reset_timer_start(pid);\n\n\tactual_pkt = (struct diag_pkt_frame_t *)buf;\n\tfor (i = 0; i < len; i++) {\n\t\tif (actual_pkt->start == CONTROL_CHAR &&\n\t\t\t\tactual_pkt->version == 1 &&\n\t\t\t\tactual_pkt->length < len &&\n\t\t\t\t(*(uint8_t *)(buf +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) +\n\t\t\t\tactual_pkt->length) == CONTROL_CHAR)) {\n\t\t\tstart_ptr = &buf[i];\n\t\t\tbreak;\n\t\t}\n\t\tbad_byte_counter++;\n\t\tif (bad_byte_counter > (DIAG_MAX_REQ_SIZE +\n\t\t\t\tsizeof(struct diag_pkt_frame_t) + 1)) {\n\t\t\tbad_byte_counter = 0;\n\t\t\tpr_err("diag: In %s, re-enabling HDLC encoding\\n",\n\t\t\t\t\t__func__);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tmutex_lock(&driver->md_session_lock);\n\t\t\tinfo = diag_md_session_get_pid(pid);\n\t\t\tif (info)\n\t\t\t\tinfo->hdlc_disabled = 0;\n\t\t\telse\n\t\t\t\tdriver->hdlc_disabled = 0;\n\n\t\t\tperipheral =\n\t\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif (peripheral > 0 && info) {\n\t\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\t\telse if (\n\t\t\t\t\t!diag_md_session_get_peripheral(i))\n\t\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t\t} else {\n\t\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (start_ptr) {\n\t\t/* Discard any partial packet reads */\n\t\tmutex_lock(&driver->hdlc_recovery_mutex);\n\t\tdriver->incoming_pkt.processing = 0;\n\t\tmutex_unlock(&driver->hdlc_recovery_mutex);\n\t\tdiag_process_non_hdlc_pkt(start_ptr, len - i, pid);\n\t}\n}'
p202
S'aef5910fdda8'
p203
ss(g126
S'diag_send_rsp'
p204
tp205
(dp206
S'static void diag_send_rsp(unsigned char *buf, int len,\n\tint pid)\n{\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tsession_info = (info) ? info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (hdlc_disabled)\n\t\tpack_rsp_and_send(buf, len, pid);\n\telse\n\t\tencode_rsp_and_send(buf, len, pid);\n}'
p207
g203
sS'static void diag_send_rsp(unsigned char *buf, int len,\n\tint pid)\n{\n\tstruct diag_md_session_t *session_info = NULL, *info = NULL;\n\tuint8_t hdlc_disabled;\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tsession_info = (info) ? info :\n\t\t\t\tdiag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled)\n\t\tpack_rsp_and_send(buf, len, pid);\n\telse\n\t\tencode_rsp_and_send(buf, len, pid);\n}'
p208
g131
ss(g144
S'diag_ioctl_hdlc_toggle'
p209
tp210
(dp211
S'static int diag_ioctl_hdlc_toggle(unsigned long ioarg)\n{\n\tuint8_t hdlc_support;\n\tstruct diag_md_session_t *session_info = NULL;\n\tif (copy_from_user(&hdlc_support, (void __user *)ioarg,\n\t\t\t\tsizeof(uint8_t)))\n\t\treturn -EFAULT;\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(current->tgid);\n\tif (session_info)\n\t\tsession_info->hdlc_disabled = hdlc_support;\n\telse\n\t\tdriver->hdlc_disabled = hdlc_support;\n\tmutex_unlock(&driver->md_session_lock);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\treturn 0;\n}'
p212
g153
sS'static int diag_ioctl_hdlc_toggle(unsigned long ioarg)\n{\n\tuint8_t hdlc_support, i;\n\tint peripheral = -EINVAL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (copy_from_user(&hdlc_support, (void __user *)ioarg,\n\t\t\t\tsizeof(uint8_t)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_pid(current->tgid);\n\tif (session_info)\n\t\tsession_info->hdlc_disabled = hdlc_support;\n\telse\n\t\tdriver->hdlc_disabled = hdlc_support;\n\n\tperipheral =\n\t\tdiag_md_session_match_pid_peripheral(current->tgid,\n\t\t0);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (peripheral > 0 && session_info) {\n\t\t\tif (peripheral & (1 << i))\n\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\tsession_info->hdlc_disabled;\n\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\tdriver->hdlc_disabled;\n\t\t} else {\n\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\tdriver->hdlc_disabled;\n\t\t}\n\t}\n\n\tmutex_unlock(&driver->md_session_lock);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\n\treturn 0;\n}'
p213
S'aef5910fdda8'
p214
ss(g126
S'diagfwd_mux_read_done'
p215
tp216
(dp217
S'static int diagfwd_mux_read_done(unsigned char *buf, int len, int ctxt)\n{\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (!driver->hdlc_disabled)\n\t\tdiag_process_hdlc_pkt(buf, len, 0);\n\telse\n\t\tdiag_process_non_hdlc_pkt(buf, len, 0);\n\n\tdiag_mux_queue_read(ctxt);\n\treturn 0;\n}'
p218
g131
ss(g132
S'diag_cmd_get_msg_mask'
p219
tp220
(dp221
S'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p222
S'57d3486c6e7a'
p223
sS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p224
g141
sS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p225
g137
sS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p226
g139
sS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p227
g143
ss(g116
S'diagfwd_data_process_done'
p228
tp229
(dp230
S'static void diagfwd_data_process_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   struct diagfwd_buf_t *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0, peripheral = 0;\n\tunsigned char *write_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t__func__, fwd_info->type,\n\t\t\tfwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\tperipheral =\n\t\tdiag_md_get_peripheral(buf->ctxt);\n\tif (peripheral < 0) {\n\t\tpr_err("diag:%s:%d invalid peripheral = %d\\n",\n\t\t\t__func__, __LINE__, peripheral);\n\t\tmutex_unlock(&fwd_info->data_mutex);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\thdlc_disabled = driver->p_hdlc_disabled[peripheral];\n\n\tif (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\tif (write_len <= 0)\n\t\t\tgoto end;\n\t\twrite_buf = buf->data_raw;\n\t} else {\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\n\t\twrite_len = check_bufsize_for_encoding(buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len,\n\t\t\tbuf->data_raw, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p231
g125
sS'static void diagfwd_data_process_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   struct diagfwd_buf_t *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0, peripheral = 0;\n\tunsigned char *write_buf = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t__func__, fwd_info->type,\n\t\t\tfwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\tperipheral =\n\t\tdiag_md_get_peripheral(buf->ctxt);\n\tif (peripheral < 0) {\n\t\tpr_err("diag:%s:%d invalid peripheral = %d\\n",\n\t\t\t__func__, __LINE__, peripheral);\n\t\tmutex_unlock(&fwd_info->data_mutex);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\thdlc_disabled = driver->p_hdlc_disabled[peripheral];\n\n\tif (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\tif (write_len <= 0)\n\t\t\tgoto end;\n\t\twrite_buf = buf->data_raw;\n\t} else {\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\n\t\twrite_len = check_bufsize_for_encoding(buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len,\n\t\t\tbuf->data_raw, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end_write;\n\t\t}\n\t}\n\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\nend_write:\n\tdiag_ws_release();\n\tif (buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p232
g123
sS'static void diagfwd_data_process_done(struct diagfwd_info *fwd_info,\n\t\t\t\t   struct diagfwd_buf_t *buf, int len)\n{\n\tint err = 0;\n\tint write_len = 0, peripheral = 0;\n\tunsigned char *write_buf = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!fwd_info || !buf || len <= 0) {\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tswitch (fwd_info->type) {\n\tcase TYPE_DATA:\n\tcase TYPE_CMD:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid type %d for peripheral %d\\n",\n\t\t\t__func__, fwd_info->type,\n\t\t\tfwd_info->peripheral);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&fwd_info->data_mutex);\n\n\tperipheral =\n\t\tdiag_md_get_peripheral(buf->ctxt);\n\tif (peripheral < 0) {\n\t\tpr_err("diag:%s:%d invalid peripheral = %d\\n",\n\t\t\t__func__, __LINE__, peripheral);\n\t\tmutex_unlock(&fwd_info->data_mutex);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\tdiag_ws_release();\n\t\treturn;\n\t}\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled) {\n\t\t/* The data is raw and and on APPS side HDLC is disabled */\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t       __func__, buf, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\tif (len > PERIPHERAL_BUF_SZ) {\n\t\t\tpr_err("diag: In %s, Incoming buffer too large %d, peripheral %d, type: %d\\n",\n\t\t\t       __func__, len, fwd_info->peripheral,\n\t\t\t       fwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\t\twrite_len = len;\n\t\tif (write_len <= 0)\n\t\t\tgoto end;\n\t\twrite_buf = buf->data_raw;\n\t} else {\n\t\tif (!buf) {\n\t\t\tpr_err("diag: In %s, no match for non encode buffer %pK, peripheral %d, type: %d\\n",\n\t\t\t\t__func__, buf, fwd_info->peripheral,\n\t\t\t\tfwd_info->type);\n\t\t\tgoto end;\n\t\t}\n\n\t\twrite_len = check_bufsize_for_encoding(buf, len);\n\t\tif (write_len <= 0) {\n\t\t\tpr_err("diag: error in checking buf for encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t\twrite_buf = buf->data;\n\t\terr = diag_add_hdlc_encoding(write_buf, &write_len,\n\t\t\tbuf->data_raw, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: error in adding hdlc encoding\\n");\n\t\t\tgoto end;\n\t\t}\n\t}\n\n\tif (write_len > 0) {\n\t\terr = diag_mux_write(DIAG_LOCAL_PROC, write_buf, write_len,\n\t\t\t\t     buf->ctxt);\n\t\tif (err) {\n\t\t\tpr_err_ratelimited("diag: In %s, unable to write to mux error: %d\\n",\n\t\t\t\t\t   __func__, err);\n\t\t\tgoto end;\n\t\t}\n\t}\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tdiagfwd_queue_read(fwd_info);\n\treturn;\n\nend:\n\tdiag_ws_release();\n\tmutex_unlock(&fwd_info->data_mutex);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"Marking buffer as free p: %d, t: %d, buf_num: %d\\n",\n\t\t\tfwd_info->peripheral, fwd_info->type,\n\t\t\tGET_BUF_NUM(buf->ctxt));\n\t\tdiagfwd_write_done(fwd_info->peripheral, fwd_info->type,\n\t\t\t\t   GET_BUF_NUM(buf->ctxt));\n\t}\n\tdiagfwd_queue_read(fwd_info);\n}'
p233
g121
ss(g132
S'diag_cmd_get_log_range'
p234
tp235
(dp236
S'static int diag_cmd_get_log_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = (struct diag_log_mask_t *)log_mask.ptr;\n\n\tif (!mask)\n\t\treturn -EINVAL;\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_RANGE;\n\trsp.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\n\tfor (i = 0; i < MAX_EQUIP_ID && write_len < dest_len; i++, mask++) {\n\t\t*(uint32_t *)(dest_buf + write_len) = mask->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t}\n\n\treturn write_len;\n}'
p237
g137
ss(g132
S'diag_cmd_update_event_mask'
p238
tp239
(dp240
S'static int diag_cmd_update_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, mask_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_event_mask_config_t);\n\tstruct diag_event_mask_config_t rsp;\n\tstruct diag_event_mask_config_t *req;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\treq = (struct diag_event_mask_config_t *)src_buf;\n\tmask_len = EVENT_COUNT_TO_BYTES(req->num_bits);\n\tif (mask_len <= 0 || mask_len > event_mask.mask_len) {\n\t\tpr_err("diag: In %s, invalid event mask len: %d\\n", __func__,\n\t\t       mask_len);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);\n\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_SET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tmemcpy(dest_buf + write_len, mask_info->ptr, mask_len);\n\twrite_len += mask_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p241
g137
sS'static int diag_cmd_update_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, mask_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_event_mask_config_t);\n\tstruct diag_event_mask_config_t rsp;\n\tstruct diag_event_mask_config_t *req;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_event_mask_config_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\treq = (struct diag_event_mask_config_t *)src_buf;\n\tmask_len = EVENT_COUNT_TO_BYTES(req->num_bits);\n\tif (mask_len <= 0 || mask_len > event_mask.mask_len) {\n\t\tpr_err("diag: In %s, invalid event mask len: %d\\n", __func__,\n\t\t       mask_len);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tif (src_len >= header_len + mask_len)\n\t\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);\n\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_SET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tmemcpy(dest_buf + write_len, mask_info->ptr, mask_len);\n\twrite_len += mask_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p242
g141
sS'static int diag_cmd_update_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, mask_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_event_mask_config_t);\n\tstruct diag_event_mask_config_t rsp;\n\tstruct diag_event_mask_config_t *req;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &event_mask : info->event_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\treq = (struct diag_event_mask_config_t *)src_buf;\n\tmask_len = EVENT_COUNT_TO_BYTES(req->num_bits);\n\tif (mask_len <= 0 || mask_len > event_mask.mask_len) {\n\t\tpr_err("diag: In %s, invalid event mask len: %d\\n", __func__,\n\t\t       mask_len);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tmemcpy(mask_info->ptr, src_buf + header_len, mask_len);\n\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(EVENT_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_SET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tmemcpy(dest_buf + write_len, mask_info->ptr, mask_len);\n\twrite_len += mask_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_event_mask_update(peripheral);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p243
g159
ss(S'drivers/char/diag/diag_memorydevice.c'
p244
S'diag_md_write'
p245
tp246
(dp247
S'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\n\tch = &diag_md[id];\n\tif (!ch || !ch->md_info_inited) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p248
S'5bed7228b299'
p249
sS'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tch = &diag_md[id];\n\tif (!ch)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p250
S'4ab88a87a831'
p251
sS'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\n\tch = &diag_md[id];\n\tif (!ch || !ch->md_info_inited) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\tmutex_unlock(&driver->md_session_lock);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p252
S'd1d4ca7a8303'
p253
sS'int diag_md_write(int id, unsigned char *buf, int len, int ctx)\n{\n\tint i, peripheral, pid = 0;\n\tuint8_t found = 0;\n\tunsigned long flags;\n\tstruct diag_md_info *ch = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (id < 0 || id >= NUM_DIAG_MD_DEV || id >= DIAG_NUM_PROC)\n\t\treturn -EINVAL;\n\n\tif (!buf || len < 0)\n\t\treturn -EINVAL;\n\n\tperipheral = diag_md_get_peripheral(ctx);\n\tif (peripheral < 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(peripheral);\n\tif (!session_info) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EIO;\n\t}\n\tpid = session_info->pid;\n\tmutex_unlock(&driver->md_session_lock);\n\n\tch = &diag_md[id];\n\tif (!ch || !ch->md_info_inited)\n\t\treturn -EINVAL;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].buf != buf)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tpr_err_ratelimited("diag: trying to write the same buffer buf: %pK, len: %d, back to the table for p: %d, t: %d, buf_num: %d, proc: %d, i: %d\\n",\n\t\t\t\t   buf, ch->tbl[i].len, GET_BUF_PERIPHERAL(ctx),\n\t\t\t\t   GET_BUF_TYPE(ctx), GET_BUF_NUM(ctx), id, i);\n\t\tch->tbl[i].buf = NULL;\n\t\tch->tbl[i].len = 0;\n\t\tch->tbl[i].ctx = 0;\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (found)\n\t\treturn -ENOMEM;\n\n\tspin_lock_irqsave(&ch->lock, flags);\n\tfor (i = 0; i < ch->num_tbl_entries && !found; i++) {\n\t\tif (ch->tbl[i].len == 0) {\n\t\t\tch->tbl[i].buf = buf;\n\t\t\tch->tbl[i].len = len;\n\t\t\tch->tbl[i].ctx = ctx;\n\t\t\tfound = 1;\n\t\t\tdiag_ws_on_read(DIAG_WS_MUX, len);\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&ch->lock, flags);\n\n\tif (!found) {\n\t\tpr_err_ratelimited("diag: Unable to find an empty space in table, please reduce logging rate, proc: %d\\n",\n\t\t\t\t   id);\n\t\treturn -ENOMEM;\n\t}\n\n\tfound = 0;\n\tfor (i = 0; i < driver->num_clients && !found; i++) {\n\t\tif ((driver->client_map[i].pid != pid) ||\n\t\t    (driver->client_map[i].pid == 0))\n\t\t\tcontinue;\n\n\t\tfound = 1;\n\t\tif (!(driver->data_ready[i] & USER_SPACE_DATA_TYPE)) {\n\t\t\tdriver->data_ready[i] |= USER_SPACE_DATA_TYPE;\n\t\t\tatomic_inc(&driver->data_ready_notif[i]);\n\t\t}\n\t\tpr_debug("diag: wake up logging process\\n");\n\t\twake_up_interruptible(&driver->wait_q);\n\t}\n\n\tif (!found)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}'
p254
S'd3cd55b71dd3'
p255
ss(g144
S'diag_user_process_raw_data'
p256
tp257
(dp258
S'static int diag_user_process_raw_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint ret = 0;\n\tint token_offset = 0;\n\tint remote_proc = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\n\tif (!buf || len <= 0 || len > CALLBACK_BUF_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data)\n\t\treturn -ENOMEM;\n\n\terr = copy_from_user(user_space_data, buf, len);\n\tif (err) {\n\t\tpr_err("diag: copy failed for user space data\\n");\n\t\tgoto fail;\n\t}\n\n\t/* Check for proc_type */\n\tif (len >= sizeof(int))\n\t\tremote_proc = diag_get_remote(*(int *)user_space_data);\n\tif (remote_proc) {\n\t\ttoken_offset = sizeof(int);\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: In %s, possible integer underflow, payload size: %d\\n",\n\t\t       __func__, len);\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tlen -= sizeof(int);\n\t}\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(user_space_data +\n\t\t\t\t\t\ttoken_offset, len)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (remote_proc) {\n\t\tret = diag_send_raw_data_remote(remote_proc,\n\t\t\t\t(void *)(user_space_data + token_offset),\n\t\t\t\tlen, USER_SPACE_RAW_DATA);\n\t\tif (ret) {\n\t\t\tpr_err("diag: Error sending data to remote proc %d, err: %d\\n",\n\t\t\t\tremote_proc, ret);\n\t\t}\n\t} else {\n\t\twait_event_interruptible(driver->wait_q,\n\t\t\t\t\t (driver->in_busy_pktdata == 0));\n\t\tret = diag_process_apps_pkt(user_space_data, len,\n\t\t\tcurrent->tgid);\n\t\tif (ret == 1)\n\t\t\tdiag_send_error_rsp((void *)(user_space_data), len,\n\t\t\t\t\t\tcurrent->tgid);\n\t}\nfail:\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\treturn ret;\n}'
p259
S'a77c16d4981b'
p260
sS'static int diag_user_process_raw_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint ret = 0;\n\tint token_offset = 0;\n\tint remote_proc = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\n\tif (!buf || len <= 0 || len > CALLBACK_BUF_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data)\n\t\treturn -ENOMEM;\n\n\terr = copy_from_user(user_space_data, buf, len);\n\tif (err) {\n\t\tpr_err("diag: copy failed for user space data\\n");\n\t\tgoto fail;\n\t}\n\n\t/* Check for proc_type */\n\tremote_proc = diag_get_remote(*(int *)user_space_data);\n\tif (remote_proc) {\n\t\ttoken_offset = sizeof(int);\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: In %s, possible integer underflow, payload size: %d\\n",\n\t\t       __func__, len);\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tlen -= sizeof(int);\n\t}\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(user_space_data +\n\t\t\t\t\t\ttoken_offset)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\t\tuser_space_data = NULL;\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (remote_proc) {\n\t\tret = diag_send_raw_data_remote(remote_proc,\n\t\t\t\t(void *)(user_space_data + token_offset),\n\t\t\t\tlen, USER_SPACE_RAW_DATA);\n\t\tif (ret) {\n\t\t\tpr_err("diag: Error sending data to remote proc %d, err: %d\\n",\n\t\t\t\tremote_proc, ret);\n\t\t}\n\t} else {\n\t\twait_event_interruptible(driver->wait_q,\n\t\t\t\t\t (driver->in_busy_pktdata == 0));\n\t\tret = diag_process_apps_pkt(user_space_data, len,\n\t\t\tcurrent->tgid);\n\t\tif (ret == 1)\n\t\t\tdiag_send_error_rsp((void *)(user_space_data), len,\n\t\t\t\t\t\tcurrent->tgid);\n\t}\nfail:\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\treturn ret;\n}'
p261
g153
ss(g132
S'diag_process_apps_masks'
p262
tp263
(dp264
S'int diag_process_apps_masks(unsigned char *buf, int len, int pid)\n{\n\tint size = 0, sub_cmd = 0;\n\tint (*hdlr)(unsigned char *src_buf, int src_len,\n\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (*buf == DIAG_CMD_LOG_CONFIG) {\n\t\tsub_cmd = *(int *)(buf + sizeof(int));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_LOG_DISABLE:\n\t\t\thdlr = diag_cmd_disable_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_RANGE:\n\t\t\thdlr = diag_cmd_get_log_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_LOG_MASK:\n\t\t\thdlr = diag_cmd_set_log_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_MASK:\n\t\t\thdlr = diag_cmd_get_log_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_MSG_CONFIG) {\n\t\tsub_cmd = *(uint8_t *)(buf + sizeof(uint8_t));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_GET_SSID_RANGE:\n\t\t\thdlr = diag_cmd_get_ssid_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_BUILD_MASK:\n\t\t\thdlr = diag_cmd_get_build_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_MSG_MASK:\n\t\t\thdlr = diag_cmd_get_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_ALL_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_all_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_GET_EVENT_MASK) {\n\t\thdlr = diag_cmd_get_event_mask;\n\t} else if (*buf == DIAG_CMD_SET_EVENT_MASK) {\n\t\thdlr = diag_cmd_update_event_mask;\n\t\tdriver->set_mask_cmd = 1;\n\t} else if (*buf == DIAG_CMD_EVENT_TOGGLE) {\n\t\thdlr = diag_cmd_toggle_events;\n\t\tdriver->set_mask_cmd = 1;\n\t}\n\n\tif (hdlr)\n\t\tsize = hdlr(buf, len, driver->apps_rsp_buf,\n\t\t\t    DIAG_MAX_RSP_SIZE, pid);\n\n\treturn (size > 0) ? size : 0;\n}'
p265
S'23405c80e9d7'
p266
sS'int diag_process_apps_masks(unsigned char *buf, int len, int pid)\n{\n\tint size = 0, sub_cmd = 0;\n\tint (*hdlr)(unsigned char *src_buf, int src_len,\n\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (*buf == DIAG_CMD_LOG_CONFIG) {\n\t\tsub_cmd = *(int *)(buf + sizeof(int));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_LOG_DISABLE:\n\t\t\thdlr = diag_cmd_disable_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_RANGE:\n\t\t\thdlr = diag_cmd_get_log_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_LOG_MASK:\n\t\t\thdlr = diag_cmd_set_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_MASK:\n\t\t\thdlr = diag_cmd_get_log_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_MSG_CONFIG) {\n\t\tsub_cmd = *(uint8_t *)(buf + sizeof(uint8_t));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_GET_SSID_RANGE:\n\t\t\thdlr = diag_cmd_get_ssid_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_BUILD_MASK:\n\t\t\thdlr = diag_cmd_get_build_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_MSG_MASK:\n\t\t\thdlr = diag_cmd_get_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_ALL_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_all_msg_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_GET_EVENT_MASK) {\n\t\thdlr = diag_cmd_get_event_mask;\n\t} else if (*buf == DIAG_CMD_SET_EVENT_MASK) {\n\t\thdlr = diag_cmd_update_event_mask;\n\t} else if (*buf == DIAG_CMD_EVENT_TOGGLE) {\n\t\thdlr = diag_cmd_toggle_events;\n\t}\n\n\tif (hdlr)\n\t\tsize = hdlr(buf, len, driver->apps_rsp_buf,\n\t\t\t    DIAG_MAX_RSP_SIZE, pid);\n\n\treturn (size > 0) ? size : 0;\n}'
p267
g137
sS'int diag_process_apps_masks(unsigned char *buf, int len, int pid)\n{\n\tint size = 0, sub_cmd = 0;\n\tint (*hdlr)(unsigned char *src_buf, int src_len,\n\t\t    unsigned char *dest_buf, int dest_len, int pid) = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EINVAL;\n\n\tif (*buf == DIAG_CMD_LOG_CONFIG) {\n\t\tif (len < (2 * sizeof(int)))\n\t\t\treturn -EINVAL;\n\t\tsub_cmd = *(int *)(buf + sizeof(int));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_LOG_DISABLE:\n\t\t\thdlr = diag_cmd_disable_log_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_RANGE:\n\t\t\thdlr = diag_cmd_get_log_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_LOG_MASK:\n\t\t\thdlr = diag_cmd_set_log_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_LOG_MASK:\n\t\t\thdlr = diag_cmd_get_log_mask;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_MSG_CONFIG) {\n\t\tif (len < (2 * sizeof(uint8_t)))\n\t\t\treturn -EINVAL;\n\t\tsub_cmd = *(uint8_t *)(buf + sizeof(uint8_t));\n\t\tswitch (sub_cmd) {\n\t\tcase DIAG_CMD_OP_GET_SSID_RANGE:\n\t\t\thdlr = diag_cmd_get_ssid_range;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_BUILD_MASK:\n\t\t\thdlr = diag_cmd_get_build_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_GET_MSG_MASK:\n\t\t\thdlr = diag_cmd_get_msg_mask;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\tcase DIAG_CMD_OP_SET_ALL_MSG_MASK:\n\t\t\thdlr = diag_cmd_set_all_msg_mask;\n\t\t\tdriver->set_mask_cmd = 1;\n\t\t\tbreak;\n\t\t}\n\t} else if (*buf == DIAG_CMD_GET_EVENT_MASK) {\n\t\thdlr = diag_cmd_get_event_mask;\n\t} else if (*buf == DIAG_CMD_SET_EVENT_MASK) {\n\t\thdlr = diag_cmd_update_event_mask;\n\t\tdriver->set_mask_cmd = 1;\n\t} else if (*buf == DIAG_CMD_EVENT_TOGGLE) {\n\t\thdlr = diag_cmd_toggle_events;\n\t\tdriver->set_mask_cmd = 1;\n\t}\n\n\tif (hdlr)\n\t\tsize = hdlr(buf, len, driver->apps_rsp_buf,\n\t\t\t    DIAG_MAX_RSP_SIZE, pid);\n\n\treturn (size > 0) ? size : 0;\n}'
p268
g141
ss(g126
S'diag_update_md_clients'
p269
tp270
(dp271
S'void diag_update_md_clients(unsigned int type)\n{\n\tint i, j;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfor (j = 0; j < driver->num_clients; j++) {\n\t\t\t\tif (driver->client_map[j].pid != 0 &&\n\t\t\t\t\tdriver->client_map[j].pid ==\n\t\t\t\t\tdriver->md_session_map[i]->pid) {\n\t\t\t\t\tif (!(driver->data_ready[j] & type)) {\n\t\t\t\t\t\tdriver->data_ready[j] |= type;\n\t\t\t\t\t\tatomic_inc(\n\t\t\t\t\t\t&driver->data_ready_notif[j]);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t}\n\tmutex_unlock(&driver->md_session_lock);\n\twake_up_interruptible(&driver->wait_q);\n\tmutex_unlock(&driver->diagchar_mutex);\n}'
p272
g131
ss(g126
S'diag_process_hdlc_pkt'
p273
tp274
(dp275
S'void diag_process_hdlc_pkt(void *data, unsigned int len, int pid)\n{\n\tint err = 0;\n\tint ret = 0;\n\n\tif (len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\tpr_err("diag: In %s, invalid length: %d\\n", __func__, len);\n\t\treturn;\n\t}\n\n\tmutex_lock(&driver->diag_hdlc_mutex);\n\tpr_debug("diag: In %s, received packet of length: %d, req_buf_len: %d\\n",\n\t\t __func__, len, driver->hdlc_buf_len);\n\n\tif (driver->hdlc_buf_len >= DIAG_MAX_REQ_SIZE) {\n\t\tpr_err("diag: In %s, request length is more than supported len. Dropping packet.\\n",\n\t\t       __func__);\n\t\tgoto fail;\n\t}\n\n\thdlc_decode->dest_ptr = driver->hdlc_buf + driver->hdlc_buf_len;\n\thdlc_decode->dest_size = DIAG_MAX_HDLC_BUF_SIZE - driver->hdlc_buf_len;\n\thdlc_decode->src_ptr = data;\n\thdlc_decode->src_size = len;\n\thdlc_decode->src_idx = 0;\n\thdlc_decode->dest_idx = 0;\n\n\tret = diag_hdlc_decode(hdlc_decode);\n\t/*\n\t * driver->hdlc_buf is of size DIAG_MAX_HDLC_BUF_SIZE. But the decoded\n\t * packet should be within DIAG_MAX_REQ_SIZE.\n\t */\n\tif (driver->hdlc_buf_len + hdlc_decode->dest_idx <= DIAG_MAX_REQ_SIZE) {\n\t\tdriver->hdlc_buf_len += hdlc_decode->dest_idx;\n\t} else {\n\t\tpr_err_ratelimited("diag: In %s, Dropping packet. pkt_size: %d, max: %d\\n",\n\t\t\t\t   __func__,\n\t\t\t\t   driver->hdlc_buf_len + hdlc_decode->dest_idx,\n\t\t\t\t   DIAG_MAX_REQ_SIZE);\n\t\tgoto fail;\n\t}\n\n\tif (ret == HDLC_COMPLETE) {\n\t\terr = crc_check(driver->hdlc_buf, driver->hdlc_buf_len);\n\t\tif (err) {\n\t\t\t/* CRC check failed. */\n\t\t\tpr_err_ratelimited("diag: In %s, bad CRC. Dropping packet\\n",\n\t\t\t\t\t   __func__);\n\t\t\tgoto fail;\n\t\t}\n\t\tdriver->hdlc_buf_len -= HDLC_FOOTER_LEN;\n\n\t\tif (driver->hdlc_buf_len < 1) {\n\t\t\tpr_err_ratelimited("diag: In %s, message is too short, len: %d, dest len: %d\\n",\n\t\t\t\t\t   __func__, driver->hdlc_buf_len,\n\t\t\t\t\t   hdlc_decode->dest_idx);\n\t\t\tgoto fail;\n\t\t}\n\n\t\terr = diag_process_apps_pkt(driver->hdlc_buf,\n\t\t\t\t\t    driver->hdlc_buf_len, pid);\n\t\tif (err < 0)\n\t\t\tgoto fail;\n\t} else {\n\t\tgoto end;\n\t}\n\n\tdriver->hdlc_buf_len = 0;\n\tmutex_unlock(&driver->diag_hdlc_mutex);\n\treturn;\n\nfail:\n\t/*\n\t * Tools needs to get a response in order to start its\n\t * recovery algorithm. Send an error response if the\n\t * packet is not in expected format.\n\t */\n\tdiag_send_error_rsp(driver->hdlc_buf, driver->hdlc_buf_len, pid);\n\tdriver->hdlc_buf_len = 0;\nend:\n\tmutex_unlock(&driver->diag_hdlc_mutex);\n}'
p276
g131
ss(g144
S'diag_user_process_userspace_data'
p277
tp278
(dp279
S'static int diag_user_process_userspace_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint max_retries = 3;\n\tint retry_count = 0;\n\tint remote_proc = 0;\n\tint token_offset = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > USER_SPACE_DATA) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tdo {\n\t\tif (!driver->user_space_data_busy)\n\t\t\tbreak;\n\t\tretry_count++;\n\t\tusleep_range(10000, 10100);\n\t} while (retry_count < max_retries);\n\n\tif (driver->user_space_data_busy)\n\t\treturn -EAGAIN;\n\n\terr = copy_from_user(driver->user_space_data_buf, buf, len);\n\tif (err) {\n\t\tpr_err("diag: In %s, failed to copy data from userspace, err: %d\\n",\n\t\t       __func__, err);\n\t\treturn -EIO;\n\t}\n\n\t/* Check for proc_type */\n\tremote_proc = diag_get_remote(*(int *)driver->user_space_data_buf);\n\tif (remote_proc) {\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: Integer underflow in %s, payload size: %d",\n\t\t\t       __func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\ttoken_offset = sizeof(int);\n\t\tlen -= sizeof(int);\n\t}\n\n\t/* Check masks for On-Device logging */\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(driver->user_space_data_buf +\n\t\t\t\t\t   token_offset)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t/* send masks to local processor now */\n\tif (!remote_proc) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\tpr_err("diag:In %s request came from invalid md session pid:%d",\n\t\t\t\t__func__, current->tgid);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (session_info)\n\t\t\thdlc_disabled = session_info->hdlc_disabled;\n\t\telse\n\t\t\thdlc_disabled = driver->hdlc_disabled;\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (!hdlc_disabled)\n\t\t\tdiag_process_hdlc_pkt((void *)\n\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\tlen, current->tgid);\n\t\telse\n\t\t\tdiag_process_non_hdlc_pkt((char *)\n\t\t\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\t\t\tlen, current->tgid);\n\t\treturn 0;\n\t}\n\n\terr = diag_process_userspace_remote(remote_proc,\n\t\t\t\t\t    driver->user_space_data_buf +\n\t\t\t\t\t    token_offset, len);\n\tif (err) {\n\t\tdriver->user_space_data_busy = 0;\n\t\tpr_err("diag: Error sending mask to remote proc %d, err: %d\\n",\n\t\t       remote_proc, err);\n\t}\n\n\treturn err;\n}'
p280
g153
sS'static int diag_user_process_userspace_data(const char __user *buf, int len)\n{\n\tint err = 0;\n\tint max_retries = 3;\n\tint retry_count = 0;\n\tint remote_proc = 0;\n\tint token_offset = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > USER_SPACE_DATA) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tdo {\n\t\tif (!driver->user_space_data_busy)\n\t\t\tbreak;\n\t\tretry_count++;\n\t\tusleep_range(10000, 10100);\n\t} while (retry_count < max_retries);\n\n\tif (driver->user_space_data_busy)\n\t\treturn -EAGAIN;\n\n\terr = copy_from_user(driver->user_space_data_buf, buf, len);\n\tif (err) {\n\t\tpr_err("diag: In %s, failed to copy data from userspace, err: %d\\n",\n\t\t       __func__, err);\n\t\treturn -EIO;\n\t}\n\n\t/* Check for proc_type */\n\tremote_proc = diag_get_remote(*(int *)driver->user_space_data_buf);\n\tif (remote_proc) {\n\t\tif (len <= MIN_SIZ_ALLOW) {\n\t\t\tpr_err("diag: Integer underflow in %s, payload size: %d",\n\t\t\t       __func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\ttoken_offset = sizeof(int);\n\t\tlen -= sizeof(int);\n\t}\n\n\t/* Check masks for On-Device logging */\n\tif (driver->mask_check) {\n\t\tif (!mask_request_validate(driver->user_space_data_buf +\n\t\t\t\t\t   token_offset, len)) {\n\t\t\tpr_alert("diag: mask request Invalid\\n");\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\t/* send masks to local processor now */\n\tif (!remote_proc) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\tpr_err("diag:In %s request came from invalid md session pid:%d",\n\t\t\t\t__func__, current->tgid);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (session_info)\n\t\t\thdlc_disabled = session_info->hdlc_disabled;\n\t\telse\n\t\t\thdlc_disabled = driver->hdlc_disabled;\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (!hdlc_disabled)\n\t\t\tdiag_process_hdlc_pkt((void *)\n\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\tlen, current->tgid);\n\t\telse\n\t\t\tdiag_process_non_hdlc_pkt((char *)\n\t\t\t\t\t\t(driver->user_space_data_buf),\n\t\t\t\t\t\tlen, current->tgid);\n\t\treturn 0;\n\t}\n\n\terr = diag_process_userspace_remote(remote_proc,\n\t\t\t\t\t    driver->user_space_data_buf +\n\t\t\t\t\t    token_offset, len);\n\tif (err) {\n\t\tdriver->user_space_data_busy = 0;\n\t\tpr_err("diag: Error sending mask to remote proc %d, err: %d\\n",\n\t\t       remote_proc, err);\n\t}\n\n\treturn err;\n}'
p281
g260
ss(g126
S'hdlc_reset_timer_start'
p282
tp283
(dp284
S'static void hdlc_reset_timer_start(int pid)\n{\n\tstruct diag_md_session_t *info = NULL;\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tif (!hdlc_timer_in_progress) {\n\t\thdlc_timer_in_progress = 1;\n\t\tif (info)\n\t\t\tmod_timer(&info->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t\telse\n\t\t\tmod_timer(&driver->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t}\n\tmutex_unlock(&driver->md_session_lock);\n}'
p285
g131
sS'static void hdlc_reset_timer_start(int pid)\n{\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tif (!hdlc_timer_in_progress) {\n\t\thdlc_timer_in_progress = 1;\n\t\tif (info)\n\t\t\tmod_timer(&info->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t\telse\n\t\t\tmod_timer(&driver->hdlc_reset_timer,\n\t\t\t  jiffies + msecs_to_jiffies(200));\n\t}\n\tmutex_unlock(&driver->md_session_lock);\n}'
p286
g203
ss(g144
S'diag_md_peripheral_switch'
p287
tp288
(dp289
S'static int diag_md_peripheral_switch(int pid,\n\t\t\t\tint peripheral_mask, int req_mode) {\n\tint i, bit = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn -EINVAL;\n\tif (req_mode != DIAG_USB_MODE || req_mode != DIAG_MEMORY_DEVICE_MODE ||\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * check that md_session_map for i == session_info,\n\t * if not then race condition occurred and bail\n\t */\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tbit = MD_PERIPHERAL_MASK(i) & peripheral_mask;\n\t\tif (!bit)\n\t\t\tcontinue;\n\t\tif (req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE) {\n\t\t\tif (driver->md_session_map[i] != session_info)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = NULL;\n\t\t\tdriver->md_session_mask &= ~bit;\n\t\t\tsession_info->peripheral_mask &= ~bit;\n\n\t\t} else {\n\t\t\tif (driver->md_session_map[i] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = session_info;\n\t\t\tdriver->md_session_mask |= bit;\n\t\t\tsession_info->peripheral_mask |= bit;\n\n\t\t}\n\t}\n\n\tdriver->md_session_mode = DIAG_MD_PERIPHERAL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "Changed Peripherals:0x%x to mode:%d\\n",\n\t\tperipheral_mask, req_mode);\n}'
p290
g192
sS'static int diag_md_peripheral_switch(int pid,\n\t\t\t\tint peripheral_mask, int req_mode) {\n\tint i, bit = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn -EINVAL;\n\tif (req_mode != DIAG_USB_MODE || req_mode != DIAG_MEMORY_DEVICE_MODE)\n\t\treturn -EINVAL;\n\n\t/*\n\t * check that md_session_map for i == session_info,\n\t * if not then race condition occurred and bail\n\t */\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tbit = MD_PERIPHERAL_MASK(i) & peripheral_mask;\n\t\tif (!bit)\n\t\t\tcontinue;\n\t\tif (req_mode == DIAG_USB_MODE) {\n\t\t\tif (driver->md_session_map[i] != session_info)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = NULL;\n\t\t\tdriver->md_session_mask &= ~bit;\n\t\t\tsession_info->peripheral_mask &= ~bit;\n\n\t\t} else {\n\t\t\tif (driver->md_session_map[i] != NULL)\n\t\t\t\treturn -EINVAL;\n\t\t\tdriver->md_session_map[i] = session_info;\n\t\t\tdriver->md_session_mask |= bit;\n\t\t\tsession_info->peripheral_mask |= bit;\n\n\t\t}\n\t}\n\n\tdriver->md_session_mode = DIAG_MD_PERIPHERAL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "Changed Peripherals:0x%x to mode:%d\\n",\n\t\tperipheral_mask, req_mode);\n}'
p291
g153
ss(g144
S'diag_md_session_close'
p292
tp293
(dp294
S'static void diag_md_session_close(int pid)\n{\n\tint i;\n\tuint8_t found = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != session_info)\n\t\t\tcontinue;\n\t\tdriver->md_session_map[i] = NULL;\n\t\tdriver->md_session_mask &= ~session_info->peripheral_mask;\n\t}\n\tdiag_log_mask_free(session_info->log_mask);\n\tkfree(session_info->log_mask);\n\tsession_info->log_mask = NULL;\n\tdiag_msg_mask_free(session_info->msg_mask);\n\tkfree(session_info->msg_mask);\n\tsession_info->msg_mask = NULL;\n\tdiag_event_mask_free(session_info->event_mask);\n\tkfree(session_info->event_mask);\n\tsession_info->event_mask = NULL;\n\tdel_timer(&session_info->hdlc_reset_timer);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS && !found; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfound = 1;\n\t}\n\n\tdriver->md_session_mode = (found) ? DIAG_MD_PERIPHERAL : DIAG_MD_NONE;\n\tkfree(session_info);\n\tsession_info = NULL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "cleared up session\\n");\n}'
p295
g153
sS'static void diag_md_session_close(int pid)\n{\n\tint i;\n\tuint8_t found = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != session_info)\n\t\t\tcontinue;\n\t\tdriver->md_session_map[i] = NULL;\n\t\tdriver->md_session_mask &= ~session_info->peripheral_mask;\n\t}\n\tdiag_log_mask_free(session_info->log_mask);\n\tkfree(session_info->log_mask);\n\tsession_info->log_mask = NULL;\n\tdiag_msg_mask_free(session_info->msg_mask,\n\t\tsession_info);\n\tkfree(session_info->msg_mask);\n\tsession_info->msg_mask = NULL;\n\tdiag_event_mask_free(session_info->event_mask);\n\tkfree(session_info->event_mask);\n\tsession_info->event_mask = NULL;\n\tdel_timer(&session_info->hdlc_reset_timer);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS && !found; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfound = 1;\n\t}\n\n\tdriver->md_session_mode = (found) ? DIAG_MD_PERIPHERAL : DIAG_MD_NONE;\n\tkfree(session_info);\n\tsession_info = NULL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "cleared up session\\n");\n}'
p296
S'57d3486c6e7a'
p297
ss(g132
S'diag_cmd_set_msg_mask'
p298
tp299
(dp300
S'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (i < (driver->msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p301
g159
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tif (mask_size && src_len >= header_len + mask_size)\n\t\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p302
S'7dca8885b04d'
p303
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (driver->msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p304
g139
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p305
g141
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (i < (driver->msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p306
g137
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p307
g223
ss(g132
S'diag_cmd_get_log_mask'
p308
tp309
(dp310
S'static int diag_cmd_get_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint status = LOG_STATUS_INVALID;\n\tint write_len = 0;\n\tint read_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_mask_t *log_item = NULL;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_MASK;\n\t/*\n\t * Don\'t copy the response header now. Copy at the end after\n\t * calculating the status field value\n\t */\n\twrite_len += rsp_header_len;\n\n\tlog_item = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!log_item->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask: %pK\\n",\n\t\t\t__func__, log_item);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, log_item++) {\n\t\tif (log_item->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&log_item->lock);\n\t\tmask_size = LOG_ITEMS_TO_SIZE(log_item->num_items_tools);\n\t\t/*\n\t\t * Make sure we have space to fill the response in the buffer.\n\t\t * Destination buffer should atleast be able to hold equip_id\n\t\t * (uint32_t), num_items(uint32_t), mask (mask_size) and the\n\t\t * response header.\n\t\t */\n\t\tif ((mask_size + (2 * sizeof(uint32_t)) + rsp_header_len) >\n\t\t\t\t\t\t\t\tdest_len) {\n\t\t\tpr_err("diag: In %s, invalid length: %d, max rsp_len: %d\\n",\n\t\t\t\t__func__, mask_size, dest_len);\n\t\t\tstatus = LOG_STATUS_FAIL;\n\t\t\tmutex_unlock(&log_item->lock);\n\t\t\tbreak;\n\t\t}\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->equip_id;\n\t\twrite_len += sizeof(uint32_t);\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t\tif (mask_size > 0) {\n\t\t\tmemcpy(dest_buf + write_len, log_item->ptr, mask_size);\n\t\t\twrite_len += mask_size;\n\t\t}\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending log e %d num_items %d size %d\\n",\n\t\t\t log_item->equip_id, log_item->num_items_tools,\n\t\t\t log_item->range_tools);\n\t\tmutex_unlock(&log_item->lock);\n\t\tstatus = LOG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\trsp.status = status;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p311
g141
sS'static int diag_cmd_get_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint status = LOG_STATUS_INVALID;\n\tint write_len = 0;\n\tint read_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_mask_t *log_item = NULL;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_MASK;\n\t/*\n\t * Don\'t copy the response header now. Copy at the end after\n\t * calculating the status field value\n\t */\n\twrite_len += rsp_header_len;\n\n\tlog_item = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!log_item->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask: %pK\\n",\n\t\t\t__func__, log_item);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, log_item++) {\n\t\tif (log_item->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&log_item->lock);\n\t\tmask_size = LOG_ITEMS_TO_SIZE(log_item->num_items_tools);\n\t\t/*\n\t\t * Make sure we have space to fill the response in the buffer.\n\t\t * Destination buffer should atleast be able to hold equip_id\n\t\t * (uint32_t), num_items(uint32_t), mask (mask_size) and the\n\t\t * response header.\n\t\t */\n\t\tif ((mask_size + (2 * sizeof(uint32_t)) + rsp_header_len) >\n\t\t\t\t\t\t\t\tdest_len) {\n\t\t\tpr_err("diag: In %s, invalid length: %d, max rsp_len: %d\\n",\n\t\t\t\t__func__, mask_size, dest_len);\n\t\t\tstatus = LOG_STATUS_FAIL;\n\t\t\tmutex_unlock(&log_item->lock);\n\t\t\tbreak;\n\t\t}\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->equip_id;\n\t\twrite_len += sizeof(uint32_t);\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t\tif (mask_size > 0) {\n\t\t\tmemcpy(dest_buf + write_len, log_item->ptr, mask_size);\n\t\t\twrite_len += mask_size;\n\t\t}\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending log e %d num_items %d size %d\\n",\n\t\t\t log_item->equip_id, log_item->num_items_tools,\n\t\t\t log_item->range_tools);\n\t\tmutex_unlock(&log_item->lock);\n\t\tstatus = LOG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\trsp.status = status;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p312
g137
sS'static int diag_cmd_get_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint status = LOG_STATUS_INVALID;\n\tint write_len = 0;\n\tint read_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_mask_t *log_item = NULL;\n\tstruct diag_log_config_get_req_t *req;\n\tstruct diag_log_config_rsp_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_get_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\treq = (struct diag_log_config_get_req_t *)src_buf;\n\tread_len += req_header_len;\n\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_LOG_MASK;\n\t/*\n\t * Don\'t copy the response header now. Copy at the end after\n\t * calculating the status field value\n\t */\n\twrite_len += rsp_header_len;\n\n\tlog_item = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!log_item->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask: %pK\\n",\n\t\t\t__func__, log_item);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, log_item++) {\n\t\tif (log_item->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&log_item->lock);\n\t\tmask_size = LOG_ITEMS_TO_SIZE(log_item->num_items_tools);\n\t\t/*\n\t\t * Make sure we have space to fill the response in the buffer.\n\t\t * Destination buffer should atleast be able to hold equip_id\n\t\t * (uint32_t), num_items(uint32_t), mask (mask_size) and the\n\t\t * response header.\n\t\t */\n\t\tif ((mask_size + (2 * sizeof(uint32_t)) + rsp_header_len) >\n\t\t\t\t\t\t\t\tdest_len) {\n\t\t\tpr_err("diag: In %s, invalid length: %d, max rsp_len: %d\\n",\n\t\t\t\t__func__, mask_size, dest_len);\n\t\t\tstatus = LOG_STATUS_FAIL;\n\t\t\tmutex_unlock(&log_item->lock);\n\t\t\tbreak;\n\t\t}\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->equip_id;\n\t\twrite_len += sizeof(uint32_t);\n\t\t*(uint32_t *)(dest_buf + write_len) = log_item->num_items_tools;\n\t\twrite_len += sizeof(uint32_t);\n\t\tif (mask_size > 0) {\n\t\t\tmemcpy(dest_buf + write_len, log_item->ptr, mask_size);\n\t\t\twrite_len += mask_size;\n\t\t}\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending log e %d num_items %d size %d\\n",\n\t\t\t log_item->equip_id, log_item->num_items_tools,\n\t\t\t log_item->range_tools);\n\t\tmutex_unlock(&log_item->lock);\n\t\tstatus = LOG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\n\trsp.status = status;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p313
S'8ac6e23e1acb'
p314
ss(g132
S'diag_cmd_set_log_mask'
p315
tp316
(dp317
S'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p318
g137
sS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p319
S'c9ebd8b20d52'
p320
sS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p321
g159
sS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0 && src_len >= read_len + mask_size)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p322
g141
ss(g132
S'diag_cmd_get_ssid_range'
p323
tp324
(dp325
S'static int diag_cmd_get_ssid_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tstruct diag_msg_ssid_query_t rsp;\n\tstruct diag_ssid_range_t ssid_range;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\tdriver->msg_mask_tbl_count;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_SSID_RANGE;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.count = msg_mask_tbl_count;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmask_ptr = (struct diag_msg_mask_t *)mask_info->ptr;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask_ptr++) {\n\t\tif (write_len + sizeof(ssid_range) > dest_len) {\n\t\t\tpr_err("diag: In %s, Truncating response due to size limitations of rsp buffer\\n",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tssid_range.ssid_first = mask_ptr->ssid_first;\n\t\tssid_range.ssid_last = mask_ptr->ssid_last_tools;\n\t\tmemcpy(dest_buf + write_len, &ssid_range, sizeof(ssid_range));\n\t\twrite_len += sizeof(ssid_range);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p326
g223
sS'static int diag_cmd_get_ssid_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tstruct diag_msg_ssid_query_t rsp;\n\tstruct diag_ssid_range_t ssid_range;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_SSID_RANGE;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.count = driver->msg_mask_tbl_count;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmask_ptr = (struct diag_msg_mask_t *)mask_info->ptr;\n\tfor (i = 0; i <  driver->msg_mask_tbl_count; i++, mask_ptr++) {\n\t\tif (write_len + sizeof(ssid_range) > dest_len) {\n\t\t\tpr_err("diag: In %s, Truncating response due to size limitations of rsp buffer\\n",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tssid_range.ssid_first = mask_ptr->ssid_first;\n\t\tssid_range.ssid_last = mask_ptr->ssid_last_tools;\n\t\tmemcpy(dest_buf + write_len, &ssid_range, sizeof(ssid_range));\n\t\twrite_len += sizeof(ssid_range);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p327
g137
ss(g144
S'diag_clear_masks'
p328
tp329
(dp330
S'void diag_clear_masks(int pid)\n{\n\tint ret;\n\tchar cmd_disable_log_mask[] = { 0x73, 0, 0, 0, 0, 0, 0, 0};\n\tchar cmd_disable_msg_mask[] = { 0x7D, 0x05, 0, 0, 0, 0, 0, 0};\n\tchar cmd_disable_event_mask[] = { 0x60, 0};\n\n\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t"diag: %s: masks clear request upon %s\\n", __func__,\n\t((pid) ? "ODL exit" : "USB Disconnection"));\n\n\tret = diag_process_apps_masks(cmd_disable_log_mask,\n\t\t\tsizeof(cmd_disable_log_mask), pid);\n\tret = diag_process_apps_masks(cmd_disable_msg_mask,\n\t\t\tsizeof(cmd_disable_msg_mask), pid);\n\tret = diag_process_apps_masks(cmd_disable_event_mask,\n\t\t\tsizeof(cmd_disable_event_mask), pid);\n\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t"diag:%s: masks cleared successfully\\n", __func__);\n}'
p331
g153
ss(g144
S'diag_md_session_check'
p332
tp333
(dp334
S'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)\n\t\treturn -EINVAL;\n\n\tif (req_mode == DIAG_USB_MODE) {\n\t\tif (curr_mode == DIAG_USB_MODE)\n\t\t\treturn 0;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p335
g153
sS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE)\n\t\treturn -EINVAL;\n\n\tif (req_mode == DIAG_USB_MODE) {\n\t\tif (curr_mode == DIAG_USB_MODE)\n\t\t\treturn 0;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p336
g214
sS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_PCIE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\tif (req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE) {\n\t\tif (curr_mode == req_mode)\n\t\t\treturn 0;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (driver->transport_set == DIAG_ROUTE_TO_PCIE)\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);\n\t\t\telse\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p337
g192
sS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_PCIE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\tif (curr_mode == req_mode)\n\t\treturn 0;\n\n\tif ((req_mode ==  DIAG_USB_MODE && curr_mode == DIAG_PCIE_MODE) ||\n\t\t(req_mode == DIAG_PCIE_MODE && curr_mode == DIAG_USB_MODE)) {\n\t\t*change_mode = 1;\n\t\treturn 0;\n\t} else if ((req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE)\n\t\t&& curr_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, req_mode);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);\n\t\t\telse\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p338
g194
sS'static int diag_md_session_check(int curr_mode, int req_mode,\n\t\t\t\t const struct diag_logging_mode_param_t *param,\n\t\t\t\t uint8_t *change_mode)\n{\n\tint i, bit = 0, err = 0, peripheral_mask = 0;\n\tint change_mask = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tif (!param || !change_mode)\n\t\treturn -EIO;\n\n\t*change_mode = 0;\n\n\tswitch (curr_mode) {\n\tcase DIAG_USB_MODE:\n\tcase DIAG_MEMORY_DEVICE_MODE:\n\tcase DIAG_PCIE_MODE:\n\tcase DIAG_MULTI_MODE:\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tif (req_mode != DIAG_USB_MODE && req_mode != DIAG_MEMORY_DEVICE_MODE &&\n\t\treq_mode != DIAG_PCIE_MODE)\n\t\treturn -EINVAL;\n\n\tif (curr_mode == req_mode)\n\t\treturn 0;\n\n\tif ((req_mode ==  DIAG_USB_MODE && curr_mode == DIAG_PCIE_MODE) ||\n\t\t(req_mode == DIAG_PCIE_MODE && curr_mode == DIAG_USB_MODE)) {\n\t\t*change_mode = 1;\n\t\treturn 0;\n\t} else if ((req_mode == DIAG_USB_MODE || req_mode == DIAG_PCIE_MODE)\n\t\t&& (curr_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t\tcurr_mode == DIAG_MULTI_MODE)) {\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tif (driver->md_session_mode == DIAG_MD_NONE\n\t\t    && driver->md_session_mask == 0 && driver->logging_mask) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\t/*\n\t\t * curr_mode is either DIAG_MULTI_MODE or DIAG_MD_MODE\n\t\t * Check if requested peripherals are already in usb mode\n\t\t */\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tbit = MD_PERIPHERAL_MASK(i) & param->peripheral_mask;\n\t\t\tif (!bit)\n\t\t\t\tcontinue;\n\t\t\tif (bit & driver->logging_mask)\n\t\t\t\tchange_mask |= bit;\n\t\t}\n\t\tif (!change_mask) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t/*\n\t\t * Change is needed. Check if this md_session has set all the\n\t\t * requested peripherals. If another md session set a requested\n\t\t * peripheral then we cannot switch that peripheral to USB.\n\t\t * If this session owns all the requested peripherals, then\n\t\t * call function to switch the modes/masks for the md_session\n\t\t */\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (!session_info) {\n\t\t\t*change_mode = 1;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn 0;\n\t\t}\n\t\tperipheral_mask = session_info->peripheral_mask;\n\t\tif ((change_mask & peripheral_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*change_mode = 1;\n\n\t\t/* If all peripherals are being set to USB Mode, call close */\n\t\tif (~change_mask & peripheral_mask) {\n\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, req_mode);\n\t\t} else\n\t\t\tdiag_md_session_close(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn err;\n\n\t} else if (req_mode == DIAG_MEMORY_DEVICE_MODE) {\n\t\t/*\n\t\t * Get bit mask that represents what peripherals already have\n\t\t * been set. Check that requested peripherals already set are\n\t\t * owned by this md session\n\t\t */\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tchange_mask = driver->md_session_mask & param->peripheral_mask;\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\n\t\tif (session_info) {\n\t\t\tif ((session_info->peripheral_mask & change_mask)\n\t\t\t\t\t\t\t!= change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (driver->pcie_transport_def == DIAG_ROUTE_TO_PCIE)\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_PCIE_MODE);\n\t\t\telse\n\t\t\t\terr = diag_md_peripheral_switch(current->tgid,\n\t\t\t\t\tchange_mask, DIAG_USB_MODE);\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (change_mask) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t    "Another MD Session owns a requested peripheral\\n");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\terr = diag_md_session_create(DIAG_MD_PERIPHERAL,\n\t\t\t\tparam->peripheral_mask, DIAG_LOCAL_PROC);\n\t\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\t\tif ((param->peripheral_mask > 0) &&\n\t\t\t\t\t(param->peripheral_mask & (1 << i)))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] = 0;\n\t\t\t}\n\t\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\t}\n\t\t*change_mode = 1;\n\t\treturn err;\n\t}\n\treturn -EINVAL;\n}'
p339
S'2851bf7e6847'
p340
ss(g126
S'diag_process_apps_pkt'
p341
tp342
(dp343
S'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret, peripheral = -EINVAL;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\ttemp += sizeof(uint16_t);\n\n\tpr_debug("diag: In %s, received cmd %02x %02x %02x\\n",\n\t\t __func__, entry.cmd_code, entry.subsys_id, entry.cmd_code_hi);\n\n\tif (*buf == DIAG_CMD_LOG_ON_DMND && driver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);\n\t\tif (len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((chk_apps_master()) && (*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif (*buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if (*buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tperipheral =\n\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (peripheral > 0 && info) {\n\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t} else {\n\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p344
g203
sS'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\ttemp += sizeof(uint8_t);\n\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\ttemp += sizeof(uint16_t);\n\n\tpr_debug("diag: In %s, received cmd %02x %02x %02x\\n",\n\t\t __func__, entry.cmd_code, entry.subsys_id, entry.cmd_code_hi);\n\n\tif (*buf == DIAG_CMD_LOG_ON_DMND && driver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);\n\t\tif (len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((chk_apps_master()) && (*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif (*buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if (*buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p345
g131
sS'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret, peripheral = -EINVAL;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tif (len >= sizeof(uint8_t)) {\n\t\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code %02x\\n", entry.cmd_code);\n\t}\n\tif (len >= (2 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received subsys_id %02x\\n", entry.subsys_id);\n\t}\n\tif (len == (3 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint8_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t} else if (len >= (2 * sizeof(uint8_t)) + sizeof(uint16_t)) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t}\n\n\tif ((len >= sizeof(uint8_t)) && *buf == DIAG_CMD_LOG_ON_DMND &&\n\t\tdriver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\tlen = diag_process_stm_cmd(buf, driver->apps_rsp_buf);\n\t\tif (len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((len >= sizeof(uint8_t)) && (chk_apps_master()) &&\n\t\t(*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((len >= (3 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) && (*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif ((len >= sizeof(uint8_t)) && *buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if ((len >= sizeof(uint8_t)) && *buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tperipheral =\n\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (peripheral > 0 && info) {\n\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t} else {\n\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p346
S'9393739f2aa4'
p347
sS'int diag_process_apps_pkt(unsigned char *buf, int len, int pid)\n{\n\tint i, p_mask = 0;\n\tint mask_ret, peripheral = -EINVAL;\n\tint write_len = 0;\n\tunsigned char *temp = NULL;\n\tstruct diag_cmd_reg_entry_t entry;\n\tstruct diag_cmd_reg_entry_t *temp_entry = NULL;\n\tstruct diag_cmd_reg_t *reg_item = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tuint32_t pd_mask = 0;\n\tstruct diag_md_session_t *info = NULL;\n\n\tif (!buf || len <= 0)\n\t\treturn -EIO;\n\n\t/* Check if the command is a supported mask command */\n\tmask_ret = diag_process_apps_masks(buf, len, pid);\n\tif (mask_ret > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, mask_ret, pid);\n\t\treturn 0;\n\t}\n\n\ttemp = buf;\n\tif (len >= sizeof(uint8_t)) {\n\t\tentry.cmd_code = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code %02x\\n", entry.cmd_code);\n\t}\n\tif (len >= (2 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.subsys_id = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received subsys_id %02x\\n", entry.subsys_id);\n\t}\n\tif (len == (3 * sizeof(uint8_t))) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint8_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint8_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t} else if (len >= (2 * sizeof(uint8_t)) + sizeof(uint16_t)) {\n\t\ttemp += sizeof(uint8_t);\n\t\tentry.cmd_code_hi = (uint16_t)(*(uint16_t *)temp);\n\t\tentry.cmd_code_lo = (uint16_t)(*(uint16_t *)temp);\n\t\tpr_debug("diag: received cmd_code_hi %02x\\n",\n\t\t\tentry.cmd_code_hi);\n\t}\n\n\tif ((len >= sizeof(uint8_t)) && *buf == DIAG_CMD_LOG_ON_DMND &&\n\t\tdriver->log_on_demand_support &&\n\t    driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask) {\n\t\twrite_len = diag_cmd_log_on_demand(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->cmd_reg_mutex);\n\ttemp_entry = diag_cmd_search(&entry, ALL_PROC);\n\tif (temp_entry) {\n\t\treg_item = container_of(temp_entry, struct diag_cmd_reg_t,\n\t\t\t\t\tentry);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info) {\n\t\t\tp_mask = info->peripheral_mask;\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tMD_PERIPHERAL_PD_MASK(TYPE_CMD, reg_item->proc,\n\t\t\t\tpd_mask);\n\t\t\tif ((MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tp_mask) || (pd_mask & p_mask))\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t} else {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tif (MD_PERIPHERAL_MASK(reg_item->proc) &\n\t\t\t\tdriver->logging_mask) {\n\t\t\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\t\t\tdiag_send_error_rsp(buf, len, pid);\n\t\t\t\treturn write_len;\n\t\t\t}\n\t\t\telse\n\t\t\t\twrite_len = diag_send_data(reg_item, buf, len);\n\t\t}\n\t\tmutex_unlock(&driver->cmd_reg_mutex);\n\t\treturn write_len;\n\t}\n\tmutex_unlock(&driver->cmd_reg_mutex);\n\n#if defined(CONFIG_DIAG_OVER_USB)\n\t/* Check for the command/respond msg for the maximum packet length */\n\tif ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == 0x0055)) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\t*(driver->apps_rsp_buf+i) = *(buf+i);\n\t\t*(uint32_t *)(driver->apps_rsp_buf+4) = DIAG_MAX_REQ_SIZE;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 8, pid);\n\t\treturn 0;\n\t} else if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x12) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_DIAG_STM)) {\n\t\twrite_len = diag_process_stm_cmd(buf, len,\n\t\t\tdriver->apps_rsp_buf);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t\treturn write_len;\n\t}\n\t/* Check for time sync query command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for time sync switch command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_SET_TIME_API)) {\n\t\twrite_len = diag_process_time_sync_switch_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for diag id command */\n\telse if ((len >= ((2 * sizeof(uint8_t)) + sizeof(uint16_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t(*(buf+1) == DIAG_SS_DIAG) &&\n\t\t(*(uint16_t *)(buf+2) == DIAG_GET_DIAG_ID)) {\n\t\twrite_len = diag_process_diag_id_query_cmd(buf, len,\n\t\t\t\t\t\t\tdriver->apps_rsp_buf,\n\t\t\t\t\t\t\tDIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0)\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\t/* Check for download command */\n\telse if ((len >= sizeof(uint8_t)) && (chk_apps_master()) &&\n\t\t(*buf == 0x3A)) {\n\t\t/* send response back */\n\t\tdriver->apps_rsp_buf[0] = *buf;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 1, pid);\n\t\tmsleep(5000);\n\t\t/* call download API */\n\t\tmsm_set_restart_mode(RESTART_DLOAD);\n\t\tpr_crit("diag: download mode set, Rebooting SoC..\\n");\n\t\tkernel_restart(NULL);\n\t\t/* Not required, represents that command isn\'t sent to modem */\n\t\treturn 0;\n\t}\n\t/* Check for polling for Apps only DIAG */\n\telse if ((len >= (3 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) && (*(buf+2) == 0x03)) {\n\t\t/* If no one has registered for polling */\n\t\tif (chk_polling_response()) {\n\t\t\t/* Respond to polling for Apps only DIAG */\n\t\t\tfor (i = 0; i < 3; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = *(buf+i);\n\t\t\tfor (i = 0; i < 13; i++)\n\t\t\t\tdriver->apps_rsp_buf[i+3] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 16, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t/* Return the Delayed Response Wrap Status */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x04) && (*(buf+3) == 0x0)) {\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_enabled;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 5, pid);\n\t\treturn 0;\n\t}\n\t/* Wrap the Delayed Rsp ID */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == 0x4b) && (*(buf+1) == 0x32) &&\n\t\t(*(buf+2) == 0x05) && (*(buf+3) == 0x0)) {\n\t\twrap_enabled = true;\n\t\tmemcpy(driver->apps_rsp_buf, buf, 4);\n\t\tdriver->apps_rsp_buf[4] = wrap_count;\n\t\tdiag_send_rsp(driver->apps_rsp_buf, 6, pid);\n\t\treturn 0;\n\t}\n\t/* Mobile ID Rsp */\n\telse if ((len >= (4 * sizeof(uint8_t))) &&\n\t\t(*buf == DIAG_CMD_DIAG_SUBSYS) &&\n\t\t\t(*(buf+1) == DIAG_SS_PARAMS) &&\n\t\t\t(*(buf+2) == DIAG_EXT_MOBILE_ID) && (*(buf+3) == 0x0)) {\n\t\twrite_len = diag_cmd_get_mobile_id(buf, len,\n\t\t\t\t\t\t   driver->apps_rsp_buf,\n\t\t\t\t\t\t   DIAG_MAX_RSP_SIZE);\n\t\tif (write_len > 0) {\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\t /*\n\t  * If the apps processor is master and no other\n\t  * processor has registered for polling command.\n\t  * If modem is not up and we have not received feature\n\t  * mask update from modem, in that case APPS should\n\t  * respond for 0X7C command\n\t  */\n\telse if (chk_apps_master() &&\n\t\t !(driver->polling_reg_flag) &&\n\t\t !(driver->diagfwd_cntl[PERIPHERAL_MODEM]->ch_open) &&\n\t\t !(driver->feature[PERIPHERAL_MODEM].rcvd_feature_mask)) {\n\t\t/* respond to 0x0 command */\n\t\tif ((len >= sizeof(uint8_t)) && *buf == 0x00) {\n\t\t\tfor (i = 0; i < 55; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 55, pid);\n\t\t\treturn 0;\n\t\t}\n\t\t/* respond to 0x7c command */\n\t\telse if ((len >= sizeof(uint8_t)) && *buf == 0x7c) {\n\t\t\tdriver->apps_rsp_buf[0] = 0x7c;\n\t\t\tfor (i = 1; i < 8; i++)\n\t\t\t\tdriver->apps_rsp_buf[i] = 0;\n\t\t\t/* Tools ID for APQ 8060 */\n\t\t\t*(int *)(driver->apps_rsp_buf + 8) =\n\t\t\t\t\t\t\t chk_config_get_id();\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 12) = \'\\0\';\n\t\t\t*(unsigned char *)(driver->apps_rsp_buf + 13) = \'\\0\';\n\t\t\tdiag_send_rsp(driver->apps_rsp_buf, 14, pid);\n\t\t\treturn 0;\n\t\t}\n\t}\n\twrite_len = diag_cmd_chk_stats(buf, len, driver->apps_rsp_buf,\n\t\t\t\t       DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\treturn 0;\n\t}\n\twrite_len = diag_cmd_disable_hdlc(buf, len, driver->apps_rsp_buf,\n\t\t\t\t\t  DIAG_MAX_RSP_SIZE);\n\tif (write_len > 0) {\n\t\t/*\n\t\t * This mutex lock is necessary since we need to drain all the\n\t\t * pending buffers from peripherals which may be HDLC encoded\n\t\t * before disabling HDLC encoding on Apps processor.\n\t\t */\n\t\tmutex_lock(&driver->hdlc_disable_mutex);\n\t\tdiag_send_rsp(driver->apps_rsp_buf, write_len, pid);\n\t\t/*\n\t\t * Set the value of hdlc_disabled after sending the response to\n\t\t * the tools. This is required since the tools is expecting a\n\t\t * HDLC encoded response for this request.\n\t\t */\n\t\tpr_debug("diag: In %s, disabling HDLC encoding\\n",\n\t\t       __func__);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tinfo = diag_md_session_get_pid(pid);\n\t\tif (info)\n\t\t\tinfo->hdlc_disabled = 1;\n\t\telse\n\t\t\tdriver->hdlc_disabled = 1;\n\t\tperipheral =\n\t\t\tdiag_md_session_match_pid_peripheral(pid, 0);\n\t\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\t\tif (peripheral > 0 && info) {\n\t\t\t\tif (peripheral & (1 << i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tinfo->hdlc_disabled;\n\t\t\t\telse if (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t} else {\n\t\t\t\tif (!diag_md_session_get_peripheral(i))\n\t\t\t\t\tdriver->p_hdlc_disabled[i] =\n\t\t\t\t\tdriver->hdlc_disabled;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdiag_update_md_clients(HDLC_SUPPORT_TYPE);\n\t\tmutex_unlock(&driver->hdlc_disable_mutex);\n\t\treturn 0;\n\t}\n#endif\n\n\t/* We have now come to the end of the function. */\n\tif (chk_apps_only())\n\t\tdiag_send_error_rsp(buf, len, pid);\n\n\treturn 0;\n}'
p348
S'e276e60d848d'
p349
ss(g144
S'diag_drain_work_fn'
p350
tp351
(dp352
S'void diag_drain_work_fn(struct work_struct *work)\n{\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\ttimer_in_progress = 0;\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (!hdlc_disabled)\n\t\tdiag_drain_apps_data(&hdlc_data);\n\telse\n\t\tdiag_drain_apps_data(&non_hdlc_data);\n\tmutex_unlock(&apps_data_mutex);\n}'
p353
g153
sS'void diag_drain_work_fn(struct work_struct *work)\n{\n\tuint8_t hdlc_disabled = 0;\n\n\ttimer_in_progress = 0;\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (!hdlc_disabled)\n\t\tdiag_drain_apps_data(&hdlc_data);\n\telse\n\t\tdiag_drain_apps_data(&non_hdlc_data);\n\tmutex_unlock(&apps_data_mutex);\n}'
p354
g214
ss(g132
S'diag_cmd_get_event_mask'
p355
tp356
(dp357
S'static int diag_cmd_get_event_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint write_len = 0;\n\tuint32_t mask_size;\n\tstruct diag_event_mask_config_t rsp;\n\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds())\n\t\treturn 0;\n\n\tmask_size = EVENT_COUNT_TO_BYTES(driver->last_event_id);\n\tif (mask_size + sizeof(rsp) > dest_len) {\n\t\tpr_err("diag: In %s, invalid mask size: %d\\n", __func__,\n\t\t       mask_size);\n\t\treturn -ENOMEM;\n\t}\n\n\trsp.cmd_code = DIAG_CMD_GET_EVENT_MASK;\n\trsp.status = EVENT_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.num_bits = driver->last_event_id + 1;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmemcpy(dest_buf + write_len, event_mask.ptr, mask_size);\n\twrite_len += mask_size;\n\n\treturn write_len;\n}'
p358
g137
ss(g132
S'diag_cmd_set_all_msg_mask'
p359
tp360
(dp361
S'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p362
g141
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p363
g320
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, req->rt_mask,\n\t\t       mask->range * sizeof(uint32_t));\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p364
g159
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p365
g223
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, req->rt_mask,\n\t\t       mask->range * sizeof(uint32_t));\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p366
g137
ss(g144
S'diag_send_raw_data_remote'
p367
tp368
(dp369
S'static int diag_send_raw_data_remote(int proc, void *buf, int len,\n\t\t\t\t    uint8_t hdlc_flag)\n{\n\tint err = 0;\n\tint max_len = 0;\n\tuint8_t retry_count = 0;\n\tuint8_t max_retries = 3;\n\tuint16_t payload = 0;\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tint bridge_index = proc - 1;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (len <= 0) {\n\t\tpr_err("diag: In %s, invalid len: %d", __func__, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (bridge_index < 0 || bridge_index > NUM_REMOTE_DEV) {\n\t\tpr_err("diag: In %s, invalid bridge index: %d\\n", __func__,\n\t\t\tbridge_index);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tif (driver->hdlc_encode_buf_len == 0)\n\t\t\tbreak;\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\t} while (retry_count < max_retries);\n\n\tif (driver->hdlc_encode_buf_len != 0)\n\t\treturn -EAGAIN;\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled) {\n\t\tif (len < 4) {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tpayload = *(uint16_t *)(buf + 2);\n\t\tif (payload > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, payload size is %d\\n",\n\t\t\t\tpayload);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = payload;\n\t\t/*\n\t\t * Adding 5 bytes for start (1 byte), version (1 byte),\n\t\t * payload (2 bytes) and end (1 byte)\n\t\t */\n\t\tif (len == (payload + 5)) {\n\t\t\t/*\n\t\t\t * Adding 4 bytes for start (1 byte), version (1 byte)\n\t\t\t * and payload (2 bytes)\n\t\t\t */\n\t\t\tmemcpy(driver->hdlc_encode_buf, buf + 4, payload);\n\t\t\tgoto send_data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\tif (hdlc_flag) {\n\t\tif (len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t\t       len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = len;\n\t\tmemcpy(driver->hdlc_encode_buf, buf, len);\n\t\tgoto send_data;\n\t}\n\n\t/*\n\t * The worst case length will be twice as the incoming packet length.\n\t * Add 3 bytes for CRC bytes (2 bytes) and delimiter (1 byte)\n\t */\n\tmax_len = (2 * len) + 3;\n\tif (max_len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t       max_len);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* Perform HDLC encoding on incoming data */\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = (void *)(buf);\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\n\tenc.dest = driver->hdlc_encode_buf;\n\tenc.dest_last = (void *)(driver->hdlc_encode_buf + max_len - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->hdlc_encode_buf_len = (int)(enc.dest -\n\t\t\t\t\t(void *)driver->hdlc_encode_buf);\n\nsend_data:\n\terr = diagfwd_bridge_write(bridge_index, driver->hdlc_encode_buf,\n\t\t\t\t   driver->hdlc_encode_buf_len);\n\tif (err) {\n\t\tpr_err_ratelimited("diag: Error writing Callback packet to proc: %d, err: %d\\n",\n\t\t\t\t   proc, err);\n\t\tdriver->hdlc_encode_buf_len = 0;\n\t}\n\n\treturn err;\n}'
p370
g153
sS'static int diag_send_raw_data_remote(int proc, void *buf, int len,\n\t\t\t\t    uint8_t hdlc_flag)\n{\n\tint err = 0;\n\tint max_len = 0;\n\tuint8_t retry_count = 0;\n\tuint8_t max_retries = 3;\n\tuint16_t payload = 0;\n\tstruct diag_send_desc_type send = { NULL, NULL, DIAG_STATE_START, 0 };\n\tstruct diag_hdlc_dest_type enc = { NULL, NULL, 0 };\n\tint bridge_index = proc - 1;\n\tuint8_t hdlc_disabled = 0;\n\n\tif (!buf)\n\t\treturn -EINVAL;\n\n\tif (len <= 0) {\n\t\tpr_err("diag: In %s, invalid len: %d", __func__, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (bridge_index < 0 || bridge_index > NUM_REMOTE_DEV) {\n\t\tpr_err("diag: In %s, invalid bridge index: %d\\n", __func__,\n\t\t\tbridge_index);\n\t\treturn -EINVAL;\n\t}\n\n\tdo {\n\t\tif (driver->hdlc_encode_buf_len == 0)\n\t\t\tbreak;\n\t\tusleep_range(10000, 10100);\n\t\tretry_count++;\n\t} while (retry_count < max_retries);\n\n\tif (driver->hdlc_encode_buf_len != 0)\n\t\treturn -EAGAIN;\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (hdlc_disabled) {\n\t\tif (len < 4) {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tpayload = *(uint16_t *)(buf + 2);\n\t\tif (payload > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, payload size is %d\\n",\n\t\t\t\tpayload);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = payload;\n\t\t/*\n\t\t * Adding 5 bytes for start (1 byte), version (1 byte),\n\t\t * payload (2 bytes) and end (1 byte)\n\t\t */\n\t\tif (len == (payload + 5)) {\n\t\t\t/*\n\t\t\t * Adding 4 bytes for start (1 byte), version (1 byte)\n\t\t\t * and payload (2 bytes)\n\t\t\t */\n\t\t\tmemcpy(driver->hdlc_encode_buf, buf + 4, payload);\n\t\t\tgoto send_data;\n\t\t} else {\n\t\t\tpr_err("diag: In %s, invalid len: %d of non_hdlc pkt",\n\t\t\t__func__, len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t}\n\n\tif (hdlc_flag) {\n\t\tif (len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t\t       len);\n\t\t\treturn -EBADMSG;\n\t\t}\n\t\tdriver->hdlc_encode_buf_len = len;\n\t\tmemcpy(driver->hdlc_encode_buf, buf, len);\n\t\tgoto send_data;\n\t}\n\n\t/*\n\t * The worst case length will be twice as the incoming packet length.\n\t * Add 3 bytes for CRC bytes (2 bytes) and delimiter (1 byte)\n\t */\n\tmax_len = (2 * len) + 3;\n\tif (max_len > DIAG_MAX_HDLC_BUF_SIZE) {\n\t\tpr_err("diag: Dropping packet, HDLC encoded packet payload size crosses buffer limit. Current payload size %d\\n",\n\t\t       max_len);\n\t\treturn -EBADMSG;\n\t}\n\n\t/* Perform HDLC encoding on incoming data */\n\tsend.state = DIAG_STATE_START;\n\tsend.pkt = (void *)(buf);\n\tsend.last = (void *)(buf + len - 1);\n\tsend.terminate = 1;\n\n\tenc.dest = driver->hdlc_encode_buf;\n\tenc.dest_last = (void *)(driver->hdlc_encode_buf + max_len - 1);\n\tdiag_hdlc_encode(&send, &enc);\n\tdriver->hdlc_encode_buf_len = (int)(enc.dest -\n\t\t\t\t\t(void *)driver->hdlc_encode_buf);\n\nsend_data:\n\terr = diagfwd_bridge_write(bridge_index, driver->hdlc_encode_buf,\n\t\t\t\t   driver->hdlc_encode_buf_len);\n\tif (err) {\n\t\tpr_err_ratelimited("diag: Error writing Callback packet to proc: %d, err: %d\\n",\n\t\t\t\t   proc, err);\n\t\tdriver->hdlc_encode_buf_len = 0;\n\t}\n\n\treturn err;\n}'
p371
g214
ss(g144
S'diag_user_process_apps_data'
p372
tp373
(dp374
S'static int diag_user_process_apps_data(const char __user *buf, int len,\n\t\t\t\t       int pkt_type)\n{\n\tint ret = 0;\n\tint stm_size = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\tstruct diag_md_session_t *session_info = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > DIAG_MAX_RSP_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tswitch (pkt_type) {\n\tcase DATA_TYPE_EVENT:\n\tcase DATA_TYPE_F3:\n\tcase DATA_TYPE_LOG:\n\tcase DATA_TYPE_RESPONSE:\n\tcase DATA_TYPE_DELAYED_RESPONSE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid pkt_type: %d\\n",\n\t\t\t\t   __func__, pkt_type);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data) {\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_from_user(user_space_data, buf, len);\n\tif (ret) {\n\t\tpr_alert("diag: In %s, unable to copy data from userspace, err: %d\\n",\n\t\t\t __func__, ret);\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (driver->stm_state[APPS_DATA] &&\n\t    (pkt_type >= DATA_TYPE_EVENT) && (pkt_type <= DATA_TYPE_LOG)) {\n\t\tstm_size = stm_log_inv_ts(OST_ENTITY_DIAG, 0, user_space_data,\n\t\t\t\t\t  len);\n\t\tif (stm_size == 0) {\n\t\t\tpr_debug("diag: In %s, stm_log_inv_ts returned size of 0\\n",\n\t\t\t\t __func__);\n\t\t}\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\tmutex_lock(&driver->md_session_lock);\n\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\tif (session_info)\n\t\thdlc_disabled = session_info->hdlc_disabled;\n\telse\n\t\thdlc_disabled = driver->hdlc_disabled;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (hdlc_disabled)\n\t\tret = diag_process_apps_data_non_hdlc(user_space_data, len,\n\t\t\t\t\t\t      pkt_type);\n\telse\n\t\tret = diag_process_apps_data_hdlc(user_space_data, len,\n\t\t\t\t\t\t  pkt_type);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tmutex_unlock(&apps_data_mutex);\n\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\n\tcheck_drain_timer();\n\n\tif (ret == PKT_DROP)\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\telse if (ret == PKT_ALLOC)\n\t\tdiag_record_stats(pkt_type, PKT_ALLOC);\n\telse\n\t\treturn ret;\n\n\treturn 0;\n}'
p375
g153
sS'static int diag_user_process_apps_data(const char __user *buf, int len,\n\t\t\t\t       int pkt_type)\n{\n\tint ret = 0;\n\tint stm_size = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > DIAG_MAX_RSP_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tswitch (pkt_type) {\n\tcase DATA_TYPE_EVENT:\n\tcase DATA_TYPE_F3:\n\tcase DATA_TYPE_LOG:\n\tcase DATA_TYPE_RESPONSE:\n\tcase DATA_TYPE_DELAYED_RESPONSE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid pkt_type: %d\\n",\n\t\t\t\t   __func__, pkt_type);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data) {\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_from_user(user_space_data, buf, len);\n\tif (ret) {\n\t\tpr_alert("diag: In %s, unable to copy data from userspace, err: %d\\n",\n\t\t\t __func__, ret);\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (driver->stm_state[APPS_DATA] &&\n\t    (pkt_type >= DATA_TYPE_EVENT) && (pkt_type <= DATA_TYPE_LOG)) {\n\t\tstm_size = stm_log_inv_ts(OST_ENTITY_DIAG, 0, user_space_data,\n\t\t\t\t\t  len);\n\t\tif (stm_size == 0) {\n\t\t\tpr_debug("diag: In %s, stm_log_inv_ts returned size of 0\\n",\n\t\t\t\t __func__);\n\t\t}\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tif (hdlc_disabled)\n\t\tret = diag_process_apps_data_non_hdlc(user_space_data, len,\n\t\t\t\t\t\t      pkt_type);\n\telse\n\t\tret = diag_process_apps_data_hdlc(user_space_data, len,\n\t\t\t\t\t\t  pkt_type);\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tmutex_unlock(&apps_data_mutex);\n\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\n\tcheck_drain_timer();\n\n\tif (ret == PKT_DROP)\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\telse if (ret == PKT_ALLOC)\n\t\tdiag_record_stats(pkt_type, PKT_ALLOC);\n\telse\n\t\treturn ret;\n\n\treturn 0;\n}'
p376
g214
sS'static int diag_user_process_apps_data(const char __user *buf, int len,\n\t\t\t\t       int pkt_type)\n{\n\tint ret = 0;\n\tint stm_size = 0;\n\tconst int mempool = POOL_TYPE_COPY;\n\tunsigned char *user_space_data = NULL;\n\tuint8_t hdlc_disabled;\n\n\tif (!buf || len <= 0 || len > DIAG_MAX_RSP_SIZE) {\n\t\tpr_err_ratelimited("diag: In %s, invalid buf %pK len: %d\\n",\n\t\t\t\t   __func__, buf, len);\n\t\treturn -EBADMSG;\n\t}\n\n\tswitch (pkt_type) {\n\tcase DATA_TYPE_EVENT:\n\tcase DATA_TYPE_F3:\n\tcase DATA_TYPE_LOG:\n\tcase DATA_TYPE_RESPONSE:\n\tcase DATA_TYPE_DELAYED_RESPONSE:\n\t\tbreak;\n\tdefault:\n\t\tpr_err_ratelimited("diag: In %s, invalid pkt_type: %d\\n",\n\t\t\t\t   __func__, pkt_type);\n\t\treturn -EBADMSG;\n\t}\n\n\tuser_space_data = diagmem_alloc(driver, len, mempool);\n\tif (!user_space_data) {\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -ENOMEM;\n\t}\n\n\tret = copy_from_user(user_space_data, buf, len);\n\tif (ret) {\n\t\tpr_alert("diag: In %s, unable to copy data from userspace, err: %d\\n",\n\t\t\t __func__, ret);\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\t\treturn -EBADMSG;\n\t}\n\n\tif (driver->stm_state[APPS_DATA] &&\n\t    (pkt_type >= DATA_TYPE_EVENT) && (pkt_type <= DATA_TYPE_LOG)) {\n\t\tstm_size = stm_log_inv_ts(OST_ENTITY_DIAG, 0, user_space_data,\n\t\t\t\t\t  len);\n\t\tif (stm_size == 0) {\n\t\t\tpr_debug("diag: In %s, stm_log_inv_ts returned size of 0\\n",\n\t\t\t\t __func__);\n\t\t}\n\t\tdiagmem_free(driver, user_space_data, mempool);\n\t\tuser_space_data = NULL;\n\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&apps_data_mutex);\n\tmutex_lock(&driver->hdlc_disable_mutex);\n\thdlc_disabled = driver->p_hdlc_disabled[APPS_DATA];\n\tmutex_unlock(&driver->hdlc_disable_mutex);\n\tif (hdlc_disabled)\n\t\tret = diag_process_apps_data_non_hdlc(user_space_data, len,\n\t\t\t\t\t\t      pkt_type);\n\telse\n\t\tret = diag_process_apps_data_hdlc(user_space_data, len,\n\t\t\t\t\t\t  pkt_type);\n\tmutex_unlock(&apps_data_mutex);\n\n\tdiagmem_free(driver, user_space_data, mempool);\n\tuser_space_data = NULL;\n\n\tcheck_drain_timer();\n\n\tif (ret == PKT_DROP)\n\t\tdiag_record_stats(pkt_type, PKT_DROP);\n\telse if (ret == PKT_ALLOC)\n\t\tdiag_record_stats(pkt_type, PKT_ALLOC);\n\telse\n\t\treturn ret;\n\n\treturn 0;\n}'
p377
g192
ss(g132
S'diag_cmd_disable_log_mask'
p378
tp379
(dp380
S'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, 0, mask->range);\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p381
g137
sS'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tmutex_lock(&mask->lock);\n\t\tmemset(mask->ptr, 0, mask->range);\n\t\tmutex_unlock(&mask->lock);\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p382
g159
sS'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, 0, mask->range);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p383
g320
ss(g144
S'diag_md_session_get_pid'
p384
tp385
(dp386
S'struct diag_md_session_t *diag_md_session_get_pid(int pid)\n{\n\tint i;\n\tif (pid <= 0)\n\t\treturn NULL;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] &&\n\t\t    driver->md_session_map[i]->pid == pid)\n\t\t\treturn driver->md_session_map[i];\n\t}\n\treturn NULL;\n}'
p387
g153
sssS'CVE-2019-10529'
p388
(dp389
(S'drivers/gpu/msm/kgsl.c'
p390
S'kgsl_mem_entry_destroy'
p391
tp392
(dp393
S"kgsl_mem_entry_destroy(struct kref *kref)\n{\n\tstruct kgsl_mem_entry *entry = container_of(kref,\n\t\t\t\t\t\t    struct kgsl_mem_entry,\n\t\t\t\t\t\t    refcount);\n\tunsigned int memtype;\n\n\tif (entry == NULL)\n\t\treturn;\n\n\t/* pull out the memtype before the flags get cleared */\n\tmemtype = kgsl_memdesc_usermem_type(&entry->memdesc);\n\n\t/* Detach from process list */\n\tkgsl_mem_entry_detach_process(entry);\n\n\tif (memtype != KGSL_MEM_ENTRY_KERNEL)\n\t\tatomic_long_sub(entry->memdesc.size,\n\t\t\t&kgsl_driver.stats.mapped);\n\n\t/*\n\t * Ion takes care of freeing the sg_table for us so\n\t * clear the sg table before freeing the sharedmem\n\t * so kgsl_sharedmem_free doesn't try to free it again\n\t */\n\tif (memtype == KGSL_MEM_ENTRY_ION)\n\t\tentry->memdesc.sgt = NULL;\n\n\tif ((memtype == KGSL_MEM_ENTRY_USER)\n\t\t&& !(entry->memdesc.flags & KGSL_MEMFLAGS_GPUREADONLY)) {\n\t\tint i = 0, j;\n\t\tstruct scatterlist *sg;\n\t\tstruct page *page;\n\t\t/*\n\t\t * Mark all of pages in the scatterlist as dirty since they\n\t\t * were writable by the GPU.\n\t\t */\n\t\tfor_each_sg(entry->memdesc.sgt->sgl, sg,\n\t\t\t    entry->memdesc.sgt->nents, i) {\n\t\t\tpage = sg_page(sg);\n\t\t\tfor (j = 0; j < (sg->length >> PAGE_SHIFT); j++)\n\t\t\t\tset_page_dirty_lock(nth_page(page, j));\n\t\t}\n\t}\n\n\tkgsl_sharedmem_free(&entry->memdesc);\n\n\tswitch (memtype) {\n\tcase KGSL_MEM_ENTRY_ION:\n\t\tkgsl_destroy_ion(entry->priv_data);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkfree(entry);\n}"
p394
S'a77c16d4981b'
p395
sssS'CVE-2018-11818'
p396
(dp397
(S'drivers/video/fbdev/msm/mdss_mdp.c'
p398
S'mdss_mdp_scaler_init'
p399
tp400
(dp401
S'static u32 mdss_mdp_scaler_init(struct mdss_data_type *mdata,\n\t\t\t\tstruct device *dev)\n{\n\tint ret;\n\tstruct device_node *node;\n\tu32 prop_val;\n\n\tif (!dev)\n\t\treturn -EPERM;\n\n\tnode = of_get_child_by_name(dev->of_node, "qcom,mdss-scaler-offsets");\n\tif (!node)\n\t\treturn 0;\n\n\tif (mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmdata->scaler_off = devm_kzalloc(&mdata->pdev->dev,\n\t\t\tsizeof(*mdata->scaler_off), GFP_KERNEL);\n\tif (!mdata->scaler_off)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_off = prop_val;\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-lut-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-lut-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_lut_off = prop_val;\n\tmdata->scaler_off->has_dest_scaler =\n\t\tof_property_read_bool(mdata->pdev->dev.of_node,\n\t\t\t\t"qcom,mdss-has-dest-scaler");\n\tif (mdata->scaler_off->has_dest_scaler) {\n\t\tret = of_property_read_u32(node,\n\t\t\t\t"qcom,mdss-dest-block-off",\n\t\t\t\t&prop_val);\n\t\tif (ret) {\n\t\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t\t"qcom,mdss-dest-block-off", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmdata->scaler_off->dest_base = mdata->mdss_io.base +\n\t\t\tprop_val;\n\t\tmdata->scaler_off->ndest_scalers =\n\t\t\tmdss_mdp_parse_dt_prop_len(mdata->pdev,\n\t\t\t\t\t"qcom,mdss-dest-scalers-off");\n\t\tmdata->scaler_off->dest_scaler_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_off)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scaler-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t\tmdata->scaler_off->dest_scaler_lut_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_lut_off)\n\t\t\treturn -ENOMEM;\n\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scalers-lut-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_lut_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&mdata->scaler_off->scaler_lock);\n\treturn 0;\n}'
p402
S'2e1a28c65e2f'
p403
sS'static u32 mdss_mdp_scaler_init(struct mdss_data_type *mdata,\n\t\t\t\tstruct device *dev)\n{\n\tint ret;\n\tstruct device_node *node;\n\tu32 prop_val;\n\n\tif (!dev)\n\t\treturn -EPERM;\n\n\tnode = of_get_child_by_name(dev->of_node, "qcom,mdss-scaler-offsets");\n\tif (!node)\n\t\treturn 0;\n\n\tif (mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmdata->scaler_off = devm_kzalloc(&mdata->pdev->dev,\n\t\t\tsizeof(*mdata->scaler_off), GFP_KERNEL);\n\tif (!mdata->scaler_off)\n\t\treturn -ENOMEM;\n\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_off = prop_val;\n\tret = of_property_read_u32(node,\n\t\t\t"qcom,mdss-vig-scaler-lut-off",\n\t\t\t&prop_val);\n\tif (ret) {\n\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t"qcom,mdss-vig-scaler-lut-off", ret);\n\t\treturn -EINVAL;\n\t}\n\tmdata->scaler_off->vig_scaler_lut_off = prop_val;\n\tmdata->scaler_off->has_dest_scaler =\n\t\tof_property_read_bool(mdata->pdev->dev.of_node,\n\t\t\t\t"qcom,mdss-has-dest-scaler");\n\tif (mdata->scaler_off->has_dest_scaler) {\n\t\tret = of_property_read_u32(node,\n\t\t\t\t"qcom,mdss-dest-block-off",\n\t\t\t\t&prop_val);\n\t\tif (ret) {\n\t\t\tpr_err("read property %s failed ret %d\\n",\n\t\t\t\t\t"qcom,mdss-dest-block-off", ret);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tmdata->scaler_off->dest_base = mdata->mdss_io.base +\n\t\t\tprop_val;\n\t\tmdata->scaler_off->ndest_scalers =\n\t\t\tmdss_mdp_parse_dt_prop_len(mdata->pdev,\n\t\t\t\t\t"qcom,mdss-dest-scalers-off");\n\t\tmdata->scaler_off->dest_scaler_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_off) {\n\t\t\tkfree(mdata->scaler_off->dest_scaler_off);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scaler-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t\tmdata->scaler_off->dest_scaler_lut_off =\n\t\t\tdevm_kzalloc(&mdata->pdev->dev, sizeof(u32) *\n\t\t\t\t\tmdata->scaler_off->ndest_scalers,\n\t\t\t\t\tGFP_KERNEL);\n\t\tif  (!mdata->scaler_off->dest_scaler_lut_off) {\n\t\t\tkfree(mdata->scaler_off->dest_scaler_lut_off);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tret = mdss_mdp_parse_dt_handler(mdata->pdev,\n\t\t\t\t"qcom,mdss-dest-scalers-lut-off",\n\t\t\t\tmdata->scaler_off->dest_scaler_lut_off,\n\t\t\t\tmdata->scaler_off->ndest_scalers);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_init(&mdata->scaler_off->scaler_lock);\n\treturn 0;\n}'
p404
S'78a8a5037990'
p405
ss(S'drivers/video/fbdev/msm/mdss_mdp_pp.c'
p406
S'mdss_mdp_scaler_lut_cfg'
p407
tp408
(dp409
S'int mdss_mdp_scaler_lut_cfg(struct mdp_scale_data_v2 *scaler,\n\t\t\t\t\t\tchar __iomem *offset)\n{\n\tint i, j, filter;\n\tstruct mdss_data_type *mdata;\n\tchar __iomem *lut_addr;\n\tuint32_t *lut_type[QSEED3_FILTERS] = {NULL, NULL, NULL, NULL, NULL};\n\tuint32_t lut_offset, lut_len;\n\tstruct mdss_mdp_qseed3_lut_tbl *lut_tbl;\n\t/* for each filter, 4 lut regions offset and length table */\n\tstatic uint32_t offset_tbl[QSEED3_FILTERS][QSEED3_LUT_REGIONS][2] = {\n\t\t{{18, 0x000}, {12, 0x120}, {12, 0x1E0}, {8, 0x2A0} },\n\t\t{{6, 0x320}, {3, 0x3E0}, {3, 0x440}, {3, 0x4A0} },\n\t\t{{6, 0x380}, {3, 0x410}, {3, 0x470}, {3, 0x4d0} },\n\t\t{{6, 0x500}, {3, 0x5c0}, {3, 0x620}, {3, 0x680} },\n\t\t{{6, 0x560}, {3, 0x5f0}, {3, 0x650}, {3, 0x6b0} },\n\t};\n\n\tmdata = mdss_mdp_get_mdata();\n\n\tmutex_lock(&mdata->scaler_off->scaler_lock);\n\n\tlut_tbl = &mdata->scaler_off->lut_tbl;\n\tif ((!lut_tbl) || (!lut_tbl->valid)) {\n\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\t\tpr_err("%s:Invalid QSEED3 LUT TABLE\\n", __func__);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((scaler->lut_flag & SCALER_LUT_DIR_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_Y_CIR_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_UV_CIR_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_Y_SEP_WR) ||\n\t\t(scaler->lut_flag & SCALER_LUT_UV_SEP_WR)) {\n\n\t\tif (scaler->lut_flag & SCALER_LUT_DIR_WR)\n\t\t\tlut_type[0] = lut_tbl->dir_lut;\n\t\tif (scaler->lut_flag & SCALER_LUT_Y_CIR_WR)\n\t\t\tlut_type[1] =\n\t\t\t\tlut_tbl->cir_lut + scaler->y_rgb_cir_lut_idx *\n\t\t\t\tCIR_LUT_COEFFS;\n\t\tif (scaler->lut_flag & SCALER_LUT_UV_CIR_WR)\n\t\t\tlut_type[2] = lut_tbl->cir_lut +\n\t\t\t\tscaler->uv_cir_lut_idx * CIR_LUT_COEFFS;\n\t\tif (scaler->lut_flag & SCALER_LUT_Y_SEP_WR)\n\t\t\tlut_type[3] =\n\t\t\t\tlut_tbl->sep_lut + scaler->y_rgb_sep_lut_idx *\n\t\t\t\tSEP_LUT_COEFFS;\n\t\tif (scaler->lut_flag & SCALER_LUT_UV_SEP_WR)\n\t\t\tlut_type[4] =\n\t\t\t\tlut_tbl->sep_lut + scaler->uv_sep_lut_idx *\n\t\t\t\tSEP_LUT_COEFFS;\n\n\t\t/* for each filter per plane */\n\t\tfor (filter = 0; filter < QSEED3_FILTERS; filter++) {\n\t\t\tif (!lut_type[filter])\n\t\t\t\tcontinue;\n\t\t\tlut_offset = 0;\n\t\t\t/* for each lut region */\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tlut_addr = offset +\n\t\t\t\t\toffset_tbl[filter][i][1];\n\t\t\t\tlut_len =\n\t\t\t\t\toffset_tbl[filter][i][0] << 2;\n\t\t\t\tfor (j = 0; j < lut_len; j++) {\n\t\t\t\t\twritel_relaxed(\n\t\t\t\t\t\t\t(lut_type[filter])\n\t\t\t\t\t\t\t[lut_offset++],\n\t\t\t\t\t\t\t\tlut_addr);\n\t\t\t\t\t\tlut_addr += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t}\n\n\tif (scaler->lut_flag & SCALER_LUT_SWAP)\n\t\twritel_relaxed(BIT(0), MDSS_MDP_REG_SCALER_COEF_LUT_CTRL +\n\t\t\t\toffset);\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn 0;\n}'
p410
S'78a8a5037990'
p411
ss(S'drivers/video/fbdev/msm/mdss_mdp_overlay.c'
p412
S'mdss_mdp_scaler_lut_init'
p413
tp414
(dp415
S'static int mdss_mdp_scaler_lut_init(struct mdss_data_type *mdata,\n\t\tstruct mdp_scale_luts_info *lut_tbl)\n{\n\tstruct mdss_mdp_qseed3_lut_tbl *qseed3_lut_tbl;\n\tint ret = 0;\n\n\tif (!mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mdata->scaler_off->scaler_lock);\n\n\tqseed3_lut_tbl = &mdata->scaler_off->lut_tbl;\n\tif ((lut_tbl->dir_lut_size !=\n\t\tDIR_LUT_IDX * DIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->cir_lut_size !=\n\t\t CIR_LUT_IDX * CIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->sep_lut_size !=\n\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t))) {\n\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!qseed3_lut_tbl->dir_lut) {\n\t\tqseed3_lut_tbl->dir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->dir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->dir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->cir_lut) {\n\t\tqseed3_lut_tbl->cir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->cir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->cir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_dir_lut;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->sep_lut) {\n\t\tqseed3_lut_tbl->sep_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->sep_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->sep_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_cir_lut;\n\t\t}\n\t}\n\n\t/* Invalidate before updating */\n\tqseed3_lut_tbl->valid = false;\n\n\tif (copy_from_user(qseed3_lut_tbl->dir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->dir_lut,\n\t\t\t\tlut_tbl->dir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->cir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->cir_lut,\n\t\t\t\tlut_tbl->cir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->sep_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->sep_lut,\n\t\t\t\tlut_tbl->sep_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tqseed3_lut_tbl->valid = true;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n\nfail_free_sep_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->sep_lut);\nfail_free_cir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->cir_lut);\nfail_free_dir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->dir_lut);\nerr:\n\tqseed3_lut_tbl->dir_lut = NULL;\n\tqseed3_lut_tbl->cir_lut = NULL;\n\tqseed3_lut_tbl->sep_lut = NULL;\n\tqseed3_lut_tbl->valid = false;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n}'
p416
S'7696915bcc23'
p417
sS'static int mdss_mdp_scaler_lut_init(struct mdss_data_type *mdata,\n\t\tstruct mdp_scale_luts_info *lut_tbl)\n{\n\tstruct mdss_mdp_qseed3_lut_tbl *qseed3_lut_tbl;\n\tint ret;\n\n\tif (!mdata->scaler_off)\n\t\treturn -EFAULT;\n\n\tmutex_lock(&mdata->scaler_off->scaler_lock);\n\n\tqseed3_lut_tbl = &mdata->scaler_off->lut_tbl;\n\tif ((lut_tbl->dir_lut_size !=\n\t\tDIR_LUT_IDX * DIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->cir_lut_size !=\n\t\t CIR_LUT_IDX * CIR_LUT_COEFFS * sizeof(uint32_t)) ||\n\t\t(lut_tbl->sep_lut_size !=\n\t\t SEP_LUT_IDX * SEP_LUT_COEFFS * sizeof(uint32_t))) {\n\t\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!qseed3_lut_tbl->dir_lut) {\n\t\tqseed3_lut_tbl->dir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->dir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->dir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->cir_lut) {\n\t\tqseed3_lut_tbl->cir_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->cir_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->cir_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_dir_lut;\n\t\t}\n\t}\n\n\tif (!qseed3_lut_tbl->sep_lut) {\n\t\tqseed3_lut_tbl->sep_lut = devm_kzalloc(&mdata->pdev->dev,\n\t\t\t\tlut_tbl->sep_lut_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!qseed3_lut_tbl->sep_lut) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto fail_free_cir_lut;\n\t\t}\n\t}\n\n\t/* Invalidate before updating */\n\tqseed3_lut_tbl->valid = false;\n\n\tif (copy_from_user(qseed3_lut_tbl->dir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->dir_lut,\n\t\t\t\tlut_tbl->dir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->cir_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->cir_lut,\n\t\t\t\tlut_tbl->cir_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tif (copy_from_user(qseed3_lut_tbl->sep_lut,\n\t\t\t\t(void *)(unsigned long)lut_tbl->sep_lut,\n\t\t\t\tlut_tbl->sep_lut_size)) {\n\t\tret = -EINVAL;\n\t\tgoto fail_free_sep_lut;\n\t}\n\n\tqseed3_lut_tbl->valid = true;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n\nfail_free_sep_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->sep_lut);\nfail_free_cir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->cir_lut);\nfail_free_dir_lut:\n\tdevm_kfree(&mdata->pdev->dev, qseed3_lut_tbl->dir_lut);\nerr:\n\tqseed3_lut_tbl->dir_lut = NULL;\n\tqseed3_lut_tbl->cir_lut = NULL;\n\tqseed3_lut_tbl->sep_lut = NULL;\n\tqseed3_lut_tbl->valid = false;\n\tmutex_unlock(&mdata->scaler_off->scaler_lock);\n\n\treturn ret;\n}'
p418
S'78a8a5037990'
p419
sssS'CVE-2019-10607'
p420
(dp421
(S'security/selinux/ss/services.c'
p422
S'security_context_to_sid_core'
p423
tp424
(dp425
S'static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\n\t/* Copy the string to allow changes and ensure a NUL terminator */\n\tscontext2 = kmemdup_nul(scontext, scontext_len, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\n\tif (!ss_initialized) {\n\t\tint i;\n\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext2)) {\n\t\t\t\t*sid = i;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\tgoto out;\n\t}\n\t*sid = SECSID_NULL;\n\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = strlen(str) + 1;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}'
p426
S'2e93e7371810'
p427
sssS'CVE-2019-2287'
p428
(dp429
(S'drivers/media/platform/msm/vidc/hfi_response_handler.c'
p430
S'hfi_fill_codec_info'
p431
tp432
(dp433
S'static int hfi_fill_codec_info(u8 *data_ptr,\n\t\tstruct vidc_hal_sys_init_done *sys_init_done) {\n\tu32 i;\n\tu32 codecs = 0, codec_count = 0, size = 0;\n\tstruct msm_vidc_capability *capability;\n\tu32 prop_id = *((u32 *)data_ptr);\n\tu8 *orig_data_ptr = data_ptr;\n\n\tif (prop_id ==  HFI_PROPERTY_PARAM_CODEC_SUPPORTED) {\n\t\tstruct hfi_codec_supported *prop;\n\n\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\tprop = (struct hfi_codec_supported *) data_ptr;\n\t\tsys_init_done->dec_codec_supported =\n\t\t\tprop->decoder_codec_supported;\n\t\tsys_init_done->enc_codec_supported =\n\t\t\tprop->encoder_codec_supported;\n\t\tsize = sizeof(struct hfi_codec_supported) + sizeof(u32);\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"%s: prop_id %#x, expected codec_supported property\\n",\n\t\t\t__func__, prop_id);\n\t}\n\n\tcodecs = sys_init_done->dec_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_DECODER);\n\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported decoder sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcodecs = sys_init_done->enc_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_ENCODER);\n\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsys_init_done->codec_count = codec_count;\n\n\tprop_id = *((u32 *)(orig_data_ptr + size));\n\tif (prop_id == HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED) {\n\t\tstruct hfi_max_sessions_supported *prop =\n\t\t\t(struct hfi_max_sessions_supported *)\n\t\t\t(orig_data_ptr + size + sizeof(u32));\n\n\t\tsys_init_done->max_sessions_supported = prop->max_sessions;\n\t\tsize += sizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\tdprintk(VIDC_DBG, "max_sessions_supported %d\\n",\n\t\t\t\tprop->max_sessions);\n\t}\n\treturn size;\n}'
p434
S'de6abb23dc05'
p435
sS'static int hfi_fill_codec_info(u8 *data_ptr,\n\t\tstruct vidc_hal_sys_init_done *sys_init_done, u32 rem_size) {\n\tu32 i;\n\tu32 codecs = 0, codec_count = 0, size = 0;\n\tstruct msm_vidc_capability *capability;\n\tu32 prop_id = *((u32 *)data_ptr);\n\tu8 *orig_data_ptr = data_ptr;\n\n\tif (prop_id ==  HFI_PROPERTY_PARAM_CODEC_SUPPORTED) {\n\t\tstruct hfi_codec_supported *prop;\n\n\t\tif (!validate_pkt_size(rem_size - sizeof(u32),\n\t\t\t\t       sizeof(struct hfi_codec_supported)))\n\t\t\treturn -E2BIG;\n\t\tdata_ptr = data_ptr + sizeof(u32);\n\t\tprop = (struct hfi_codec_supported *) data_ptr;\n\t\tsys_init_done->dec_codec_supported =\n\t\t\tprop->decoder_codec_supported;\n\t\tsys_init_done->enc_codec_supported =\n\t\t\tprop->encoder_codec_supported;\n\t\tsize = sizeof(struct hfi_codec_supported) + sizeof(u32);\n\t\trem_size -=\n\t\t\tsizeof(struct hfi_codec_supported) + sizeof(u32);\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"%s: prop_id %#x, expected codec_supported property\\n",\n\t\t\t__func__, prop_id);\n\t}\n\n\tcodecs = sys_init_done->dec_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_DECODER);\n\t\t\tif (codec_count == VIDC_MAX_DECODE_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported decoder sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tcodecs = sys_init_done->enc_codec_supported;\n\tfor (i = 0; i < 8 * sizeof(codecs); i++) {\n\t\tif ((1 << i) & codecs) {\n\t\t\tcapability =\n\t\t\t\t&sys_init_done->capabilities[codec_count++];\n\t\t\tcapability->codec =\n\t\t\t\tvidc_get_hal_codec((1 << i) & codecs);\n\t\t\tcapability->domain =\n\t\t\t\tvidc_get_hal_domain(HFI_VIDEO_DOMAIN_ENCODER);\n\t\t\tif (codec_count == VIDC_MAX_SESSIONS) {\n\t\t\t\tdprintk(VIDC_ERR,\n\t\t\t\t\t"Max supported sessions reached");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tsys_init_done->codec_count = codec_count;\n\n\tif (!validate_pkt_size(rem_size, sizeof(u32)))\n\t\treturn -E2BIG;\n\tprop_id = *((u32 *)(orig_data_ptr + size));\n\tif (prop_id == HFI_PROPERTY_PARAM_MAX_SESSIONS_SUPPORTED) {\n\t\tstruct hfi_max_sessions_supported *prop;\n\n\t\tif (!validate_pkt_size(rem_size - sizeof(u32), sizeof(struct\n\t\t\t\thfi_max_sessions_supported)))\n\t\t\treturn -E2BIG;\n\t\tprop = (struct hfi_max_sessions_supported *)\n\t\t\t(orig_data_ptr + size + sizeof(u32));\n\n\t\tsys_init_done->max_sessions_supported = prop->max_sessions;\n\t\tsize += sizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\trem_size -=\n\t\t\tsizeof(struct hfi_max_sessions_supported) + sizeof(u32);\n\t\tdprintk(VIDC_DBG, "max_sessions_supported %d\\n",\n\t\t\t\tprop->max_sessions);\n\t}\n\treturn size;\n}'
p436
S'2851bf7e6847'
p437
sssS'CVE-2019-2182'
p438
(dp439
(S'arch/arm64/mm/mmu.c'
p440
S'pmd_set_huge'
p441
tp442
(dp443
S"int pmd_set_huge(pmd_t *pmd, phys_addr_t phys, pgprot_t prot)\n{\n\t/* ioremap_page_range doesn't honour BBM */\n\tif (pmd_present(READ_ONCE(*pmd)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmd, __pmd(phys | PMD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));\n\treturn 1;\n}"
p444
S'0fc5d4170d0e'
p445
sS'int pmd_set_huge(pmd_t *pmd, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmd)),\n\t\t\t\t   pmd_val(new_pmd)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmd, new_pmd);\n\treturn 1;\n}'
p446
S'a77c16d4981b'
p447
sS'int pmd_set_huge(pmd_t *pmdp, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PMD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpmd_t new_pmd = pfn_pmd(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pmd_val(*pmdp)),\n\t\t\t\t   pmd_val(new_pmd)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PMD_MASK);\n\tset_pmd(pmdp, new_pmd);\n\treturn 1;\n}'
p448
S'146de2055790'
p449
ss(g440
S'pud_set_huge'
p450
tp451
(dp452
S"int pud_set_huge(pud_t *pud, phys_addr_t phys, pgprot_t prot)\n{\n\t/* ioremap_page_range doesn't honour BBM */\n\tif (pud_present(READ_ONCE(*pud)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PUD_MASK);\n\tset_pud(pud, __pud(phys | PUD_TYPE_SECT | pgprot_val(mk_sect_prot(prot))));\n\treturn 1;\n}"
p453
g445
sS'int pud_set_huge(pud_t *pud, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PUD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpud_t new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pud_val(*pud)),\n\t\t\t\t   pud_val(new_pud)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PUD_MASK);\n\tset_pud(pud, new_pud);\n\treturn 1;\n}'
p454
g447
sS'int pud_set_huge(pud_t *pudp, phys_addr_t phys, pgprot_t prot)\n{\n\tpgprot_t sect_prot = __pgprot(PUD_TYPE_SECT |\n\t\t\t\t\tpgprot_val(mk_sect_prot(prot)));\n\tpud_t new_pud = pfn_pud(__phys_to_pfn(phys), sect_prot);\n\n\t/* Only allow permission changes for now */\n\tif (!pgattr_change_is_safe(READ_ONCE(pud_val(*pudp)),\n\t\t\t\t   pud_val(new_pud)))\n\t\treturn 0;\n\n\tBUG_ON(phys & ~PUD_MASK);\n\tset_pud(pudp, new_pud);\n\treturn 1;\n}'
p455
g449
sssS'CVE-2019-10524'
p456
(dp457
(S'drivers/media/platform/msm/camera_v2/common/msm_camera_io_util.c'
p458
S'msm_cam_clk_enable'
p459
tp460
(dp461
S'int msm_cam_clk_enable(struct device *dev, struct msm_cam_clk_info *clk_info,\n\t\tstruct clk **clk_ptr, int num_clk, int enable)\n{\n\tint i;\n\tint rc = 0;\n\tlong clk_rate;\n\n\tif (enable) {\n\t\tfor (i = 0; i < num_clk; i++) {\n\t\t\tCDBG("%s enable %s\\n", __func__, clk_info[i].clk_name);\n\t\t\tclk_ptr[i] = clk_get(dev, clk_info[i].clk_name);\n\t\t\tif (IS_ERR(clk_ptr[i])) {\n\t\t\t\tpr_err("%s get failed\\n", clk_info[i].clk_name);\n\t\t\t\trc = PTR_ERR(clk_ptr[i]);\n\t\t\t\tgoto cam_clk_get_err;\n\t\t\t}\n\t\t\tif (clk_info[i].clk_rate > 0) {\n\t\t\t\tclk_rate = clk_round_rate(clk_ptr[i],\n\t\t\t\t\tclk_info[i].clk_rate);\n\t\t\t\tif (clk_rate < 0) {\n\t\t\t\t\tpr_err("%s round failed\\n",\n\t\t\t\t\t\t   clk_info[i].clk_name);\n\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t}\n\t\t\t\trc = clk_set_rate(clk_ptr[i],\n\t\t\t\t\tclk_rate);\n\t\t\t\tif (rc < 0) {\n\t\t\t\t\tpr_err("%s set failed\\n",\n\t\t\t\t\t\tclk_info[i].clk_name);\n\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t}\n\n\t\t\t} else if (clk_info[i].clk_rate == INIT_RATE) {\n\t\t\t\tclk_rate = clk_get_rate(clk_ptr[i]);\n\t\t\t\tif (clk_rate == 0) {\n\t\t\t\t\tclk_rate =\n\t\t\t\t\t\t  clk_round_rate(clk_ptr[i], 0);\n\t\t\t\t\tif (clk_rate < 0) {\n\t\t\t\t\t\tpr_err("%s round rate failed\\n",\n\t\t\t\t\t\t\t  clk_info[i].clk_name);\n\t\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t\t}\n\t\t\t\t\trc = clk_set_rate(clk_ptr[i],\n\t\t\t\t\t\t\t\tclk_rate);\n\t\t\t\t\tif (rc < 0) {\n\t\t\t\t\t\tpr_err("%s set rate failed\\n",\n\t\t\t\t\t\t\t  clk_info[i].clk_name);\n\t\t\t\t\t\tgoto cam_clk_set_err;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trc = clk_prepare(clk_ptr[i]);\n\t\t\tif (rc < 0) {\n\t\t\t\tpr_err("%s prepare failed\\n",\n\t\t\t\t\t   clk_info[i].clk_name);\n\t\t\t\tgoto cam_clk_prepare_err;\n\t\t\t}\n\n\t\t\trc = clk_enable(clk_ptr[i]);\n\t\t\tif (rc < 0) {\n\t\t\t\tpr_err("%s enable failed\\n",\n\t\t\t\t\t   clk_info[i].clk_name);\n\t\t\t\tgoto cam_clk_enable_err;\n\t\t\t}\n\t\t\tif (clk_info[i].delay > 20) {\n\t\t\t\tmsleep(clk_info[i].delay);\n\t\t\t} else if (clk_info[i].delay) {\n\t\t\t\tusleep_range(clk_info[i].delay * 1000,\n\t\t\t\t\t(clk_info[i].delay * 1000) + 1000);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (i = num_clk - 1; i >= 0; i--) {\n\t\t\tif (!IS_ERR_OR_NULL(clk_ptr[i])) {\n\t\t\t\tCDBG("%s disable %s\\n", __func__,\n\t\t\t\t\tclk_info[i].clk_name);\n\t\t\t\tclk_disable(clk_ptr[i]);\n\t\t\t\tclk_unprepare(clk_ptr[i]);\n\t\t\t\tclk_put(clk_ptr[i]);\n\t\t\t\tclk_ptr[i] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\treturn rc;\n\n\ncam_clk_enable_err:\n\tclk_unprepare(clk_ptr[i]);\ncam_clk_prepare_err:\ncam_clk_set_err:\n\tclk_put(clk_ptr[i]);\ncam_clk_get_err:\n\tfor (i--; i >= 0; i--) {\n\t\tif (!IS_ERR_OR_NULL(clk_ptr[i])) {\n\t\t\tclk_disable(clk_ptr[i]);\n\t\t\tclk_unprepare(clk_ptr[i]);\n\t\t\tclk_put(clk_ptr[i]);\n\t\t\tclk_ptr[i] = NULL;\n\t\t}\n\t}\n\treturn rc;\n}'
p462
S'9393739f2aa4'
p463
sssS'CVE-2019-2333'
p464
(dp465
(S'drivers/platform/msm/ipa/ipa_v3/ipa_intf.c'
p466
S'ipa3_read'
p467
tp468
(dp469
S'ssize_t ipa3_read(struct file *filp, char __user *buf, size_t count,\n\t\t  loff_t *f_pos)\n{\n\tchar __user *start;\n\tstruct ipa3_push_msg *msg = NULL;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint locked;\n\n\tstart = buf;\n\n\tadd_wait_queue(&ipa3_ctx->msg_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&ipa3_ctx->msg_lock);\n\t\tlocked = 1;\n\n\t\tif (!list_empty(&ipa3_ctx->msg_list)) {\n\t\t\tmsg = list_first_entry(&ipa3_ctx->msg_list,\n\t\t\t\t\tstruct ipa3_push_msg, link);\n\t\t\tlist_del(&msg->link);\n\t\t}\n\n\t\tIPADBG_LOW("msg=%p\\n", msg);\n\n\t\tif (msg) {\n\t\t\tlocked = 0;\n\t\t\tmutex_unlock(&ipa3_ctx->msg_lock);\n\t\t\tif (count < sizeof(struct ipa_msg_meta)) {\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (copy_to_user(buf, &msg->meta,\n\t\t\t\t\t  sizeof(struct ipa_msg_meta))) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += sizeof(struct ipa_msg_meta);\n\t\t\tcount -= sizeof(struct ipa_msg_meta);\n\t\t\tif (msg->buff) {\n\t\t\t\tif (count >= msg->meta.msg_len) {\n\t\t\t\t\tif (copy_to_user(buf, msg->buff,\n\t\t\t\t\t\t\tmsg->meta.msg_len)) {\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t\tkfree(msg);\n\t\t\t\t\t\tmsg = NULL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tkfree(msg);\n\t\t\t\t\tmsg = NULL;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuf += msg->meta.msg_len;\n\t\t\t\tcount -= msg->meta.msg_len;\n\t\t\t\tmsg->callback(msg->buff, msg->meta.msg_len,\n\t\t\t\t\t       msg->meta.msg_type);\n\t\t\t}\n\t\t\tIPA_STATS_INC_CNT(\n\t\t\t\tipa3_ctx->stats.msg_r[msg->meta.msg_type]);\n\t\t\tkfree(msg);\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\tlocked = 0;\n\t\tmutex_unlock(&ipa3_ctx->msg_lock);\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\n\tremove_wait_queue(&ipa3_ctx->msg_waitq, &wait);\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\n\tif (locked)\n\t\tmutex_unlock(&ipa3_ctx->msg_lock);\n\n\treturn ret;\n}'
p470
S'6c6aaf4e8330'
p471
ss(S'drivers/platform/msm/ipa/ipa_v2/ipa_intf.c'
p472
S'ipa_read'
p473
tp474
(dp475
S'ssize_t ipa_read(struct file *filp, char __user *buf, size_t count,\n\t\t  loff_t *f_pos)\n{\n\tchar __user *start;\n\tstruct ipa_push_msg *msg = NULL;\n\tint ret;\n\tDEFINE_WAIT_FUNC(wait, woken_wake_function);\n\tint locked;\n\n\tstart = buf;\n\n\tadd_wait_queue(&ipa_ctx->msg_waitq, &wait);\n\twhile (1) {\n\t\tmutex_lock(&ipa_ctx->msg_lock);\n\t\tlocked = 1;\n\t\tif (!list_empty(&ipa_ctx->msg_list)) {\n\t\t\tmsg = list_first_entry(&ipa_ctx->msg_list,\n\t\t\t\t\tstruct ipa_push_msg, link);\n\t\t\tlist_del(&msg->link);\n\t\t}\n\n\t\tif (msg) {\n\t\t\tIPADBG("msg=%pK\\n", msg);\n\t\t\tlocked = 0;\n\t\t\tmutex_unlock(&ipa_ctx->msg_lock);\n\t\t\tif (count < sizeof(struct ipa_msg_meta)) {\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (copy_to_user(buf, &msg->meta,\n\t\t\t\t\tsizeof(struct ipa_msg_meta))) {\n\t\t\t\tkfree(msg);\n\t\t\t\tmsg = NULL;\n\t\t\t\tret = -EFAULT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += sizeof(struct ipa_msg_meta);\n\t\t\tcount -= sizeof(struct ipa_msg_meta);\n\t\t\tif (msg->buff) {\n\t\t\t\tif (count >= msg->meta.msg_len) {\n\t\t\t\t\tif (copy_to_user(buf, msg->buff,\n\t\t\t\t\t\t\tmsg->meta.msg_len)) {\n\t\t\t\t\t\tkfree(msg);\n\t\t\t\t\t\tmsg = NULL;\n\t\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkfree(msg);\n\t\t\t\t\tmsg = NULL;\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tbuf += msg->meta.msg_len;\n\t\t\t\tcount -= msg->meta.msg_len;\n\t\t\t\tmsg->callback(msg->buff, msg->meta.msg_len,\n\t\t\t\t\t       msg->meta.msg_type);\n\t\t\t}\n\t\t\tIPA_STATS_INC_CNT(\n\t\t\t\tipa_ctx->stats.msg_r[msg->meta.msg_type]);\n\t\t\tkfree(msg);\n\t\t\tmsg = NULL;\n\t\t}\n\n\t\tret = -EAGAIN;\n\t\tif (filp->f_flags & O_NONBLOCK)\n\t\t\tbreak;\n\n\t\tret = -EINTR;\n\t\tif (signal_pending(current))\n\t\t\tbreak;\n\n\t\tif (start != buf)\n\t\t\tbreak;\n\n\t\tlocked = 0;\n\t\tmutex_unlock(&ipa_ctx->msg_lock);\n\t\twait_woken(&wait, TASK_INTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);\n\t}\n\n\tremove_wait_queue(&ipa_ctx->msg_waitq, &wait);\n\tif (start != buf && ret != -EFAULT)\n\t\tret = buf - start;\n\n\tif (locked)\n\t\tmutex_unlock(&ipa_ctx->msg_lock);\n\n\treturn ret;\n}'
p476
S'6c6aaf4e8330'
p477
sssS'CVE-2019-2308'
p478
(dp479
(S'drivers/char/adsprpc.c'
p480
S'fastrpc_munmap_on_dsp_rh'
p481
tp482
(dp483
S'static int fastrpc_munmap_on_dsp_rh(struct fastrpc_file *fl, uint64_t phys,\n\t\t\t\t\t\tsize_t size, uint32_t flags)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tint tgid = 0;\n\tint destVM[1] = {VMID_HLOS};\n\tint destVMperm[1] = {PERM_READ | PERM_WRITE | PERM_EXEC};\n\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\t\tstruct scm_desc desc = {0};\n\t\tremote_arg_t ra[2];\n\n\t\tstruct {\n\t\t\tuint8_t skey;\n\t\t} routargs;\n\n\t\tif (fl == NULL)\n\t\t\tgoto bail;\n\t\ttgid = fl->tgid;\n\t\tra[0].buf.pv = (void *)&tgid;\n\t\tra[0].buf.len = sizeof(tgid);\n\t\tra[1].buf.pv = (void *)&routargs;\n\t\tra[1].buf.len = sizeof(routargs);\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(9, 1, 1);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\n\n\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.args[3] = routargs.skey;\n\t\tdesc.arginfo = SCM_ARGS(4);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_CLEAR_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\tdestVM, destVMperm, 1));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn err;\n}'
p484
S'0c755962c9cc'
p485
sS'static int fastrpc_munmap_on_dsp_rh(struct fastrpc_file *fl, uint64_t phys,\n\t\t\t\t\t\tsize_t size, uint32_t flags)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tint tgid = 0;\n\tint destVM[1] = {VMID_HLOS};\n\tint destVMperm[1] = {PERM_READ | PERM_WRITE | PERM_EXEC};\n\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\t\tstruct scm_desc desc = {0};\n\t\tremote_arg_t ra[2];\n\n\t\tstruct {\n\t\t\tuint8_t skey;\n\t\t} routargs;\n\n\t\tif (fl == NULL)\n\t\t\tgoto bail;\n\t\ttgid = fl->tgid;\n\t\tra[0].buf.pv = (void *)&tgid;\n\t\tra[0].buf.len = sizeof(tgid);\n\t\tra[1].buf.pv = (void *)&routargs;\n\t\tra[1].buf.len = sizeof(routargs);\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(9, 1, 1);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\n\n\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err == AEE_EUNSUPPORTED) {\n\t\t\tremote_arg_t ra[1];\n\n\t\t\tpr_warn("ADSPRPC:Failed to get security key with updated remote call, falling back to older method");\n\t\t\tra[0].buf.pv = (void *)&routargs;\n\t\t\tra[0].buf.len = sizeof(routargs);\n\t\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);\n\t\t\tioctl.inv.pra = ra;\n\t\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\t}\n\t\tif (err)\n\t\t\tgoto bail;\n\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.args[3] = routargs.skey;\n\t\tdesc.arginfo = SCM_ARGS(4);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_CLEAR_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\tdestVM, destVMperm, 1));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn err;\n}'
p486
S'7dca8885b04d'
p487
sS'static int fastrpc_munmap_on_dsp_rh(struct fastrpc_file *fl, uint64_t phys,\n\t\t\t\t\t\tsize_t size, uint32_t flags)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tint destVM[1] = {VMID_HLOS};\n\tint destVMperm[1] = {PERM_READ | PERM_WRITE | PERM_EXEC};\n\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\t\tstruct scm_desc desc = {0};\n\t\tremote_arg_t ra[1];\n\t\tint err = 0;\n\t\tstruct {\n\t\t\tuint8_t skey;\n\t\t} routargs;\n\n\t\tra[0].buf.pv = (void *)&routargs;\n\t\tra[0].buf.len = sizeof(routargs);\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 0, 1);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tif (fl == NULL)\n\t\t\tgoto bail;\n\n\t\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.args[3] = routargs.skey;\n\t\tdesc.arginfo = SCM_ARGS(4);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_CLEAR_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\tdestVM, destVMperm, 1));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\nbail:\n\treturn err;\n}'
p488
S'058ddcee4c12'
p489
ss(g480
S'fastrpc_mmap_on_dsp'
p490
tp491
(dp492
S'static int fastrpc_mmap_on_dsp(struct fastrpc_file *fl, uint32_t flags,\n\t\t\t\t\tuintptr_t va, uint64_t phys,\n\t\t\t\t\tsize_t size, uintptr_t *raddr)\n{\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tstruct fastrpc_apps *me = &gfa;\n\tstruct smq_phy_page page;\n\tint num = 1;\n\tremote_arg_t ra[3];\n\tint err = 0;\n\tstruct {\n\t\tint pid;\n\t\tuint32_t flags;\n\t\tuintptr_t vaddrin;\n\t\tint num;\n\t} inargs;\n\tstruct {\n\t\tuintptr_t vaddrout;\n\t} routargs;\n\n\tinargs.pid = fl->tgid;\n\tinargs.vaddrin = (uintptr_t)va;\n\tinargs.flags = flags;\n\tinargs.num = fl->apps->compat ? num * sizeof(page) : num;\n\tra[0].buf.pv = (void *)&inargs;\n\tra[0].buf.len = sizeof(inargs);\n\tpage.addr = phys;\n\tpage.size = size;\n\tra[1].buf.pv = (void *)&page;\n\tra[1].buf.len = num * sizeof(page);\n\n\tra[2].buf.pv = (void *)&routargs;\n\tra[2].buf.len = sizeof(routargs);\n\n\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\tif (fl->apps->compat)\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(4, 2, 1);\n\telse\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(2, 2, 1);\n\tioctl.inv.pra = ra;\n\tioctl.fds = NULL;\n\tioctl.attrs = NULL;\n\tioctl.crc = NULL;\n\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t*raddr = (uintptr_t)routargs.vaddrout;\n\tif (err)\n\t\tgoto bail;\n\tif (flags == ADSP_MMAP_HEAP_ADDR) {\n\t\tstruct scm_desc desc = {0};\n\n\t\tdesc.args[0] = TZ_PIL_AUTH_QDSP6_PROC;\n\t\tdesc.args[1] = phys;\n\t\tdesc.args[2] = size;\n\t\tdesc.arginfo = SCM_ARGS(3);\n\t\terr = scm_call2(SCM_SIP_FNID(SCM_SVC_PIL,\n\t\t\tTZ_PIL_PROTECT_MEM_SUBSYS_ID), &desc);\n\t} else if (flags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\thlosvm, 1, me->channel[fl->cid].rhvm.vmid,\n\t\t\t\tme->channel[fl->cid].rhvm.vmperm,\n\t\t\t\tme->channel[fl->cid].rhvm.vmcount));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\nbail:\n\treturn err;\n}'
p493
g489
ss(g480
S'fastrpc_internal_invoke'
p494
tp495
(dp496
S'static int fastrpc_internal_invoke(struct fastrpc_file *fl, uint32_t mode,\n\t\t\t\t   uint32_t kernel,\n\t\t\t\t   struct fastrpc_ioctl_invoke_crc *inv)\n{\n\tstruct smq_invoke_ctx *ctx = NULL;\n\tstruct fastrpc_ioctl_invoke *invoke = &inv->inv;\n\tint cid = fl->cid;\n\tint interrupted = 0;\n\tint err = 0;\n\tstruct timespec invoket = {0};\n\tint64_t *perf_counter = getperfcounter(fl, PERF_COUNT);\n\n\tif (fl->profile)\n\t\tgetnstimeofday(&invoket);\n\n\tif (!kernel) {\n\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);\n\t\tif (err) {\n\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",\n\t\t\t\t__func__, current->comm, cid);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tVERIFY(err, fl->sctx != NULL);\n\tif (err)\n\t\tgoto bail;\n\tVERIFY(err, fl->cid >= 0 && fl->cid < NUM_CHANNELS);\n\tif (err)\n\t\tgoto bail;\n\n\tif (!kernel) {\n\t\tVERIFY(err, 0 == context_restore_interrupted(fl, inv,\n\t\t\t\t\t\t\t\t&ctx));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (fl->sctx->smmu.faults)\n\t\t\terr = FASTRPC_ENOSUCH;\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (ctx)\n\t\t\tgoto wait;\n\t}\n\n\tVERIFY(err, 0 == context_alloc(fl, kernel, inv, &ctx));\n\tif (err)\n\t\tgoto bail;\n\n\tif (REMOTE_SCALARS_LENGTH(ctx->sc)) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_GETARGS),\n\t\tVERIFY(err, 0 == get_args(kernel, ctx));\n\t\tPERF_END);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tif (!fl->sctx->smmu.coherent) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\t\tinv_args_pre(ctx);\n\t\tPERF_END);\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_LINK),\n\tVERIFY(err, 0 == fastrpc_invoke_send(ctx, kernel, invoke->handle));\n\tPERF_END);\n\n\tif (err)\n\t\tgoto bail;\n wait:\n\tif (kernel)\n\t\twait_for_completion(&ctx->work);\n\telse {\n\t\tinterrupted = wait_for_completion_interruptible(&ctx->work);\n\t\tVERIFY(err, 0 == (err = interrupted));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\tif (ctx->handle)\n\t\tglink_rx_done(ctx->handle, ctx->ptr, true);\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\tif (!fl->sctx->smmu.coherent)\n\t\tinv_args(ctx);\n\tPERF_END);\n\n\tVERIFY(err, 0 == (err = ctx->retval));\n\tif (err)\n\t\tgoto bail;\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_PUTARGS),\n\tVERIFY(err, 0 == put_args(kernel, ctx, invoke->pra));\n\tPERF_END);\n\tif (err)\n\t\tgoto bail;\n bail:\n\tif (ctx && interrupted == -ERESTARTSYS)\n\t\tcontext_save_interrupted(ctx);\n\telse if (ctx)\n\t\tcontext_free(ctx);\n\tif (fl->ssrcount != fl->apps->channel[cid].ssrcount)\n\t\terr = ECONNRESET;\n\n\tif (fl->profile && !interrupted) {\n\t\tif (invoke->handle != FASTRPC_STATIC_HANDLE_LISTENER) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_INVOKE);\n\n\t\t\tif (count)\n\t\t\t\t*count += getnstimediff(&invoket);\n\t\t}\n\t\tif (invoke->handle > FASTRPC_STATIC_HANDLE_MAX) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_COUNT);\n\n\t\t\tif (count)\n\t\t\t\t*count = *count+1;\n\t\t}\n\t}\n\treturn err;\n}'
p497
S'1d1a62b98700'
p498
sS'static int fastrpc_internal_invoke(struct fastrpc_file *fl, uint32_t mode,\n\t\t\t\t   uint32_t kernel,\n\t\t\t\t   struct fastrpc_ioctl_invoke_crc *inv)\n{\n\tstruct smq_invoke_ctx *ctx = NULL;\n\tstruct fastrpc_ioctl_invoke *invoke = &inv->inv;\n\tint cid = fl->cid;\n\tint interrupted = 0;\n\tint err = 0;\n\tstruct timespec invoket = {0};\n\tint64_t *perf_counter = getperfcounter(fl, PERF_COUNT);\n\n\tif (fl->profile)\n\t\tgetnstimeofday(&invoket);\n\n\tif (!kernel) {\n\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);\n\t\tif (err) {\n\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",\n\t\t\t\t__func__, current->comm, cid);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tVERIFY(err, fl->sctx != NULL);\n\tif (err)\n\t\tgoto bail;\n\tVERIFY(err, fl->cid >= 0 && fl->cid < NUM_CHANNELS);\n\tif (err)\n\t\tgoto bail;\n\n\tif (!kernel) {\n\t\tVERIFY(err, 0 == context_restore_interrupted(fl, inv,\n\t\t\t\t\t\t\t\t&ctx));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (fl->sctx->smmu.faults)\n\t\t\terr = FASTRPC_ENOSUCH;\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (ctx)\n\t\t\tgoto wait;\n\t}\n\n\tVERIFY(err, 0 == context_alloc(fl, kernel, inv, &ctx));\n\tif (err)\n\t\tgoto bail;\n\n\tif (REMOTE_SCALARS_LENGTH(ctx->sc)) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_GETARGS),\n\t\tVERIFY(err, 0 == get_args(kernel, ctx));\n\t\tPERF_END);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tif (!fl->sctx->smmu.coherent) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\t\tinv_args_pre(ctx);\n\t\tPERF_END);\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_LINK),\n\tVERIFY(err, 0 == fastrpc_invoke_send(ctx, kernel, invoke->handle));\n\tPERF_END);\n\n\tif (err)\n\t\tgoto bail;\n wait:\n\tif (kernel)\n\t\twait_for_completion(&ctx->work);\n\telse {\n\t\tinterrupted = wait_for_completion_interruptible(&ctx->work);\n\t\tVERIFY(err, 0 == (err = interrupted));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\tif (!fl->sctx->smmu.coherent)\n\t\tinv_args(ctx);\n\tPERF_END);\n\n\tVERIFY(err, 0 == (err = ctx->retval));\n\tif (err)\n\t\tgoto bail;\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_PUTARGS),\n\tVERIFY(err, 0 == put_args(kernel, ctx, invoke->pra));\n\tPERF_END);\n\tif (err)\n\t\tgoto bail;\n bail:\n\tif (ctx && interrupted == -ERESTARTSYS)\n\t\tcontext_save_interrupted(ctx);\n\telse if (ctx)\n\t\tcontext_free(ctx);\n\tif (fl->ssrcount != fl->apps->channel[cid].ssrcount)\n\t\terr = ECONNRESET;\n\n\tif (fl->profile && !interrupted) {\n\t\tif (invoke->handle != FASTRPC_STATIC_HANDLE_LISTENER) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_INVOKE);\n\n\t\t\tif (count)\n\t\t\t\t*count += getnstimediff(&invoket);\n\t\t}\n\t\tif (invoke->handle > FASTRPC_STATIC_HANDLE_MAX) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_COUNT);\n\n\t\t\tif (count)\n\t\t\t\t*count = *count+1;\n\t\t}\n\t}\n\treturn err;\n}'
p499
g489
sS'static int fastrpc_internal_invoke(struct fastrpc_file *fl, uint32_t mode,\n\t\t\t\t   uint32_t kernel,\n\t\t\t\t   struct fastrpc_ioctl_invoke_crc *inv)\n{\n\tstruct smq_invoke_ctx *ctx = NULL;\n\tstruct fastrpc_ioctl_invoke *invoke = &inv->inv;\n\tint err = 0, cid = -1, interrupted = 0;\n\tstruct timespec invoket = {0};\n\tint64_t *perf_counter = NULL;\n\n\tcid = fl->cid;\n\tVERIFY(err, cid >= ADSP_DOMAIN_ID && cid < NUM_CHANNELS);\n\tif (err) {\n\t\terr = -ECHRNG;\n\t\tgoto bail;\n\t}\n\tVERIFY(err, fl->sctx != NULL);\n\tif (err) {\n\t\terr = -EBADR;\n\t\tgoto bail;\n\t}\n\tperf_counter = getperfcounter(fl, PERF_COUNT);\n\n\tif (fl->profile)\n\t\tgetnstimeofday(&invoket);\n\n\tif (!kernel) {\n\t\tVERIFY(err, invoke->handle != FASTRPC_STATIC_HANDLE_KERNEL);\n\t\tif (err) {\n\t\t\tpr_err("adsprpc: ERROR: %s: user application %s trying to send a kernel RPC message to channel %d",\n\t\t\t\t__func__, current->comm, cid);\n\t\t\tgoto bail;\n\t\t}\n\t}\n\n\tif (!kernel) {\n\t\tVERIFY(err, 0 == context_restore_interrupted(fl, inv,\n\t\t\t\t\t\t\t\t&ctx));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (fl->sctx->smmu.faults)\n\t\t\terr = FASTRPC_ENOSUCH;\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (ctx)\n\t\t\tgoto wait;\n\t}\n\n\tVERIFY(err, 0 == context_alloc(fl, kernel, inv, &ctx));\n\tif (err)\n\t\tgoto bail;\n\n\tif (REMOTE_SCALARS_LENGTH(ctx->sc)) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_GETARGS),\n\t\tVERIFY(err, 0 == get_args(kernel, ctx));\n\t\tPERF_END);\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\n\tif (!fl->sctx->smmu.coherent) {\n\t\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\t\tinv_args_pre(ctx);\n\t\tPERF_END);\n\t}\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_LINK),\n\tVERIFY(err, 0 == fastrpc_invoke_send(ctx, kernel, invoke->handle));\n\tPERF_END);\n\n\tif (err)\n\t\tgoto bail;\n wait:\n\tif (kernel)\n\t\twait_for_completion(&ctx->work);\n\telse {\n\t\tinterrupted = wait_for_completion_interruptible(&ctx->work);\n\t\tVERIFY(err, 0 == (err = interrupted));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\n\tif (ctx->handle)\n\t\tglink_rx_done(ctx->handle, ctx->ptr, true);\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_INVARGS),\n\tif (!fl->sctx->smmu.coherent)\n\t\tinv_args(ctx);\n\tPERF_END);\n\n\tVERIFY(err, 0 == (err = ctx->retval));\n\tif (err)\n\t\tgoto bail;\n\n\tPERF(fl->profile, GET_COUNTER(perf_counter, PERF_PUTARGS),\n\tVERIFY(err, 0 == put_args(kernel, ctx, invoke->pra));\n\tPERF_END);\n\tif (err)\n\t\tgoto bail;\n bail:\n\tif (ctx && interrupted == -ERESTARTSYS)\n\t\tcontext_save_interrupted(ctx);\n\telse if (ctx)\n\t\tcontext_free(ctx);\n\tif (fl->ssrcount != fl->apps->channel[cid].ssrcount)\n\t\terr = ECONNRESET;\n\n\tif (fl->profile && !interrupted) {\n\t\tif (invoke->handle != FASTRPC_STATIC_HANDLE_LISTENER) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_INVOKE);\n\n\t\t\tif (count)\n\t\t\t\t*count += getnstimediff(&invoket);\n\t\t}\n\t\tif (invoke->handle > FASTRPC_STATIC_HANDLE_MAX) {\n\t\t\tint64_t *count = GET_COUNTER(perf_counter, PERF_COUNT);\n\n\t\t\tif (count)\n\t\t\t\t*count = *count+1;\n\t\t}\n\t}\n\treturn err;\n}'
p500
S'd6d7f6f8d00c'
p501
ss(g480
S'fastrpc_init_process'
p502
tp503
(dp504
S'static int fastrpc_init_process(struct fastrpc_file *fl,\n\t\t\t\tstruct fastrpc_ioctl_init_attrs *uproc)\n{\n\tint err = 0;\n\tstruct fastrpc_apps *me = &gfa;\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tstruct fastrpc_ioctl_init *init = &uproc->init;\n\tstruct smq_phy_page pages[1];\n\tstruct fastrpc_mmap *file = NULL, *mem = NULL;\n\tstruct fastrpc_buf *imem = NULL;\n\tunsigned long imem_dma_attr = 0;\n\tchar *proc_name = NULL;\n\n\tVERIFY(err, 0 == (err = fastrpc_channel_open(fl)));\n\tif (err)\n\t\tgoto bail;\n\tif (init->flags == FASTRPC_INIT_ATTACH ||\n\t\t\tinit->flags == FASTRPC_INIT_ATTACH_SENSORS) {\n\t\tremote_arg_t ra[1];\n\t\tint tgid = fl->tgid;\n\n\t\tra[0].buf.pv = (void *)&tgid;\n\t\tra[0].buf.len = sizeof(tgid);\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(0, 1, 0);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tif (init->flags == FASTRPC_INIT_ATTACH)\n\t\t\tfl->pd = 0;\n\t\telse if (init->flags == FASTRPC_INIT_ATTACH_SENSORS) {\n\t\t\tfl->spdname = SENSORS_PDR_SERVICE_LOCATION_CLIENT_NAME;\n\t\t\tfl->pd = 2;\n\t\t}\n\t\tVERIFY(err, !(err = fastrpc_internal_invoke(fl,\n\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t} else if (init->flags == FASTRPC_INIT_CREATE) {\n\t\tremote_arg_t ra[6];\n\t\tint fds[6];\n\t\tint mflags = 0;\n\t\tint memlen;\n\t\tstruct {\n\t\t\tint pgid;\n\t\t\tunsigned int namelen;\n\t\t\tunsigned int filelen;\n\t\t\tunsigned int pageslen;\n\t\t\tint attrs;\n\t\t\tint siglen;\n\t\t} inbuf;\n\n\t\tinbuf.pgid = fl->tgid;\n\t\tinbuf.namelen = strlen(current->comm) + 1;\n\t\tinbuf.filelen = init->filelen;\n\t\tfl->pd = 1;\n\n\t\tVERIFY(err, access_ok(0, (void __user *)init->file,\n\t\t\tinit->filelen));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tif (init->filelen) {\n\t\t\tmutex_lock(&fl->fl_map_mutex);\n\t\t\tVERIFY(err, !fastrpc_mmap_create(fl, init->filefd, 0,\n\t\t\t\tinit->file, init->filelen, mflags, &file));\n\t\t\tmutex_unlock(&fl->fl_map_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t}\n\t\tinbuf.pageslen = 1;\n\n\t\tVERIFY(err, !init->mem);\n\t\tif (err) {\n\t\t\terr = -EINVAL;\n\t\t\tpr_err("adsprpc: %s: %s: ERROR: donated memory allocated in userspace\\n",\n\t\t\t\tcurrent->comm, __func__);\n\t\t\tgoto bail;\n\t\t}\n\t\tmemlen = ALIGN(max(1024*1024*3, (int)init->filelen * 4),\n\t\t\t\t\t\t1024*1024);\n\t\timem_dma_attr = DMA_ATTR_EXEC_MAPPING |\n\t\t\t\t\t\tDMA_ATTR_NO_KERNEL_MAPPING |\n\t\t\t\t\t\tDMA_ATTR_FORCE_NON_COHERENT;\n\t\terr = fastrpc_buf_alloc(fl, memlen, imem_dma_attr, 0, 0, &imem);\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tfl->init_mem = imem;\n\n\t\tinbuf.pageslen = 1;\n\t\tra[0].buf.pv = (void *)&inbuf;\n\t\tra[0].buf.len = sizeof(inbuf);\n\t\tfds[0] = 0;\n\n\t\tra[1].buf.pv = (void *)current->comm;\n\t\tra[1].buf.len = inbuf.namelen;\n\t\tfds[1] = 0;\n\n\t\tra[2].buf.pv = (void *)init->file;\n\t\tra[2].buf.len = inbuf.filelen;\n\t\tfds[2] = init->filefd;\n\n\t\tpages[0].addr = imem->phys;\n\t\tpages[0].size = imem->size;\n\t\tra[3].buf.pv = (void *)pages;\n\t\tra[3].buf.len = 1 * sizeof(*pages);\n\t\tfds[3] = 0;\n\n\t\tinbuf.attrs = uproc->attrs;\n\t\tra[4].buf.pv = (void *)&(inbuf.attrs);\n\t\tra[4].buf.len = sizeof(inbuf.attrs);\n\t\tfds[4] = 0;\n\n\t\tinbuf.siglen = uproc->siglen;\n\t\tra[5].buf.pv = (void *)&(inbuf.siglen);\n\t\tra[5].buf.len = sizeof(inbuf.siglen);\n\t\tfds[5] = 0;\n\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(6, 4, 0);\n\t\tif (uproc->attrs)\n\t\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(7, 6, 0);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = fds;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tVERIFY(err, !(err = fastrpc_internal_invoke(fl,\n\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t} else if (init->flags == FASTRPC_INIT_CREATE_STATIC) {\n\t\tremote_arg_t ra[3];\n\t\tuint64_t phys = 0;\n\t\tsize_t size = 0;\n\t\tint fds[3];\n\t\tstruct {\n\t\t\tint pgid;\n\t\t\tunsigned int namelen;\n\t\t\tunsigned int pageslen;\n\t\t} inbuf;\n\n\t\tif (!init->filelen)\n\t\t\tgoto bail;\n\n\t\tproc_name = kzalloc(init->filelen, GFP_KERNEL);\n\t\tVERIFY(err, !IS_ERR_OR_NULL(proc_name));\n\t\tif (err)\n\t\t\tgoto bail;\n\t\tVERIFY(err, 0 == copy_from_user((void *)proc_name,\n\t\t\t(void __user *)init->file, init->filelen));\n\t\tif (err)\n\t\t\tgoto bail;\n\n\t\tfl->pd = 1;\n\t\tinbuf.pgid = current->tgid;\n\t\tinbuf.namelen = init->filelen;\n\t\tinbuf.pageslen = 0;\n\n\t\tif (!strcmp(proc_name, "audiopd")) {\n\t\t\tfl->spdname = AUDIO_PDR_SERVICE_LOCATION_CLIENT_NAME;\n\t\t\tVERIFY(err, !fastrpc_mmap_remove_pdr(fl));\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t}\n\n\t\tif (!me->staticpd_flags) {\n\t\t\tinbuf.pageslen = 1;\n\t\t\tmutex_lock(&fl->fl_map_mutex);\n\t\t\tVERIFY(err, !fastrpc_mmap_create(fl, -1, 0, init->mem,\n\t\t\t\t init->memlen, ADSP_MMAP_REMOTE_HEAP_ADDR,\n\t\t\t\t &mem));\n\t\t\tmutex_unlock(&fl->fl_map_mutex);\n\t\t\tif (err)\n\t\t\t\tgoto bail;\n\t\t\tphys = mem->phys;\n\t\t\tsize = mem->size;\n\t\t\tVERIFY(err, !hyp_assign_phys(phys, (uint64_t)size,\n\t\t\t\thlosvm, 1, me->channel[fl->cid].rhvm.vmid,\n\t\t\t\tme->channel[fl->cid].rhvm.vmperm,\n\t\t\t\tme->channel[fl->cid].rhvm.vmcount));\n\t\t\tif (err) {\n\t\t\t\tpr_err("ADSPRPC: hyp_assign_phys fail err %d",\n\t\t\t\t\t\t\t err);\n\t\t\t\tpr_err("map->phys %llx, map->size %d\\n",\n\t\t\t\t\t\t\t phys, (int)size);\n\t\t\t\tgoto bail;\n\t\t\t}\n\t\t\tme->staticpd_flags = 1;\n\t\t}\n\n\t\tra[0].buf.pv = (void *)&inbuf;\n\t\tra[0].buf.len = sizeof(inbuf);\n\t\tfds[0] = 0;\n\n\t\tra[1].buf.pv = (void *)proc_name;\n\t\tra[1].buf.len = inbuf.namelen;\n\t\tfds[1] = 0;\n\n\t\tpages[0].addr = phys;\n\t\tpages[0].size = size;\n\n\t\tra[2].buf.pv = (void *)pages;\n\t\tra[2].buf.len = sizeof(*pages);\n\t\tfds[2] = 0;\n\t\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(8, 3, 0);\n\t\tioctl.inv.pra = ra;\n\t\tioctl.fds = NULL;\n\t\tioctl.attrs = NULL;\n\t\tioctl.crc = NULL;\n\t\tVERIFY(err, !(err = fastrpc_internal_invoke(fl,\n\t\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\t\tif (err)\n\t\t\tgoto bail;\n\t} else {\n\t\terr = -ENOTTY;\n\t}\nbail:\n\tkfree(proc_name);\n\tif (err && (init->flags == FASTRPC_INIT_CREATE_STATIC))\n\t\tme->staticpd_flags = 0;\n\tif (mem && err) {\n\t\tif (mem->flags == ADSP_MMAP_REMOTE_HEAP_ADDR)\n\t\t\thyp_assign_phys(mem->phys, (uint64_t)mem->size,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmid,\n\t\t\t\t\tme->channel[fl->cid].rhvm.vmcount,\n\t\t\t\t\thlosvm, hlosvmperm, 1);\n\t\tmutex_lock(&fl->fl_map_mutex);\n\t\tfastrpc_mmap_free(mem, 0);\n\t\tmutex_unlock(&fl->fl_map_mutex);\n\t}\n\tif (file) {\n\t\tmutex_lock(&fl->fl_map_mutex);\n\t\tfastrpc_mmap_free(file, 0);\n\t\tmutex_unlock(&fl->fl_map_mutex);\n\t}\n\treturn err;\n}'
p505
g489
ss(g480
S'fastrpc_release_current_dsp_process'
p506
tp507
(dp508
S'static int fastrpc_release_current_dsp_process(struct fastrpc_file *fl)\n{\n\tint err = 0;\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tremote_arg_t ra[1];\n\tint tgid = 0;\n\n\tVERIFY(err, fl->cid >= 0 && fl->cid < NUM_CHANNELS);\n\tif (err)\n\t\tgoto bail;\n\tVERIFY(err, fl->apps->channel[fl->cid].chan != NULL);\n\tif (err)\n\t\tgoto bail;\n\ttgid = fl->tgid;\n\tra[0].buf.pv = (void *)&tgid;\n\tra[0].buf.len = sizeof(tgid);\n\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\tioctl.inv.sc = REMOTE_SCALARS_MAKE(1, 1, 0);\n\tioctl.inv.pra = ra;\n\tioctl.fds = NULL;\n\tioctl.attrs = NULL;\n\tioctl.crc = NULL;\n\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\nbail:\n\treturn err;\n}'
p509
g489
ss(g480
S'fastrpc_munmap_on_dsp'
p510
tp511
(dp512
S'static int fastrpc_munmap_on_dsp(struct fastrpc_file *fl, uintptr_t raddr,\n\t\t\t\tuint64_t phys, size_t size, uint32_t flags)\n{\n\tstruct fastrpc_ioctl_invoke_crc ioctl;\n\tremote_arg_t ra[1];\n\tint err = 0;\n\tstruct {\n\t\tint pid;\n\t\tuintptr_t vaddrout;\n\t\tsize_t size;\n\t} inargs;\n\n\tinargs.pid = fl->tgid;\n\tinargs.size = size;\n\tinargs.vaddrout = raddr;\n\tra[0].buf.pv = (void *)&inargs;\n\tra[0].buf.len = sizeof(inargs);\n\n\tioctl.inv.handle = FASTRPC_STATIC_HANDLE_KERNEL;\n\tif (fl->apps->compat)\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(5, 1, 0);\n\telse\n\t\tioctl.inv.sc = REMOTE_SCALARS_MAKE(3, 1, 0);\n\tioctl.inv.pra = ra;\n\tioctl.fds = NULL;\n\tioctl.attrs = NULL;\n\tioctl.crc = NULL;\n\tVERIFY(err, 0 == (err = fastrpc_internal_invoke(fl,\n\t\tFASTRPC_MODE_PARALLEL, 1, &ioctl)));\n\tif (err)\n\t\tgoto bail;\n\tif (flags == ADSP_MMAP_HEAP_ADDR ||\n\t\t\t\tflags == ADSP_MMAP_REMOTE_HEAP_ADDR) {\n\t\tVERIFY(err, !fastrpc_munmap_on_dsp_rh(fl, phys, size, flags));\n\t\tif (err)\n\t\t\tgoto bail;\n\t}\nbail:\n\treturn err;\n}'
p513
g489
sssS'CVE-2019-2323'
p514
(dp515
(S'drivers/crypto/msm/ice.c'
p516
S'qcom_ice_setup_ice_hw'
p517
tp518
(dp519
S'int qcom_ice_setup_ice_hw(const char *storage_type, int enable)\n{\n\tint ret = -1;\n\tstruct ice_device *ice_dev = NULL;\n\n\tice_dev = get_ice_device_from_storage_type(storage_type);\n\tif (ice_dev == ERR_PTR(-EPROBE_DEFER))\n\t\treturn -EPROBE_DEFER;\n\n\tif (!ice_dev || (ice_dev->is_ice_enabled == false))\n\t\treturn ret;\n\n\tif (enable)\n\t\treturn enable_ice_setup(ice_dev);\n\telse\n\t\treturn disable_ice_setup(ice_dev);\n}'
p520
S'de6abb23dc05'
p521
ss(g516
S'get_ice_device_from_storage_type'
p522
tp523
(dp524
g95
g521
sssS'CVE-2018-1000204'
p525
(dp526
(S'drivers/scsi/sg.c'
p527
S'sg_build_indirect'
p528
tp529
(dp530
S'sg_build_indirect(Sg_scatter_hold * schp, Sg_fd * sfp, int buff_size)\n{\n\tint ret_sz = 0, i, k, rem_sz, num, mx_sc_elems;\n\tint sg_tablesize = sfp->parentdp->sg_tablesize;\n\tint blk_size = buff_size, order;\n\tgfp_t gfp_mask = GFP_ATOMIC | __GFP_COMP | __GFP_NOWARN;\n\tstruct sg_device *sdp = sfp->parentdp;\n\n\tif (blk_size < 0)\n\t\treturn -EFAULT;\n\tif (0 == blk_size)\n\t\t++blk_size;\t/* don\'t know why */\n\t/* round request up to next highest SG_SECTOR_SZ byte boundary */\n\tblk_size = ALIGN(blk_size, SG_SECTOR_SZ);\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t"sg_build_indirect: buff_size=%d, blk_size=%d\\n",\n\t\tbuff_size, blk_size));\n\n\t/* N.B. ret_sz carried into this block ... */\n\tmx_sc_elems = sg_build_sgat(schp, sfp, sg_tablesize);\n\tif (mx_sc_elems < 0)\n\t\treturn mx_sc_elems;\t/* most likely -ENOMEM */\n\n\tnum = scatter_elem_sz;\n\tif (unlikely(num != scatter_elem_sz_prev)) {\n\t\tif (num < PAGE_SIZE) {\n\t\t\tscatter_elem_sz = PAGE_SIZE;\n\t\t\tscatter_elem_sz_prev = PAGE_SIZE;\n\t\t} else\n\t\t\tscatter_elem_sz_prev = num;\n\t}\n\n\tif (sdp->device->host->unchecked_isa_dma)\n\t\tgfp_mask |= GFP_DMA;\n\n\tif (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))\n\t\tgfp_mask |= __GFP_ZERO;\n\n\torder = get_order(num);\nretry:\n\tret_sz = 1 << (PAGE_SHIFT + order);\n\n\tfor (k = 0, rem_sz = blk_size; rem_sz > 0 && k < mx_sc_elems;\n\t     k++, rem_sz -= ret_sz) {\n\n\t\tnum = (rem_sz > scatter_elem_sz_prev) ?\n\t\t\tscatter_elem_sz_prev : rem_sz;\n\n\t\tschp->pages[k] = alloc_pages(gfp_mask | __GFP_ZERO, order);\n\t\tif (!schp->pages[k])\n\t\t\tgoto out;\n\n\t\tif (num == scatter_elem_sz_prev) {\n\t\t\tif (unlikely(ret_sz > scatter_elem_sz_prev)) {\n\t\t\t\tscatter_elem_sz = ret_sz;\n\t\t\t\tscatter_elem_sz_prev = ret_sz;\n\t\t\t}\n\t\t}\n\n\t\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\t "sg_build_indirect: k=%d, num=%d, ret_sz=%d\\n",\n\t\t\t\t k, num, ret_sz));\n\t}\t\t/* end of for loop */\n\n\tschp->page_order = order;\n\tschp->k_use_sg = k;\n\tSCSI_LOG_TIMEOUT(5, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t "sg_build_indirect: k_use_sg=%d, rem_sz=%d\\n",\n\t\t\t k, rem_sz));\n\n\tschp->bufflen = blk_size;\n\tif (rem_sz > 0)\t/* must have failed */\n\t\treturn -ENOMEM;\n\treturn 0;\nout:\n\tfor (i = 0; i < k; i++)\n\t\t__free_pages(schp->pages[i], order);\n\n\tif (--order >= 0)\n\t\tgoto retry;\n\n\treturn -ENOMEM;\n}'
p531
S'98ae89537923'
p532
sssS'CVE-2019-15917'
p533
(dp534
(S'drivers/bluetooth/hci_ldisc.c'
p535
S'hci_uart_set_proto'
p536
tp537
(dp538
S'static int hci_uart_set_proto(struct hci_uart *hu, int id)\n{\n\tconst struct hci_uart_proto *p;\n\tint err;\n\n\tp = hci_uart_get_proto(id);\n\tif (!p)\n\t\treturn -EPROTONOSUPPORT;\n\n\terr = p->open(hu);\n\tif (err)\n\t\treturn err;\n\n\thu->proto = p;\n\n\terr = hci_uart_register_dev(hu);\n\tif (err) {\n\t\tp->close(hu);\n\t\treturn err;\n\t}\n\n\tset_bit(HCI_UART_PROTO_READY, &hu->flags);\n\treturn 0;\n}'
p539
S'e276e60d848d'
p540
sssS'CVE-2018-11919'
p541
(dp542
(S'drivers/soc/qcom/msm_bus/msm_bus_fabric_adhoc.c'
p543
S'msm_bus_device_init'
p544
tp545
(dp546
S'static struct device *msm_bus_device_init(\n\t\t\tstruct msm_bus_node_device_type *pdata)\n{\n\tstruct device *bus_dev = NULL;\n\tstruct msm_bus_node_device_type *bus_node = NULL;\n\tstruct msm_bus_node_info_type *node_info = NULL;\n\tint ret = 0;\n\n\t/**\n\t* Init here so we can use devm calls\n\t*/\n\n\tbus_node = kzalloc(sizeof(struct msm_bus_node_device_type), GFP_KERNEL);\n\tif (!bus_node) {\n\t\tret = -ENOMEM;\n\t\tgoto err_device_init;\n\t}\n\tbus_dev = &bus_node->dev;\n\tdevice_initialize(bus_dev);\n\n\tnode_info = devm_kzalloc(bus_dev,\n\t\t\tsizeof(struct msm_bus_node_info_type), GFP_KERNEL);\n\tif (!node_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_device;\n\t}\n\n\tbus_node->node_info = node_info;\n\tbus_node->ap_owned = pdata->ap_owned;\n\tbus_dev->of_node = pdata->of_node;\n\n\tret = msm_bus_copy_node_info(pdata, bus_dev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tbus_dev->bus = &msm_bus_type;\n\tdev_set_name(bus_dev, bus_node->node_info->name);\n\n\tret = device_add(bus_dev);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error registering device %d",\n\t\t\t\t__func__, pdata->node_info->id);\n\t\tgoto err_put_device;\n\t}\n\tdevice_create_file(bus_dev, &dev_attr_bw);\n\tINIT_LIST_HEAD(&bus_node->devlist);\n\treturn bus_dev;\n\nerr_put_device:\n\tput_device(bus_dev);\n\tbus_dev = NULL;\n\tkfree(bus_node);\nerr_device_init:\n\treturn ERR_PTR(ret);\n}'
p547
S'4d65a7ab88b7'
p548
ss(g543
S'msm_bus_device_probe'
p549
tp550
(dp551
S'static int msm_bus_device_probe(struct platform_device *pdev)\n{\n\tunsigned int i, ret;\n\tstruct msm_bus_device_node_registration *pdata;\n\n\t/* If possible, get pdata from device-tree */\n\tif (pdev->dev.of_node)\n\t\tpdata = msm_bus_of_to_pdata(pdev);\n\telse {\n\t\tpdata = (struct msm_bus_device_node_registration *)pdev->\n\t\t\tdev.platform_data;\n\t}\n\n\tif (IS_ERR_OR_NULL(pdata)) {\n\t\tMSM_BUS_ERR("No platform data found");\n\t\tret = -ENODATA;\n\t\tgoto exit_device_probe;\n\t}\n\n\tfor (i = 0; i < pdata->num_devices; i++) {\n\t\tstruct device *node_dev = NULL;\n\n\t\tnode_dev = msm_bus_device_init(&pdata->info[i]);\n\n\t\tif (IS_ERR(node_dev)) {\n\t\t\tMSM_BUS_ERR("%s: Error during dev init for %d",\n\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\tret = PTR_ERR(node_dev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\n\t\tret = msm_bus_init_clk(node_dev, &pdata->info[i]);\n\t\tif (ret) {\n\t\t\tMSM_BUS_ERR("\\n Failed to init bus clk. ret %d", ret);\n\t\t\tmsm_bus_device_remove(pdev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\t\t/*Is this a fabric device ?*/\n\t\tif (pdata->info[i].node_info->is_fab_dev) {\n\t\t\tMSM_BUS_DBG("%s: %d is a fab", __func__,\n\t\t\t\t\t\tpdata->info[i].node_info->id);\n\t\t\tret = msm_bus_fabric_init(node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing fab %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL,\n\t\t\t\t\t\tmsm_bus_setup_dev_conn);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error setting up dev connections", __func__);\n\t\tgoto exit_device_probe;\n\t}\n\n\t/*\n\t * Setup the QoS for the nodes, don\'t check the error codes as we\n\t * defer QoS programming to the first transaction in cases of failure\n\t * and we want to continue the probe.\n\t */\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);\n\n\t/* Register the arb layer ops */\n\tmsm_bus_arb_setops_adhoc(&arb_ops);\n\tbus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);\n\n\tdevm_kfree(&pdev->dev, pdata->info);\n\tdevm_kfree(&pdev->dev, pdata);\n\n\tdev_info(&pdev->dev, "Bus scaling driver probe successful\\n");\n\nexit_device_probe:\n\treturn ret;\n}'
p552
g548
ss(S'drivers/soc/qcom/msm_bus/msm_bus_fabric_rpmh.c'
p553
S'msm_bus_device_init'
p554
tp555
(dp556
S'static struct device *msm_bus_device_init(\n\t\t\tstruct msm_bus_node_device_type *pdata)\n{\n\tstruct device *bus_dev = NULL;\n\tstruct msm_bus_node_device_type *bus_node = NULL;\n\tstruct msm_bus_node_info_type *node_info = NULL;\n\tint ret = -ENODEV, i = 0;\n\n\t/**\n\t* Init here so we can use devm calls\n\t*/\n\n\tbus_node = kzalloc(sizeof(struct msm_bus_node_device_type), GFP_KERNEL);\n\tif (!bus_node) {\n\t\tret = -ENOMEM;\n\t\tgoto err_device_init;\n\t}\n\tbus_dev = &bus_node->dev;\n\tdevice_initialize(bus_dev);\n\n\tnode_info = devm_kzalloc(bus_dev,\n\t\t\tsizeof(struct msm_bus_node_info_type), GFP_KERNEL);\n\tif (!node_info) {\n\t\tret = -ENOMEM;\n\t\tgoto err_put_device;\n\t}\n\n\tbus_node->node_info = node_info;\n\tbus_node->ap_owned = pdata->ap_owned;\n\tbus_node->dirty = false;\n\tbus_node->num_qos_bcms = pdata->num_qos_bcms;\n\tif (bus_node->num_qos_bcms) {\n\t\tbus_node->qos_bcms = devm_kzalloc(bus_dev,\n\t\t\t\t\t(sizeof(struct qos_bcm_type) *\n\t\t\t\t\tbus_node->num_qos_bcms), GFP_KERNEL);\n\t\tif (!bus_node->qos_bcms) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_put_device;\n\t\t}\n\t\tfor (i = 0; i < bus_node->num_qos_bcms; i++) {\n\t\t\tbus_node->qos_bcms[i].qos_bcm_id =\n\t\t\t\t\tpdata->qos_bcms[i].qos_bcm_id;\n\t\t\tbus_node->qos_bcms[i].vec.vec_a =\n\t\t\t\t\tpdata->qos_bcms[i].vec.vec_a;\n\t\t\tbus_node->qos_bcms[i].vec.vec_b =\n\t\t\t\t\tpdata->qos_bcms[i].vec.vec_b;\n\t\t}\n\t}\n\n\tbus_dev->of_node = pdata->of_node;\n\n\tret = msm_bus_copy_node_info(pdata, bus_dev);\n\tif (ret)\n\t\tgoto err_put_device;\n\n\tbus_dev->bus = &msm_bus_type;\n\tdev_set_name(bus_dev, bus_node->node_info->name);\n\n\tret = device_add(bus_dev);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error registering device %d",\n\t\t\t\t__func__, pdata->node_info->id);\n\t\tgoto err_put_device;\n\t}\n\tdevice_create_file(bus_dev, &dev_attr_bw);\n\tINIT_LIST_HEAD(&bus_node->devlist);\n\treturn bus_dev;\n\nerr_put_device:\n\tput_device(bus_dev);\n\tbus_dev = NULL;\n\tkfree(bus_node);\nerr_device_init:\n\treturn ERR_PTR(ret);\n}'
p557
S'4d65a7ab88b7'
p558
ss(g553
S'msm_bus_device_probe'
p559
tp560
(dp561
S'static int msm_bus_device_probe(struct platform_device *pdev)\n{\n\tunsigned int i = 1, ret;\n\tstruct msm_bus_device_node_registration *pdata;\n\n\tMSM_BUS_ERR("msm_bus: Probe started");\n\t/* If possible, get pdata from device-tree */\n\tif (pdev->dev.of_node)\n\t\tpdata = msm_bus_of_to_pdata(pdev);\n\telse {\n\t\tpdata = (struct msm_bus_device_node_registration *)pdev->\n\t\t\tdev.platform_data;\n\t}\n\n\tMSM_BUS_ERR("msm_bus: DT Parsing complete");\n\n\tif (IS_ERR_OR_NULL(pdata)) {\n\t\tMSM_BUS_ERR("No platform data found");\n\t\tret = -ENODATA;\n\t\tgoto exit_device_probe;\n\t}\n\n\tfor (i = 0; i < pdata->num_devices; i++) {\n\t\tstruct device *node_dev = NULL;\n\n\t\tnode_dev = msm_bus_device_init(&pdata->info[i]);\n\n\t\tif (IS_ERR(node_dev)) {\n\t\t\tMSM_BUS_ERR("%s: Error during dev init for %d",\n\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\tret = PTR_ERR(node_dev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\n\t\tret = msm_bus_init_clk(node_dev, &pdata->info[i]);\n\t\tif (ret) {\n\t\t\tMSM_BUS_ERR("\\n Failed to init bus clk. ret %d", ret);\n\t\t\tmsm_bus_device_remove(pdev);\n\t\t\tgoto exit_device_probe;\n\t\t}\n\t\t/*Is this a fabric device ?*/\n\t\tif (pdata->info[i].node_info->is_fab_dev) {\n\t\t\tMSM_BUS_DBG("%s: %d is a fab", __func__,\n\t\t\t\t\t\tpdata->info[i].node_info->id);\n\t\t\tret = msm_bus_fabric_init(node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing fab %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t\tif (pdata->info[i].node_info->is_bcm_dev) {\n\t\t\tret = msm_bus_bcm_init(node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing bcm %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t\tif (pdata->info[i].node_info->is_rsc_dev) {\n\t\t\tret = msm_bus_rsc_init(pdev, node_dev, &pdata->info[i]);\n\t\t\tif (ret) {\n\t\t\t\tMSM_BUS_ERR("%s: Error intializing rsc %d",\n\t\t\t\t\t__func__, pdata->info[i].node_info->id);\n\t\t\t\tgoto exit_device_probe;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL,\n\t\t\t\t\t\tmsm_bus_setup_dev_conn);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error setting up dev connections", __func__);\n\t\tgoto exit_device_probe;\n\t}\n\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL,\n\t\t\t\t\t\tmsm_bus_postcon_setup);\n\tif (ret) {\n\t\tMSM_BUS_ERR("%s: Error post connection setup", __func__);\n\t\tgoto exit_device_probe;\n\t}\n\n\t/*\n\t * Setup the QoS for the nodes, don\'t check the error codes as we\n\t * defer QoS programming to the first transaction in cases of failure\n\t * and we want to continue the probe.\n\t */\n\tret = bus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_dev_init_qos);\n\n\t/* Register the arb layer ops */\n\tmsm_bus_arb_setops_adhoc(&arb_ops);\n\tbus_for_each_dev(&msm_bus_type, NULL, NULL, msm_bus_node_debug);\n\n\tdevm_kfree(&pdev->dev, pdata->info);\n\tdevm_kfree(&pdev->dev, pdata);\nexit_device_probe:\n\treturn ret;\n}'
p562
g558
sssS'CVE-2018-1000199'
p563
(dp564
(S'kernel/events/hw_breakpoint.c'
p565
S'modify_user_hw_breakpoint'
p566
tp567
(dp568
S'int modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\t/*\n\t * modify_user_hw_breakpoint can be invoked with IRQs disabled and hence it\n\t * will not be possible to raise IPIs that invoke __perf_event_disable.\n\t * So call the function directly after making sure we are targeting the\n\t * current task.\n\t */\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\tperf_event_disable_local(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\tbp->attr.bp_addr = attr->bp_addr;\n\tbp->attr.bp_type = attr->bp_type;\n\tbp->attr.bp_len = attr->bp_len;\n\tbp->attr.disabled = 1;\n\n\tif (!attr->disabled) {\n\t\tint err = validate_hw_breakpoint(bp);\n\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tperf_event_enable(bp);\n\t\tbp->attr.disabled = 0;\n\t}\n\n\treturn 0;\n}'
p569
S'230f5ef8edc6'
p570
sssS'CVE-2019-2263'
p571
(dp572
(S'drivers/char/diag/diagchar_core.c'
p573
S'check_data_ready'
p574
tp575
(dp576
S'static int check_data_ready(int index)\n{\n\tint data_type = 0;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tdata_type = driver->data_ready[index];\n\tmutex_unlock(&driver->diagchar_mutex);\n\treturn data_type;\n}'
p577
S'854975ee1bbf'
p578
ss(g573
S'diagchar_read'
p579
tp580
(dp581
S'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q, (check_data_ready(index)) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p582
g578
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p583
S'e7d24e4b76b3'
p584
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client)\n\t\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p585
S'f332617ebb03'
p586
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client) {\n\t\t\t\tif (entry->client->tgid != current->tgid) {\n\t\t\t\t\tput_task_struct(task_s);\n\t\t\t\t\tput_pid(pid_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!entry->in_service) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tput_task_struct(task_s);\n\t\t\tput_pid(pid_struct);\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p587
S'6c6aaf4e8330'
p588
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q, (check_data_ready(index)) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT)\n\t\t\t\tgoto exit;\n\t\t}\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p589
S'e2e3f32ff024'
p590
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p591
S'4ab88a87a831'
p592
sssS'CVE-2018-18397'
p593
(dp594
(S'fs/userfaultfd.c'
p595
S'userfaultfd_register'
p596
tp597
(dp598
S"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }),\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
p599
S'19a8101c2309'
p600
sS"static int userfaultfd_register(struct userfaultfd_ctx *ctx,\n\t\t\t\tunsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_register uffdio_register;\n\tstruct uffdio_register __user *user_uffdio_register;\n\tunsigned long vm_flags, new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\n\tuser_uffdio_register = (struct uffdio_register __user *) arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_register, user_uffdio_register,\n\t\t\t   sizeof(uffdio_register)-sizeof(__u64)))\n\t\tgoto out;\n\n\tret = -EINVAL;\n\tif (!uffdio_register.mode)\n\t\tgoto out;\n\tif (uffdio_register.mode & ~(UFFDIO_REGISTER_MODE_MISSING|\n\t\t\t\t     UFFDIO_REGISTER_MODE_WP))\n\t\tgoto out;\n\tvm_flags = 0;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_MISSING)\n\t\tvm_flags |= VM_UFFD_MISSING;\n\tif (uffdio_register.mode & UFFDIO_REGISTER_MODE_WP) {\n\t\tvm_flags |= VM_UFFD_WP;\n\t\t/*\n\t\t * FIXME: remove the below error constraint by\n\t\t * implementing the wprotect tracking mode.\n\t\t */\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = validate_range(mm, uffdio_register.range.start,\n\t\t\t     uffdio_register.range.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_register.range.start;\n\tend = start + uffdio_register.range.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/* check not compatible vmas */\n\t\tret = -EINVAL;\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * UFFDIO_COPY will fill file holes even without\n\t\t * PROT_WRITE. This check enforces that if this is a\n\t\t * MAP_SHARED, the process has write permission to the backing\n\t\t * file. If VM_MAYWRITE is set it also enforces that on a\n\t\t * MAP_SHARED vma: there is no F_WRITE_SEAL and no further\n\t\t * F_WRITE_SEAL can be taken until the vma is destroyed.\n\t\t */\n\t\tret = -EPERM;\n\t\tif (unlikely(!(cur->vm_flags & VM_MAYWRITE)))\n\t\t\tgoto out_unlock;\n\n\t\t/*\n\t\t * Check that this vma isn't already owned by a\n\t\t * different userfaultfd. We can't allow more than one\n\t\t * userfaultfd to own a single vma simultaneously or we\n\t\t * wouldn't know which one to deliver the userfaults to.\n\t\t */\n\t\tret = -EBUSY;\n\t\tif (cur->vm_userfaultfd_ctx.ctx &&\n\t\t    cur->vm_userfaultfd_ctx.ctx != ctx)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tBUG_ON(vma->vm_userfaultfd_ctx.ctx &&\n\t\t       vma->vm_userfaultfd_ctx.ctx != ctx);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (vma->vm_userfaultfd_ctx.ctx == ctx &&\n\t\t    (vma->vm_flags & vm_flags) == vm_flags)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = (vma->vm_flags & ~vm_flags) | vm_flags;\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t ((struct vm_userfaultfd_ctx){ ctx }),\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx.ctx = ctx;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\n\tif (!ret) {\n\t\t/*\n\t\t * Now that we scanned all vmas we can already tell\n\t\t * userland which ioctls methods are guaranteed to\n\t\t * succeed on this range.\n\t\t */\n\t\tif (put_user(UFFD_API_RANGE_IOCTLS,\n\t\t\t     &user_uffdio_register->ioctls))\n\t\t\tret = -EFAULT;\n\t}\nout:\n\treturn ret;\n}"
p601
S'7bb76790999d'
p602
ss(g595
S'userfaultfd_unregister'
p603
tp604
(dp605
S"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tif (!mmget_still_valid(mm))\n\t\tgoto out_unlock;\n\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX,\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
p606
g602
sS"static int userfaultfd_unregister(struct userfaultfd_ctx *ctx,\n\t\t\t\t  unsigned long arg)\n{\n\tstruct mm_struct *mm = ctx->mm;\n\tstruct vm_area_struct *vma, *prev, *cur;\n\tint ret;\n\tstruct uffdio_range uffdio_unregister;\n\tunsigned long new_flags;\n\tbool found;\n\tunsigned long start, end, vma_end;\n\tconst void __user *buf = (void __user *)arg;\n\n\tret = -EFAULT;\n\tif (copy_from_user(&uffdio_unregister, buf, sizeof(uffdio_unregister)))\n\t\tgoto out;\n\n\tret = validate_range(mm, uffdio_unregister.start,\n\t\t\t     uffdio_unregister.len);\n\tif (ret)\n\t\tgoto out;\n\n\tstart = uffdio_unregister.start;\n\tend = start + uffdio_unregister.len;\n\n\tret = -ENOMEM;\n\tif (!mmget_not_zero(mm))\n\t\tgoto out;\n\n\tdown_write(&mm->mmap_sem);\n\tvma = find_vma_prev(mm, start, &prev);\n\tif (!vma)\n\t\tgoto out_unlock;\n\n\t/* check that there's at least one vma in the range */\n\tret = -EINVAL;\n\tif (vma->vm_start >= end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Search for not compatible vmas.\n\t *\n\t * FIXME: this shall be relaxed later so that it doesn't fail\n\t * on tmpfs backed vmas (in addition to the current allowance\n\t * on anonymous vmas).\n\t */\n\tfound = false;\n\tret = -EINVAL;\n\tfor (cur = vma; cur && cur->vm_start < end; cur = cur->vm_next) {\n\t\tcond_resched();\n\n\t\tBUG_ON(!!cur->vm_userfaultfd_ctx.ctx ^\n\t\t       !!(cur->vm_flags & (VM_UFFD_MISSING | VM_UFFD_WP)));\n\n\t\t/*\n\t\t * Check not compatible vmas, not strictly required\n\t\t * here as not compatible vmas cannot have an\n\t\t * userfaultfd_ctx registered on them, but this\n\t\t * provides for more strict behavior to notice\n\t\t * unregistration errors.\n\t\t */\n\t\tif (cur->vm_ops)\n\t\t\tgoto out_unlock;\n\n\t\tfound = true;\n\t}\n\tBUG_ON(!found);\n\n\tif (vma->vm_start < start)\n\t\tprev = vma;\n\n\tret = 0;\n\tdo {\n\t\tcond_resched();\n\n\t\tBUG_ON(vma->vm_ops);\n\t\tWARN_ON(!(vma->vm_flags & VM_MAYWRITE));\n\n\t\t/*\n\t\t * Nothing to do: this vma is already registered into this\n\t\t * userfaultfd and with the right tracking mode too.\n\t\t */\n\t\tif (!vma->vm_userfaultfd_ctx.ctx)\n\t\t\tgoto skip;\n\n\t\tif (vma->vm_start > start)\n\t\t\tstart = vma->vm_start;\n\t\tvma_end = min(end, vma->vm_end);\n\n\t\tnew_flags = vma->vm_flags & ~(VM_UFFD_MISSING | VM_UFFD_WP);\n\t\tprev = vma_merge(mm, prev, start, vma_end, new_flags,\n\t\t\t\t vma->anon_vma, vma->vm_file, vma->vm_pgoff,\n\t\t\t\t vma_policy(vma),\n\t\t\t\t NULL_VM_UFFD_CTX,\n\t\t\t\t vma_get_anon_name(vma));\n\t\tif (prev) {\n\t\t\tvma = prev;\n\t\t\tgoto next;\n\t\t}\n\t\tif (vma->vm_start < start) {\n\t\t\tret = split_vma(mm, vma, start, 1);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (vma->vm_end > end) {\n\t\t\tret = split_vma(mm, vma, end, 0);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\tnext:\n\t\t/*\n\t\t * In the vma_merge() successful mprotect-like case 8:\n\t\t * the next vma was merged into the current one and\n\t\t * the current one has not been updated yet.\n\t\t */\n\t\tvm_write_begin(vma);\n\t\tWRITE_ONCE(vma->vm_flags, new_flags);\n\t\tvma->vm_userfaultfd_ctx = NULL_VM_UFFD_CTX;\n\t\tvm_write_end(vma);\n\n\tskip:\n\t\tprev = vma;\n\t\tstart = vma->vm_end;\n\t\tvma = vma->vm_next;\n\t} while (vma && vma->vm_start < end);\nout_unlock:\n\tup_write(&mm->mmap_sem);\n\tmmput(mm);\nout:\n\treturn ret;\n}"
p607
g600
ss(S'mm/userfaultfd.c'
p608
S'__mcopy_atomic'
p609
tp610
(dp611
S"static __always_inline ssize_t __mcopy_atomic(struct mm_struct *dst_mm,\n\t\t\t\t\t      unsigned long dst_start,\n\t\t\t\t\t      unsigned long src_start,\n\t\t\t\t\t      unsigned long len,\n\t\t\t\t\t      bool zeropage)\n{\n\tstruct vm_area_struct *dst_vma;\n\tssize_t err;\n\tpmd_t *dst_pmd;\n\tunsigned long src_addr, dst_addr;\n\tlong copied;\n\tstruct page *page;\n\n\t/*\n\t * Sanitize the command parameters:\n\t */\n\tBUG_ON(dst_start & ~PAGE_MASK);\n\tBUG_ON(len & ~PAGE_MASK);\n\n\t/* Does the address range wrap, or is the span zero-sized? */\n\tBUG_ON(src_start + len <= src_start);\n\tBUG_ON(dst_start + len <= dst_start);\n\n\tsrc_addr = src_start;\n\tdst_addr = dst_start;\n\tcopied = 0;\n\tpage = NULL;\nretry:\n\tdown_read(&dst_mm->mmap_sem);\n\n\t/*\n\t * Make sure the vma is not shared, that the dst range is\n\t * both valid and fully within a single existing vma.\n\t */\n\terr = -EINVAL;\n\tdst_vma = find_vma(dst_mm, dst_start);\n\tif (!dst_vma || (dst_vma->vm_flags & VM_SHARED))\n\t\tgoto out_unlock;\n\tif (dst_start < dst_vma->vm_start ||\n\t    dst_start + len > dst_vma->vm_end)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Check the vma is registered in uffd, this is required to\n\t * enforce the VM_MAYWRITE check done at uffd registration\n\t * time.\n\t */\n\tif (!dst_vma->vm_userfaultfd_ctx.ctx)\n\t\tgoto out_unlock;\n\n\t/*\n\t * FIXME: only allow copying on anonymous vmas, tmpfs should\n\t * be added.\n\t */\n\tif (dst_vma->vm_ops)\n\t\tgoto out_unlock;\n\n\t/*\n\t * Ensure the dst_vma has a anon_vma or this page\n\t * would get a NULL anon_vma when moved in the\n\t * dst_vma.\n\t */\n\terr = -ENOMEM;\n\tif (unlikely(anon_vma_prepare(dst_vma)))\n\t\tgoto out_unlock;\n\n\twhile (src_addr < src_start + len) {\n\t\tpmd_t dst_pmdval;\n\n\t\tBUG_ON(dst_addr >= dst_start + len);\n\n\t\tdst_pmd = mm_alloc_pmd(dst_mm, dst_addr);\n\t\tif (unlikely(!dst_pmd)) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\tdst_pmdval = pmd_read_atomic(dst_pmd);\n\t\t/*\n\t\t * If the dst_pmd is mapped as THP don't\n\t\t * override it and just be strict.\n\t\t */\n\t\tif (unlikely(pmd_trans_huge(dst_pmdval))) {\n\t\t\terr = -EEXIST;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(pmd_none(dst_pmdval)) &&\n\t\t    unlikely(__pte_alloc(dst_mm, dst_pmd, dst_addr))) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\t/* If an huge pmd materialized from under us fail */\n\t\tif (unlikely(pmd_trans_huge(*dst_pmd))) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\n\t\tBUG_ON(pmd_none(*dst_pmd));\n\t\tBUG_ON(pmd_trans_huge(*dst_pmd));\n\n\t\tif (!zeropage)\n\t\t\terr = mcopy_atomic_pte(dst_mm, dst_pmd, dst_vma,\n\t\t\t\t\t       dst_addr, src_addr, &page);\n\t\telse\n\t\t\terr = mfill_zeropage_pte(dst_mm, dst_pmd, dst_vma,\n\t\t\t\t\t\t dst_addr);\n\n\t\tcond_resched();\n\n\t\tif (unlikely(err == -EFAULT)) {\n\t\t\tvoid *page_kaddr;\n\n\t\t\tup_read(&dst_mm->mmap_sem);\n\t\t\tBUG_ON(!page);\n\n\t\t\tpage_kaddr = kmap(page);\n\t\t\terr = copy_from_user(page_kaddr,\n\t\t\t\t\t     (const void __user *) src_addr,\n\t\t\t\t\t     PAGE_SIZE);\n\t\t\tkunmap(page);\n\t\t\tif (unlikely(err)) {\n\t\t\t\terr = -EFAULT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto retry;\n\t\t} else\n\t\t\tBUG_ON(page);\n\n\t\tif (!err) {\n\t\t\tdst_addr += PAGE_SIZE;\n\t\t\tsrc_addr += PAGE_SIZE;\n\t\t\tcopied += PAGE_SIZE;\n\n\t\t\tif (fatal_signal_pending(current))\n\t\t\t\terr = -EINTR;\n\t\t}\n\t\tif (err)\n\t\t\tbreak;\n\t}\n\nout_unlock:\n\tup_read(&dst_mm->mmap_sem);\nout:\n\tif (page)\n\t\tput_page(page);\n\tBUG_ON(copied < 0);\n\tBUG_ON(err > 0);\n\tBUG_ON(!copied && !err);\n\treturn copied ? copied : err;\n}"
p612
S'19a8101c2309'
p613
sssS'CVE-2017-18595'
p614
(dp615
(S'kernel/trace/trace.c'
p616
S'allocate_trace_buffer'
p617
tp618
(dp619
S'allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}'
p620
S'b82affb897d2'
p621
sssS'CVE-2018-11266'
p622
(dp623
(S'drivers/char/diag/diag_dci.c'
p624
S'dci_lookup_client_entry_pid'
p625
tp626
(dp627
S'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid pid doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client)\n\t\t\tif (entry->client->tgid == tgid)\n\t\t\t\treturn entry;\n\t}\n\treturn NULL;\n}'
p628
S'01e81c03e7be'
p629
sS'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client)\n\t\t\tif (entry->client->tgid == tgid)\n\t\t\t\treturn entry;\n\t}\n\treturn NULL;\n}'
p630
S'f332617ebb03'
p631
sS'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tput_pid(pid_struct);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client) {\n\t\t\tif (entry->client->tgid == tgid) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\tput_task_struct(task_s);\n\t\tput_pid(pid_struct);\n\t}\n\treturn NULL;\n}'
p632
S'6c6aaf4e8330'
p633
sssS'CVE-2019-2345'
p634
(dp635
(S'drivers/media/platform/msm/camera_v2/jpeg_dma/msm_jpeg_dma_dev.c'
p636
S'msm_jpegdma_streamoff'
p637
tp638
(dp639
S'static int msm_jpegdma_streamoff(struct file *file,\n\tvoid *fh, enum v4l2_buf_type buf_type)\n{\n\tstruct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);\n\tint ret;\n\tmutex_lock(&ctx->lock);\n\tret = v4l2_m2m_streamoff(file, ctx->m2m_ctx, buf_type);\n\tif (ret < 0)\n\t\tdev_err(ctx->jdma_device->dev, "Stream off fails\\n");\n\tmutex_unlock(&ctx->lock);\n\treturn ret;\n}'
p640
S'6acb6f98163d'
p641
ss(g636
S'msm_jpegdma_reqbufs'
p642
tp643
(dp644
S'static int msm_jpegdma_reqbufs(struct file *file,\n\tvoid *fh, struct v4l2_requestbuffers *req)\n{\n\tint ret = 0;\n\tstruct jpegdma_ctx *ctx = msm_jpegdma_ctx_from_fh(fh);\n\n\tmutex_lock(&ctx->lock);\n\tret = v4l2_m2m_reqbufs(file, ctx->m2m_ctx, req);\n\tmutex_unlock(&ctx->lock);\n\treturn ret;\n}'
p645
g641
sssS'CVE-2018-13096'
p646
(dp647
(S'fs/f2fs/inode.c'
p648
S'do_read_inode'
p649
tp650
(dp651
S"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p652
S'c36d54c34fef'
p653
sS"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p654
S'de6abb23dc05'
p655
sS"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tif (S_ISREG(inode->i_mode))\n\t\tfi->i_flags &= ~F2FS_PROJINHERIT_FL;\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* try to recover cold bit for non-dir inode */\n\tif (!S_ISDIR(inode->i_mode) && !is_cold_node(node_page)) {\n\t\tset_cold_node(node_page, false);\n\t\tset_page_dirty(node_page);\n\t}\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p656
S'7bb76790999d'
p657
sS"static int do_read_inode(struct inode *inode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tstruct page *node_page;\n\tstruct f2fs_inode *ri;\n\tprojid_t i_projid;\n\tint err;\n\n\t/* Check if ino is within scope */\n\tif (f2fs_check_nid_range(sbi, inode->i_ino))\n\t\treturn -EINVAL;\n\n\tnode_page = f2fs_get_node_page(sbi, inode->i_ino);\n\tif (IS_ERR(node_page))\n\t\treturn PTR_ERR(node_page);\n\n\tri = F2FS_INODE(node_page);\n\n\tinode->i_mode = le16_to_cpu(ri->i_mode);\n\ti_uid_write(inode, le32_to_cpu(ri->i_uid));\n\ti_gid_write(inode, le32_to_cpu(ri->i_gid));\n\tset_nlink(inode, le32_to_cpu(ri->i_links));\n\tinode->i_size = le64_to_cpu(ri->i_size);\n\tinode->i_blocks = SECTOR_FROM_BLOCK(le64_to_cpu(ri->i_blocks) - 1);\n\n\tinode->i_atime.tv_sec = le64_to_cpu(ri->i_atime);\n\tinode->i_ctime.tv_sec = le64_to_cpu(ri->i_ctime);\n\tinode->i_mtime.tv_sec = le64_to_cpu(ri->i_mtime);\n\tinode->i_atime.tv_nsec = le32_to_cpu(ri->i_atime_nsec);\n\tinode->i_ctime.tv_nsec = le32_to_cpu(ri->i_ctime_nsec);\n\tinode->i_mtime.tv_nsec = le32_to_cpu(ri->i_mtime_nsec);\n\tinode->i_generation = le32_to_cpu(ri->i_generation);\n\tif (S_ISDIR(inode->i_mode))\n\t\tfi->i_current_depth = le32_to_cpu(ri->i_current_depth);\n\telse if (S_ISREG(inode->i_mode))\n\t\tfi->i_gc_failures[GC_FAILURE_PIN] =\n\t\t\t\t\tle16_to_cpu(ri->i_gc_failures);\n\tfi->i_xattr_nid = le32_to_cpu(ri->i_xattr_nid);\n\tfi->i_flags = le32_to_cpu(ri->i_flags);\n\tfi->flags = 0;\n\tfi->i_advise = ri->i_advise;\n\tfi->i_pino = le32_to_cpu(ri->i_pino);\n\tfi->i_dir_level = ri->i_dir_level;\n\n\tif (f2fs_init_extent_tree(inode, &ri->i_ext))\n\t\tset_page_dirty(node_page);\n\n\tget_inline_info(inode, ri);\n\n\tfi->i_extra_isize = f2fs_has_extra_attr(inode) ?\n\t\t\t\t\tle16_to_cpu(ri->i_extra_isize) : 0;\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)) {\n\t\tfi->i_inline_xattr_size = le16_to_cpu(ri->i_inline_xattr_size);\n\t} else if (f2fs_has_inline_xattr(inode) ||\n\t\t\t\tf2fs_has_inline_dentry(inode)) {\n\t\tfi->i_inline_xattr_size = DEFAULT_INLINE_XATTR_ADDRS;\n\t} else {\n\n\t\t/*\n\t\t * Previous inline data or directory always reserved 200 bytes\n\t\t * in inode layout, even if inline_xattr is disabled. In order\n\t\t * to keep inline_dentry's structure for backward compatibility,\n\t\t * we get the space back only from inline_data.\n\t\t */\n\t\tfi->i_inline_xattr_size = 0;\n\t}\n\n\tif (!sanity_check_inode(inode, node_page)) {\n\t\tf2fs_put_page(node_page, 1);\n\t\treturn -EINVAL;\n\t}\n\n\t/* check data exist */\n\tif (f2fs_has_inline_data(inode) && !f2fs_exist_data(inode))\n\t\t__recover_inline_status(inode, node_page);\n\n\t/* get rdev by using inline_info */\n\t__get_inode_rdev(inode, ri);\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\terr = __written_first_block(sbi, ri);\n\t\tif (err < 0) {\n\t\t\tf2fs_put_page(node_page, 1);\n\t\t\treturn err;\n\t\t}\n\t\tif (!err)\n\t\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\n\t}\n\n\tif (!f2fs_need_inode_block_update(sbi, inode->i_ino))\n\t\tfi->last_disk_size = inode->i_size;\n\n\tif (fi->i_flags & F2FS_PROJINHERIT_FL)\n\t\tset_inode_flag(inode, FI_PROJ_INHERIT);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_project_quota(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(ri->i_projid);\n\telse\n\t\ti_projid = F2FS_DEF_PROJID;\n\tfi->i_projid = make_kprojid(&init_user_ns, i_projid);\n\n\tif (f2fs_has_extra_attr(inode) && f2fs_sb_has_inode_crtime(sbi->sb) &&\n\t\t\tF2FS_FITS_IN_INODE(ri, fi->i_extra_isize, i_crtime)) {\n\t\tfi->i_crtime.tv_sec = le64_to_cpu(ri->i_crtime);\n\t\tfi->i_crtime.tv_nsec = le32_to_cpu(ri->i_crtime_nsec);\n\t}\n\n\tF2FS_I(inode)->i_disk_time[0] = inode->i_atime;\n\tF2FS_I(inode)->i_disk_time[1] = inode->i_ctime;\n\tF2FS_I(inode)->i_disk_time[2] = inode->i_mtime;\n\tF2FS_I(inode)->i_disk_time[3] = F2FS_I(inode)->i_crtime;\n\tf2fs_put_page(node_page, 1);\n\n\tstat_inc_inline_xattr(inode);\n\tstat_inc_inline_inode(inode);\n\tstat_inc_inline_dir(inode);\n\n\treturn 0;\n}"
p658
S'f332617ebb03'
p659
ss(g648
S'sanity_check_inode'
p660
tp661
(dp662
S'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, run fsck to fix.",\n\t\t\t  __func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: corrupted inode footer i_ino=%lx, ino,nid: [%u, %u] run fsck to fix.",\n\t\t\t  __func__, inode->i_ino,\n\t\t\t  ino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) is with extra_attr, but extra_attr feature is off",\n\t\t\t  __func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) has corrupted i_extra_isize: %d, max: %zu",\n\t\t\t  __func__, inode->i_ino, fi->i_extra_isize,\n\t\t\t  F2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\tf2fs_sb_has_flexible_inline_xattr(sbi) &&\n\t\tf2fs_has_inline_xattr(inode) &&\n\t\t(!fi->i_inline_xattr_size ||\n\t\tfi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) has corrupted i_inline_xattr_size: %d, max: %zu",\n\t\t\t  __func__, inode->i_ino, fi->i_inline_xattr_size,\n\t\t\t  MAX_INLINE_XATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_warn(sbi, "%s: inode (ino=%lx) extent info [%u, %u, %u] is incorrect, run fsck to fix",\n\t\t\t\t  __func__, inode->i_ino,\n\t\t\t\t  ei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx, mode=%u) should not have inline_data, run fsck to fix",\n\t\t\t  __func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_warn(sbi, "%s: inode (ino=%lx, mode=%u) should not have inline_dentry, run fsck to fix",\n\t\t\t  __func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p663
g657
sS'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "\n\t\t\t"run fsck to fix.",\n\t\t\t__func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "\n\t\t\t"[%u, %u] run fsck to fix.",\n\t\t\t__func__, inode->i_ino,\n\t\t\tino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi->sb)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi->sb)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) is with extra_attr, "\n\t\t\t"but extra_attr feature is off",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "\n\t\t\t"max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_extra_isize,\n\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\t\tDATA_GENERIC))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "\n\t\t\t\t"is incorrect, run fsck to fix",\n\t\t\t\t__func__, inode->i_ino,\n\t\t\t\tei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_data, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_dentry, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p664
g659
sS'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "\n\t\t\t"run fsck to fix.",\n\t\t\t__func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "\n\t\t\t"[%u, %u] run fsck to fix.",\n\t\t\t__func__, inode->i_ino,\n\t\t\tino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) is with extra_attr, "\n\t\t\t"but extra_attr feature is off",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "\n\t\t\t"max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_extra_isize,\n\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk, DATA_GENERIC) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\t\tDATA_GENERIC))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "\n\t\t\t\t"is incorrect, run fsck to fix",\n\t\t\t\t__func__, inode->i_ino,\n\t\t\t\tei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_data, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_dentry, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p665
g655
sS'static bool sanity_check_inode(struct inode *inode, struct page *node_page)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct f2fs_inode_info *fi = F2FS_I(inode);\n\tunsigned long long iblocks;\n\n\tiblocks = le64_to_cpu(F2FS_INODE(node_page)->i_blocks);\n\tif (!iblocks) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode i_blocks i_ino=%lx iblocks=%llu, "\n\t\t\t"run fsck to fix.",\n\t\t\t__func__, inode->i_ino, iblocks);\n\t\treturn false;\n\t}\n\n\tif (ino_of_node(node_page) != nid_of_node(node_page)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode footer i_ino=%lx, ino,nid: "\n\t\t\t"[%u, %u] run fsck to fix.",\n\t\t\t__func__, inode->i_ino,\n\t\t\tino_of_node(node_page), nid_of_node(node_page));\n\t\treturn false;\n\t}\n\n\tif (f2fs_sb_has_flexible_inline_xattr(sbi)\n\t\t\t&& !f2fs_has_extra_attr(inode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: corrupted inode ino=%lx, run fsck to fix.",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\t\t!f2fs_sb_has_extra_attr(sbi)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) is with extra_attr, "\n\t\t\t"but extra_attr feature is off",\n\t\t\t__func__, inode->i_ino);\n\t\treturn false;\n\t}\n\n\tif (fi->i_extra_isize > F2FS_TOTAL_EXTRA_ATTR_SIZE ||\n\t\t\tfi->i_extra_isize % sizeof(__le32)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted i_extra_isize: %d, "\n\t\t\t"max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_extra_isize,\n\t\t\tF2FS_TOTAL_EXTRA_ATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_extra_attr(inode) &&\n\t\tf2fs_sb_has_flexible_inline_xattr(sbi) &&\n\t\tf2fs_has_inline_xattr(inode) &&\n\t\t(!fi->i_inline_xattr_size ||\n\t\tfi->i_inline_xattr_size > MAX_INLINE_XATTR_SIZE)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx) has corrupted "\n\t\t\t"i_inline_xattr_size: %d, max: %zu",\n\t\t\t__func__, inode->i_ino, fi->i_inline_xattr_size,\n\t\t\tMAX_INLINE_XATTR_SIZE);\n\t\treturn false;\n\t}\n\n\tif (F2FS_I(inode)->extent_tree) {\n\t\tstruct extent_info *ei = &F2FS_I(inode)->extent_tree->largest;\n\n\t\tif (ei->len &&\n\t\t\t(!f2fs_is_valid_blkaddr(sbi, ei->blk,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE) ||\n\t\t\t!f2fs_is_valid_blkaddr(sbi, ei->blk + ei->len - 1,\n\t\t\t\t\t\tDATA_GENERIC_ENHANCE))) {\n\t\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\t"%s: inode (ino=%lx) extent info [%u, %u, %u] "\n\t\t\t\t"is incorrect, run fsck to fix",\n\t\t\t\t__func__, inode->i_ino,\n\t\t\t\tei->blk, ei->fofs, ei->len);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tif (f2fs_has_inline_data(inode) &&\n\t\t\t(!S_ISREG(inode->i_mode) && !S_ISLNK(inode->i_mode))) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_data, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\tif (f2fs_has_inline_dentry(inode) && !S_ISDIR(inode->i_mode)) {\n\t\tset_sbi_flag(sbi, SBI_NEED_FSCK);\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t"%s: inode (ino=%lx, mode=%u) should not have "\n\t\t\t"inline_dentry, run fsck to fix",\n\t\t\t__func__, inode->i_ino, inode->i_mode);\n\t\treturn false;\n\t}\n\n\treturn true;\n}'
p666
S'61fe509b8406'
p667
sssS'CVE-2019-10538'
p668
(dp669
(S'drivers/soc/qcom/icnss.c'
p670
S'wlfw_msa_mem_info_send_sync_msg'
p671
tp672
(dp673
S'static int wlfw_msa_mem_info_send_sync_msg(void)\n{\n\tint ret;\n\tint i;\n\tstruct wlfw_msa_info_req_msg_v01 req;\n\tstruct wlfw_msa_info_resp_msg_v01 resp;\n\tstruct msg_desc req_desc, resp_desc;\n\tuint64_t max_mapped_addr;\n\n\tif (!penv || !penv->wlfw_clnt)\n\t\treturn -ENODEV;\n\n\ticnss_pr_dbg("Sending MSA mem info, state: 0x%lx\\n", penv->state);\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&resp, 0, sizeof(resp));\n\n\treq.msa_addr = penv->msa_pa;\n\treq.size = penv->msa_mem_size;\n\n\treq_desc.max_msg_len = WLFW_MSA_INFO_REQ_MSG_V01_MAX_MSG_LEN;\n\treq_desc.msg_id = QMI_WLFW_MSA_INFO_REQ_V01;\n\treq_desc.ei_array = wlfw_msa_info_req_msg_v01_ei;\n\n\tresp_desc.max_msg_len = WLFW_MSA_INFO_RESP_MSG_V01_MAX_MSG_LEN;\n\tresp_desc.msg_id = QMI_WLFW_MSA_INFO_RESP_V01;\n\tresp_desc.ei_array = wlfw_msa_info_resp_msg_v01_ei;\n\n\tpenv->stats.msa_info_req++;\n\n\tret = qmi_send_req_wait(penv->wlfw_clnt, &req_desc, &req, sizeof(req),\n\t\t\t&resp_desc, &resp, sizeof(resp), WLFW_TIMEOUT_MS);\n\tif (ret < 0) {\n\t\ticnss_pr_err("Send MSA Mem info req failed %d\\n", ret);\n\t\tgoto out;\n\t}\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\ticnss_pr_err("QMI MSA Mem info request rejected, result:%d error:%d\\n",\n\t\t\tresp.resp.result, resp.resp.error);\n\t\tret = -resp.resp.result;\n\t\tgoto out;\n\t}\n\n\ticnss_pr_dbg("Receive mem_region_info_len: %d\\n",\n\t\t     resp.mem_region_info_len);\n\n\tif (resp.mem_region_info_len > QMI_WLFW_MAX_NUM_MEMORY_REGIONS_V01) {\n\t\ticnss_pr_err("Invalid memory region length received: %d\\n",\n\t\t\t     resp.mem_region_info_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmax_mapped_addr = penv->msa_pa + penv->msa_mem_size;\n\tpenv->stats.msa_info_resp++;\n\tpenv->nr_mem_region = resp.mem_region_info_len;\n\tfor (i = 0; i < resp.mem_region_info_len; i++) {\n\n\t\tif (resp.mem_region_info[i].size > penv->msa_mem_size ||\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr ||\n\t\t    resp.mem_region_info[i].region_addr < penv->msa_pa ||\n\t\t    resp.mem_region_info[i].size +\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {\n\t\t\ticnss_pr_dbg("Received out of range Addr: 0x%llx Size: 0x%x\\n",\n\t\t\t\t\tresp.mem_region_info[i].region_addr,\n\t\t\t\t\tresp.mem_region_info[i].size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_unwind;\n\t\t}\n\n\t\tpenv->mem_region[i].reg_addr =\n\t\t\tresp.mem_region_info[i].region_addr;\n\t\tpenv->mem_region[i].size =\n\t\t\tresp.mem_region_info[i].size;\n\t\tpenv->mem_region[i].secure_flag =\n\t\t\tresp.mem_region_info[i].secure_flag;\n\t\ticnss_pr_dbg("Memory Region: %d Addr: 0x%llx Size: 0x%x Flag: 0x%08x\\n",\n\t\t\t     i, penv->mem_region[i].reg_addr,\n\t\t\t     penv->mem_region[i].size,\n\t\t\t     penv->mem_region[i].secure_flag);\n\t}\n\n\treturn 0;\n\nfail_unwind:\n\tmemset(&penv->mem_region[0], 0, sizeof(penv->mem_region[0]) * i);\nout:\n\tpenv->stats.msa_info_err++;\n\tICNSS_QMI_ASSERT();\n\treturn ret;\n}'
p674
S'a77c16d4981b'
p675
sS'static int wlfw_msa_mem_info_send_sync_msg(void)\n{\n\tint ret;\n\tint i;\n\tstruct wlfw_msa_info_req_msg_v01 req;\n\tstruct wlfw_msa_info_resp_msg_v01 resp;\n\tstruct msg_desc req_desc, resp_desc;\n\tuint64_t max_mapped_addr;\n\n\tif (!penv || !penv->wlfw_clnt)\n\t\treturn -ENODEV;\n\n\ticnss_pr_dbg("Sending MSA mem info, state: 0x%lx\\n", penv->state);\n\n\tmemset(&req, 0, sizeof(req));\n\tmemset(&resp, 0, sizeof(resp));\n\n\treq.msa_addr = penv->msa_pa;\n\treq.size = penv->msa_mem_size;\n\n\treq_desc.max_msg_len = WLFW_MSA_INFO_REQ_MSG_V01_MAX_MSG_LEN;\n\treq_desc.msg_id = QMI_WLFW_MSA_INFO_REQ_V01;\n\treq_desc.ei_array = wlfw_msa_info_req_msg_v01_ei;\n\n\tresp_desc.max_msg_len = WLFW_MSA_INFO_RESP_MSG_V01_MAX_MSG_LEN;\n\tresp_desc.msg_id = QMI_WLFW_MSA_INFO_RESP_V01;\n\tresp_desc.ei_array = wlfw_msa_info_resp_msg_v01_ei;\n\n\tpenv->stats.msa_info_req++;\n\n\tret = qmi_send_req_wait(penv->wlfw_clnt, &req_desc, &req, sizeof(req),\n\t\t\t&resp_desc, &resp, sizeof(resp), WLFW_TIMEOUT_MS);\n\tif (ret < 0) {\n\t\ticnss_pr_err("Send MSA Mem info req failed %d\\n", ret);\n\t\tgoto out;\n\t}\n\n\tif (resp.resp.result != QMI_RESULT_SUCCESS_V01) {\n\t\ticnss_pr_err("QMI MSA Mem info request rejected, result:%d error:%d\\n",\n\t\t\tresp.resp.result, resp.resp.error);\n\t\tret = -resp.resp.result;\n\t\tgoto out;\n\t}\n\n\ticnss_pr_dbg("Receive mem_region_info_len: %d\\n",\n\t\t     resp.mem_region_info_len);\n\n\tif (resp.mem_region_info_len > QMI_WLFW_MAX_NUM_MEMORY_REGIONS_V01) {\n\t\ticnss_pr_err("Invalid memory region length received: %d\\n",\n\t\t\t     resp.mem_region_info_len);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tmax_mapped_addr = penv->msa_pa + penv->msa_mem_size;\n\tpenv->stats.msa_info_resp++;\n\tpenv->nr_mem_region = resp.mem_region_info_len;\n\tfor (i = 0; i < resp.mem_region_info_len; i++) {\n\n\t\tif (resp.mem_region_info[i].size > penv->msa_mem_size ||\n\t\t    resp.mem_region_info[i].region_addr >= max_mapped_addr ||\n\t\t    resp.mem_region_info[i].region_addr < penv->msa_pa ||\n\t\t    resp.mem_region_info[i].size +\n\t\t    resp.mem_region_info[i].region_addr > max_mapped_addr) {\n\t\t\ticnss_pr_dbg("Received out of range Addr: 0x%llx Size: 0x%x\\n",\n\t\t\t\t\tresp.mem_region_info[i].region_addr,\n\t\t\t\t\tresp.mem_region_info[i].size);\n\t\t\tret = -EINVAL;\n\t\t\tgoto fail_unwind;\n\t\t}\n\n\t\tpenv->mem_region[i].reg_addr =\n\t\t\tresp.mem_region_info[i].region_addr;\n\t\tpenv->mem_region[i].size =\n\t\t\tresp.mem_region_info[i].size;\n\t\tpenv->mem_region[i].secure_flag =\n\t\t\tresp.mem_region_info[i].secure_flag;\n\t\ticnss_pr_dbg("Memory Region: %d Addr: 0x%llx Size: 0x%x Flag: 0x%08x\\n",\n\t\t\t     i, penv->mem_region[i].reg_addr,\n\t\t\t     penv->mem_region[i].size,\n\t\t\t     penv->mem_region[i].secure_flag);\n\t}\n\n\treturn 0;\n\nfail_unwind:\n\tmemset(&penv->mem_region[0], 0, sizeof(penv->mem_region[0]) * i);\nout:\n\tpenv->stats.msa_info_err++;\n\tICNSS_QMI_ASSERT();\n\treturn ret;\n}'
p676
S'0c755962c9cc'
p677
sssS'CVE-2019-2330'
p678
(dp679
(S'drivers/staging/android/ion/ion_system_heap.c'
p680
S'alloc_from_pool_preferred'
p681
tp682
(dp683
S'static struct page_info *alloc_from_pool_preferred(\n\t\tstruct ion_system_heap *heap, struct ion_buffer *buffer,\n\t\tunsigned long size, unsigned int max_order)\n{\n\tstruct page *page;\n\tstruct page_info *info;\n\tint i;\n\n\tif (buffer->flags & ION_FLAG_POOL_FORCE_ALLOC)\n\t\tgoto force_alloc;\n\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn NULL;\n\n\tfor (i = 0; i < num_orders; i++) {\n\t\tif (size < order_to_size(orders[i]))\n\t\t\tcontinue;\n\t\tif (max_order < orders[i])\n\t\t\tcontinue;\n\n\t\tpage = alloc_from_secure_pool_order(heap, buffer, orders[i]);\n\t\tif (!page)\n\t\t\tcontinue;\n\n\t\tinfo->page = page;\n\t\tinfo->order = orders[i];\n\t\tinfo->from_pool = true;\n\t\tINIT_LIST_HEAD(&info->list);\n\t\treturn info;\n\t}\n\n\tpage = split_page_from_secure_pool(heap, buffer);\n\tif (page) {\n\t\tinfo->page = page;\n\t\tinfo->order = 0;\n\t\tinfo->from_pool = true;\n\t\tINIT_LIST_HEAD(&info->list);\n\t\treturn info;\n\t}\n\n\tkfree(info);\nforce_alloc:\n\treturn alloc_largest_available(heap, buffer, size, max_order);\n}'
p684
S'19a8101c2309'
p685
sssS'CVE-2019-2260'
p686
(dp687
(S'kernel/events/core.c'
p688
S'perf_event_zombie_cleanup'
p689
tp690
(dp691
S'static void perf_event_zombie_cleanup(unsigned int cpu)\n{\n\tstruct perf_event *event, *tmp;\n\n\tspin_lock(&zombie_list_lock);\n\n\tlist_for_each_entry_safe(event, tmp, &zombie_list, zombie_entry) {\n\t\tif (event->cpu != cpu)\n\t\t\tcontinue;\n\n\t\tlist_del(&event->zombie_entry);\n\t\tspin_unlock(&zombie_list_lock);\n\n\t\t/*\n\t\t * The detachment of the event with the\n\t\t * PMU expects it to be in an active state\n\t\t */\n\t\tevent->state = PERF_EVENT_STATE_ACTIVE;\n\t\t__perf_event_release_kernel(event);\n\n\t\tspin_lock(&zombie_list_lock);\n\t}\n\n\tspin_unlock(&zombie_list_lock);\n}'
p692
S'f332617ebb03'
p693
ss(g688
S'perf_event_release_kernel'
p694
tp695
(dp696
S'int perf_event_release_kernel(struct perf_event *event)\n{\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = __perf_event_release_kernel(event);\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}'
p697
g693
ss(g688
S'perf_event_start_swevents'
p698
tp699
(dp700
S'static int perf_event_start_swevents(unsigned int cpu)\n{\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tstruct perf_event *event;\n\tint idx;\n\n\tmutex_lock(&pmus_lock);\n\tperf_event_zombie_cleanup(cpu);\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tctx = &per_cpu_ptr(pmu->pmu_cpu_context, cpu)->ctx;\n\t\tmutex_lock(&ctx->mutex);\n\t\traw_spin_lock(&ctx->lock);\n\t\tlist_for_each_entry(event, &ctx->event_list, event_entry)\n\t\t\tcheck_hotplug_start_event(event);\n\t\traw_spin_unlock(&ctx->lock);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\tper_cpu(is_hotplugging, cpu) = false;\n\tmutex_unlock(&pmus_lock);\n\n\treturn 0;\n}'
p701
g693
ss(g688
S'__perf_event_release_kernel'
p702
tp703
(dp704
S"static int __perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\n\t/*\n\t * If the cpu associated to this event is offline, set the event as a\n\t *  zombie event. The cleanup of the cpu would be done if the CPU is\n\t *  back online.\n\t */\n#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE\n\tif (event->cpu != -1 && per_cpu(is_hotplugging, event->cpu)) {\n\t\tif (event->state == PERF_EVENT_STATE_ZOMBIE)\n\t\t\treturn 0;\n\n\t\tevent->state = PERF_EVENT_STATE_ZOMBIE;\n\n\t\tspin_lock(&zombie_list_lock);\n\t\tlist_add_tail(&event->zombie_entry, &zombie_list);\n\t\tspin_unlock(&zombie_list_lock);\n\n\t\treturn 0;\n\t}\n#endif\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event)) {\n\t\tperf_remove_from_owner(event);\n\t}\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\tif (perf_event_delete_kernel_shared(event) > 0) {\n\t\tperf_event__state_init(event);\n\t\tperf_install_in_context(ctx, event, event->cpu);\n\n\t\tperf_event_ctx_unlock(event, ctx);\n\n\t\tperf_event_enable(event);\n\n\t\treturn 0;\n\t}\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this even as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = lockless_dereference(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_del(&child->child_list);\n\t\t\tfree_event(child);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}"
p705
g693
sS"static int __perf_event_release_kernel(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_event *child, *tmp;\n\n#if defined CONFIG_HOTPLUG_CPU || defined CONFIG_KEXEC_CORE\n\tif (event->cpu != -1) {\n\t\tspin_lock(&dormant_event_list_lock);\n\t\tif (event->state == PERF_EVENT_STATE_DORMANT)\n\t\t\tlist_del(&event->dormant_event_entry);\n\t\tspin_unlock(&dormant_event_list_lock);\n\t}\n#endif\n\n\t/*\n\t * If we got here through err_file: fput(event_file); we will not have\n\t * attached to a context yet.\n\t */\n\tif (!ctx) {\n\t\tWARN_ON_ONCE(event->attach_state &\n\t\t\t\t(PERF_ATTACH_CONTEXT|PERF_ATTACH_GROUP));\n\t\tgoto no_ctx;\n\t}\n\n\tif (!is_kernel_event(event)) {\n\t\tperf_remove_from_owner(event);\n\t}\n\n\tctx = perf_event_ctx_lock(event);\n\tWARN_ON_ONCE(ctx->parent_ctx);\n\tperf_remove_from_context(event, DETACH_GROUP);\n\n\tif (perf_event_delete_kernel_shared(event) > 0) {\n\t\tperf_event__state_init(event);\n\t\tperf_install_in_context(ctx, event, event->cpu);\n\n\t\tperf_event_ctx_unlock(event, ctx);\n\n\t\tperf_event_enable(event);\n\n\t\treturn 0;\n\t}\n\n\traw_spin_lock_irq(&ctx->lock);\n\t/*\n\t * Mark this even as STATE_DEAD, there is no external reference to it\n\t * anymore.\n\t *\n\t * Anybody acquiring event->child_mutex after the below loop _must_\n\t * also see this, most importantly inherit_event() which will avoid\n\t * placing more children on the list.\n\t *\n\t * Thus this guarantees that we will in fact observe and kill _ALL_\n\t * child events.\n\t */\n\tevent->state = PERF_EVENT_STATE_DEAD;\n\traw_spin_unlock_irq(&ctx->lock);\n\n\tperf_event_ctx_unlock(event, ctx);\n\nagain:\n\tmutex_lock(&event->child_mutex);\n\tlist_for_each_entry(child, &event->child_list, child_list) {\n\n\t\t/*\n\t\t * Cannot change, child events are not migrated, see the\n\t\t * comment with perf_event_ctx_lock_nested().\n\t\t */\n\t\tctx = lockless_dereference(child->ctx);\n\t\t/*\n\t\t * Since child_mutex nests inside ctx::mutex, we must jump\n\t\t * through hoops. We start by grabbing a reference on the ctx.\n\t\t *\n\t\t * Since the event cannot get freed while we hold the\n\t\t * child_mutex, the context must also exist and have a !0\n\t\t * reference count.\n\t\t */\n\t\tget_ctx(ctx);\n\n\t\t/*\n\t\t * Now that we have a ctx ref, we can drop child_mutex, and\n\t\t * acquire ctx::mutex without fear of it going away. Then we\n\t\t * can re-acquire child_mutex.\n\t\t */\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_lock(&ctx->mutex);\n\t\tmutex_lock(&event->child_mutex);\n\n\t\t/*\n\t\t * Now that we hold ctx::mutex and child_mutex, revalidate our\n\t\t * state, if child is still the first entry, it didn't get freed\n\t\t * and we can continue doing so.\n\t\t */\n\t\ttmp = list_first_entry_or_null(&event->child_list,\n\t\t\t\t\t       struct perf_event, child_list);\n\t\tif (tmp == child) {\n\t\t\tperf_remove_from_context(child, DETACH_GROUP);\n\t\t\tlist_del(&child->child_list);\n\t\t\tfree_event(child);\n\t\t\t/*\n\t\t\t * This matches the refcount bump in inherit_event();\n\t\t\t * this can't be the last reference.\n\t\t\t */\n\t\t\tput_event(event);\n\t\t}\n\n\t\tmutex_unlock(&event->child_mutex);\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\tmutex_unlock(&event->child_mutex);\n\nno_ctx:\n\tput_event(event); /* Must be the 'last' reference */\n\treturn 0;\n}"
p706
S'c36d54c34fef'
p707
ss(g688
S'perf_event_exit_cpu'
p708
tp709
(dp710
S'int perf_event_exit_cpu(unsigned int cpu)\n{\n\tmutex_lock(&pmus_lock);\n\tper_cpu(is_hotplugging, cpu) = true;\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_unlock(&pmus_lock);\n\treturn 0;\n}'
p711
g693
sS'int perf_event_exit_cpu(unsigned int cpu)\n{\n\n\tmutex_lock(&pmus_lock);\n\tperf_event_exit_cpu_context(cpu);\n\tmutex_unlock(&pmus_lock);\n\treturn 0;\n}'
p712
g707
sssS'CVE-2019-2283'
p713
(dp714
(S'drivers/soc/qcom/glink_smem_native_xprt.c'
p715
S'fifo_read'
p716
tp717
(dp718
S'static int fifo_read(struct edge_info *einfo, void *_data, int len)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tvoid *data = _data;\n\tint orig_len = len;\n\tuint32_t read_index = einfo->rx_ch_desc->read_index;\n\tuint32_t write_index = einfo->rx_ch_desc->write_index;\n\tuint32_t fifo_size = einfo->rx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index > fifo_size && write_index > fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->rx_fifo + read_index;\n\t\tif (read_index <= write_index)\n\t\t\tn = write_index - read_index;\n\t\telse\n\t\t\tn = fifo_size - read_index;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->read_from_fifo(data, ptr, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\tread_index += n;\n\t\tif (read_index >= fifo_size)\n\t\t\tread_index -= fifo_size;\n\t}\n\teinfo->rx_ch_desc->read_index = read_index;\n\n\treturn orig_len - len;\n}'
p719
S'c36d54c34fef'
p720
sS'static int fifo_read(struct edge_info *einfo, void *_data, int len)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tvoid *data = _data;\n\tint orig_len = len;\n\tuint32_t read_index = einfo->rx_ch_desc->read_index;\n\tuint32_t write_index = einfo->rx_ch_desc->write_index;\n\tuint32_t fifo_size = einfo->rx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || write_index >= fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->rx_fifo + read_index;\n\t\tif (read_index <= write_index)\n\t\t\tn = write_index - read_index;\n\t\telse\n\t\t\tn = fifo_size - read_index;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->read_from_fifo(data, ptr, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\tread_index += n;\n\t\tif (read_index >= fifo_size)\n\t\t\tread_index -= fifo_size;\n\t}\n\teinfo->rx_ch_desc->read_index = read_index;\n\n\treturn orig_len - len;\n}'
p721
S'2dc9dcdbb971'
p722
sS'static int fifo_read(struct edge_info *einfo, void *_data, int len)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tvoid *data = _data;\n\tint orig_len = len;\n\tuint32_t read_index = einfo->rx_ch_desc->read_index;\n\tuint32_t write_index = einfo->rx_ch_desc->write_index;\n\tuint32_t fifo_size = einfo->rx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || write_index >= fifo_size) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\twhile (len) {\n\t\tptr = einfo->rx_fifo + read_index;\n\t\tif (read_index <= write_index)\n\t\t\tn = write_index - read_index;\n\t\telse\n\t\t\tn = fifo_size - read_index;\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->read_from_fifo(data, ptr, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\tread_index += n;\n\t\tif (read_index >= fifo_size)\n\t\t\tread_index -= fifo_size;\n\t}\n\teinfo->rx_ch_desc->read_index = read_index;\n\n\treturn orig_len - len;\n}'
p723
S'70f432282130'
p724
ss(g715
S'fifo_write_body'
p725
tp726
(dp727
S'static int fifo_write_body(struct edge_info *einfo, const void *_data,\n\t\t\t\tint len, uint32_t *write_index)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tconst void *data = _data;\n\tuint32_t read_index = einfo->tx_ch_desc->read_index;\n\tuint32_t fifo_size = einfo->tx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index > fifo_size && *write_index > fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->tx_fifo + *write_index;\n\t\tif (*write_index < read_index) {\n\t\t\tn = read_index - *write_index - FIFO_FULL_RESERVE;\n\t\t} else {\n\t\t\tif (read_index < FIFO_FULL_RESERVE)\n\t\t\t\tn = fifo_size + read_index - *write_index -\n\t\t\t\t\t\t\tFIFO_FULL_RESERVE;\n\t\t\telse\n\t\t\t\tn = fifo_size - *write_index;\n\t\t}\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->write_to_fifo(ptr, data, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\t*write_index += n;\n\t\tif (*write_index >= fifo_size)\n\t\t\t*write_index -= fifo_size;\n\t}\n\treturn len;\n}'
p728
g720
sS'static int fifo_write_body(struct edge_info *einfo, const void *_data,\n\t\t\t\tint len, uint32_t *write_index)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tconst void *data = _data;\n\tuint32_t read_index = einfo->tx_ch_desc->read_index;\n\tuint32_t fifo_size = einfo->tx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || *write_index >= fifo_size)\n\t\treturn 0;\n\twhile (len) {\n\t\tptr = einfo->tx_fifo + *write_index;\n\t\tif (*write_index < read_index) {\n\t\t\tn = read_index - *write_index - FIFO_FULL_RESERVE;\n\t\t} else {\n\t\t\tif (read_index < FIFO_FULL_RESERVE)\n\t\t\t\tn = fifo_size + read_index - *write_index -\n\t\t\t\t\t\t\tFIFO_FULL_RESERVE;\n\t\t\telse\n\t\t\t\tn = fifo_size - *write_index;\n\t\t}\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->write_to_fifo(ptr, data, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\t*write_index += n;\n\t\tif (*write_index >= fifo_size)\n\t\t\t*write_index -= fifo_size;\n\t}\n\treturn len;\n}'
p729
g722
sS'static int fifo_write_body(struct edge_info *einfo, const void *_data,\n\t\t\t\tint len, uint32_t *write_index)\n{\n\tvoid *ptr;\n\tvoid *ret;\n\tconst void *data = _data;\n\tuint32_t read_index = einfo->tx_ch_desc->read_index;\n\tuint32_t fifo_size = einfo->tx_fifo_size;\n\tuint32_t n;\n\n\tif (read_index >= fifo_size || *write_index >= fifo_size) {\n\t\tWARN_ON_ONCE(1);\n\t\treturn -EINVAL;\n\t}\n\twhile (len) {\n\t\tptr = einfo->tx_fifo + *write_index;\n\t\tif (*write_index < read_index) {\n\t\t\tn = read_index - *write_index - FIFO_FULL_RESERVE;\n\t\t} else {\n\t\t\tif (read_index < FIFO_FULL_RESERVE)\n\t\t\t\tn = fifo_size + read_index - *write_index -\n\t\t\t\t\t\t\tFIFO_FULL_RESERVE;\n\t\t\telse\n\t\t\t\tn = fifo_size - *write_index;\n\t\t}\n\n\t\tif (n == 0)\n\t\t\tbreak;\n\t\tif (n > len)\n\t\t\tn = len;\n\n\t\tret = einfo->write_to_fifo(ptr, data, n);\n\t\tif (IS_ERR(ret))\n\t\t\treturn PTR_ERR(ret);\n\n\t\tdata += n;\n\t\tlen -= n;\n\t\t*write_index += n;\n\t\tif (*write_index >= fifo_size)\n\t\t\t*write_index -= fifo_size;\n\t}\n\treturn len;\n}'
p730
g724
sssS'CVE-2018-11983'
p731
(dp732
(S'drivers/char/diag/diagfwd_cntl.c'
p733
S'process_ssid_range_report'
p734
tp735
(dp736
S'static void process_ssid_range_report(uint8_t *buf, uint32_t len,\n\t\t\t\t      uint8_t peripheral)\n{\n\tint i;\n\tint j;\n\tint read_len = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tint err = 0;\n\tstruct diag_ctrl_ssid_range_report *header = NULL;\n\tstruct diag_ssid_range_t *ssid_range = NULL;\n\tint header_len = sizeof(struct diag_ctrl_ssid_range_report);\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tuint8_t *ptr = buf;\n\tuint8_t *temp = NULL;\n\tuint32_t min_len = header_len - sizeof(struct diag_ctrl_pkt_header_t);\n\n\tif (!buf || peripheral >= NUM_PERIPHERALS || len < min_len) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid parameters:(!buf) = %d, peripheral = %d, len = %d, min_len = %d\\n",\n\t\t!buf, peripheral, len, min_len);\n\t\treturn;\n\t}\n\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: started processing ssid range for peripheral (%d)\\n",\n\t\tperipheral);\n\n\theader = (struct diag_ctrl_ssid_range_report *)ptr;\n\tptr += header_len;\n\t/* Don\'t account for pkt_id and length */\n\tread_len += header_len - (2 * sizeof(uint32_t));\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tdriver->max_ssid_count[peripheral] = header->count;\n\tfor (i = 0; i < header->count && read_len < len; i++) {\n\t\tssid_range = (struct diag_ssid_range_t *)ptr;\n\t\tptr += sizeof(struct diag_ssid_range_t);\n\t\tread_len += sizeof(struct diag_ssid_range_t);\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\tfound = 0;\n\t\tfor (j = 0; j < driver->msg_mask_tbl_count; j++, mask_ptr++) {\n\t\t\tif (!mask_ptr->ptr || !ssid_range) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mask_ptr->ssid_first != ssid_range->ssid_first)\n\t\t\t\tcontinue;\n\t\t\tmutex_lock(&mask_ptr->lock);\n\t\t\terr = update_msg_mask_tbl_entry(mask_ptr, ssid_range);\n\t\t\tmutex_unlock(&mask_ptr->lock);\n\t\t\tif (err == -ENOMEM) {\n\t\t\t\tpr_err("diag: In %s, unable to increase the msg mask table range\\n",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tnew_size = (driver->msg_mask_tbl_count + 1) *\n\t\t\t   sizeof(struct diag_msg_mask_t);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"diag: receiving msg mask size more that Apps can handle\\n");\n\t\ttemp = krealloc(msg_mask.ptr, new_size, GFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tpr_err("diag: In %s, Unable to add new ssid table to msg mask, ssid first: %d, last: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last);\n\t\t\tcontinue;\n\t\t}\n\t\tmsg_mask.ptr = temp;\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\terr = diag_create_msg_mask_table_entry(mask_ptr, ssid_range);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, first: %d last: %d err: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last, err);\n\t\t\tcontinue;\n\t\t}\n\t\tdriver->msg_mask_tbl_count += 1;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: processed ssid range for peripheral(%d)\\n",\n\t\tperipheral);\n}'
p737
S'38a1d53987e4'
p738
sS'static void process_ssid_range_report(uint8_t *buf, uint32_t len,\n\t\t\t\t      uint8_t peripheral)\n{\n\tint i;\n\tint j;\n\tint read_len = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tint err = 0;\n\tstruct diag_ctrl_ssid_range_report *header = NULL;\n\tstruct diag_ssid_range_t *ssid_range = NULL;\n\tint header_len = sizeof(struct diag_ctrl_ssid_range_report);\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tuint8_t *ptr = buf;\n\tuint8_t *temp = NULL;\n\tuint32_t min_len = header_len - sizeof(struct diag_ctrl_pkt_header_t);\n\n\tif (!buf || peripheral >= NUM_PERIPHERALS || len < min_len) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid parameters:(!buf) = %d, peripheral = %d, len = %d, min_len = %d\\n",\n\t\t!buf, peripheral, len, min_len);\n\t\treturn;\n\t}\n\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: started processing ssid range for peripheral (%d)\\n",\n\t\tperipheral);\n\n\theader = (struct diag_ctrl_ssid_range_report *)ptr;\n\tptr += header_len;\n\t/* Don\'t account for pkt_id and length */\n\tread_len += header_len - (2 * sizeof(uint32_t));\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tdriver->max_ssid_count[peripheral] = header->count;\n\tfor (i = 0; i < header->count && read_len < len; i++) {\n\t\tssid_range = (struct diag_ssid_range_t *)ptr;\n\t\tptr += sizeof(struct diag_ssid_range_t);\n\t\tread_len += sizeof(struct diag_ssid_range_t);\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\tfound = 0;\n\t\tfor (j = 0; j < driver->msg_mask_tbl_count; j++, mask_ptr++) {\n\t\t\tif (!mask_ptr || !ssid_range) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (mask_ptr->ssid_first != ssid_range->ssid_first)\n\t\t\t\tcontinue;\n\t\t\tmutex_lock(&mask_ptr->lock);\n\t\t\terr = update_msg_mask_tbl_entry(mask_ptr, ssid_range);\n\t\t\tmutex_unlock(&mask_ptr->lock);\n\t\t\tif (err == -ENOMEM) {\n\t\t\t\tpr_err("diag: In %s, unable to increase the msg mask table range\\n",\n\t\t\t\t       __func__);\n\t\t\t}\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (found)\n\t\t\tcontinue;\n\n\t\tnew_size = (driver->msg_mask_tbl_count + 1) *\n\t\t\t   sizeof(struct diag_msg_mask_t);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"diag: receiving msg mask size more that Apps can handle\\n");\n\t\ttemp = krealloc(msg_mask.ptr, new_size, GFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tpr_err("diag: In %s, Unable to add new ssid table to msg mask, ssid first: %d, last: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last);\n\t\t\tcontinue;\n\t\t}\n\t\tmsg_mask.ptr = temp;\n\t\tmask_ptr = (struct diag_msg_mask_t *)msg_mask.ptr;\n\t\terr = diag_create_msg_mask_table_entry(mask_ptr, ssid_range);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, first: %d last: %d err: %d\\n",\n\t\t\t       __func__, ssid_range->ssid_first,\n\t\t\t       ssid_range->ssid_last, err);\n\t\t\tcontinue;\n\t\t}\n\t\tdriver->msg_mask_tbl_count += 1;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: processed ssid range for peripheral(%d)\\n",\n\t\tperipheral);\n}'
p739
S'c9ebd8b20d52'
p740
ss(S'drivers/char/diag/diag_masks.c'
p741
S'diag_cmd_set_log_mask'
p742
tp743
(dp744
S'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p745
S'c9ebd8b20d52'
p746
sS'static int diag_cmd_set_log_mask(unsigned char *src_buf, int src_len,\n\t\t\t\t unsigned char *dest_buf, int dest_len,\n\t\t\t\t int pid)\n{\n\tint i, peripheral, write_len = 0;\n\tint status = LOG_STATUS_SUCCESS;\n\tint read_len = 0, payload_len = 0;\n\tint req_header_len = sizeof(struct diag_log_config_req_t);\n\tint rsp_header_len = sizeof(struct diag_log_config_set_rsp_t);\n\tuint32_t mask_size = 0;\n\tstruct diag_log_config_req_t *req;\n\tstruct diag_log_config_set_rsp_t rsp;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tunsigned char *temp_buf = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\tsrc_len < sizeof(struct diag_log_config_req_t)) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_log_config_req_t *)src_buf;\n\tread_len += req_header_len;\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (req->equip_id >= MAX_EQUIP_ID) {\n\t\tpr_err("diag: In %s, Invalid logging mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tif (req->num_items == 0) {\n\t\tpr_err("diag: In %s, Invalid number of items in log mask request, equip_id: %d\\n",\n\t\t       __func__, req->equip_id);\n\t\tstatus = LOG_STATUS_INVALID;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID && !status; i++, mask++) {\n\t\tif (!mask || !mask->ptr)\n\t\t\tcontinue;\n\t\tif (mask->equip_id != req->equip_id)\n\t\t\tcontinue;\n\t\tmutex_lock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS, "e: %d current: %d %d new: %d %d",\n\t\t\t mask->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, req->num_items,\n\t\t\t LOG_ITEMS_TO_SIZE(req->num_items));\n\t\t/*\n\t\t * If the size of the log mask cannot fit into our\n\t\t * buffer, trim till we have space left in the buffer.\n\t\t * num_items should then reflect the items that we have\n\t\t * in our buffer.\n\t\t */\n\t\tmask->num_items_tools = (req->num_items > MAX_ITEMS_ALLOWED) ?\n\t\t\t\t\tMAX_ITEMS_ALLOWED : req->num_items;\n\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\tmemset(mask->ptr, 0, mask->range_tools);\n\t\tif (mask_size > mask->range_tools) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t\t "log range mismatch, e: %d old: %d new: %d\\n",\n\t\t\t\t req->equip_id, mask->range_tools,\n\t\t\t\t LOG_ITEMS_TO_SIZE(mask->num_items_tools));\n\t\t\t/* Change in the mask reported by tools */\n\t\t\ttemp_buf = krealloc(mask->ptr, mask_size, GFP_KERNEL);\n\t\t\tif (!temp_buf) {\n\t\t\t\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask->ptr = temp_buf;\n\t\t\tmemset(mask->ptr, 0, mask_size);\n\t\t\tmask->range_tools = mask_size;\n\t\t}\n\t\treq->num_items = mask->num_items_tools;\n\t\tif (mask_size > 0 && src_len >= read_len + mask_size)\n\t\t\tmemcpy(mask->ptr, src_buf + read_len, mask_size);\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "copying log mask, e %d num %d range %d size %d\\n",\n\t\t\t req->equip_id, mask->num_items_tools,\n\t\t\t mask->range_tools, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\tpayload_len = LOG_ITEMS_TO_SIZE(req->num_items);\n\tif ((payload_len + rsp_header_len > dest_len) || (payload_len == 0)) {\n\t\tpr_err("diag: In %s, invalid length, payload_len: %d, header_len: %d, dest_len: %d\\n",\n\t\t       __func__, payload_len, rsp_header_len, dest_len);\n\t\tstatus = LOG_STATUS_FAIL;\n\t}\n\trsp.cmd_code = DIAG_CMD_LOG_CONFIG;\n\trsp.padding[0] = 0;\n\trsp.padding[1] = 0;\n\trsp.padding[2] = 0;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_LOG_MASK;\n\trsp.status = status;\n\trsp.equip_id = req->equip_id;\n\trsp.num_items = req->num_items;\n\tmemcpy(dest_buf, &rsp, rsp_header_len);\n\twrite_len += rsp_header_len;\n\tif (status != LOG_STATUS_SUCCESS)\n\t\tgoto end;\n\tmemcpy(dest_buf + write_len, src_buf + read_len, payload_len);\n\twrite_len += payload_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, req->equip_id);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p747
S'a77c16d4981b'
p748
ss(g741
S'diag_cmd_set_all_msg_mask'
p749
tp750
(dp751
S'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < driver->msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p752
g746
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p753
g748
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p754
S'57d3486c6e7a'
p755
ss(g733
S'process_last_event_report'
p756
tp757
(dp758
S'static void process_last_event_report(uint8_t *buf, uint32_t len,\n\t\t\t\t      uint8_t peripheral)\n{\n\tstruct diag_ctrl_last_event_report *header = NULL;\n\tuint8_t *ptr = buf;\n\tuint8_t *temp = NULL;\n\tuint32_t pkt_len = sizeof(uint32_t) + sizeof(uint16_t);\n\tuint16_t event_size = 0;\n\n\tif (!buf || peripheral >= NUM_PERIPHERALS || len != pkt_len) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid parameters:(!buf) = %d, peripheral = %d, len = %d, pkt_len = %d\\n",\n\t\t!buf, peripheral, len, pkt_len);\n\t\treturn;\n\t}\n\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag:started processing last event report for peripheral (%d)\\n",\n\t\tperipheral);\n\n\tmutex_lock(&event_mask.lock);\n\theader = (struct diag_ctrl_last_event_report *)ptr;\n\tevent_size = ((header->event_last_id / 8) + 1);\n\tif (event_size >= driver->event_mask_size) {\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t"diag: receiving event mask size more that Apps can handle\\n");\n\t\ttemp = krealloc(driver->event_mask->ptr, event_size,\n\t\t\t\tGFP_KERNEL);\n\t\tif (!temp) {\n\t\t\tpr_err("diag: In %s, unable to reallocate event mask to support events from %d\\n",\n\t\t\t       __func__, peripheral);\n\t\t\tgoto err;\n\t\t}\n\t\tdriver->event_mask->ptr = temp;\n\t\tdriver->event_mask_size = event_size;\n\t}\n\n\tdriver->num_event_id[peripheral] = header->event_last_id;\n\tif (header->event_last_id > driver->last_event_id)\n\t\tdriver->last_event_id = header->event_last_id;\nerr:\n\tmutex_unlock(&event_mask.lock);\n\tDIAG_LOG(DIAG_DEBUG_CONTROL,\n\t\t"diag: last event report processed for peripheral (%d)\\n",\n\t\tperipheral);\n}'
p759
g740
ss(g733
S'diag_build_time_mask_update'
p760
tp761
(dp762
S'static void diag_build_time_mask_update(uint8_t *buf,\n\t\t\t\t\tstruct diag_ssid_range_t *range)\n{\n\tint i;\n\tint j;\n\tint num_items = 0;\n\tint err = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tuint8_t *temp = NULL;\n\tuint32_t *mask_ptr = (uint32_t *)buf;\n\tuint32_t *dest_ptr = NULL;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\n\tif (!range || !buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid %s\\n",\n\t\t(!range ? "range" : (!buf ? "buf" : " ")));\n\t\treturn;\n\t}\n\n\tif (range->ssid_last < range->ssid_first) {\n\t\tpr_err("diag: In %s, invalid ssid range, first: %d, last: %d\\n",\n\t\t       __func__, range->ssid_first, range->ssid_last);\n\t\treturn;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tbuild_mask = (struct diag_msg_mask_t *)(driver->build_time_mask->ptr);\n\tnum_items = range->ssid_last - range->ssid_first + 1;\n\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask->ptr) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (build_mask->ssid_first != range->ssid_first)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tmutex_lock(&build_mask->lock);\n\t\terr = update_msg_mask_tbl_entry(build_mask, range);\n\t\tif (err == -ENOMEM) {\n\t\t\tpr_err("diag: In %s, unable to increase the msg build mask table range\\n",\n\t\t\t       __func__);\n\t\t}\n\t\tdest_ptr = build_mask->ptr;\n\t\tfor (j = 0; (j < build_mask->range) && mask_ptr && dest_ptr;\n\t\t\tj++, mask_ptr++, dest_ptr++)\n\t\t\t*(uint32_t *)dest_ptr |= *mask_ptr;\n\t\tmutex_unlock(&build_mask->lock);\n\t\tbreak;\n\t}\n\n\tif (found)\n\t\tgoto end;\n\n\tnew_size = (driver->bt_msg_mask_tbl_count + 1) *\n\t\t   sizeof(struct diag_msg_mask_t);\n\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t"diag: receiving build time mask size more that Apps can handle\\n");\n\n\ttemp = krealloc(driver->build_time_mask->ptr, new_size, GFP_KERNEL);\n\tif (!temp) {\n\t\tpr_err("diag: In %s, unable to create a new entry for build time mask\\n",\n\t\t       __func__);\n\t\tgoto end;\n\t}\n\tdriver->build_time_mask->ptr = temp;\n\tbuild_mask = (struct diag_msg_mask_t *)driver->build_time_mask->ptr;\n\terr = diag_create_msg_mask_table_entry(build_mask, range);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, err: %d\\n",\n\t\t       __func__, err);\n\t\tgoto end;\n\t}\n\tdriver->bt_msg_mask_tbl_count += 1;\nend:\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn;\n}'
p763
g738
sS'static void diag_build_time_mask_update(uint8_t *buf,\n\t\t\t\t\tstruct diag_ssid_range_t *range)\n{\n\tint i;\n\tint j;\n\tint num_items = 0;\n\tint err = 0;\n\tint found = 0;\n\tint new_size = 0;\n\tuint8_t *temp = NULL;\n\tuint32_t *mask_ptr = (uint32_t *)buf;\n\tuint32_t *dest_ptr = NULL;\n\tstruct diag_msg_mask_t *build_mask = NULL;\n\n\tif (!range || !buf) {\n\t\tDIAG_LOG(DIAG_DEBUG_PERIPHERALS,\n\t\t"diag: Invalid %s\\n",\n\t\t(!range ? "range" : (!buf ? "buf" : " ")));\n\t\treturn;\n\t}\n\n\tif (range->ssid_last < range->ssid_first) {\n\t\tpr_err("diag: In %s, invalid ssid range, first: %d, last: %d\\n",\n\t\t       __func__, range->ssid_first, range->ssid_last);\n\t\treturn;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tbuild_mask = (struct diag_msg_mask_t *)(driver->build_time_mask->ptr);\n\tnum_items = range->ssid_last - range->ssid_first + 1;\n\n\tfor (i = 0; i < driver->bt_msg_mask_tbl_count; i++, build_mask++) {\n\t\tif (!build_mask) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t\tif (build_mask->ssid_first != range->ssid_first)\n\t\t\tcontinue;\n\t\tfound = 1;\n\t\tmutex_lock(&build_mask->lock);\n\t\terr = update_msg_mask_tbl_entry(build_mask, range);\n\t\tif (err == -ENOMEM) {\n\t\t\tpr_err("diag: In %s, unable to increase the msg build mask table range\\n",\n\t\t\t       __func__);\n\t\t}\n\t\tdest_ptr = build_mask->ptr;\n\t\tfor (j = 0; (j < build_mask->range) && mask_ptr && dest_ptr;\n\t\t\tj++, mask_ptr++, dest_ptr++)\n\t\t\t*(uint32_t *)dest_ptr |= *mask_ptr;\n\t\tmutex_unlock(&build_mask->lock);\n\t\tbreak;\n\t}\n\n\tif (found)\n\t\tgoto end;\n\n\tnew_size = (driver->bt_msg_mask_tbl_count + 1) *\n\t\t   sizeof(struct diag_msg_mask_t);\n\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t"diag: receiving build time mask size more that Apps can handle\\n");\n\n\ttemp = krealloc(driver->build_time_mask->ptr, new_size, GFP_KERNEL);\n\tif (!temp) {\n\t\tpr_err("diag: In %s, unable to create a new entry for build time mask\\n",\n\t\t       __func__);\n\t\tgoto end;\n\t}\n\tdriver->build_time_mask->ptr = temp;\n\tbuild_mask = (struct diag_msg_mask_t *)driver->build_time_mask->ptr;\n\terr = diag_create_msg_mask_table_entry(build_mask, range);\n\tif (err) {\n\t\tpr_err("diag: In %s, Unable to create a new msg mask table entry, err: %d\\n",\n\t\t       __func__, err);\n\t\tgoto end;\n\t}\n\tdriver->bt_msg_mask_tbl_count += 1;\nend:\n\tmutex_unlock(&driver->msg_mask_lock);\n\treturn;\n}'
p764
g740
ss(g741
S'diag_cmd_disable_log_mask'
p765
tp766
(dp767
S'static int diag_cmd_disable_log_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diag_log_config_rsp_t header;\n\tint write_len = 0, i, peripheral;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &log_mask : info->log_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, 0, mask->range);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmask_info->status = DIAG_CTRL_MASK_ALL_DISABLED;\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(LOG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\theader.cmd_code = DIAG_CMD_LOG_CONFIG;\n\theader.padding[0] = 0;\n\theader.padding[1] = 0;\n\theader.padding[2] = 0;\n\theader.sub_cmd = DIAG_CMD_OP_LOG_DISABLE;\n\theader.status = LOG_STATUS_SUCCESS;\n\tmemcpy(dest_buf, &header, sizeof(struct diag_log_config_rsp_t));\n\twrite_len += sizeof(struct diag_log_config_rsp_t);\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_log_mask_update(peripheral, ALL_EQUIP_ID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p768
g746
sssS'CVE-2018-11986'
p769
(dp770
(S'drivers/media/platform/msm/camera_v2/pproc/cpp/msm_cpp.c'
p771
S'SWAP_IDENTITY_FOR_BATCH_ON_PREVIEW'
p772
tp773
(dp774
g95
S'85a4a4c4437e'
p775
ss(g771
S'msm_cpp_empty_list'
p776
tp777
(dp778
g95
g775
ss(g771
S'msm_cpp_irq'
p779
tp780
(dp781
S'static irqreturn_t msm_cpp_irq(int irq_num, void *data)\n{\n\tunsigned long flags;\n\tuint32_t tx_level;\n\tuint32_t irq_status;\n\tuint32_t i;\n\tuint32_t tx_fifo[MSM_CPP_TX_FIFO_LEVEL];\n\tstruct cpp_device *cpp_dev = data;\n\tstruct msm_cpp_tasklet_queue_cmd *queue_cmd;\n\n\tirq_status = msm_camera_io_r(cpp_dev->base + MSM_CPP_MICRO_IRQGEN_STAT);\n\n\tif (irq_status & 0x8) {\n\t\ttx_level = msm_camera_io_r(cpp_dev->base +\n\t\t\tMSM_CPP_MICRO_FIFO_TX_STAT) >> 2;\n\t\tif (tx_level < MSM_CPP_TX_FIFO_LEVEL) {\n\t\t\tfor (i = 0; i < tx_level; i++) {\n\t\t\t\ttx_fifo[i] = msm_camera_io_r(cpp_dev->base +\n\t\t\t\t\tMSM_CPP_MICRO_FIFO_TX_DATA);\n\t\t\t}\n\t\t} else {\n\t\t\tpr_err("Fatal invalid tx level %d", tx_level);\n\t\t\tgoto err;\n\t\t}\n\t\tspin_lock_irqsave(&cpp_dev->tasklet_lock, flags);\n\t\tqueue_cmd = &cpp_dev->tasklet_queue_cmd[cpp_dev->taskletq_idx];\n\t\tif (queue_cmd->cmd_used) {\n\t\t\tpr_err("%s:%d] cpp tasklet queue overflow tx %d rc %x",\n\t\t\t\t__func__, __LINE__, tx_level, irq_status);\n\t\t\tlist_del(&queue_cmd->list);\n\t\t} else {\n\t\t\tatomic_add(1, &cpp_dev->irq_cnt);\n\t\t}\n\t\tqueue_cmd->irq_status = irq_status;\n\t\tqueue_cmd->tx_level = tx_level;\n\t\tmemset(&queue_cmd->tx_fifo[0], 0, sizeof(queue_cmd->tx_fifo));\n\t\tfor (i = 0; i < tx_level; i++)\n\t\t\tqueue_cmd->tx_fifo[i] = tx_fifo[i];\n\n\t\tqueue_cmd->cmd_used = 1;\n\t\tcpp_dev->taskletq_idx =\n\t\t\t(cpp_dev->taskletq_idx + 1) % MSM_CPP_TASKLETQ_SIZE;\n\t\tlist_add_tail(&queue_cmd->list, &cpp_dev->tasklet_q);\n\t\tspin_unlock_irqrestore(&cpp_dev->tasklet_lock, flags);\n\n\t\ttasklet_schedule(&cpp_dev->cpp_tasklet);\n\t} else if (irq_status & 0x7C0) {\n\t\tpr_debug("irq_status: 0x%x\\n", irq_status);\n\t\tpr_debug("DEBUG_SP: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x40));\n\t\tpr_debug("DEBUG_T: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x44));\n\t\tpr_debug("DEBUG_N: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x48));\n\t\tpr_debug("DEBUG_R: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x4C));\n\t\tpr_debug("DEBUG_OPPC: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x50));\n\t\tpr_debug("DEBUG_MO: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x54));\n\t\tpr_debug("DEBUG_TIMER0: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x60));\n\t\tpr_debug("DEBUG_TIMER1: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x64));\n\t\tpr_debug("DEBUG_GPI: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x70));\n\t\tpr_debug("DEBUG_GPO: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x74));\n\t\tpr_debug("DEBUG_T0: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x80));\n\t\tpr_debug("DEBUG_R0: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x84));\n\t\tpr_debug("DEBUG_T1: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x88));\n\t\tpr_debug("DEBUG_R1: 0x%x\\n",\n\t\t\tmsm_camera_io_r(cpp_dev->base + 0x8C));\n\t}\nerr:\n\tmsm_camera_io_w(irq_status, cpp_dev->base + MSM_CPP_MICRO_IRQGEN_CLR);\n\treturn IRQ_HANDLED;\n}'
p782
g775
sssS'CVE-2018-11987'
p783
(dp784
(S'drivers/staging/android/ion/ion_system_heap.c'
p785
S'ion_system_heap_destroy_pools'
p786
tp787
(dp788
S'static void ion_system_heap_destroy_pools(struct ion_page_pool **pools)\n{\n\tint i;\n\tfor (i = 0; i < num_orders; i++)\n\t\tif (pools[i]) {\n\t\t\tion_page_pool_destroy(pools[i]);\n\t\t\tpools[i] = NULL;\n\t\t}\n}'
p789
S'b50d2bd7c7df'
p790
sssS'CVE-2018-11984'
p791
(dp792
(S'drivers/char/diag/diag_masks.c'
p793
S'diag_send_log_mask_update'
p794
tp795
(dp796
S'static void diag_send_log_mask_update(uint8_t peripheral, int equip_id)\n{\n\tint err = 0, send_once = 0, i;\n\tint header_len = sizeof(struct diag_ctrl_log_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_ctrl_log_mask ctrl_pkt;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->log_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->log_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &log_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr)\n\t\treturn;\n\tbuf = mask_info->update_buf;\n\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tsend_once = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid log_mask status\\n", __func__);\n\t\treturn;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\n\t\tif (equip_id != i && equip_id != ALL_EQUIP_ID)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&mask->lock);\n\t\tctrl_pkt.cmd_type = DIAG_CTRL_MSG_LOG_MASK;\n\t\tctrl_pkt.stream_id = 1;\n\t\tctrl_pkt.status = mask_info->status;\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\t\tctrl_pkt.equip_id = i;\n\t\t\tctrl_pkt.num_items = mask->num_items_tools;\n\t\t\tctrl_pkt.log_mask_size = mask_size;\n\t\t}\n\t\tctrl_pkt.data_len = LOG_MASK_CTRL_HEADER_LEN + mask_size;\n\n\t\tif (header_len + mask_size > mask_info->update_buf_len) {\n\t\t\ttemp = krealloc(buf, header_len + mask_size,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: Unable to realloc log update buffer, new size: %d, equip_id: %d\\n",\n\t\t\t\t       header_len + mask_size, equip_id);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask_info->update_buf = temp;\n\t\t\tmask_info->update_buf_len = header_len + mask_size;\n\t\t\tbuf = temp;\n\t\t}\n\n\t\tmemcpy(buf, &ctrl_pkt, header_len);\n\t\tif (mask_size > 0 && mask_size <= LOG_MASK_SIZE)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending ctrl pkt to %d, e %d num_items %d size %d\\n",\n\t\t\t peripheral, i, ctrl_pkt.num_items,\n\t\t\t ctrl_pkt.log_mask_size);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL,\n\t\t\t\t    buf, header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send log masks to peripheral %d, equip_id: %d, err: %d\\n",\n\t\t\t       peripheral, i, err);\n\t\tif (send_once || equip_id != ALL_EQUIP_ID)\n\t\t\tbreak;\n\n\t}\n\tmutex_unlock(&mask_info->lock);\n}'
p797
S'38a1d53987e4'
p798
sS'static void diag_send_log_mask_update(uint8_t peripheral, int equip_id)\n{\n\tint err = 0, send_once = 0, i;\n\tint header_len = sizeof(struct diag_ctrl_log_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_ctrl_log_mask ctrl_pkt;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_log_mask_t *mask = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->log_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->log_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &log_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\n\tmask = (struct diag_log_mask_t *)mask_info->ptr;\n\tif (!mask->ptr)\n\t\treturn;\n\tbuf = mask_info->update_buf;\n\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tctrl_pkt.equip_id = 0;\n\t\tctrl_pkt.num_items = 0;\n\t\tctrl_pkt.log_mask_size = 0;\n\t\tsend_once = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tsend_once = 0;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid log_mask status\\n", __func__);\n\t\treturn;\n\t}\n\n\tmutex_lock(&mask_info->lock);\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, mask++) {\n\t\tif (equip_id != i && equip_id != ALL_EQUIP_ID)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&mask->lock);\n\t\tctrl_pkt.cmd_type = DIAG_CTRL_MSG_LOG_MASK;\n\t\tctrl_pkt.stream_id = 1;\n\t\tctrl_pkt.status = mask_info->status;\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size = LOG_ITEMS_TO_SIZE(mask->num_items_tools);\n\t\t\tctrl_pkt.equip_id = i;\n\t\t\tctrl_pkt.num_items = mask->num_items_tools;\n\t\t\tctrl_pkt.log_mask_size = mask_size;\n\t\t}\n\t\tctrl_pkt.data_len = LOG_MASK_CTRL_HEADER_LEN + mask_size;\n\n\t\tif (header_len + mask_size > mask_info->update_buf_len) {\n\t\t\ttemp = krealloc(buf, header_len + mask_size,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: Unable to realloc log update buffer, new size: %d, equip_id: %d\\n",\n\t\t\t\t       header_len + mask_size, equip_id);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmask_info->update_buf = temp;\n\t\t\tmask_info->update_buf_len = header_len + mask_size;\n\t\t\tbuf = temp;\n\t\t}\n\n\t\tmemcpy(buf, &ctrl_pkt, header_len);\n\t\tif (mask_size > 0 && mask_size <= LOG_MASK_SIZE)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\n\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t "sending ctrl pkt to %d, e %d num_items %d size %d\\n",\n\t\t\t peripheral, i, ctrl_pkt.num_items,\n\t\t\t ctrl_pkt.log_mask_size);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL,\n\t\t\t\t    buf, header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send log masks to peripheral %d, equip_id: %d, err: %d\\n",\n\t\t\t       peripheral, i, err);\n\t\tif (send_once || equip_id != ALL_EQUIP_ID)\n\t\t\tbreak;\n\n\t}\n\tmutex_unlock(&mask_info->lock);\n}'
p799
S'f1ef67c39eac'
p800
ss(g793
S'diag_send_msg_mask_update'
p801
tp802
(dp803
S'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tstruct diag_md_session_t *md_session_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t\t\tmd_session_info =\n\t\t\t\t\tdriver->md_session_map[peripheral];\n\t\t\t}\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t\t\tmd_session_info = driver->md_session_map[upd];\n\t\t\t}\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tif (md_session_info)\n\t\tmsg_mask_tbl_count_local = md_session_info->msg_mask_tbl_count;\n\telse\n\t\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p804
S'57d3486c6e7a'
p805
sS'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p806
g800
sS'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p807
g798
ss(g793
S'diag_send_event_mask_update'
p808
tp809
(dp810
S'static void diag_send_event_mask_update(uint8_t peripheral)\n{\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint32_t pd_mask = 0;\n\tint num_bytes = EVENT_COUNT_TO_BYTES(driver->last_event_id);\n\tint write_len = 0, err = 0, i = 0, temp_len = 0;\n\tstruct diag_ctrl_event_mask header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diagfwd_info *fwd_info = NULL;\n\n\tif (num_bytes <= 0 || num_bytes > driver->event_mask_size) {\n\t\tpr_debug("diag: In %s, invalid event mask length %d\\n",\n\t\t\t __func__, num_bytes);\n\t\treturn;\n\t}\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->event_mask;\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd])\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->event_mask;\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &event_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\n\tbuf = mask_info->update_buf;\n\tmutex_lock(&mask_info->lock);\n\theader.cmd_type = DIAG_CTRL_MSG_EVENT_MASK;\n\theader.stream_id = 1;\n\theader.status = mask_info->status;\n\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\theader.event_config = 0;\n\t\theader.event_mask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\theader.event_config = 1;\n\t\theader.event_mask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\theader.event_config = 1;\n\t\theader.event_mask_size = num_bytes;\n\t\tif (num_bytes + sizeof(header) > mask_info->update_buf_len) {\n\t\t\ttemp_len = num_bytes + sizeof(header);\n\t\t\ttemp = krealloc(buf, temp_len, GFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: Unable to realloc event mask update buffer\\n");\n\t\t\t\tgoto err;\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t}\n\t\t}\n\t\tif (num_bytes > 0 && num_bytes < mask_info->mask_len)\n\t\t\tmemcpy(buf + sizeof(header), mask_info->ptr, num_bytes);\n\t\telse {\n\t\t\tpr_err("diag: num_bytes(%d) is not satisfying length condition\\n",\n\t\t\t\tnum_bytes);\n\t\t\tgoto err;\n\t\t}\n\t\twrite_len += num_bytes;\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\theader.data_len = EVENT_MASK_CTRL_HEADER_LEN + header.event_mask_size;\n\tmemcpy(buf, &header, sizeof(header));\n\twrite_len += sizeof(header);\n\n\terr = diagfwd_write(peripheral, TYPE_CNTL, buf, write_len);\n\tif (err && err != -ENODEV)\n\t\tpr_err_ratelimited("diag: Unable to send event masks to peripheral %d\\n",\n\t\t       peripheral);\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p811
g800
sssS'CVE-2019-2284'
p812
(dp813
(S'drivers/media/platform/msm/camera/cam_req_mgr/cam_req_mgr_core.c'
p814
S'cam_req_mgr_link'
p815
tp816
(dp817
S'int cam_req_mgr_link(struct cam_req_mgr_link_info *link_info)\n{\n\tint                                     rc = 0;\n\tint                                     wq_flag = 0;\n\tchar                                    buf[128];\n\tstruct cam_create_dev_hdl               root_dev;\n\tstruct cam_req_mgr_core_session        *cam_session;\n\tstruct cam_req_mgr_core_link           *link;\n\n\tif (!link_info) {\n\t\tCAM_DBG(CAM_CRM, "NULL pointer");\n\t\treturn -EINVAL;\n\t}\n\tif (link_info->num_devices > CAM_REQ_MGR_MAX_HANDLES) {\n\t\tCAM_ERR(CAM_CRM, "Invalid num devices %d",\n\t\t\tlink_info->num_devices);\n\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&g_crm_core_dev->crm_lock);\n\n\t/* session hdl\'s priv data is cam session struct */\n\tcam_session = (struct cam_req_mgr_core_session *)\n\t\tcam_get_device_priv(link_info->session_hdl);\n\tif (!cam_session) {\n\t\tCAM_DBG(CAM_CRM, "NULL pointer");\n\t\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\t\treturn -EINVAL;\n\t}\n\n\t/* Allocate link struct and map it with session\'s request queue */\n\tlink = __cam_req_mgr_reserve_link(cam_session);\n\tif (!link) {\n\t\tCAM_ERR(CAM_CRM, "failed to reserve new link");\n\t\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\t\treturn -EINVAL;\n\t}\n\tCAM_DBG(CAM_CRM, "link reserved %pK %x", link, link->link_hdl);\n\n\tmemset(&root_dev, 0, sizeof(struct cam_create_dev_hdl));\n\troot_dev.session_hdl = link_info->session_hdl;\n\troot_dev.priv = (void *)link;\n\n\tmutex_lock(&link->lock);\n\t/* Create unique dev handle for link */\n\tlink->link_hdl = cam_create_device_hdl(&root_dev);\n\tif (link->link_hdl < 0) {\n\t\tCAM_ERR(CAM_CRM,\n\t\t\t"Insufficient memory to create new device handle");\n\t\trc = link->link_hdl;\n\t\tgoto link_hdl_fail;\n\t}\n\tlink_info->link_hdl = link->link_hdl;\n\n\t/* Allocate memory to hold data of all linked devs */\n\trc = __cam_req_mgr_create_subdevs(&link->l_dev,\n\t\tlink_info->num_devices);\n\tif (rc < 0) {\n\t\tCAM_ERR(CAM_CRM,\n\t\t\t"Insufficient memory to create new crm subdevs");\n\t\tgoto create_subdev_failed;\n\t}\n\n\t/* Using device ops query connected devs, prepare request tables */\n\trc = __cam_req_mgr_setup_link_info(link, link_info);\n\tif (rc < 0)\n\t\tgoto setup_failed;\n\n\tspin_lock_bh(&link->link_state_spin_lock);\n\tlink->state = CAM_CRM_LINK_STATE_READY;\n\tspin_unlock_bh(&link->link_state_spin_lock);\n\n\t/* Create worker for current link */\n\tsnprintf(buf, sizeof(buf), "%x-%x",\n\t\tlink_info->session_hdl, link->link_hdl);\n\twq_flag = CAM_WORKQ_FLAG_HIGH_PRIORITY | CAM_WORKQ_FLAG_SERIAL;\n\trc = cam_req_mgr_workq_create(buf, CRM_WORKQ_NUM_TASKS,\n\t\t&link->workq, CRM_WORKQ_USAGE_NON_IRQ, wq_flag);\n\tif (rc < 0) {\n\t\tCAM_ERR(CAM_CRM, "FATAL: unable to create worker");\n\t\t__cam_req_mgr_destroy_link_info(link);\n\t\tgoto setup_failed;\n\t}\n\n\t/* Assign payload to workqueue tasks */\n\trc = __cam_req_mgr_setup_payload(link->workq);\n\tif (rc < 0) {\n\t\t__cam_req_mgr_destroy_link_info(link);\n\t\tcam_req_mgr_workq_destroy(&link->workq);\n\t\tgoto setup_failed;\n\t}\n\n\tmutex_unlock(&link->lock);\n\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\treturn rc;\nsetup_failed:\n\t__cam_req_mgr_destroy_subdev(link->l_dev);\ncreate_subdev_failed:\n\tcam_destroy_device_hdl(link->link_hdl);\n\tlink_info->link_hdl = 0;\nlink_hdl_fail:\n\tmutex_unlock(&link->lock);\n\t__cam_req_mgr_unreserve_link(cam_session, link);\n\tmutex_unlock(&g_crm_core_dev->crm_lock);\n\treturn rc;\n}'
p818
S'1d7b97667c43'
p819
sssS'CVE-2019-9457'
p820
(dp821
(S'fs/exec.c'
p822
S'get_arg_page'
p823
tp824
(dp825
S"static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,\n\t\tint write)\n{\n\tstruct page *page;\n\tint ret;\n\tunsigned int gup_flags = FOLL_FORCE;\n\n#ifdef CONFIG_STACK_GROWSUP\n\tif (write) {\n\t\tret = expand_downwards(bprm->vma, pos);\n\t\tif (ret < 0)\n\t\t\treturn NULL;\n\t}\n#endif\n\n\tif (write)\n\t\tgup_flags |= FOLL_WRITE;\n\n\t/*\n\t * We are doing an exec().  'current' is the process\n\t * doing the exec and bprm->mm is the new process's mm.\n\t */\n\tret = get_user_pages_remote(current, bprm->mm, pos, 1, gup_flags,\n\t\t\t&page, NULL);\n\tif (ret <= 0)\n\t\treturn NULL;\n\n\tif (write) {\n\t\tunsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;\n\t\tunsigned long ptr_size, limit;\n\n\t\t/*\n\t\t * Since the stack will hold pointers to the strings, we\n\t\t * must account for them as well.\n\t\t *\n\t\t * The size calculation is the entire vma while each arg page is\n\t\t * built, so each time we get here it's calculating how far it\n\t\t * is currently (rather than each call being just the newly\n\t\t * added size from the arg page).  As a result, we need to\n\t\t * always add the entire size of the pointers, so that on the\n\t\t * last call to get_arg_page() we'll actually have the entire\n\t\t * correct size.\n\t\t */\n\t\tptr_size = (bprm->argc + bprm->envc) * sizeof(void *);\n\t\tif (ptr_size > ULONG_MAX - size)\n\t\t\tgoto fail;\n\t\tsize += ptr_size;\n\n\t\tacct_arg_size(bprm, size / PAGE_SIZE);\n\n\t\t/*\n\t\t * We've historically supported up to 32 pages (ARG_MAX)\n\t\t * of argument strings even with small stacks\n\t\t */\n\t\tif (size <= ARG_MAX)\n\t\t\treturn page;\n\n\t\t/*\n\t\t * Limit to 1/4 of the max stack size or 3/4 of _STK_LIM\n\t\t * (whichever is smaller) for the argv+env strings.\n\t\t * This ensures that:\n\t\t *  - the remaining binfmt code will not run out of stack space,\n\t\t *  - the program will have a reasonable amount of stack left\n\t\t *    to work from.\n\t\t */\n\t\tlimit = _STK_LIM / 4 * 3;\n\t\tlimit = min(limit, rlimit(RLIMIT_STACK) / 4);\n\t\tif (size > limit)\n\t\t\tgoto fail;\n\t}\n\n\treturn page;\n\nfail:\n\tput_page(page);\n\treturn NULL;\n}"
p826
S'1388873ab814'
p827
sssS'CVE-2019-9456'
p828
(dp829
(S'drivers/usb/mon/mon_text.c'
p830
S'mon_text_read_u'
p831
tp832
(dp833
S'static ssize_t mon_text_read_u(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_u(rp, &ptr, ep);\n\t\tif (ep->type == \'E\') {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {\n\t\t\tmon_text_read_isostat(rp, &ptr, ep);\n\t\t\tmon_text_read_isodesc(rp, &ptr, ep);\n\t\t} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {\n\t\t\tmon_text_read_intstat(rp, &ptr, ep);\n\t\t} else {\n\t\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\t}\n\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    " %d", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}'
p834
S'78667dedc643'
p835
ss(g830
S'mon_text_copy_to_user'
p836
tp837
(dp838
S'static ssize_t mon_text_copy_to_user(struct mon_reader_text *rp,\n    char __user * const buf, const size_t nbytes)\n{\n\tconst size_t togo = min(nbytes, rp->printf_togo);\n\n\tif (copy_to_user(buf, &rp->printf_buf[rp->printf_offset], togo))\n\t\treturn -EFAULT;\n\trp->printf_togo -= togo;\n\trp->printf_offset += togo;\n\treturn togo;\n}'
p839
g835
ss(g830
S'mon_text_read_t'
p840
tp841
(dp842
S'static ssize_t mon_text_read_t(struct file *file, char __user *buf,\n    size_t nbytes, loff_t *ppos)\n{\n\tstruct mon_reader_text *rp = file->private_data;\n\tstruct mon_event_text *ep;\n\tstruct mon_text_ptr ptr;\n\tssize_t ret;\n\n\tmutex_lock(&rp->printf_lock);\n\n\tif (rp->printf_togo == 0) {\n\n\t\tep = mon_text_read_wait(rp, file);\n\t\tif (IS_ERR(ep)) {\n\t\t\tmutex_unlock(&rp->printf_lock);\n\t\t\treturn PTR_ERR(ep);\n\t\t}\n\t\tptr.cnt = 0;\n\t\tptr.pbuf = rp->printf_buf;\n\t\tptr.limit = rp->printf_size;\n\n\t\tmon_text_read_head_t(rp, &ptr, ep);\n\t\tmon_text_read_statset(rp, &ptr, ep);\n\t\tptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,\n\t\t    " %d", ep->length);\n\t\tmon_text_read_data(rp, &ptr, ep);\n\n\t\trp->printf_togo = ptr.cnt;\n\t\trp->printf_offset = 0;\n\n\t\tkmem_cache_free(rp->e_slab, ep);\n\t}\n\n\tret = mon_text_copy_to_user(rp, buf, nbytes);\n\tmutex_unlock(&rp->printf_lock);\n\treturn ret;\n}'
p843
g835
sssS'CVE-2018-3564'
p844
(dp845
(S'drivers/char/adsprpc.c'
p846
S'fastrpc_file_free'
p847
tp848
(dp849
S'static int fastrpc_file_free(struct fastrpc_file *fl)\n{\n\tstruct hlist_node *n = NULL;\n\tstruct fastrpc_mmap *map = NULL, *lmap = NULL;\n\tstruct fastrpc_perf *perf = NULL, *fperf = NULL;\n\tint cid;\n\n\tif (!fl)\n\t\treturn 0;\n\tcid = fl->cid;\n\n\t(void)fastrpc_release_current_dsp_process(fl);\n\n\tspin_lock(&fl->apps->hlock);\n\thlist_del_init(&fl->hn);\n\tspin_unlock(&fl->apps->hlock);\n\n\tif (!fl->sctx) {\n\t\tkfree(fl);\n\t\treturn 0;\n\t}\n\tspin_lock(&fl->hlock);\n\tfl->file_close = 1;\n\tspin_unlock(&fl->hlock);\n\tfastrpc_context_list_dtor(fl);\n\tfastrpc_buf_list_free(fl);\n\tmutex_lock(&fl->fl_map_mutex);\n\tdo {\n\t\tlmap = NULL;\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\thlist_del_init(&map->hn);\n\t\t\tlmap = map;\n\t\t\tbreak;\n\t\t}\n\t\tfastrpc_mmap_free(lmap, 1);\n\t} while (lmap);\n\tmutex_unlock(&fl->fl_map_mutex);\n\tif (fl->refcount && (fl->ssrcount == fl->apps->channel[cid].ssrcount))\n\t\tkref_put_mutex(&fl->apps->channel[cid].kref,\n\t\t\t\tfastrpc_channel_close, &fl->apps->smd_mutex);\n\tif (fl->sctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->sctx);\n\tif (fl->secsctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->secsctx);\n\n\tmutex_lock(&fl->perf_mutex);\n\tdo {\n\t\tstruct hlist_node *pn = NULL;\n\n\t\tfperf = NULL;\n\t\thlist_for_each_entry_safe(perf, pn, &fl->perf, hn) {\n\t\t\thlist_del_init(&perf->hn);\n\t\t\tfperf = perf;\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fperf);\n\t} while (fperf);\n\tmutex_unlock(&fl->perf_mutex);\n\tmutex_destroy(&fl->perf_mutex);\n\tmutex_destroy(&fl->fl_map_mutex);\n\tmutex_destroy(&fl->map_mutex);\n\tkfree(fl);\n\treturn 0;\n}'
p850
S'aa022618939c'
p851
sS'static int fastrpc_file_free(struct fastrpc_file *fl)\n{\n\tstruct hlist_node *n = NULL;\n\tstruct fastrpc_mmap *map = NULL, *lmap = NULL;\n\tstruct fastrpc_perf *perf = NULL, *fperf = NULL;\n\tint cid;\n\n\tif (!fl)\n\t\treturn 0;\n\tcid = fl->cid;\n\n\t(void)fastrpc_release_current_dsp_process(fl);\n\n\tspin_lock(&fl->apps->hlock);\n\thlist_del_init(&fl->hn);\n\tspin_unlock(&fl->apps->hlock);\n\tkfree(fl->debug_buf);\n\n\tif (!fl->sctx) {\n\t\tkfree(fl);\n\t\treturn 0;\n\t}\n\tspin_lock(&fl->hlock);\n\tfl->file_close = 1;\n\tspin_unlock(&fl->hlock);\n\tif (!IS_ERR_OR_NULL(fl->init_mem))\n\t\tfastrpc_buf_free(fl->init_mem, 0);\n\tfastrpc_context_list_dtor(fl);\n\tfastrpc_cached_buf_list_free(fl);\n\tmutex_lock(&fl->fl_map_mutex);\n\tdo {\n\t\tlmap = NULL;\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\thlist_del_init(&map->hn);\n\t\t\tlmap = map;\n\t\t\tbreak;\n\t\t}\n\t\tfastrpc_mmap_free(lmap, 1);\n\t} while (lmap);\n\tmutex_unlock(&fl->fl_map_mutex);\n\tif (fl->refcount && (fl->ssrcount == fl->apps->channel[cid].ssrcount))\n\t\tkref_put_mutex(&fl->apps->channel[cid].kref,\n\t\t\t\tfastrpc_channel_close, &fl->apps->smd_mutex);\n\tif (fl->sctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->sctx);\n\tif (fl->secsctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->secsctx);\n\n\tmutex_lock(&fl->perf_mutex);\n\tdo {\n\t\tstruct hlist_node *pn = NULL;\n\n\t\tfperf = NULL;\n\t\thlist_for_each_entry_safe(perf, pn, &fl->perf, hn) {\n\t\t\thlist_del_init(&perf->hn);\n\t\t\tfperf = perf;\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fperf);\n\t} while (fperf);\n\tfastrpc_remote_buf_list_free(fl);\n\tmutex_unlock(&fl->perf_mutex);\n\tmutex_destroy(&fl->perf_mutex);\n\tmutex_destroy(&fl->fl_map_mutex);\n\tmutex_destroy(&fl->map_mutex);\n\tkfree(fl);\n\treturn 0;\n}'
p852
S'b85fce5ba048'
p853
sS'static int fastrpc_file_free(struct fastrpc_file *fl)\n{\n\tstruct hlist_node *n = NULL;\n\tstruct fastrpc_mmap *map = NULL, *lmap = NULL;\n\tstruct fastrpc_perf *perf = NULL, *fperf = NULL;\n\tint cid;\n\n\tif (!fl)\n\t\treturn 0;\n\tcid = fl->cid;\n\n\t(void)fastrpc_release_current_dsp_process(fl);\n\n\tspin_lock(&fl->apps->hlock);\n\thlist_del_init(&fl->hn);\n\tspin_unlock(&fl->apps->hlock);\n\tkfree(fl->debug_buf);\n\n\tif (!fl->sctx) {\n\t\tkfree(fl);\n\t\treturn 0;\n\t}\n\tspin_lock(&fl->hlock);\n\tfl->file_close = 1;\n\tspin_unlock(&fl->hlock);\n\tfastrpc_context_list_dtor(fl);\n\tfastrpc_buf_list_free(fl);\n\tmutex_lock(&fl->fl_map_mutex);\n\tdo {\n\t\tlmap = NULL;\n\t\thlist_for_each_entry_safe(map, n, &fl->maps, hn) {\n\t\t\thlist_del_init(&map->hn);\n\t\t\tlmap = map;\n\t\t\tbreak;\n\t\t}\n\t\tfastrpc_mmap_free(lmap, 1);\n\t} while (lmap);\n\tmutex_unlock(&fl->fl_map_mutex);\n\tif (fl->refcount && (fl->ssrcount == fl->apps->channel[cid].ssrcount))\n\t\tkref_put_mutex(&fl->apps->channel[cid].kref,\n\t\t\t\tfastrpc_channel_close, &fl->apps->smd_mutex);\n\tif (fl->sctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->sctx);\n\tif (fl->secsctx)\n\t\tfastrpc_session_free(&fl->apps->channel[cid], fl->secsctx);\n\n\tmutex_lock(&fl->perf_mutex);\n\tdo {\n\t\tstruct hlist_node *pn = NULL;\n\n\t\tfperf = NULL;\n\t\thlist_for_each_entry_safe(perf, pn, &fl->perf, hn) {\n\t\t\thlist_del_init(&perf->hn);\n\t\t\tfperf = perf;\n\t\t\tbreak;\n\t\t}\n\t\tkfree(fperf);\n\t} while (fperf);\n\tmutex_unlock(&fl->perf_mutex);\n\tmutex_destroy(&fl->perf_mutex);\n\tmutex_destroy(&fl->fl_map_mutex);\n\tmutex_destroy(&fl->map_mutex);\n\tkfree(fl);\n\treturn 0;\n}'
p854
S'1b473b19279a'
p855
ss(g846
S'fastrpc_device_release'
p856
tp857
(dp858
S'static int fastrpc_device_release(struct inode *inode, struct file *file)\n{\n\tstruct fastrpc_file *fl = (struct fastrpc_file *)file->private_data;\n\n\tif (fl) {\n\t\tif (fl->qos_request && pm_qos_request_active(&fl->pm_qos_req))\n\t\t\tpm_qos_remove_request(&fl->pm_qos_req);\n\t\tif (fl->debugfs_file != NULL)\n\t\t\tdebugfs_remove(fl->debugfs_file);\n\t\tfastrpc_file_free(fl);\n\t\tfile->private_data = NULL;\n\t}\n\treturn 0;\n}'
p859
g851
sssS'CVE-2019-10515'
p860
(dp861
(S'drivers/char/diag/diag_dci.c'
p862
S'dci_lookup_client_entry_pid'
p863
tp864
(dp865
S'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client)\n\t\t\tif (entry->client->tgid == tgid)\n\t\t\t\treturn entry;\n\t}\n\treturn NULL;\n}'
p866
S'f332617ebb03'
p867
sS'struct diag_dci_client_tbl *dci_lookup_client_entry_pid(int tgid)\n{\n\tstruct list_head *start, *temp;\n\tstruct diag_dci_client_tbl *entry = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\tentry = list_entry(start, struct diag_dci_client_tbl, track);\n\t\tpid_struct = find_get_pid(entry->tgid);\n\t\tif (!pid_struct) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t"diag: Exited pid (%d) doesn\'t match dci client of pid (%d)\\n",\n\t\t\ttgid, entry->tgid);\n\t\t\tcontinue;\n\t\t}\n\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\tif (!task_s) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\tput_pid(pid_struct);\n\t\t\tcontinue;\n\t\t}\n\t\tif (task_s == entry->client) {\n\t\t\tif (entry->client->tgid == tgid) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\tput_task_struct(task_s);\n\t\tput_pid(pid_struct);\n\t}\n\treturn NULL;\n}'
p868
S'6c6aaf4e8330'
p869
ss(S'drivers/char/diag/diagchar_core.c'
p870
S'diagchar_read'
p871
tp872
(dp873
S'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client)\n\t\t\t\tif (entry->client->tgid != current->tgid)\n\t\t\t\t\tcontinue;\n\t\t\tif (!entry->in_service)\n\t\t\t\tcontinue;\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p874
S'f332617ebb03'
p875
sS'static ssize_t diagchar_read(struct file *file, char __user *buf, size_t count,\n\t\t\t  loff_t *ppos)\n{\n\tstruct diag_dci_client_tbl *entry;\n\tstruct list_head *start, *temp;\n\tint index = -1, i = 0, ret = 0;\n\tint data_type;\n\tint copy_dci_data = 0;\n\tint exit_stat = 0;\n\tint write_len = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\tstruct pid *pid_struct = NULL;\n\tstruct task_struct *task_s = NULL;\n\n\tmutex_lock(&driver->diagchar_mutex);\n\tfor (i = 0; i < driver->num_clients; i++)\n\t\tif (driver->client_map[i].pid == current->tgid)\n\t\t\tindex = i;\n\tmutex_unlock(&driver->diagchar_mutex);\n\n\tif (index == -1) {\n\t\tpr_err("diag: Client PID not found in table");\n\t\treturn -EINVAL;\n\t}\n\tif (!buf) {\n\t\tpr_err("diag: bad address from user side\\n");\n\t\treturn -EFAULT;\n\t}\n\twait_event_interruptible(driver->wait_q,\n\t\t\tatomic_read(&driver->data_ready_notif[index]) > 0);\n\n\tmutex_lock(&driver->diagchar_mutex);\n\n\tif ((driver->data_ready[index] & USER_SPACE_DATA_TYPE) &&\n\t    (driver->logging_mode == DIAG_MEMORY_DEVICE_MODE ||\n\t     driver->logging_mode == DIAG_MULTI_MODE)) {\n\t\tpr_debug("diag: process woken up\\n");\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & USER_SPACE_DATA_TYPE;\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\t/* place holder for number of data field */\n\t\tret += sizeof(int);\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\texit_stat = diag_md_copy_to_user(buf, &ret, count,\n\t\t\t\t\t\t session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t} else if (driver->data_ready[index] & USER_SPACE_DATA_TYPE) {\n\t\t/* In case, the thread wakes up and the logging mode is not\n\t\t * memory device any more, the condition needs to be cleared.\n\t\t */\n\t\tdriver->data_ready[index] ^= USER_SPACE_DATA_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t}\n\n\tif (driver->data_ready[index] & HDLC_SUPPORT_TYPE) {\n\t\tdata_type = driver->data_ready[index] & HDLC_SUPPORT_TYPE;\n\t\tdriver->data_ready[index] ^= HDLC_SUPPORT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_pid(current->tgid);\n\t\tif (session_info) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf+4,\n\t\t\t\t\tsession_info->hdlc_disabled,\n\t\t\t\t\tsizeof(uint8_t));\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DEINIT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DEINIT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DEINIT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\tdiag_remove_client_entry(file);\n\t\treturn ret;\n\t}\n\n\tif (driver->data_ready[index] & MSG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & MSG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\twrite_len = diag_copy_to_user_msg_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= MSG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & EVENT_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\t\tif (session_info && session_info->event_mask &&\n\t\t    session_info->event_mask->ptr) {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t*(session_info->event_mask->ptr),\n\t\t\t\t\tsession_info->event_mask->mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t} else {\n\t\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(int),\n\t\t\t\t\t\t*(event_mask.ptr),\n\t\t\t\t\t\tevent_mask.mask_len);\n\t\t\tif (ret == -EFAULT) {\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tdriver->data_ready[index] ^= EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & LOG_MASKS_TYPE;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tsession_info = diag_md_session_get_peripheral(APPS_DATA);\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(int));\n\t\tif (ret == -EFAULT) {\n\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\tgoto exit;\n\t\t}\n\n\t\twrite_len = diag_copy_to_user_log_mask(buf + ret, count,\n\t\t\t\t\t\t       session_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\tif (write_len > 0)\n\t\t\tret += write_len;\n\t\tdriver->data_ready[index] ^= LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & PKT_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, sizeof(data_type));\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + sizeof(data_type),\n\t\t\t\t\t*(driver->apps_req_buf),\n\t\t\t\t\tdriver->apps_req_buf_len);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_pktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_PKT_TYPE) {\n\t\t/* Copy the type of data being passed */\n\t\tdata_type = driver->data_ready[index] & DCI_PKT_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, *(driver->dci_pkt_buf),\n\t\t\t\t\tdriver->dci_pkt_length);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_PKT_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tdriver->in_busy_dcipktdata = 0;\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_EVENT_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_EVENT_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf + 8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tevent_mask_composite), DCI_EVENT_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tdriver->data_ready[index] ^= DCI_EVENT_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\n\tif (driver->data_ready[index] & DCI_LOG_MASKS_TYPE) {\n\t\t/*Copy the type of data being passed*/\n\t\tdata_type = driver->data_ready[index] & DCI_LOG_MASKS_TYPE;\n\t\tCOPY_USER_SPACE_OR_ERR(buf, data_type, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+4, driver->num_dci_client, 4);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\n\t\tCOPY_USER_SPACE_OR_ERR(buf+8, (dci_ops_tbl[DCI_LOCAL_PROC].\n\t\t\t\tlog_mask_composite), DCI_LOG_MASK_SIZE);\n\t\tif (ret == -EFAULT)\n\t\t\tgoto exit;\n\t\tdriver->data_ready[index] ^= DCI_LOG_MASKS_TYPE;\n\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\tgoto exit;\n\t}\n\nexit:\n\tif (driver->data_ready[index] & DCI_DATA_TYPE) {\n\t\tdata_type = driver->data_ready[index] & DCI_DATA_TYPE;\n\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t/* Copy the type of data being passed */\n\t\tmutex_lock(&driver->dci_mutex);\n\t\tlist_for_each_safe(start, temp, &driver->dci_client_list) {\n\t\t\tentry = list_entry(start, struct diag_dci_client_tbl,\n\t\t\t\t\t\t\t\t\ttrack);\n\t\t\tpid_struct = find_get_pid(entry->tgid);\n\t\t\tif (!pid_struct)\n\t\t\t\tcontinue;\n\t\t\ttask_s = get_pid_task(pid_struct, PIDTYPE_PID);\n\t\t\tif (!task_s) {\n\t\t\t\tDIAG_LOG(DIAG_DEBUG_DCI,\n\t\t\t\t"diag: valid task doesn\'t exist for pid = %d\\n",\n\t\t\t\tentry->tgid);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task_s == entry->client) {\n\t\t\t\tif (entry->client->tgid != current->tgid) {\n\t\t\t\t\tput_task_struct(task_s);\n\t\t\t\t\tput_pid(pid_struct);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!entry->in_service) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (copy_to_user(buf + ret, &data_type, sizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tif (copy_to_user(buf + ret, &entry->client_info.token,\n\t\t\t\tsizeof(int))) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tret += sizeof(int);\n\t\t\tcopy_dci_data = 1;\n\t\t\texit_stat = diag_copy_dci(buf, count, entry, &ret);\n\t\t\tmutex_lock(&driver->diagchar_mutex);\n\t\t\tdriver->data_ready[index] ^= DCI_DATA_TYPE;\n\t\t\tatomic_dec(&driver->data_ready_notif[index]);\n\t\t\tmutex_unlock(&driver->diagchar_mutex);\n\t\t\tif (exit_stat == 1) {\n\t\t\t\tput_task_struct(task_s);\n\t\t\t\tput_pid(pid_struct);\n\t\t\t\tmutex_unlock(&driver->dci_mutex);\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\tput_task_struct(task_s);\n\t\t\tput_pid(pid_struct);\n\t\t}\n\t\tmutex_unlock(&driver->dci_mutex);\n\t\tgoto end;\n\t}\n\tmutex_unlock(&driver->diagchar_mutex);\nend:\n\t/*\n\t * Flush any read that is currently pending on DCI data and\n\t * command channnels. This will ensure that the next read is not\n\t * missed.\n\t */\n\tif (copy_dci_data) {\n\t\tdiag_ws_on_copy_complete(DIAG_WS_DCI);\n\t\tflush_workqueue(driver->diag_dci_wq);\n\t}\n\treturn ret;\n}'
p876
S'6c6aaf4e8330'
p877
ss(g870
S'diagchar_close'
p878
tp879
(dp880
S'static int diagchar_close(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "diag: %s process exit with pid = %d\\n",\n\t\tcurrent->comm, current->tgid);\n\tret = diag_remove_client_entry(file);\n\n\treturn ret;\n}'
p881
g875
sssS'CVE-2019-10530'
p882
(dp883
(S'drivers/iommu/dma-mapping-fast.c'
p884
S'fast_smmu_alloc'
p885
tp886
(dp887
S'static void *fast_smmu_alloc(struct device *dev, size_t size,\n\t\t\t     dma_addr_t *handle, gfp_t gfp,\n\t\t\t     unsigned long attrs)\n{\n\tstruct dma_fast_smmu_mapping *mapping = dev->archdata.mapping->fast;\n\tstruct sg_table sgt;\n\tdma_addr_t dma_addr, iova_iter;\n\tvoid *addr;\n\tav8l_fast_iopte *ptep;\n\tunsigned long flags;\n\tstruct sg_mapping_iter miter;\n\tsize_t count = ALIGN(size, SZ_4K) >> PAGE_SHIFT;\n\tint prot = IOMMU_READ | IOMMU_WRITE; /* TODO: extract from attrs */\n\tbool is_coherent = is_dma_coherent(dev, attrs);\n\tpgprot_t remap_prot = __get_dma_pgprot(attrs, PAGE_KERNEL, is_coherent);\n\tstruct page **pages;\n\n\t/*\n\t * sg_alloc_table_from_pages accepts unsigned int value for count\n\t * so check count doesn\'t exceed UINT_MAX.\n\t */\n\n\tif (count > UINT_MAX) {\n\t\tdev_err(dev, "count: %zx exceeds UNIT_MAX\\n", count);\n\t\treturn NULL;\n\t}\n\n\tprot = __get_iommu_pgprot(attrs, prot, is_coherent);\n\n\t*handle = DMA_ERROR_CODE;\n\n\tpages = __fast_smmu_alloc_pages(count, gfp);\n\tif (!pages) {\n\t\tdev_err(dev, "no pages\\n");\n\t\treturn NULL;\n\t}\n\n\tsize = ALIGN(size, SZ_4K);\n\tif (sg_alloc_table_from_pages(&sgt, pages, count, 0, size, gfp)) {\n\t\tdev_err(dev, "no sg tablen\\n");\n\t\tgoto out_free_pages;\n\t}\n\n\tif (!is_coherent) {\n\t\t/*\n\t\t * The CPU-centric flushing implied by SG_MITER_TO_SG isn\'t\n\t\t * sufficient here, so skip it by using the "wrong" direction.\n\t\t */\n\t\tsg_miter_start(&miter, sgt.sgl, sgt.orig_nents,\n\t\t\t       SG_MITER_FROM_SG);\n\t\twhile (sg_miter_next(&miter))\n\t\t\t__dma_flush_area(miter.addr, miter.length);\n\t\tsg_miter_stop(&miter);\n\t}\n\n\tspin_lock_irqsave(&mapping->lock, flags);\n\tdma_addr = __fast_smmu_alloc_iova(mapping, attrs, size);\n\tif (dma_addr == DMA_ERROR_CODE) {\n\t\tdev_err(dev, "no iova\\n");\n\t\tspin_unlock_irqrestore(&mapping->lock, flags);\n\t\tgoto out_free_sg;\n\t}\n\tiova_iter = dma_addr;\n\tsg_miter_start(&miter, sgt.sgl, sgt.orig_nents,\n\t\t       SG_MITER_FROM_SG | SG_MITER_ATOMIC);\n\twhile (sg_miter_next(&miter)) {\n\t\tint nptes = miter.length >> FAST_PAGE_SHIFT;\n\n\t\tptep = iopte_pmd_offset(mapping->pgtbl_pmds, iova_iter);\n\t\tif (unlikely(av8l_fast_map_public(\n\t\t\t\t     ptep, page_to_phys(miter.page),\n\t\t\t\t     miter.length, prot))) {\n\t\t\tdev_err(dev, "no map public\\n");\n\t\t\t/* TODO: unwind previously successful mappings */\n\t\t\tgoto out_free_iova;\n\t\t}\n\t\tfast_dmac_clean_range(mapping, ptep, ptep + nptes);\n\t\tiova_iter += miter.length;\n\t}\n\tsg_miter_stop(&miter);\n\tspin_unlock_irqrestore(&mapping->lock, flags);\n\n\taddr = dma_common_pages_remap(pages, size, VM_USERMAP, remap_prot,\n\t\t\t\t      __builtin_return_address(0));\n\tif (!addr) {\n\t\tdev_err(dev, "no common pages\\n");\n\t\tgoto out_unmap;\n\t}\n\n\t*handle = dma_addr;\n\tsg_free_table(&sgt);\n\treturn addr;\n\nout_unmap:\n\t/* need to take the lock again for page tables and iova */\n\tspin_lock_irqsave(&mapping->lock, flags);\n\tptep = iopte_pmd_offset(mapping->pgtbl_pmds, dma_addr);\n\tav8l_fast_unmap_public(ptep, size);\n\tfast_dmac_clean_range(mapping, ptep, ptep + count);\nout_free_iova:\n\t__fast_smmu_free_iova(mapping, dma_addr, size);\n\tspin_unlock_irqrestore(&mapping->lock, flags);\nout_free_sg:\n\tsg_free_table(&sgt);\nout_free_pages:\n\t__fast_smmu_free_pages(pages, count);\n\treturn NULL;\n}'
p888
S'de6abb23dc05'
p889
sssS'CVE-2019-10555'
p890
(dp891
(S'drivers/video/fbdev/msm/mdss_dsi.c'
p892
S'mdss_dsi_cmd_flush'
p893
tp894
(dp895
S'static int mdss_dsi_cmd_flush(struct file *file, fl_owner_t id)\n{\n\tstruct buf_data *pcmds = file->private_data;\n\tunsigned int len;\n\tint blen, i;\n\tchar *buf, *bufp, *bp;\n\tstruct dsi_ctrl_hdr *dchdr;\n\n\tmutex_lock(&pcmds->dbg_mutex);\n\n\tif (!pcmds->string_buf) {\n\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Allocate memory for command buffer\n\t * 3 bytes per number, and 2 bytes for the last one\n\t */\n\tblen = ((pcmds->sblen) + 2) / 3;\n\tbuf = kcalloc(1, blen, GFP_KERNEL);\n\tif (!buf) {\n\t\tpr_err("%s: Failed to allocate memory\\n", __func__);\n\t\tkfree(pcmds->string_buf);\n\t\tpcmds->string_buf = NULL;\n\t\tpcmds->sblen = 0;\n\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Translate the input string to command array */\n\tbufp = pcmds->string_buf;\n\tfor (i = 0; i < blen; i++) {\n\t\tuint32_t value = 0;\n\t\tint step = 0;\n\n\t\tif (sscanf(bufp, "%02x%n", &value, &step) > 0) {\n\t\t\t*(buf+i) = (char)value;\n\t\t\tbufp += step;\n\t\t}\n\t}\n\n\t/* Scan dcs commands */\n\tbp = buf;\n\tlen = blen;\n\twhile (len >= sizeof(*dchdr)) {\n\t\tdchdr = (struct dsi_ctrl_hdr *)bp;\n\t\tdchdr->dlen = ntohs(dchdr->dlen);\n\t\tif (dchdr->dlen > (len - sizeof(*dchdr)) || dchdr->dlen < 0) {\n\t\t\tpr_err("%s: dtsi cmd=%x error, len=%d\\n",\n\t\t\t\t__func__, dchdr->dtype, dchdr->dlen);\n\t\t\tkfree(buf);\n\t\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tbp += sizeof(*dchdr);\n\t\tlen -= sizeof(*dchdr);\n\t\tbp += dchdr->dlen;\n\t\tlen -= dchdr->dlen;\n\t}\n\tif (len != 0) {\n\t\tpr_err("%s: dcs_cmd=%x len=%d error!\\n", __func__,\n\t\t\t\tbp[0], len);\n\t\tkfree(buf);\n\t\tmutex_unlock(&pcmds->dbg_mutex);\n\t\treturn -EINVAL;\n\t}\n\n\tif (pcmds->sync_flag) {\n\t\tpcmds->buf = buf;\n\t\tpcmds->blen = blen;\n\t\tpcmds->sync_flag = 0;\n\t} else {\n\t\tkfree(pcmds->buf);\n\t\tpcmds->buf = buf;\n\t\tpcmds->blen = blen;\n\t}\n\tmutex_unlock(&pcmds->dbg_mutex);\n\treturn 0;\n}'
p896
S'61fe509b8406'
p897
sssS'CVE-2018-19824'
p898
(dp899
(S'sound/usb/card.c'
p900
S'usb_audio_probe'
p901
tp902
(dp903
S'static int usb_audio_probe(struct usb_interface *intf,\n\t\t\t   const struct usb_device_id *usb_id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tconst struct snd_usb_audio_quirk *quirk =\n\t\t(const struct snd_usb_audio_quirk *)usb_id->driver_info;\n\tstruct snd_usb_audio *chip;\n\tint i, err;\n\tstruct usb_host_interface *alts;\n\tint ifnum;\n\tu32 id;\n\tstruct usb_interface_assoc_descriptor *assoc;\n\n\tassoc = intf->intf_assoc;\n\tif (assoc && assoc->bFunctionClass == USB_CLASS_AUDIO &&\n\t    assoc->bFunctionProtocol == UAC_VERSION_3 &&\n\t    assoc->bFunctionSubClass == FULL_ADC_3_0) {\n\t\tdev_info(&dev->dev, "No support for full-fledged ADC 3.0 yet!!\\n");\n\t\treturn -EINVAL;\n\t}\n\n\talts = &intf->altsetting[0];\n\tifnum = get_iface_desc(alts)->bInterfaceNumber;\n\tid = USB_ID(le16_to_cpu(dev->descriptor.idVendor),\n\t\t    le16_to_cpu(dev->descriptor.idProduct));\n\tif (get_alias_id(dev, &id))\n\t\tquirk = get_alias_quirk(dev, id);\n\tif (quirk && quirk->ifnum >= 0 && ifnum != quirk->ifnum)\n\t\treturn -ENXIO;\n\n\terr = snd_usb_apply_boot_quirk(dev, intf, quirk, id);\n\tif (err < 0)\n\t\treturn err;\n\n\t/*\n\t * found a config.  now register to ALSA\n\t */\n\n\t/* check whether it\'s already registered */\n\tchip = NULL;\n\tmutex_lock(&register_mutex);\n\tfor (i = 0; i < SNDRV_CARDS; i++) {\n\t\tif (usb_chip[i] && usb_chip[i]->dev == dev) {\n\t\t\tif (atomic_read(&usb_chip[i]->shutdown)) {\n\t\t\t\tdev_err(&dev->dev, "USB device is in the shutdown state, cannot create a card instance\\n");\n\t\t\t\terr = -EIO;\n\t\t\t\tgoto __error;\n\t\t\t}\n\t\t\tchip = usb_chip[i];\n\t\t\tatomic_inc(&chip->active); /* avoid autopm */\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! chip) {\n\t\t/* it\'s a fresh one.\n\t\t * now look for an empty slot and create a new card instance\n\t\t */\n\t\tfor (i = 0; i < SNDRV_CARDS; i++)\n\t\t\tif (enable[i] && ! usb_chip[i] &&\n\t\t\t    (vid[i] == -1 || vid[i] == USB_ID_VENDOR(id)) &&\n\t\t\t    (pid[i] == -1 || pid[i] == USB_ID_PRODUCT(id))) {\n\t\t\t\terr = snd_usb_audio_create(intf, dev, i, quirk,\n\t\t\t\t\t\t\t   &chip);\n\t\t\t\tif (err < 0)\n\t\t\t\t\tgoto __error;\n\t\t\t\tchip->pm_intf = intf;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (!chip) {\n\t\t\tdev_err(&dev->dev, "no available usb audio device\\n");\n\t\t\terr = -ENODEV;\n\t\t\tgoto __error;\n\t\t}\n\t}\n\tdev_set_drvdata(&dev->dev, chip);\n\n\t/*\n\t * For devices with more than one control interface, we assume the\n\t * first contains the audio controls. We might need a more specific\n\t * check here in the future.\n\t */\n\tif (!chip->ctrl_intf)\n\t\tchip->ctrl_intf = alts;\n\n\tchip->txfr_quirk = 0;\n\terr = 1; /* continue */\n\tif (quirk && quirk->ifnum != QUIRK_NO_INTERFACE) {\n\t\t/* need some special handlings */\n\t\terr = snd_usb_create_quirk(chip, intf, &usb_audio_driver, quirk);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\tif (err > 0) {\n\t\t/* create normal USB audio interfaces */\n\t\terr = snd_usb_create_streams(chip, ifnum);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t\terr = snd_usb_create_mixer(chip, ifnum, ignore_ctl_error);\n\t\tif (err < 0)\n\t\t\tgoto __error;\n\t}\n\n\t/* we are allowed to call snd_card_register() many times */\n\terr = snd_card_register(chip->card);\n\tif (err < 0)\n\t\tgoto __error;\n\n\tusb_chip[chip->index] = chip;\n\tchip->num_interfaces++;\n\tusb_set_intfdata(intf, chip);\n\tintf->needs_remote_wakeup = 1;\n\tusb_enable_autosuspend(chip->dev);\n\tatomic_dec(&chip->active);\n\tmutex_unlock(&register_mutex);\n\treturn 0;\n\n __error:\n\tif (chip) {\n\t\t/* chip->active is inside the chip->card object,\n\t\t * decrement before memory is possibly returned.\n\t\t */\n\t\tatomic_dec(&chip->active);\n\t\tif (!chip->num_interfaces)\n\t\t\tsnd_card_free(chip->card);\n\t}\n\tmutex_unlock(&register_mutex);\n\treturn err;\n}'
p904
S'c36d54c34fef'
p905
sssS'CVE-2018-20169'
p906
(dp907
(S'drivers/usb/core/usb.c'
p908
S'__usb_get_extra_descriptor'
p909
tp910
(dp911
S'int __usb_get_extra_descriptor(char *buffer, unsigned size,\n\t\t\t       unsigned char type, void **ptr, size_t minsize)\n{\n\tstruct usb_descriptor_header *header;\n\n\twhile (size >= sizeof(struct usb_descriptor_header)) {\n\t\theader = (struct usb_descriptor_header *)buffer;\n\n\t\tif (header->bLength < 2 || header->bLength > size) {\n\t\t\tprintk(KERN_ERR\n\t\t\t\t"%s: bogus descriptor, type %d length %d\\n",\n\t\t\t\tusbcore_name,\n\t\t\t\theader->bDescriptorType,\n\t\t\t\theader->bLength);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (header->bDescriptorType == type && header->bLength >= minsize) {\n\t\t\t*ptr = header;\n\t\t\treturn 0;\n\t\t}\n\n\t\tbuffer += header->bLength;\n\t\tsize -= header->bLength;\n\t}\n\treturn -1;\n}'
p912
S'c36d54c34fef'
p913
ss(S'drivers/usb/core/hub.c'
p914
S'usb_enumerate_device_otg'
p915
tp916
(dp917
S'static int usb_enumerate_device_otg(struct usb_device *udev)\n{\n\tint err = 0;\n\n#ifdef\tCONFIG_USB_OTG\n\t/*\n\t * OTG-aware devices on OTG-capable root hubs may be able to use SRP,\n\t * to wake us after we\'ve powered off VBUS; and HNP, switching roles\n\t * "host" to "peripheral".  The OTG descriptor helps figure this out.\n\t */\n\tif (!udev->bus->is_b_host\n\t\t\t&& udev->config\n\t\t\t&& udev->parent == udev->bus->root_hub) {\n\t\tstruct usb_otg_descriptor\t*desc = NULL;\n\t\tstruct usb_bus\t\t\t*bus = udev->bus;\n\t\tunsigned\t\t\tport1 = udev->portnum;\n\n\t\t/* descriptor may appear anywhere in config */\n\t\terr = __usb_get_extra_descriptor(udev->rawdescriptors[0],\n\t\t\t\tle16_to_cpu(udev->config[0].desc.wTotalLength),\n\t\t\t\tUSB_DT_OTG, (void **) &desc, sizeof(*desc));\n\t\tif (err || !(desc->bmAttributes & USB_OTG_HNP))\n\t\t\treturn 0;\n\n\t\tdev_info(&udev->dev, "Dual-Role OTG device on %sHNP port\\n",\n\t\t\t\t\t(port1 == bus->otg_port) ? "" : "non-");\n\n\t\t/* enable HNP before suspend, it\'s simpler */\n\t\tif (port1 == bus->otg_port) {\n\t\t\tbus->b_hnp_enable = 1;\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_B_HNP_ENABLE,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0) {\n\t\t\t\t/*\n\t\t\t\t * OTG MESSAGE: report errors here,\n\t\t\t\t * customize to match your product.\n\t\t\t\t */\n\t\t\t\tdev_err(&udev->dev, "can\'t set HNP mode: %d\\n",\n\t\t\t\t\t\t\t\t\terr);\n\t\t\t\tbus->b_hnp_enable = 0;\n\t\t\t}\n\t\t} else if (desc->bLength == sizeof\n\t\t\t\t(struct usb_otg_descriptor)) {\n\t\t\t/* Set a_alt_hnp_support for legacy otg device */\n\t\t\terr = usb_control_msg(udev,\n\t\t\t\tusb_sndctrlpipe(udev, 0),\n\t\t\t\tUSB_REQ_SET_FEATURE, 0,\n\t\t\t\tUSB_DEVICE_A_ALT_HNP_SUPPORT,\n\t\t\t\t0, NULL, 0,\n\t\t\t\tUSB_CTRL_SET_TIMEOUT);\n\t\t\tif (err < 0)\n\t\t\t\tdev_err(&udev->dev,\n\t\t\t\t\t"set a_alt_hnp_support failed: %d\\n",\n\t\t\t\t\terr);\n\t\t}\n\t}\n#endif\n\treturn err;\n}'
p918
S'c36d54c34fef'
p919
ss(S'drivers/usb/host/hwa-hc.c'
p920
S'hwahc_security_create'
p921
tp922
(dp923
S'static int hwahc_security_create(struct hwahc *hwahc)\n{\n\tint result;\n\tstruct wusbhc *wusbhc = &hwahc->wusbhc;\n\tstruct usb_device *usb_dev = hwahc->wa.usb_dev;\n\tstruct device *dev = &usb_dev->dev;\n\tstruct usb_security_descriptor *secd;\n\tstruct usb_encryption_descriptor *etd;\n\tvoid *itr, *top;\n\tsize_t itr_size, needed, bytes;\n\tu8 index;\n\tchar buf[64];\n\n\t/* Find the host\'s security descriptors in the config descr bundle */\n\tindex = (usb_dev->actconfig - usb_dev->config) /\n\t\tsizeof(usb_dev->config[0]);\n\titr = usb_dev->rawdescriptors[index];\n\titr_size = le16_to_cpu(usb_dev->actconfig->desc.wTotalLength);\n\ttop = itr + itr_size;\n\tresult = __usb_get_extra_descriptor(usb_dev->rawdescriptors[index],\n\t\t\tle16_to_cpu(usb_dev->actconfig->desc.wTotalLength),\n\t\t\tUSB_DT_SECURITY, (void **) &secd, sizeof(*secd));\n\tif (result == -1) {\n\t\tdev_warn(dev, "BUG? WUSB host has no security descriptors\\n");\n\t\treturn 0;\n\t}\n\tneeded = sizeof(*secd);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, "BUG? Not enough data to process security "\n\t\t\t"descriptor header (%zu bytes left vs %zu needed)\\n",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\tneeded = le16_to_cpu(secd->wTotalLength);\n\tif (top - (void *)secd < needed) {\n\t\tdev_err(dev, "BUG? Not enough data to process security "\n\t\t\t"descriptors (%zu bytes left vs %zu needed)\\n",\n\t\t\ttop - (void *) secd, needed);\n\t\treturn 0;\n\t}\n\t/* Walk over the sec descriptors and store CCM1\'s on wusbhc */\n\titr = (void *) secd + sizeof(*secd);\n\ttop = (void *) secd + le16_to_cpu(secd->wTotalLength);\n\tindex = 0;\n\tbytes = 0;\n\twhile (itr < top) {\n\t\tetd = itr;\n\t\tif (top - itr < sizeof(*etd)) {\n\t\t\tdev_err(dev, "BUG: bad host security descriptor; "\n\t\t\t\t"not enough data (%zu vs %zu left)\\n",\n\t\t\t\ttop - itr, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\tif (etd->bLength < sizeof(*etd)) {\n\t\t\tdev_err(dev, "BUG: bad host encryption descriptor; "\n\t\t\t\t"descriptor is too short "\n\t\t\t\t"(%zu vs %zu needed)\\n",\n\t\t\t\t(size_t)etd->bLength, sizeof(*etd));\n\t\t\tbreak;\n\t\t}\n\t\titr += etd->bLength;\n\t\tbytes += snprintf(buf + bytes, sizeof(buf) - bytes,\n\t\t\t\t  "%s (0x%02x) ",\n\t\t\t\t  wusb_et_name(etd->bEncryptionType),\n\t\t\t\t  etd->bEncryptionValue);\n\t\twusbhc->ccm1_etd = etd;\n\t}\n\tdev_info(dev, "supported encryption types: %s\\n", buf);\n\tif (wusbhc->ccm1_etd == NULL) {\n\t\tdev_err(dev, "E: host doesn\'t support CCM-1 crypto\\n");\n\t\treturn 0;\n\t}\n\t/* Pretty print what we support */\n\treturn 0;\n}'
p924
S'c36d54c34fef'
p925
sssS'CVE-2018-11823'
p926
(dp927
(S'drivers/cpuidle/lpm-levels-of.c'
p928
S'parse_cpu_levels'
p929
tp930
(dp931
S'static int parse_cpu_levels(struct device_node *node, struct lpm_cluster *c)\n{\n\tint ret;\n\tchar *key;\n\tstruct lpm_cpu *cpu;\n\n\tcpu = devm_kzalloc(&lpm_pdev->dev, sizeof(*cpu), GFP_KERNEL);\n\tif (!cpu)\n\t\treturn -ENOMEM;\n\n\tif (get_cpumask_for_node(node, &cpu->related_cpus))\n\t\treturn -EINVAL;\n\n\tcpu->parent = c;\n\n\tkey = "qcom,psci-mode-shift";\n\tret = of_property_read_u32(node, key, &cpu->psci_mode_shift);\n\tif (ret)\n\t\tgoto failed;\n\n\tkey = "qcom,psci-mode-mask";\n\tret = of_property_read_u32(node, key, &cpu->psci_mode_mask);\n\tif (ret)\n\t\tgoto failed;\n\n\tkey = "qcom,disable-prediction";\n\tcpu->lpm_prediction = !(of_property_read_bool(node, key));\n\n\tif (cpu->lpm_prediction) {\n\t\tkey = "qcom,ref-stddev";\n\t\tret = of_property_read_u32(node, key, &cpu->ref_stddev);\n\t\tif (ret || cpu->ref_stddev < STDDEV_LOW ||\n\t\t\t\t\tcpu->ref_stddev > STDDEV_HIGH)\n\t\t\tcpu->ref_stddev = DEFAULT_STDDEV;\n\n\t\tkey = "qcom,tmr-add";\n\t\tret = of_property_read_u32(node, key, &cpu->tmr_add);\n\t\tif (ret || cpu->tmr_add < TIMER_ADD_LOW ||\n\t\t\t\t\tcpu->tmr_add > TIMER_ADD_HIGH)\n\t\t\tcpu->tmr_add = DEFAULT_TIMER_ADD;\n\n\t\tkey = "qcom,ref-premature-cnt";\n\t\tret = of_property_read_u32(node, key, &cpu->ref_premature_cnt);\n\t\tif (ret || cpu->ref_premature_cnt < PREMATURE_CNT_LOW ||\n\t\t\t\tcpu->ref_premature_cnt > PREMATURE_CNT_HIGH)\n\t\t\tcpu->ref_premature_cnt = DEFAULT_PREMATURE_CNT;\n\t}\n\n\tkey = "parse_cpu";\n\tret = parse_cpu(node, cpu);\n\tif (ret)\n\t\tgoto failed;\n\n\tcpumask_or(&c->child_cpus, &c->child_cpus, &cpu->related_cpus);\n\tlist_add(&cpu->list, &c->cpu);\n\n\treturn ret;\n\nfailed:\n\tpr_err("Failed to read key: %s node: %s\\n", key, node->name);\n\treturn ret;\n}'
p932
S'070aae3337ac'
p933
ss(g928
S'free_cluster_node'
p934
tp935
(dp936
S'void free_cluster_node(struct lpm_cluster *cluster)\n{\n\tstruct lpm_cpu *cpu, *n;\n\tstruct lpm_cluster *cl, *m;\n\n\tlist_for_each_entry_safe(cl, m, &cluster->child, list) {\n\t\tlist_del(&cl->list);\n\t\tfree_cluster_node(cl);\n\t};\n\n\tlist_for_each_entry_safe(cpu, n, &cluster->cpu, list)\n\t\tlist_del(&cpu->list);\n}'
p937
g933
ss(g928
S'parse_cluster'
p938
tp939
(dp940
S'struct lpm_cluster *parse_cluster(struct device_node *node,\n\t\tstruct lpm_cluster *parent)\n{\n\tstruct lpm_cluster *c;\n\tstruct device_node *n;\n\tchar *key;\n\tint ret = 0;\n\tint i, j;\n\n\tc = devm_kzalloc(&lpm_pdev->dev, sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = parse_cluster_params(node, c);\n\tif (ret)\n\t\tgoto failed_parse_params;\n\n\tINIT_LIST_HEAD(&c->list);\n\tINIT_LIST_HEAD(&c->child);\n\tINIT_LIST_HEAD(&c->cpu);\n\tc->parent = parent;\n\tspin_lock_init(&c->sync_lock);\n\tc->min_child_level = NR_LPM_LEVELS;\n\n\tfor_each_child_of_node(node, n) {\n\n\t\tif (!n->name)\n\t\t\tcontinue;\n\n\t\tkey = "qcom,pm-cluster-level";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cluster_level(n, c)) {\n\t\t\t\tof_node_put(n);\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\t}\n\t\t\tof_node_put(n);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cluster";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tstruct lpm_cluster *child;\n\n\t\t\tchild = parse_cluster(n, c);\n\t\t\tif (!child) {\n\t\t\t\tof_node_put(n);\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\t}\n\n\t\t\tlist_add(&child->list, &c->child);\n\t\t\tcpumask_or(&c->child_cpus, &c->child_cpus,\n\t\t\t\t\t&child->child_cpus);\n\t\t\tc->aff_level = child->aff_level + 1;\n\t\t\tof_node_put(n);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cpu";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cpu_levels(n, c)) {\n\t\t\t\tof_node_put(n);\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\t}\n\n\t\t\tc->aff_level = 1;\n\t\t\tof_node_put(n);\n\t\t}\n\t}\n\n\tif (cpumask_intersects(&c->child_cpus, cpu_online_mask))\n\t\tc->last_level = c->default_level;\n\telse\n\t\tc->last_level = c->nlevels-1;\n\n\tfor (i = 0; i < c->nlevels; i++) {\n\t\tfor (j = 0; j < c->nlevels; j++) {\n\t\t\tif (i >= j) {\n\t\t\t\tc->levels[i].pwr.residencies[j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc->levels[i].pwr.residencies[j] = calculate_residency(\n\t\t\t\t&c->levels[i].pwr, &c->levels[j].pwr);\n\t\t}\n\t}\n\tset_optimum_cluster_residency(c, true);\n\treturn c;\n\nfailed_parse_cluster:\n\tpr_err("Failed parse cluster:%s\\n", key);\n\tif (parent)\n\t\tlist_del(&c->list);\n\tfree_cluster_node(c);\nfailed_parse_params:\n\tpr_err("Failed parse params\\n");\n\treturn NULL;\n}'
p941
S'718855ec578d'
p942
sS'struct lpm_cluster *parse_cluster(struct device_node *node,\n\t\tstruct lpm_cluster *parent)\n{\n\tstruct lpm_cluster *c;\n\tstruct device_node *n;\n\tchar *key;\n\tint ret = 0;\n\tint i, j;\n\n\tc = devm_kzalloc(&lpm_pdev->dev, sizeof(*c), GFP_KERNEL);\n\tif (!c)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tret = parse_cluster_params(node, c);\n\tif (ret)\n\t\tgoto failed_parse_params;\n\n\tINIT_LIST_HEAD(&c->list);\n\tINIT_LIST_HEAD(&c->child);\n\tINIT_LIST_HEAD(&c->cpu);\n\tc->parent = parent;\n\tspin_lock_init(&c->sync_lock);\n\tc->min_child_level = NR_LPM_LEVELS;\n\n\tfor_each_child_of_node(node, n) {\n\n\t\tif (!n->name)\n\t\t\tcontinue;\n\n\t\tkey = "qcom,pm-cluster-level";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cluster_level(n, c))\n\t\t\t\tgoto failed_parse_cluster;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cluster";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tstruct lpm_cluster *child;\n\n\t\t\tchild = parse_cluster(n, c);\n\t\t\tif (!child)\n\t\t\t\tgoto failed_parse_cluster;\n\n\t\t\tlist_add(&child->list, &c->child);\n\t\t\tcpumask_or(&c->child_cpus, &c->child_cpus,\n\t\t\t\t\t&child->child_cpus);\n\t\t\tc->aff_level = child->aff_level + 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = "qcom,pm-cpu";\n\t\tif (!of_node_cmp(n->name, key)) {\n\t\t\tif (parse_cpu_levels(n, c))\n\t\t\t\tgoto failed_parse_cluster;\n\n\t\t\tc->aff_level = 1;\n\t\t}\n\t}\n\n\tif (cpumask_intersects(&c->child_cpus, cpu_online_mask))\n\t\tc->last_level = c->default_level;\n\telse\n\t\tc->last_level = c->nlevels-1;\n\n\tfor (i = 0; i < c->nlevels; i++) {\n\t\tfor (j = 0; j < c->nlevels; j++) {\n\t\t\tif (i >= j) {\n\t\t\t\tc->levels[i].pwr.residencies[j] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc->levels[i].pwr.residencies[j] = calculate_residency(\n\t\t\t\t&c->levels[i].pwr, &c->levels[j].pwr);\n\t\t}\n\t}\n\tset_optimum_cluster_residency(c, true);\n\treturn c;\n\nfailed_parse_cluster:\n\tpr_err("Failed parse cluster:%s\\n", key);\n\tif (parent)\n\t\tlist_del(&c->list);\n\tfree_cluster_node(c);\nfailed_parse_params:\n\tpr_err("Failed parse params\\n");\n\treturn NULL;\n}'
p943
g933
sssS'CVE-2019-2279'
p944
(dp945
(S'drivers/media/platform/msm/vidc/venus_hfi.c'
p946
S'__write_queue'
p947
tp948
(dp949
S'static int __write_queue(struct vidc_iface_q_info *qinfo, u8 *packet,\n\t\tbool *rx_req_is_set)\n{\n\tstruct hfi_queue_header *queue;\n\tu32 packet_size_in_words, new_write_idx;\n\tu32 empty_space, read_idx, write_idx;\n\tu32 *write_ptr;\n\n\tif (!qinfo || !packet) {\n\t\tdprintk(VIDC_ERR, "Invalid Params\\n");\n\t\treturn -EINVAL;\n\t} else if (!qinfo->q_array.align_virtual_addr) {\n\t\tdprintk(VIDC_WARN, "Queues have already been freed\\n");\n\t\treturn -EINVAL;\n\t}\n\n\tqueue = (struct hfi_queue_header *) qinfo->q_hdr;\n\tif (!queue) {\n\t\tdprintk(VIDC_ERR, "queue not present\\n");\n\t\treturn -ENOENT;\n\t}\n\n\tif (msm_vidc_debug & VIDC_PKT) {\n\t\tdprintk(VIDC_PKT, "%s: %pK\\n", __func__, qinfo);\n\t\t__dump_packet(packet, VIDC_PKT);\n\t}\n\n\tpacket_size_in_words = (*(u32 *)packet) >> 2;\n\tif (!packet_size_in_words || packet_size_in_words >\n\t\tqinfo->q_array.mem_size>>2) {\n\t\tdprintk(VIDC_ERR, "Invalid packet size\\n");\n\t\treturn -ENODATA;\n\t}\n\n\tread_idx = queue->qhdr_read_idx;\n\twrite_idx = queue->qhdr_write_idx;\n\n\tempty_space = (write_idx >=  read_idx) ?\n\t\t((qinfo->q_array.mem_size>>2) - (write_idx -  read_idx)) :\n\t\t(read_idx - write_idx);\n\tif (empty_space <= packet_size_in_words) {\n\t\tqueue->qhdr_tx_req =  1;\n\t\tdprintk(VIDC_ERR, "Insufficient size (%d) to write (%d)\\n",\n\t\t\t\t\t  empty_space, packet_size_in_words);\n\t\treturn -ENOTEMPTY;\n\t}\n\n\tqueue->qhdr_tx_req =  0;\n\n\tnew_write_idx = write_idx + packet_size_in_words;\n\twrite_ptr = (u32 *)((qinfo->q_array.align_virtual_addr) +\n\t\t\t(write_idx << 2));\n\tif (write_ptr < (u32 *)qinfo->q_array.align_virtual_addr ||\n\t    write_ptr > (u32 *)(qinfo->q_array.align_virtual_addr +\n\t    qinfo->q_array.mem_size)) {\n\t\tdprintk(VIDC_ERR, "Invalid write index");\n\t\treturn -ENODATA;\n\t}\n\n\tif (new_write_idx < (qinfo->q_array.mem_size >> 2)) {\n\t\tmemcpy(write_ptr, packet, packet_size_in_words << 2);\n\t} else {\n\t\tnew_write_idx -= qinfo->q_array.mem_size >> 2;\n\t\tmemcpy(write_ptr, packet, (packet_size_in_words -\n\t\t\tnew_write_idx) << 2);\n\t\tmemcpy((void *)qinfo->q_array.align_virtual_addr,\n\t\t\tpacket + ((packet_size_in_words - new_write_idx) << 2),\n\t\t\tnew_write_idx  << 2);\n\t}\n\n\t/*\n\t * Memory barrier to make sure packet is written before updating the\n\t * write index\n\t */\n\tmb();\n\tqueue->qhdr_write_idx = new_write_idx;\n\tif (rx_req_is_set)\n\t\t*rx_req_is_set = queue->qhdr_rx_req == 1;\n\t/*\n\t * Memory barrier to make sure write index is updated before an\n\t * interrupt is raised on venus.\n\t */\n\tmb();\n\treturn 0;\n}'
p950
S'774fe2ef649e'
p951
ss(g946
S'__read_queue'
p952
tp953
(dp954
S'static int __read_queue(struct vidc_iface_q_info *qinfo, u8 *packet,\n\t\tu32 *pb_tx_req_is_set)\n{\n\tstruct hfi_queue_header *queue;\n\tu32 packet_size_in_words, new_read_idx;\n\tu32 *read_ptr;\n\tu32 receive_request = 0;\n\tu32 read_idx, write_idx;\n\tint rc = 0;\n\n\tif (!qinfo || !packet || !pb_tx_req_is_set) {\n\t\tdprintk(VIDC_ERR, "Invalid Params\\n");\n\t\treturn -EINVAL;\n\t} else if (!qinfo->q_array.align_virtual_addr) {\n\t\tdprintk(VIDC_WARN, "Queues have already been freed\\n");\n\t\treturn -EINVAL;\n\t}\n\n\t/*\n\t * Memory barrier to make sure data is valid before\n\t *reading it\n\t */\n\tmb();\n\tqueue = (struct hfi_queue_header *) qinfo->q_hdr;\n\n\tif (!queue) {\n\t\tdprintk(VIDC_ERR, "Queue memory is not allocated\\n");\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * Do not set receive request for debug queue, if set,\n\t * Venus generates interrupt for debug messages even\n\t * when there is no response message available.\n\t * In general debug queue will not become full as it\n\t * is being emptied out for every interrupt from Venus.\n\t * Venus will anyway generates interrupt if it is full.\n\t */\n\tif (queue->qhdr_type & HFI_Q_ID_CTRL_TO_HOST_MSG_Q)\n\t\treceive_request = 1;\n\n\tread_idx = queue->qhdr_read_idx;\n\twrite_idx = queue->qhdr_write_idx;\n\n\tif (read_idx == write_idx) {\n\t\tqueue->qhdr_rx_req = receive_request;\n\t\t/*\n\t\t * mb() to ensure qhdr is updated in main memory\n\t\t * so that venus reads the updated header values\n\t\t */\n\t\tmb();\n\t\t*pb_tx_req_is_set = 0;\n\t\tdprintk(VIDC_DBG,\n\t\t\t"%s queue is empty, rx_req = %u, tx_req = %u, read_idx = %u\\n",\n\t\t\treceive_request ? "message" : "debug",\n\t\t\tqueue->qhdr_rx_req, queue->qhdr_tx_req,\n\t\t\tqueue->qhdr_read_idx);\n\t\treturn -ENODATA;\n\t}\n\n\tread_ptr = (u32 *)((qinfo->q_array.align_virtual_addr) +\n\t\t\t\t(read_idx << 2));\n\tif (read_ptr < (u32 *)qinfo->q_array.align_virtual_addr ||\n\t    read_ptr > (u32 *)(qinfo->q_array.align_virtual_addr +\n\t    qinfo->q_array.mem_size - sizeof(*read_ptr))) {\n\t\tdprintk(VIDC_ERR, "Invalid read index\\n");\n\t\treturn -ENODATA;\n\t}\n\n\tpacket_size_in_words = (*read_ptr) >> 2;\n\tif (!packet_size_in_words) {\n\t\tdprintk(VIDC_ERR, "Zero packet size\\n");\n\t\treturn -ENODATA;\n\t}\n\n\tnew_read_idx = read_idx + packet_size_in_words;\n\tif (((packet_size_in_words << 2) <= VIDC_IFACEQ_VAR_HUGE_PKT_SIZE) &&\n\t\tread_idx <= (qinfo->q_array.mem_size >> 2)) {\n\t\tif (new_read_idx < (qinfo->q_array.mem_size >> 2)) {\n\t\t\tmemcpy(packet, read_ptr,\n\t\t\t\t\tpacket_size_in_words << 2);\n\t\t} else {\n\t\t\tnew_read_idx -= (qinfo->q_array.mem_size >> 2);\n\t\t\tmemcpy(packet, read_ptr,\n\t\t\t(packet_size_in_words - new_read_idx) << 2);\n\t\t\tmemcpy(packet + ((packet_size_in_words -\n\t\t\t\t\tnew_read_idx) << 2),\n\t\t\t\t\t(u8 *)qinfo->q_array.align_virtual_addr,\n\t\t\t\t\tnew_read_idx << 2);\n\t\t}\n\t} else {\n\t\tdprintk(VIDC_WARN,\n\t\t\t"BAD packet received, read_idx: %#x, pkt_size: %d\\n",\n\t\t\tread_idx, packet_size_in_words << 2);\n\t\tdprintk(VIDC_WARN, "Dropping this packet\\n");\n\t\tnew_read_idx = write_idx;\n\t\trc = -ENODATA;\n\t}\n\n\tif (new_read_idx != write_idx)\n\t\tqueue->qhdr_rx_req = 0;\n\telse\n\t\tqueue->qhdr_rx_req = receive_request;\n\n\tqueue->qhdr_read_idx = new_read_idx;\n\t/*\n\t * mb() to ensure qhdr is updated in main memory\n\t * so that venus reads the updated header values\n\t */\n\tmb();\n\n\t*pb_tx_req_is_set = (queue->qhdr_tx_req == 1) ? 1 : 0;\n\n\tif ((msm_vidc_debug & VIDC_PKT) &&\n\t\t!(queue->qhdr_type & HFI_Q_ID_CTRL_TO_HOST_DEBUG_Q)) {\n\t\tdprintk(VIDC_PKT, "%s: %pK\\n", __func__, qinfo);\n\t\t__dump_packet(packet, VIDC_PKT);\n\t}\n\n\treturn rc;\n}'
p955
g951
sssS'CVE-2019-10571'
p956
(dp957
(S'drivers/gpu/msm/adreno_snapshot.c'
p958
S'kgsl_snapshot_push_object'
p959
tp960
(dp961
S'void kgsl_snapshot_push_object(struct kgsl_process_private *process,\n\tuint64_t gpuaddr, uint64_t dwords)\n{\n\tint index;\n\tstruct kgsl_mem_entry *entry;\n\n\tif (process == NULL)\n\t\treturn;\n\n\t/*\n\t * Sometimes IBs can be reused in the same dump.  Because we parse from\n\t * oldest to newest, if we come across an IB that has already been used,\n\t * assume that it has been reused and update the list with the newest\n\t * size.\n\t */\n\n\tfor (index = 0; index < objbufptr; index++) {\n\t\tif (objbuf[index].gpuaddr == gpuaddr &&\n\t\t\tobjbuf[index].entry->priv == process) {\n\t\t\t/*\n\t\t\t * Check if newly requested size is within the\n\t\t\t * allocated range or not, otherwise continue\n\t\t\t * with previous size.\n\t\t\t */\n\t\t\tif (!kgsl_gpuaddr_in_memdesc(\n\t\t\t\t&objbuf[index].entry->memdesc,\n\t\t\t\tgpuaddr, dwords << 2)) {\n\t\t\t\tKGSL_CORE_ERR(\n\t\t\t\t\t"snapshot: IB 0x%016llx size is not within the memdesc range\\n",\n\t\t\t\t\tgpuaddr);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tobjbuf[index].size = max_t(uint64_t,\n\t\t\t\t\t\tobjbuf[index].size,\n\t\t\t\t\t\tdwords << 2);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (objbufptr == SNAPSHOT_OBJ_BUFSIZE) {\n\t\tKGSL_CORE_ERR("snapshot: too many snapshot objects\\n");\n\t\treturn;\n\t}\n\n\tentry = kgsl_sharedmem_find(process, gpuaddr);\n\tif (entry == NULL) {\n\t\tKGSL_CORE_ERR("snapshot: Can\'t find entry for 0x%016llX\\n",\n\t\t\tgpuaddr);\n\t\treturn;\n\t}\n\n\tif (!kgsl_gpuaddr_in_memdesc(&entry->memdesc, gpuaddr, dwords << 2)) {\n\t\tKGSL_CORE_ERR("snapshot: Mem entry 0x%016llX is too small\\n",\n\t\t\tgpuaddr);\n\t\tkgsl_mem_entry_put(entry);\n\t\treturn;\n\t}\n\n\t/* Put it on the list of things to parse */\n\tobjbuf[objbufptr].gpuaddr = gpuaddr;\n\tobjbuf[objbufptr].size = dwords << 2;\n\tobjbuf[objbufptr++].entry = entry;\n}'
p962
S'2851bf7e6847'
p963
sssS'CVE-2017-16939'
p964
(dp965
(S'net/xfrm/xfrm_user.c'
p966
S'xfrm_user_rcv_msg'
p967
tp968
(dp969
S'static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -EOPNOTSUPP;\n#endif\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}'
p970
S'f79dd42b805d'
p971
sS'static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.start = link->start,\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}'
p972
S'7bb76790999d'
p973
ss(g966
S'xfrm_dump_policy'
p974
tp975
(dp976
S'static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct xfrm_dump_info info;\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}'
p977
g971
ss(g966
S'xfrm_dump_policy_start'
p978
tp979
(dp980
S'static int xfrm_dump_policy_start(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\n\tBUILD_BUG_ON(sizeof(*walk) > sizeof(cb->args));\n\n\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\treturn 0;\n}'
p981
g971
ss(g966
S'xfrm_dump_policy_done'
p982
tp983
(dp984
S'static int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb->args;\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}'
p985
g971
sssS'CVE-2018-11988'
p986
(dp987
(S'drivers/misc/qseecom.c'
p988
S'qseecom_remove'
p989
tp990
(dp991
S'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle) {\n\t\t\tlist_del(&kclient->list);\n\t\t\tkzfree(kclient);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tkthread_stop(qseecom.unload_app_kthread_task);\n\n\tkthread_stop(qseecom.unregister_lsnr_kthread_task);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p992
S'7bb76790999d'
p993
sS'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle) {\n\t\t\tlist_del(&kclient->list);\n\t\t\tkzfree(kclient);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tkthread_stop(qseecom.unregister_lsnr_kthread_task);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p994
S'de6abb23dc05'
p995
sS'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle)\n\t\t\tgoto exit_free_kclient;\n\n\t\tif (list_empty(&kclient->list))\n\t\t\tgoto exit_free_kc_handle;\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\nexit_free_kc_handle:\n\tkzfree(kclient->handle);\nexit_free_kclient:\n\tkzfree(kclient);\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p996
S'9929f59dd21f'
p997
sS'static int qseecom_remove(struct platform_device *pdev)\n{\n\tstruct qseecom_registered_kclient_list *kclient = NULL;\n\tstruct qseecom_registered_kclient_list *kclient_tmp = NULL;\n\tunsigned long flags = 0;\n\tint ret = 0;\n\tint i;\n\tstruct qseecom_ce_pipe_entry *pce_entry;\n\tstruct qseecom_ce_info_use *pce_info_use;\n\n\tatomic_set(&qseecom.qseecom_state, QSEECOM_STATE_NOT_READY);\n\tspin_lock_irqsave(&qseecom.registered_kclient_list_lock, flags);\n\n\tlist_for_each_entry_safe(kclient, kclient_tmp,\n\t\t&qseecom.registered_kclient_list_head, list) {\n\n\t\t/* Break the loop if client handle is NULL */\n\t\tif (!kclient->handle) {\n\t\t\tlist_del(&kclient->list);\n\t\t\tkzfree(kclient);\n\t\t\tbreak;\n\t\t}\n\n\t\tlist_del(&kclient->list);\n\t\tmutex_lock(&app_access_lock);\n\t\tret = qseecom_unload_app(kclient->handle->dev, false);\n\t\tmutex_unlock(&app_access_lock);\n\t\tif (!ret) {\n\t\t\tkzfree(kclient->handle->dev);\n\t\t\tkzfree(kclient->handle);\n\t\t\tkzfree(kclient);\n\t\t}\n\t}\n\n\tspin_unlock_irqrestore(&qseecom.registered_kclient_list_lock, flags);\n\n\tif (qseecom.qseos_version > QSEEE_VERSION_00)\n\t\tqseecom_unload_commonlib_image();\n\n\tif (qseecom.qsee_perf_client)\n\t\tmsm_bus_scale_client_update_request(qseecom.qsee_perf_client,\n\t\t\t\t\t\t\t\t\t0);\n\tif (pdev->dev.platform_data != NULL)\n\t\tmsm_bus_scale_unregister_client(qseecom.qsee_perf_client);\n\n\tif (qseecom.support_bus_scaling) {\n\t\tcancel_work_sync(&qseecom.bw_inactive_req_ws);\n\t\tdel_timer_sync(&qseecom.bw_scale_down_timer);\n\t}\n\n\tif (qseecom.ce_info.fde) {\n\t\tpce_info_use = qseecom.ce_info.fde;\n\t\tfor (i = 0; i < qseecom.ce_info.num_fde; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.fde);\n\tif (qseecom.ce_info.pfe) {\n\t\tpce_info_use = qseecom.ce_info.pfe;\n\t\tfor (i = 0; i < qseecom.ce_info.num_pfe; i++) {\n\t\t\tpce_entry = pce_info_use->ce_pipe_entry;\n\t\t\tkfree(pce_entry);\n\t\t\tpce_info_use++;\n\t\t}\n\t}\n\tkfree(qseecom.ce_info.pfe);\n\n\t/* register client for bus scaling */\n\tif (pdev->dev.of_node) {\n\t\t__qseecom_deinit_clk(CLK_QSEE);\n\t\tif ((qseecom.qsee.instance != qseecom.ce_drv.instance) &&\n\t\t\t\t(qseecom.support_pfe || qseecom.support_fde))\n\t\t\t__qseecom_deinit_clk(CLK_CE_DRV);\n\t}\n\n\tion_client_destroy(qseecom.ion_clnt);\n\n\tcdev_del(&qseecom.cdev);\n\n\tdevice_destroy(driver_class, qseecom_device_no);\n\n\tclass_destroy(driver_class);\n\n\tunregister_chrdev_region(qseecom_device_no, 1);\n\n\treturn ret;\n}'
p998
S'fc401b6a91af'
p999
sssS'CVE-2018-13893'
p1000
(dp1001
(S'drivers/char/diag/diagchar_core.c'
p1002
S'diag_md_session_exit'
p1003
tp1004
(dp1005
S'static void diag_md_session_exit(void)\n{\n\tint i;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i]) {\n\t\t\tsession_info = driver->md_session_map[i];\n\t\t\tdiag_log_mask_free(session_info->log_mask);\n\t\t\tkfree(session_info->log_mask);\n\t\t\tsession_info->log_mask = NULL;\n\t\t\tdiag_msg_mask_free(session_info->msg_mask,\n\t\t\t\tsession_info);\n\t\t\tkfree(session_info->msg_mask);\n\t\t\tsession_info->msg_mask = NULL;\n\t\t\tdiag_event_mask_free(session_info->event_mask);\n\t\t\tkfree(session_info->event_mask);\n\t\t\tsession_info->event_mask = NULL;\n\t\t\tkfree(session_info);\n\t\t\tsession_info = NULL;\n\t\t\tdriver->md_session_map[i] = NULL;\n\t\t}\n\t}\n\tmutex_destroy(&driver->md_session_lock);\n\tdriver->md_session_mask = 0;\n\tdriver->md_session_mode = DIAG_MD_NONE;\n}'
p1006
S'57d3486c6e7a'
p1007
ss(S'drivers/char/diag/diag_masks.c'
p1008
S'diag_cmd_get_msg_mask'
p1009
tp1010
(dp1011
S'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p1012
S'57d3486c6e7a'
p1013
sS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p1014
S'a77c16d4981b'
p1015
sS'static int diag_cmd_get_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint32_t mask_size = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_build_mask_req_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info || (src_len < sizeof(struct diag_build_mask_req_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\treq = (struct diag_build_mask_req_t *)src_buf;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = MSG_STATUS_FAIL;\n\trsp.padding = 0;\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_last_tools)) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_size = mask->range * sizeof(uint32_t);\n\t\t/* Copy msg mask only till the end of the rsp buffer */\n\t\tif (mask_size + sizeof(rsp) > dest_len)\n\t\t\tmask_size = dest_len - sizeof(rsp);\n\t\tmemcpy(dest_buf + sizeof(rsp), mask->ptr, mask_size);\n\t\twrite_len += mask_size;\n\t\trsp.status = MSG_STATUS_SUCCESS;\n\t\tbreak;\n\t}\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p1016
S'9393739f2aa4'
p1017
ss(g1008
S'diag_event_mask_copy'
p1018
tp1019
(dp1020
S'int diag_event_mask_copy(struct diag_mask_info *dest,\n\t\t\t struct diag_mask_info *src)\n{\n\tint err = 0;\n\n\tif (!src || !dest)\n\t\treturn -EINVAL;\n\n\tmutex_init(&dest->lock);\n\terr = __diag_mask_init(dest, EVENT_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&dest->lock);\n\tdest->mask_len = src->mask_len;\n\tdest->status = src->status;\n\tmemcpy(dest->ptr, src->ptr, dest->mask_len);\n\tmutex_unlock(&dest->lock);\n\n\treturn err;\n}'
p1021
g1013
ss(g1002
S'diag_md_session_create'
p1022
tp1023
(dp1024
S'int diag_md_session_create(int mode, int peripheral_mask, int proc)\n{\n\tint i;\n\tint err = 0;\n\tstruct diag_md_session_t *new_session = NULL;\n\n\t/*\n\t * If a session is running with a peripheral mask and a new session\n\t * request comes in with same peripheral mask value then return\n\t * invalid param\n\t */\n\tif (driver->md_session_mode == DIAG_MD_PERIPHERAL &&\n\t    (driver->md_session_mask & peripheral_mask) != 0)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tnew_session = kzalloc(sizeof(struct diag_md_session_t), GFP_KERNEL);\n\tif (!new_session) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -ENOMEM;\n\t}\n\tnew_session->peripheral_mask = 0;\n\tnew_session->pid = current->tgid;\n\tnew_session->task = current;\n\tnew_session->log_mask = kzalloc(sizeof(struct diag_mask_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_session->log_mask) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_peripheral;\n\t}\n\tnew_session->event_mask = kzalloc(sizeof(struct diag_mask_info),\n\t\t\t\t\t  GFP_KERNEL);\n\tif (!new_session->event_mask) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_peripheral;\n\t}\n\tnew_session->msg_mask = kzalloc(sizeof(struct diag_mask_info),\n\t\t\t\t\tGFP_KERNEL);\n\tif (!new_session->msg_mask) {\n\t\terr = -ENOMEM;\n\t\tgoto fail_peripheral;\n\t}\n\n\terr = diag_log_mask_copy(new_session->log_mask, &log_mask);\n\tif (err) {\n\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t "return value of log copy. err %d\\n", err);\n\t\tgoto fail_peripheral;\n\t}\n\terr = diag_event_mask_copy(new_session->event_mask, &event_mask);\n\tif (err) {\n\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t "return value of event copy. err %d\\n", err);\n\t\tgoto fail_peripheral;\n\t}\n\tnew_session->msg_mask_tbl_count = 0;\n\terr = diag_msg_mask_copy(new_session, new_session->msg_mask,\n\t\t&msg_mask);\n\tif (err) {\n\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t "return value of msg copy. err %d\\n", err);\n\t\tgoto fail_peripheral;\n\t}\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif ((MD_PERIPHERAL_MASK(i) & peripheral_mask) == 0)\n\t\t\tcontinue;\n\t\tif (driver->md_session_map[i] != NULL) {\n\t\t\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t\t\t "another instance present for %d\\n", i);\n\t\t\terr = -EEXIST;\n\t\t\tgoto fail_peripheral;\n\t\t}\n\t\tnew_session->peripheral_mask |= MD_PERIPHERAL_MASK(i);\n\t\tdriver->md_session_map[i] = new_session;\n\t\tdriver->md_session_mask |= MD_PERIPHERAL_MASK(i);\n\t}\n\tsetup_timer(&new_session->hdlc_reset_timer,\n\t\tdiag_md_hdlc_reset_timer_func,\n\t\tnew_session->pid);\n\n\tdriver->md_session_mode = DIAG_MD_PERIPHERAL;\n\tmutex_unlock(&driver->md_session_lock);\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE,\n\t\t "created session in peripheral mode\\n");\n\treturn 0;\n\nfail_peripheral:\n\tdiag_log_mask_free(new_session->log_mask);\n\tkfree(new_session->log_mask);\n\tnew_session->log_mask = NULL;\n\tdiag_event_mask_free(new_session->event_mask);\n\tkfree(new_session->event_mask);\n\tnew_session->event_mask = NULL;\n\tdiag_msg_mask_free(new_session->msg_mask,\n\t\tnew_session);\n\tkfree(new_session->msg_mask);\n\tnew_session->msg_mask = NULL;\n\tkfree(new_session);\n\tnew_session = NULL;\n\tmutex_unlock(&driver->md_session_lock);\n\treturn err;\n}'
p1025
g1007
ss(g1008
S'diag_build_time_mask_init'
p1026
tp1027
(dp1028
S'static int diag_build_time_mask_init(void)\n{\n\tint err = 0;\n\n\t/* There is no need for update buffer for Build Time masks */\n\tmutex_init(&msg_bt_mask.lock);\n\terr = __diag_mask_init(&msg_bt_mask, MSG_MASK_SIZE, 0);\n\tif (err)\n\t\treturn err;\n\terr = diag_create_build_time_mask();\n\tif (err) {\n\t\tpr_err("diag: Unable to create msg build time masks, err: %d\\n",\n\t\t       err);\n\t\treturn err;\n\t}\n\tdriver->build_time_mask = &msg_bt_mask;\n\treturn 0;\n}'
p1029
g1013
ss(g1002
S'diag_md_session_close'
p1030
tp1031
(dp1032
S'static void diag_md_session_close(int pid)\n{\n\tint i;\n\tuint8_t found = 0;\n\tstruct diag_md_session_t *session_info = NULL;\n\n\tsession_info = diag_md_session_get_pid(pid);\n\tif (!session_info)\n\t\treturn;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (driver->md_session_map[i] != session_info)\n\t\t\tcontinue;\n\t\tdriver->md_session_map[i] = NULL;\n\t\tdriver->md_session_mask &= ~session_info->peripheral_mask;\n\t}\n\tdiag_log_mask_free(session_info->log_mask);\n\tkfree(session_info->log_mask);\n\tsession_info->log_mask = NULL;\n\tdiag_msg_mask_free(session_info->msg_mask,\n\t\tsession_info);\n\tkfree(session_info->msg_mask);\n\tsession_info->msg_mask = NULL;\n\tdiag_event_mask_free(session_info->event_mask);\n\tkfree(session_info->event_mask);\n\tsession_info->event_mask = NULL;\n\tdel_timer(&session_info->hdlc_reset_timer);\n\n\tfor (i = 0; i < NUM_MD_SESSIONS && !found; i++) {\n\t\tif (driver->md_session_map[i] != NULL)\n\t\t\tfound = 1;\n\t}\n\n\tdriver->md_session_mode = (found) ? DIAG_MD_PERIPHERAL : DIAG_MD_NONE;\n\tkfree(session_info);\n\tsession_info = NULL;\n\tDIAG_LOG(DIAG_DEBUG_USERSPACE, "cleared up session\\n");\n}'
p1033
g1007
ss(g1008
S'diag_msg_mask_copy'
p1034
tp1035
(dp1036
S'int diag_msg_mask_copy(struct diag_md_session_t *new_session,\n\tstruct diag_mask_info *dest, struct diag_mask_info *src)\n{\n\tint i, err = 0, mask_size = 0;\n\tstruct diag_msg_mask_t *src_mask = NULL;\n\tstruct diag_msg_mask_t *dest_mask = NULL;\n\tstruct diag_ssid_range_t range;\n\n\tif (!src || !dest)\n\t\treturn -EINVAL;\n\n\tmutex_init(&dest->lock);\n\tmutex_lock(&dest->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tnew_session->msg_mask_tbl_count =\n\t\tdriver->msg_mask_tbl_count;\n\terr = __diag_mask_init(dest,\n\t\t(new_session->msg_mask_tbl_count *\n\t\tsizeof(struct diag_msg_mask_t)), APPS_BUF_SIZE);\n\tif (err) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&dest->lock);\n\t\treturn err;\n\t}\n\tsrc_mask = (struct diag_msg_mask_t *)src->ptr;\n\tdest_mask = (struct diag_msg_mask_t *)dest->ptr;\n\n\tdest->mask_len = src->mask_len;\n\tdest->status = src->status;\n\tfor (i = 0; i < new_session->msg_mask_tbl_count; i++) {\n\t\trange.ssid_first = src_mask->ssid_first;\n\t\trange.ssid_last = src_mask->ssid_last;\n\t\terr = diag_create_msg_mask_table_entry(dest_mask, &range);\n\t\tif (err)\n\t\t\tbreak;\n\t\tif (src_mask->range_tools < dest_mask->range)\n\t\t\tmask_size = src_mask->range_tools * sizeof(uint32_t);\n\t\telse\n\t\t\tmask_size = dest_mask->range * sizeof(uint32_t);\n\t\tmemcpy(dest_mask->ptr, src_mask->ptr, mask_size);\n\t\tsrc_mask++;\n\t\tdest_mask++;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&dest->lock);\n\treturn err;\n}'
p1037
g1013
ss(g1008
S'diag_cmd_get_ssid_range'
p1038
tp1039
(dp1040
S'static int diag_cmd_get_ssid_range(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i;\n\tint write_len = 0;\n\tuint8_t msg_mask_tbl_count = 0;\n\tstruct diag_msg_mask_t *mask_ptr = NULL;\n\tstruct diag_msg_ssid_query_t rsp;\n\tstruct diag_ssid_range_t ssid_range;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\tif (!diag_apps_responds()) {\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn 0;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\tdriver->msg_mask_tbl_count;\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_GET_SSID_RANGE;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.count = msg_mask_tbl_count;\n\tmemcpy(dest_buf, &rsp, sizeof(rsp));\n\twrite_len += sizeof(rsp);\n\tmask_ptr = (struct diag_msg_mask_t *)mask_info->ptr;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask_ptr++) {\n\t\tif (write_len + sizeof(ssid_range) > dest_len) {\n\t\t\tpr_err("diag: In %s, Truncating response due to size limitations of rsp buffer\\n",\n\t\t\t       __func__);\n\t\t\tbreak;\n\t\t}\n\t\tssid_range.ssid_first = mask_ptr->ssid_first;\n\t\tssid_range.ssid_last = mask_ptr->ssid_last_tools;\n\t\tmemcpy(dest_buf + write_len, &ssid_range, sizeof(ssid_range));\n\t\twrite_len += sizeof(ssid_range);\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&driver->md_session_lock);\n\treturn write_len;\n}'
p1041
g1013
ss(g1008
S'diag_send_msg_mask_update'
p1042
tp1043
(dp1044
S'static void diag_send_msg_mask_update(uint8_t peripheral, int first, int last)\n{\n\tint i, err = 0, temp_len = 0;\n\tint header_len = sizeof(struct diag_ctrl_msg_mask);\n\tuint8_t *buf = NULL, *temp = NULL;\n\tuint8_t upd = 0;\n\tuint8_t msg_mask_tbl_count_local = 0;\n\tuint32_t mask_size = 0, pd_mask = 0;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_ctrl_msg_mask header;\n\tstruct diagfwd_info *fwd_info = NULL;\n\tstruct diag_md_session_t *md_session_info = NULL;\n\n\tif (peripheral >= NUM_PERIPHERALS)\n\t\treturn;\n\n\tif (!driver->diagfwd_cntl[peripheral] ||\n\t    !driver->diagfwd_cntl[peripheral]->ch_open) {\n\t\tpr_debug("diag: In %s, control channel is not open, p: %d\\n",\n\t\t\t __func__, peripheral);\n\t\treturn;\n\t}\n\n\tMD_PERIPHERAL_PD_MASK(TYPE_CNTL, peripheral, pd_mask);\n\n\tif (driver->md_session_mask != 0) {\n\t\tif (driver->md_session_mask & MD_PERIPHERAL_MASK(peripheral)) {\n\t\t\tif (driver->md_session_map[peripheral]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[peripheral]->msg_mask;\n\t\t\t\tmd_session_info =\n\t\t\t\t\tdriver->md_session_map[peripheral];\n\t\t\t}\n\t\t} else if (driver->md_session_mask & pd_mask) {\n\t\t\tupd = diag_mask_to_pd_value(driver->md_session_mask);\n\t\t\tif (upd && driver->md_session_map[upd]) {\n\t\t\t\tmask_info =\n\t\t\t\tdriver->md_session_map[upd]->msg_mask;\n\t\t\t\tmd_session_info = driver->md_session_map[upd];\n\t\t\t}\n\t\t} else {\n\t\t\tDIAG_LOG(DIAG_DEBUG_MASKS,\n\t\t\t"asking for mask update with unknown session mask\\n");\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tmask_info = &msg_mask;\n\t}\n\n\tif (!mask_info || !mask_info->ptr || !mask_info->update_buf)\n\t\treturn;\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\treturn;\n\t}\n\tbuf = mask_info->update_buf;\n\tif (md_session_info)\n\t\tmsg_mask_tbl_count_local = md_session_info->msg_mask_tbl_count;\n\telse\n\t\tmsg_mask_tbl_count_local = driver->msg_mask_tbl_count;\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_lock(&mask_info->lock);\n\tswitch (mask_info->status) {\n\tcase DIAG_CTRL_MASK_ALL_DISABLED:\n\t\tmask_size = 0;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_ALL_ENABLED:\n\t\tmask_size = 1;\n\t\tbreak;\n\tcase DIAG_CTRL_MASK_VALID:\n\t\tbreak;\n\tdefault:\n\t\tpr_debug("diag: In %s, invalid status: %d\\n", __func__,\n\t\t\t mask_info->status);\n\t\tgoto err;\n\t}\n\n\tfor (i = 0; i < msg_mask_tbl_count_local; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tmutex_lock(&driver->msg_mask_lock);\n\t\tif (((mask->ssid_first > first) ||\n\t\t\t(mask->ssid_last_tools < last)) && first != ALL_SSID) {\n\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmutex_lock(&mask->lock);\n\t\tif (mask_info->status == DIAG_CTRL_MASK_VALID) {\n\t\t\tmask_size =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp_len = mask_size * sizeof(uint32_t);\n\t\t\tif (temp_len + header_len <= mask_info->update_buf_len)\n\t\t\t\tgoto proceed;\n\t\t\ttemp = krealloc(mask_info->update_buf, temp_len,\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err("diag: In %s, unable to realloc msg_mask update buffer\\n",\n\t\t\t\t       __func__);\n\t\t\t\tmask_size = (mask_info->update_buf_len -\n\t\t\t\t\t    header_len) / sizeof(uint32_t);\n\t\t\t} else {\n\t\t\t\tmask_info->update_buf = temp;\n\t\t\t\tmask_info->update_buf_len = temp_len;\n\t\t\t\tbuf = temp;\n\t\t\t\tpr_debug("diag: In %s, successfully reallocated msg_mask update buffer to len: %d\\n",\n\t\t\t\t\t __func__, mask_info->update_buf_len);\n\t\t\t}\n\t\t} else if (mask_info->status == DIAG_CTRL_MASK_ALL_ENABLED) {\n\t\t\tmask_size = 1;\n\t\t}\nproceed:\n\t\theader.cmd_type = DIAG_CTRL_MSG_F3_MASK;\n\t\theader.status = mask_info->status;\n\t\theader.stream_id = 1;\n\t\theader.msg_mode = 0;\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.msg_mask_size = mask_size;\n\t\tmask_size *= sizeof(uint32_t);\n\t\theader.data_len = MSG_MASK_CTRL_HEADER_LEN + mask_size;\n\t\tmemcpy(buf, &header, header_len);\n\t\tif (mask_size > 0)\n\t\t\tmemcpy(buf + header_len, mask->ptr, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\n\t\terr = diagfwd_write(peripheral, TYPE_CNTL, buf,\n\t\t\t\t    header_len + mask_size);\n\t\tif (err && err != -ENODEV)\n\t\t\tpr_err_ratelimited("diag: Unable to send msg masks to peripheral %d, error = %d\\n",\n\t\t\t       peripheral, err);\n\n\t\tif (first != ALL_SSID)\n\t\t\tbreak;\n\t}\nerr:\n\tmutex_unlock(&mask_info->lock);\n}'
p1045
g1013
ss(g1008
S'diag_log_mask_init'
p1046
tp1047
(dp1048
S'static int diag_log_mask_init(void)\n{\n\tint err = 0, i;\n\n\tmutex_init(&log_mask.lock);\n\terr = __diag_mask_init(&log_mask, LOG_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\terr = diag_create_log_mask_table();\n\tif (err)\n\t\treturn err;\n\tdriver->log_mask = &log_mask;\n\n\tfor (i = 0; i < NUM_PERIPHERALS; i++)\n\t\tdriver->num_equip_id[i] = 0;\n\n\treturn 0;\n}'
p1049
g1013
ss(g1008
S'__diag_mask_init'
p1050
tp1051
(dp1052
S'static int __diag_mask_init(struct diag_mask_info *mask_info, int mask_len,\n\t\t\t    int update_buf_len)\n{\n\tif (!mask_info || mask_len < 0 || update_buf_len < 0)\n\t\treturn -EINVAL;\n\n\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\tmask_info->mask_len = mask_len;\n\tmask_info->update_buf_len = update_buf_len;\n\tif (mask_len > 0) {\n\t\tmask_info->ptr = kzalloc(mask_len, GFP_KERNEL);\n\t\tif (!mask_info->ptr)\n\t\t\treturn -ENOMEM;\n\t\tkmemleak_not_leak(mask_info->ptr);\n\t}\n\tif (update_buf_len > 0) {\n\t\tmask_info->update_buf = kzalloc(update_buf_len, GFP_KERNEL);\n\t\tif (!mask_info->update_buf) {\n\t\t\tkfree(mask_info->ptr);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkmemleak_not_leak(mask_info->update_buf);\n\t}\n\treturn 0;\n}'
p1053
g1013
sS'static int __diag_mask_init(struct diag_mask_info *mask_info, int mask_len,\n\t\t\t    int update_buf_len)\n{\n\tif (!mask_info || mask_len < 0 || update_buf_len < 0)\n\t\treturn -EINVAL;\n\n\tmask_info->status = DIAG_CTRL_MASK_INVALID;\n\tmask_info->mask_len = mask_len;\n\tmask_info->update_buf_len = update_buf_len;\n\tif (mask_len > 0) {\n\t\tmask_info->ptr = kzalloc(mask_len, GFP_KERNEL);\n\t\tif (!mask_info->ptr)\n\t\t\treturn -ENOMEM;\n\t\tkmemleak_not_leak(mask_info->ptr);\n\t}\n\tif (update_buf_len > 0) {\n\t\tmask_info->update_buf = kzalloc(update_buf_len, GFP_KERNEL);\n\t\tif (!mask_info->update_buf) {\n\t\t\tkfree(mask_info->ptr);\n\t\t\tmask_info->ptr = NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tkmemleak_not_leak(mask_info->update_buf);\n\t}\n\treturn 0;\n}'
p1054
S'c36d54c34fef'
p1055
ss(g1008
S'diag_event_mask_init'
p1056
tp1057
(dp1058
S'static int diag_event_mask_init(void)\n{\n\tint err = 0, i;\n\n\tmutex_init(&event_mask.lock);\n\terr = __diag_mask_init(&event_mask, EVENT_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\tdriver->event_mask_size = EVENT_MASK_SIZE;\n\tdriver->last_event_id = APPS_EVENT_LAST_ID;\n\tdriver->event_mask = &event_mask;\n\n\tfor (i = 0; i < NUM_PERIPHERALS; i++)\n\t\tdriver->num_event_id[i] = 0;\n\n\treturn 0;\n}'
p1059
g1013
ss(g1008
S'diag_log_mask_copy'
p1060
tp1061
(dp1062
S'int diag_log_mask_copy(struct diag_mask_info *dest, struct diag_mask_info *src)\n{\n\tint i, err = 0;\n\tstruct diag_log_mask_t *src_mask = NULL;\n\tstruct diag_log_mask_t *dest_mask = NULL;\n\n\tif (!src || !dest)\n\t\treturn -EINVAL;\n\n\tmutex_init(&dest->lock);\n\terr = __diag_mask_init(dest, LOG_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\n\tmutex_lock(&dest->lock);\n\tsrc_mask = (struct diag_log_mask_t *)(src->ptr);\n\tdest_mask = (struct diag_log_mask_t *)(dest->ptr);\n\n\tdest->mask_len = src->mask_len;\n\tdest->status = src->status;\n\n\tfor (i = 0; i < MAX_EQUIP_ID; i++, src_mask++, dest_mask++) {\n\t\tdest_mask->equip_id = src_mask->equip_id;\n\t\tdest_mask->num_items = src_mask->num_items;\n\t\tdest_mask->num_items_tools = src_mask->num_items_tools;\n\t\tmutex_init(&dest_mask->lock);\n\t\tdest_mask->range = src_mask->range;\n\t\tdest_mask->range_tools = src_mask->range_tools;\n\t\tdest_mask->ptr = kzalloc(dest_mask->range_tools, GFP_KERNEL);\n\t\tif (!dest_mask->ptr) {\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tkmemleak_not_leak(dest_mask->ptr);\n\t\tmemcpy(dest_mask->ptr, src_mask->ptr, dest_mask->range_tools);\n\t}\n\tmutex_unlock(&dest->lock);\n\n\treturn err;\n}'
p1063
g1013
ss(g1008
S'diag_cmd_set_all_msg_mask'
p1064
tp1065
(dp1066
S'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_config_rsp_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p1067
g1015
sS'static int diag_cmd_set_all_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tint i, write_len = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_config_rsp_t);\n\tstruct diag_msg_config_rsp_t rsp;\n\tstruct diag_msg_config_rsp_t *req = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_config_rsp_t *)src_buf;\n\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tmask_info->status = (req->rt_mask) ? DIAG_CTRL_MASK_ALL_ENABLED :\n\t\t\t\t\t   DIAG_CTRL_MASK_ALL_DISABLED;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (mask && mask->ptr) {\n\t\t\tmutex_lock(&mask->lock);\n\t\t\tmemset(mask->ptr, req->rt_mask,\n\t\t\t       mask->range * sizeof(uint32_t));\n\t\t\tmutex_unlock(&mask->lock);\n\t\t}\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_ALL_MSG_MASK;\n\trsp.status = MSG_STATUS_SUCCESS;\n\trsp.padding = 0;\n\trsp.rt_mask = req->rt_mask;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, ALL_SSID, ALL_SSID);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\n\n\treturn write_len;\n}'
p1068
g1013
ss(g1008
S'diag_msg_mask_free'
p1069
tp1070
(dp1071
S'void diag_msg_mask_free(struct diag_mask_info *mask_info,\n\tstruct diag_md_session_t *session_info)\n{\n\tint i;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tif (!mask_info || !mask_info->ptr)\n\t\treturn;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\treturn;\n\t}\n\tmsg_mask_tbl_count = (session_info) ?\n\t\tsession_info->msg_mask_tbl_count :\n\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tkfree(mask->ptr);\n\t\tmask->ptr = NULL;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\t__diag_mask_exit(mask_info);\n}'
p1072
g1013
ss(g1008
S'diag_msg_mask_init'
p1073
tp1074
(dp1075
S'static int diag_msg_mask_init(void)\n{\n\tint err = 0, i;\n\n\tmutex_init(&msg_mask.lock);\n\terr = __diag_mask_init(&msg_mask, MSG_MASK_SIZE, APPS_BUF_SIZE);\n\tif (err)\n\t\treturn err;\n\n\terr = diag_create_msg_mask_table();\n\tif (err) {\n\t\tpr_err("diag: Unable to create msg masks, err: %d\\n", err);\n\t\treturn err;\n\t}\n\tmutex_lock(&driver->msg_mask_lock);\n\tdriver->msg_mask = &msg_mask;\n\tfor (i = 0; i < NUM_PERIPHERALS; i++)\n\t\tdriver->max_ssid_count[i] = 0;\n\tmutex_unlock(&driver->msg_mask_lock);\n\n\treturn 0;\n}'
p1076
g1013
ss(g1008
S'diag_copy_to_user_msg_mask'
p1077
tp1078
(dp1079
S'int diag_copy_to_user_msg_mask(char __user *buf, size_t count,\n\t\t\t       struct diag_md_session_t *info)\n{\n\tint i, err = 0, len = 0;\n\tint copy_len = 0, total_len = 0;\n\tstruct diag_msg_mask_userspace_t header;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask = NULL;\n\tunsigned char *ptr = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tif (!buf || count == 0)\n\t\treturn -EINVAL;\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!mask_info)\n\t\treturn -EIO;\n\n\tif (!mask_info->ptr || !mask_info->update_buf) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK, mask_info->update_buf: %pK\\n",\n\t\t\t__func__, mask_info->ptr, mask_info->update_buf);\n\t\treturn -EINVAL;\n\t}\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\n\tmask = (struct diag_msg_mask_t *)(mask_info->ptr);\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tptr = mask_info->update_buf;\n\t\tlen = 0;\n\t\tmutex_lock(&mask->lock);\n\t\theader.ssid_first = mask->ssid_first;\n\t\theader.ssid_last = mask->ssid_last_tools;\n\t\theader.range = mask->range_tools;\n\t\tmemcpy(ptr, &header, sizeof(header));\n\t\tlen += sizeof(header);\n\t\tcopy_len = (sizeof(uint32_t) * mask->range_tools);\n\t\tif ((len + copy_len) > mask_info->update_buf_len) {\n\t\t\tpr_err("diag: In %s, no space to update msg mask, first: %d, last: %d\\n",\n\t\t\t       __func__, mask->ssid_first,\n\t\t\t       mask->ssid_last_tools);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tcontinue;\n\t\t}\n\t\tmemcpy(ptr + len, mask->ptr, copy_len);\n\t\tlen += copy_len;\n\t\tmutex_unlock(&mask->lock);\n\t\t/* + sizeof(int) to account for data_type already in buf */\n\t\tif (total_len + sizeof(int) + len > count) {\n\t\t\tpr_err("diag: In %s, unable to send msg masks to user space, total_len: %d, count: %zu\\n",\n\t\t\t       __func__, total_len, count);\n\t\t\terr = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\terr = copy_to_user(buf + total_len, (void *)ptr, len);\n\t\tif (err) {\n\t\t\tpr_err("diag: In %s Unable to send msg masks to user space clients, err: %d\\n",\n\t\t\t       __func__, err);\n\t\t\tbreak;\n\t\t}\n\t\ttotal_len += len;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\treturn err ? err : total_len;\n}'
p1080
g1013
ss(g1008
S'diag_cmd_set_msg_mask'
p1081
tp1082
(dp1083
S'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p1084
g1015
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || dest_len <= 0 || !mask_info ||\n\t\t(src_len < sizeof(struct diag_msg_build_mask_t))) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tif (mask_size && src_len >= header_len + mask_size)\n\t\t\tmemcpy(mask->ptr + offset, src_buf + header_len,\n\t\t\t\tmask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tif (mask_size && src_len >= header_len + mask_size)\n\t\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p1085
S'7dca8885b04d'
p1086
sS'static int diag_cmd_set_msg_mask(unsigned char *src_buf, int src_len,\n\t\t\tunsigned char *dest_buf, int dest_len, int pid)\n{\n\tuint32_t mask_size = 0, offset = 0;\n\tuint32_t *temp = NULL;\n\tint write_len = 0, i = 0, found = 0, peripheral;\n\tint header_len = sizeof(struct diag_msg_build_mask_t);\n\tstruct diag_msg_mask_t *mask = NULL;\n\tstruct diag_msg_build_mask_t *req = NULL;\n\tstruct diag_msg_build_mask_t rsp;\n\tstruct diag_mask_info *mask_info = NULL;\n\tstruct diag_msg_mask_t *mask_next = NULL;\n\tstruct diag_md_session_t *info = NULL;\n\tuint8_t msg_mask_tbl_count = 0;\n\n\tmutex_lock(&driver->md_session_lock);\n\tinfo = diag_md_session_get_pid(pid);\n\n\tmask_info = (!info) ? &msg_mask : info->msg_mask;\n\tif (!src_buf || !dest_buf || src_len <= 0 || dest_len <= 0 ||\n\t    !mask_info) {\n\t\tpr_err("diag: Invalid input in %s, src_buf: %pK, src_len: %d, dest_buf: %pK, dest_len: %d, mask_info: %pK\\n",\n\t\t       __func__, src_buf, src_len, dest_buf, dest_len,\n\t\t       mask_info);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tif (!mask_info->ptr) {\n\t\tpr_err("diag: In %s, invalid input mask_info->ptr: %pK\\n",\n\t\t\t__func__, mask_info->ptr);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\n\treq = (struct diag_msg_build_mask_t *)src_buf;\n\tmutex_lock(&mask_info->lock);\n\tmutex_lock(&driver->msg_mask_lock);\n\tmask = (struct diag_msg_mask_t *)mask_info->ptr;\n\tif (!mask->ptr) {\n\t\tpr_err("diag: Invalid input in %s, mask->ptr: %pK\\n",\n\t\t\t__func__, mask->ptr);\n\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\tmutex_unlock(&mask_info->lock);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t\treturn -EINVAL;\n\t}\n\tmsg_mask_tbl_count = (info) ? info->msg_mask_tbl_count :\n\t\t\tdriver->msg_mask_tbl_count;\n\tfor (i = 0; i < msg_mask_tbl_count; i++, mask++) {\n\t\tif (!mask->ptr)\n\t\t\tcontinue;\n\t\tif (i < (msg_mask_tbl_count - 1)) {\n\t\t\tmask_next = mask;\n\t\t\tmask_next++;\n\t\t} else\n\t\t\tmask_next = NULL;\n\n\t\tif ((req->ssid_first < mask->ssid_first) ||\n\t\t    (req->ssid_first > mask->ssid_first + MAX_SSID_PER_RANGE) ||\n\t\t    (mask_next && (req->ssid_first >= mask_next->ssid_first))) {\n\t\t\tcontinue;\n\t\t}\n\t\tmask_next = NULL;\n\t\tfound = 1;\n\t\tmutex_lock(&mask->lock);\n\t\tmask_size = req->ssid_last - req->ssid_first + 1;\n\t\tif (mask_size > MAX_SSID_PER_RANGE) {\n\t\t\tpr_warn("diag: In %s, truncating ssid range, %d-%d to max allowed: %d\\n",\n\t\t\t\t__func__, mask->ssid_first, mask->ssid_last,\n\t\t\t\tMAX_SSID_PER_RANGE);\n\t\t\tmask_size = MAX_SSID_PER_RANGE;\n\t\t\tmask->range_tools = MAX_SSID_PER_RANGE;\n\t\t\tmask->ssid_last_tools =\n\t\t\t\tmask->ssid_first + mask->range_tools;\n\t\t}\n\t\tif (req->ssid_last > mask->ssid_last_tools) {\n\t\t\tpr_debug("diag: Msg SSID range mismatch\\n");\n\t\t\tif (mask_size != MAX_SSID_PER_RANGE)\n\t\t\t\tmask->ssid_last_tools = req->ssid_last;\n\t\t\tmask->range_tools =\n\t\t\t\tmask->ssid_last_tools - mask->ssid_first + 1;\n\t\t\ttemp = krealloc(mask->ptr,\n\t\t\t\t\tmask->range_tools * sizeof(uint32_t),\n\t\t\t\t\tGFP_KERNEL);\n\t\t\tif (!temp) {\n\t\t\t\tpr_err_ratelimited("diag: In %s, unable to allocate memory for msg mask ptr, mask_size: %d\\n",\n\t\t\t\t\t\t   __func__, mask_size);\n\t\t\t\tmutex_unlock(&mask->lock);\n\t\t\t\tmutex_unlock(&driver->msg_mask_lock);\n\t\t\t\tmutex_unlock(&mask_info->lock);\n\t\t\t\tmutex_unlock(&driver->md_session_lock);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tmask->ptr = temp;\n\t\t}\n\n\t\toffset = req->ssid_first - mask->ssid_first;\n\t\tif (offset + mask_size > mask->range_tools) {\n\t\t\tpr_err("diag: In %s, Not in msg mask range, mask_size: %d, offset: %d\\n",\n\t\t\t       __func__, mask_size, offset);\n\t\t\tmutex_unlock(&mask->lock);\n\t\t\tbreak;\n\t\t}\n\t\tmask_size = mask_size * sizeof(uint32_t);\n\t\tmemcpy(mask->ptr + offset, src_buf + header_len, mask_size);\n\t\tmutex_unlock(&mask->lock);\n\t\tmask_info->status = DIAG_CTRL_MASK_VALID;\n\t\tbreak;\n\t}\n\tmutex_unlock(&driver->msg_mask_lock);\n\tmutex_unlock(&mask_info->lock);\n\tmutex_unlock(&driver->md_session_lock);\n\tif (diag_check_update(APPS_DATA, pid))\n\t\tdiag_update_userspace_clients(MSG_MASKS_TYPE);\n\n\t/*\n\t * Apps processor must send the response to this command. Frame the\n\t * response.\n\t */\n\trsp.cmd_code = DIAG_CMD_MSG_CONFIG;\n\trsp.sub_cmd = DIAG_CMD_OP_SET_MSG_MASK;\n\trsp.ssid_first = req->ssid_first;\n\trsp.ssid_last = req->ssid_last;\n\trsp.status = found;\n\trsp.padding = 0;\n\tmemcpy(dest_buf, &rsp, header_len);\n\twrite_len += header_len;\n\tif (!found)\n\t\tgoto end;\n\tif (mask_size + write_len > dest_len)\n\t\tmask_size = dest_len - write_len;\n\tmemcpy(dest_buf + write_len, src_buf + header_len, mask_size);\n\twrite_len += mask_size;\n\tfor (i = 0; i < NUM_MD_SESSIONS; i++) {\n\t\tif (i == APPS_DATA)\n\t\t\tcontinue;\n\t\tif (!diag_check_update(i, pid))\n\t\t\tcontinue;\n\t\tif (i > NUM_PERIPHERALS)\n\t\t\tperipheral = diag_search_peripheral_by_pd(i);\n\t\telse\n\t\t\tperipheral = i;\n\t\tmutex_lock(&driver->md_session_lock);\n\t\tdiag_send_msg_mask_update(peripheral, req->ssid_first,\n\t\t\treq->ssid_last);\n\t\tmutex_unlock(&driver->md_session_lock);\n\t}\nend:\n\treturn write_len;\n}'
p1087
g1013
sssS'CVE-2019-10565'
p1088
(dp1089
(S'drivers/media/platform/msm/camera/cam_sensor_module/cam_sensor/cam_sensor_core.c'
p1090
S'cam_sensor_driver_cmd'
p1091
tp1092
(dp1093
S'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif ((s_ctrl->is_probe_succeed == 0) ||\n\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t\t"Not in right state to aquire %d",\n\t\t\t\ts_ctrl->sensor_state);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,\n\t\t\tsizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p1094
S'e8e82015f51d'
p1095
sS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_setting *pu = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tkfree(pu);\n\t\t\t\tkfree(pd);\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tpu = power_info->power_setting;\n\t\tpd = power_info->power_down_setting;\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,\n\t\t\tsizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p1096
S'ea0cb145f495'
p1097
sS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_setting *pu = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tkfree(pu);\n\t\t\t\tkfree(pd);\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tpu = power_info->power_setting;\n\t\tpd = power_info->power_down_setting;\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe Succees,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tkfree(pu);\n\t\t\tkfree(pd);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\t(void __user *) cmd->handle, sizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user((void __user *) cmd->handle, &sensor_cap,\n\t\t\tsizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p1098
S'8eedcc7ff9de'
p1099
sS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif ((s_ctrl->is_probe_succeed == 0) ||\n\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t\t"Not in right state to aquire %d",\n\t\t\t\ts_ctrl->sensor_state);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\tu64_to_user_ptr(cmd->handle),\n\t\t\tsizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p1100
S'f332617ebb03'
p1101
sS'int32_t cam_sensor_driver_cmd(struct cam_sensor_ctrl_t *s_ctrl,\n\tvoid *arg)\n{\n\tint rc = 0;\n\tstruct cam_control *cmd = (struct cam_control *)arg;\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tif (!s_ctrl || !arg) {\n\t\tCAM_ERR(CAM_SENSOR, "s_ctrl is NULL");\n\t\treturn -EINVAL;\n\t}\n\n\tif (cmd->op_code != CAM_SENSOR_PROBE_CMD) {\n\t\tif (cmd->handle_type != CAM_HANDLE_USER_POINTER) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid handle type: %d",\n\t\t\t\tcmd->handle_type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tmutex_lock(&(s_ctrl->cam_sensor_mutex));\n\tswitch (cmd->op_code) {\n\tcase CAM_SENSOR_PROBE_CMD: {\n\t\tif (s_ctrl->is_probe_succeed == 1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Already Sensor Probed in the slot");\n\t\t\tbreak;\n\t\t}\n\n\t\tif (cmd->handle_type ==\n\t\t\tCAM_HANDLE_MEM_HANDLE) {\n\t\t\trc = cam_handle_mem_ptr(cmd->handle, s_ctrl);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Get Buffer Handle Failed");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command Type: %d",\n\t\t\t\t cmd->handle_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerup settings */\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PUP rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Parse and fill vreg params for powerdown settings*/\n\t\trc = msm_camera_fill_vreg_params(\n\t\t\t&s_ctrl->soc_info,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting,\n\t\t\ts_ctrl->sensordata->power_info.power_down_setting_size);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Fail in filling vreg params for PDOWN rc %d",\n\t\t\t\t rc);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Power up and probe sensor */\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "power up failed");\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\t/* Match sensor ID */\n\t\trc = cam_sensor_match_id(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tcam_sensor_power_down(s_ctrl);\n\t\t\tmsleep(20);\n\t\t\tgoto free_power_settings;\n\t\t}\n\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"Probe success,slot:%d,slave_addr:0x%x,sensor_id:0x%x",\n\t\t\ts_ctrl->soc_info.index,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id);\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "fail in Sensor Power Down");\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\t/*\n\t\t * Set probe succeeded flag to 1 so that no other camera shall\n\t\t * probed on this slot\n\t\t */\n\t\ts_ctrl->is_probe_succeed = 1;\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t}\n\t\tbreak;\n\tcase CAM_ACQUIRE_DEV: {\n\t\tstruct cam_sensor_acquire_dev sensor_acq_dev;\n\t\tstruct cam_create_dev_hdl bridge_params;\n\n\t\tif ((s_ctrl->is_probe_succeed == 0) ||\n\t\t\t(s_ctrl->sensor_state != CAM_SENSOR_INIT)) {\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t\t"Not in right state to aquire %d",\n\t\t\t\ts_ctrl->sensor_state);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.device_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Device is already acquired");\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = copy_from_user(&sensor_acq_dev,\n\t\t\tu64_to_user_ptr(cmd->handle),\n\t\t\tsizeof(sensor_acq_dev));\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copying from user");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tbridge_params.session_hdl = sensor_acq_dev.session_handle;\n\t\tbridge_params.ops = &s_ctrl->bridge_intf.ops;\n\t\tbridge_params.v4l2_sub_dev_flag = 0;\n\t\tbridge_params.media_entity_flag = 0;\n\t\tbridge_params.priv = s_ctrl;\n\n\t\tsensor_acq_dev.device_handle =\n\t\t\tcam_create_device_hdl(&bridge_params);\n\t\ts_ctrl->bridge_intf.device_hdl = sensor_acq_dev.device_handle;\n\t\ts_ctrl->bridge_intf.session_hdl = sensor_acq_dev.session_handle;\n\n\t\tCAM_DBG(CAM_SENSOR, "Device Handle: %d",\n\t\t\tsensor_acq_dev.device_handle);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_acq_dev,\n\t\t\tsizeof(struct cam_sensor_acquire_dev))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_up(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power up failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_ACQUIRE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_RELEASE_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to release : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->bridge_intf.link_hdl != -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Device [%d] still active on link 0x%x",\n\t\t\t\ts_ctrl->sensor_state,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EAGAIN;\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\trc = cam_sensor_power_down(s_ctrl);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Sensor Power Down failed");\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\tcam_sensor_release_stream_rsc(s_ctrl);\n\t\tif (s_ctrl->bridge_intf.device_hdl == -1) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid Handles: link hdl: %d device hdl: %d",\n\t\t\t\ts_ctrl->bridge_intf.device_hdl,\n\t\t\t\ts_ctrl->bridge_intf.link_hdl);\n\t\t\trc = -EINVAL;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\t\tif (rc < 0)\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"failed in destroying the device hdl");\n\t\ts_ctrl->bridge_intf.device_hdl = -1;\n\t\ts_ctrl->bridge_intf.link_hdl = -1;\n\t\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\t\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_RELEASE_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t\ts_ctrl->streamon_count = 0;\n\t\ts_ctrl->streamoff_count = 0;\n\t}\n\t\tbreak;\n\tcase CAM_QUERY_CAP: {\n\t\tstruct  cam_sensor_query_cap sensor_cap;\n\n\t\tcam_sensor_query_cap(s_ctrl, &sensor_cap);\n\t\tif (copy_to_user(u64_to_user_ptr(cmd->handle),\n\t\t\t&sensor_cap, sizeof(struct  cam_sensor_query_cap))) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed Copy to User");\n\t\t\trc = -EFAULT;\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tbreak;\n\t}\n\tcase CAM_START_DEV: {\n\t\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) ||\n\t\t\t(s_ctrl->sensor_state == CAM_SENSOR_START)) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to start : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamon_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamon_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMON);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply streamon settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t}\n\t\ts_ctrl->sensor_state = CAM_SENSOR_START;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_START_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_STOP_DEV: {\n\t\tif (s_ctrl->sensor_state != CAM_SENSOR_START) {\n\t\t\trc = -EINVAL;\n\t\t\tCAM_WARN(CAM_SENSOR,\n\t\t\t"Not in right state to stop : %d",\n\t\t\ts_ctrl->sensor_state);\n\t\t\tgoto release_mutex;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.streamoff_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.streamoff_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_STREAMOFF);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"cannot apply streamoff settings");\n\t\t\t}\n\t\t}\n\n\t\tcam_sensor_release_per_frame_resource(s_ctrl);\n\t\ts_ctrl->sensor_state = CAM_SENSOR_ACQUIRE;\n\t\tCAM_INFO(CAM_SENSOR,\n\t\t\t"CAM_STOP_DEV Success, sensor_id:0x%x,sensor_slave_addr:0x%x",\n\t\t\ts_ctrl->sensordata->slave_info.sensor_id,\n\t\t\ts_ctrl->sensordata->slave_info.sensor_slave_addr);\n\t}\n\t\tbreak;\n\tcase CAM_CONFIG_DEV: {\n\t\trc = cam_sensor_i2c_pkt_parse(s_ctrl, arg);\n\t\tif (rc < 0) {\n\t\t\tCAM_ERR(CAM_SENSOR, "Failed CCI Config: %d", rc);\n\t\t\tgoto release_mutex;\n\t\t}\n\t\tif (s_ctrl->i2c_data.init_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.init_settings.request_id == 0)) {\n\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_INITIAL_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.init_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the Init settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->i2c_data.init_settings.request_id = -1;\n\t\t}\n\n\t\tif (s_ctrl->i2c_data.config_settings.is_settings_valid &&\n\t\t\t(s_ctrl->i2c_data.config_settings.request_id == 0)) {\n\t\t\trc = cam_sensor_apply_settings(s_ctrl, 0,\n\t\t\t\tCAM_SENSOR_PACKET_OPCODE_SENSOR_CONFIG);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"cannot apply config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\trc = delete_request(&s_ctrl->i2c_data.config_settings);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail in deleting the config settings");\n\t\t\t\tgoto release_mutex;\n\t\t\t}\n\t\t\ts_ctrl->sensor_state = CAM_SENSOR_CONFIG;\n\t\t\ts_ctrl->i2c_data.config_settings.request_id = -1;\n\t\t}\n\t}\n\t\tbreak;\n\tdefault:\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Opcode: %d", cmd->op_code);\n\t\trc = -EINVAL;\n\t\tgoto release_mutex;\n\t}\n\nrelease_mutex:\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\tmutex_unlock(&(s_ctrl->cam_sensor_mutex));\n\treturn rc;\n}'
p1102
S'a5bdc9ebe5cf'
p1103
ss(S'drivers/media/platform/msm/camera/cam_sensor_module/cam_sensor_utils/cam_sensor_util.c'
p1104
S'cam_sensor_core_power_up'
p1105
tp1106
(dp1107
S'int cam_sensor_core_power_up(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint rc = 0, index = 0, no_gpio = 0, ret = 0, num_vreg, j = 0, i = 0;\n\tint32_t vreg_idx = -1;\n\tstruct cam_sensor_power_setting *power_setting = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid ctrl handle");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(true);\n\n\tret = msm_camera_pinctrl_init(&(ctrl->pinctrl_info), ctrl->dev);\n\tif (ret < 0) {\n\t\t/* Some sensor subdev no pinctrl. */\n\t\tCAM_DBG(CAM_SENSOR, "Initialization of pinctrl failed");\n\t\tctrl->cam_pinctrl_status = 0;\n\t} else {\n\t\tctrl->cam_pinctrl_status = 1;\n\t}\n\n\tif (cam_res_mgr_shared_pinctrl_init()) {\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to init shared pinctrl");\n\t\treturn -EINVAL;\n\t}\n\n\trc = cam_sensor_util_request_gpio_table(soc_info, 1);\n\tif (rc < 0)\n\t\tno_gpio = rc;\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\tctrl->pinctrl_info.gpio_state_active);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to active state");\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_select_state(true);\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Cannot set shared pin to active state");\n\n\tCAM_DBG(CAM_SENSOR, "power setting size: %d", ctrl->power_setting_size);\n\n\tfor (index = 0; index < ctrl->power_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "index: %d", index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tif (!power_setting) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power up settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tCAM_DBG(CAM_SENSOR, "seq_type %d", power_setting->seq_type);\n\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tif (power_setting->seq_val >= soc_info->num_clk) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk index %d >= max %u",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tsoc_info->num_clk);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tfor (j = 0; j < num_vreg; j++) {\n\t\t\t\tif (!strcmp(soc_info->rgltr_name[j],\n\t\t\t\t\t"cam_clk")) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Enable cam_clk: %d", j);\n\n\t\t\t\t\tsoc_info->rgltr[j] =\n\t\t\t\t\tregulator_get(\n\t\t\t\t\t\tsoc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[j]);\n\n\t\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\t\tsoc_info->rgltr[j])) {\n\t\t\t\t\t\trc = PTR_ERR(\n\t\t\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\t\t\trc = rc ? rc : -EINVAL;\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t\t"vreg %s %d",\n\t\t\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\t\t\trc);\n\t\t\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t\t}\n\n\t\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\t\t\t\t\tif (rc) {\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t\t"Reg enable failed");\n\t\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t\t}\n\t\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (power_setting->config_val)\n\t\t\t\tsoc_info->clk_rate[0][power_setting->seq_val] =\n\t\t\t\t\tpower_setting->config_val;\n\n\t\t\tfor (j = 0; j < soc_info->num_clk; j++) {\n\t\t\t\trc = cam_soc_util_clk_enable(soc_info->clk[j],\n\t\t\t\t\tsoc_info->clk_name[j],\n\t\t\t\t\tsoc_info->clk_rate[0][j]);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk enable failed");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (no_gpio) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "request gpio failed");\n\t\t\t\treturn no_gpio;\n\t\t\t}\n\t\t\tif (!gpio_num_info) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid gpio_num_info");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tCAM_DBG(CAM_SENSOR, "gpio set val %d",\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type]);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info,\n\t\t\t\t(int) power_setting->config_val);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tif (power_setting->seq_val >= CAM_VREG_MAX) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "vreg index %d >= max %d",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tCAM_VREG_MAX);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Enable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\tsoc_info->rgltr[vreg_idx] =\n\t\t\t\t\tregulator_get(soc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx])) {\n\t\t\t\t\trc = PTR_ERR(soc_info->rgltr[vreg_idx]);\n\t\t\t\t\trc = rc ? rc : -EINVAL;\n\n\t\t\t\t\tCAM_ERR(CAM_SENSOR, "%s get failed %d",\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\t\trc);\n\n\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t}\n\n\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\t\t\t\tif (rc) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Reg Enable failed for %s",\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\t\tgoto power_up_failed;\n\t\t\t\t}\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "usr_idx:%d dts_idx:%d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20)\n\t\t\tmsleep(power_setting->delay);\n\t\telse if (power_setting->delay)\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_post_init();\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to post init shared pinctrl");\n\n\treturn 0;\npower_up_failed:\n\tCAM_ERR(CAM_SENSOR, "failed");\n\tfor (index--; index >= 0; index--) {\n\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tCAM_DBG(CAM_SENSOR, "type %d",\n\t\t\tpower_setting->seq_type);\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {\n\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],\n\t\t\t\t\tsoc_info->clk_name[i]);\n\t\t\t}\n\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);\n\t\t\tif (ret < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"config clk reg failed rc: %d", ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (!gpio_num_info)\n\t\t\t\tcontinue;\n\t\t\tif (!gpio_num_info->valid\n\t\t\t\t[power_setting->seq_type])\n\t\t\t\tcontinue;\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type], GPIOF_OUT_INIT_LOW);\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\trc =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Fail to disalbe reg: %s",\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t\t\tmsm_cam_sensor_handle_reg_gpio(\n\t\t\t\t\t\tpower_setting->seq_type,\n\t\t\t\t\t\tgpio_num_info,\n\t\t\t\t\t\tGPIOF_OUT_INIT_LOW);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\n\t\t\t\tregulator_put(soc_info->rgltr[vreg_idx]);\n\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "seq_val:%d > num_vreg: %d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\tmsm_cam_sensor_handle_reg_gpio(power_setting->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20) {\n\t\t\tmsleep(power_setting->delay);\n\t\t} else if (power_setting->delay) {\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t\t}\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn rc;\n}'
p1108
S'e8e82015f51d'
p1109
sS'int cam_sensor_core_power_up(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint rc = 0, index = 0, no_gpio = 0, ret = 0, num_vreg, j = 0;\n\tint32_t vreg_idx = -1;\n\tstruct cam_sensor_power_setting *power_setting = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid ctrl handle");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(true);\n\n\tret = msm_camera_pinctrl_init(&(ctrl->pinctrl_info), ctrl->dev);\n\tif (ret < 0) {\n\t\t/* Some sensor subdev no pinctrl. */\n\t\tCAM_DBG(CAM_SENSOR, "Initialization of pinctrl failed");\n\t\tctrl->cam_pinctrl_status = 0;\n\t} else {\n\t\tctrl->cam_pinctrl_status = 1;\n\t}\n\n\tif (cam_res_mgr_shared_pinctrl_init()) {\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to init shared pinctrl");\n\t\treturn -EINVAL;\n\t}\n\n\trc = cam_sensor_util_request_gpio_table(soc_info, 1);\n\tif (rc < 0)\n\t\tno_gpio = rc;\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\tctrl->pinctrl_info.gpio_state_active);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to active state");\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_select_state(true);\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Cannot set shared pin to active state");\n\n\tCAM_DBG(CAM_SENSOR, "power setting size: %d", ctrl->power_setting_size);\n\n\tfor (index = 0; index < ctrl->power_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "index: %d", index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tif (!power_setting) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power up settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tCAM_DBG(CAM_SENSOR, "seq_type %d", power_setting->seq_type);\n\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tif (power_setting->seq_val >= soc_info->num_clk) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk index %d >= max %u",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tsoc_info->num_clk);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tfor (j = 0; j < num_vreg; j++) {\n\t\t\t\tif (!strcmp(soc_info->rgltr_name[j],\n\t\t\t\t\t"cam_clk")) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Enable cam_clk: %d", j);\n\n\t\t\t\t\tsoc_info->rgltr[j] =\n\t\t\t\t\tregulator_get(\n\t\t\t\t\t\tsoc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[j]);\n\n\t\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\t\tsoc_info->rgltr[j])) {\n\t\t\t\t\t\trc = PTR_ERR(\n\t\t\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\t\t\trc = rc ? rc : -EINVAL;\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t\t"vreg %s %d",\n\t\t\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\t\t\trc);\n\t\t\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t\t\t}\n\n\t\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\n\t\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (power_setting->config_val)\n\t\t\t\tsoc_info->clk_rate[0][power_setting->seq_val] =\n\t\t\t\t\tpower_setting->config_val;\n\n\t\t\tfor (j = 0; j < soc_info->num_clk; j++) {\n\t\t\t\trc = cam_soc_util_clk_enable(soc_info->clk[j],\n\t\t\t\t\tsoc_info->clk_name[j],\n\t\t\t\t\tsoc_info->clk_rate[0][j]);\n\t\t\t\tif (rc)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "clk enable failed");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (no_gpio) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "request gpio failed");\n\t\t\t\treturn no_gpio;\n\t\t\t}\n\t\t\tif (!gpio_num_info) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid gpio_num_info");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tCAM_DBG(CAM_SENSOR, "gpio set val %d",\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type]);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info,\n\t\t\t\t(int) power_setting->config_val);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tif (power_setting->seq_val >= CAM_VREG_MAX) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "vreg index %d >= max %d",\n\t\t\t\t\tpower_setting->seq_val,\n\t\t\t\t\tCAM_VREG_MAX);\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Enable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\tsoc_info->rgltr[vreg_idx] =\n\t\t\t\t\tregulator_get(soc_info->dev,\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx]);\n\t\t\t\tif (IS_ERR_OR_NULL(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx])) {\n\t\t\t\t\trc = PTR_ERR(soc_info->rgltr[vreg_idx]);\n\t\t\t\t\trc = rc ? rc : -EINVAL;\n\n\t\t\t\t\tCAM_ERR(CAM_SENSOR, "%s get failed %d",\n\t\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\t\trc);\n\n\t\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t\t}\n\n\t\t\t\trc =  cam_soc_util_regulator_enable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "usr_idx:%d dts_idx:%d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\trc = msm_cam_sensor_handle_reg_gpio(\n\t\t\t\tpower_setting->seq_type,\n\t\t\t\tgpio_num_info, 1);\n\t\t\tif (rc < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error in handling VREG GPIO");\n\t\t\t\tgoto power_up_failed;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20)\n\t\t\tmsleep(power_setting->delay);\n\t\telse if (power_setting->delay)\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t}\n\n\tret = cam_res_mgr_shared_pinctrl_post_init();\n\tif (ret)\n\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t"Failed to post init shared pinctrl");\n\n\treturn 0;\npower_up_failed:\n\tCAM_ERR(CAM_SENSOR, "failed");\n\tfor (index--; index >= 0; index--) {\n\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);\n\t\tpower_setting = &ctrl->power_setting[index];\n\t\tCAM_DBG(CAM_SENSOR, "type %d",\n\t\t\tpower_setting->seq_type);\n\t\tswitch (power_setting->seq_type) {\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\t\t\tif (!gpio_num_info)\n\t\t\t\tcontinue;\n\t\t\tif (!gpio_num_info->valid\n\t\t\t\t[power_setting->seq_type])\n\t\t\t\tcontinue;\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[power_setting->seq_type], GPIOF_OUT_INIT_LOW);\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (power_setting->seq_val < num_vreg) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");\n\t\t\t\tvreg_idx = power_setting->seq_val;\n\n\t\t\t\trc =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_name[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_min_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_max_volt[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_op_mode[vreg_idx],\n\t\t\t\t\tsoc_info->rgltr_delay[vreg_idx]);\n\n\t\t\t\tpower_setting->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[vreg_idx];\n\n\t\t\t\tregulator_put(\n\t\t\t\t\tsoc_info->rgltr[vreg_idx]);\n\t\t\t\tsoc_info->rgltr[vreg_idx] = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t\tCAM_ERR(CAM_SENSOR, "seq_val:%d > num_vreg: %d",\n\t\t\t\t\tpower_setting->seq_val, num_vreg);\n\n\t\t\tmsm_cam_sensor_handle_reg_gpio(power_setting->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpower_setting->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (power_setting->delay > 20) {\n\t\t\tmsleep(power_setting->delay);\n\t\t} else if (power_setting->delay) {\n\t\t\tusleep_range(power_setting->delay * 1000,\n\t\t\t\t(power_setting->delay * 1000) + 1000);\n\t\t}\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn rc;\n}'
p1110
S'8eedcc7ff9de'
p1111
ss(g1104
S'msm_camera_power_down'
p1112
tp1113
(dp1114
S'int msm_camera_power_down(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint index = 0, ret = 0, num_vreg = 0, i;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl || !soc_info) {\n\t\tCAM_ERR(CAM_SENSOR, "failed ctrl %pK",  ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tif (ctrl->power_down_setting_size > MAX_POWER_CONFIG) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid: power setting size %d",\n\t\t\tctrl->power_setting_size);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (index = 0; index < ctrl->power_down_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "power_down_index %d",  index);\n\t\tpd = &ctrl->power_down_setting[index];\n\t\tif (!pd) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power down settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tps = NULL;\n\t\tCAM_DBG(CAM_SENSOR, "seq_type %d",  pd->seq_type);\n\t\tswitch (pd->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {\n\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],\n\t\t\t\t\tsoc_info->clk_name[i]);\n\t\t\t}\n\n\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);\n\t\t\tif (ret < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"config clk reg failed rc: %d", ret);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\n\t\t\tif (!gpio_num_info->valid[pd->seq_type])\n\t\t\t\tcontinue;\n\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[pd->seq_type],\n\t\t\t\t(int) pd->config_val);\n\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (pd->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tps = msm_camera_get_power_settings(\n\t\t\t\tctrl, pd->seq_type,\n\t\t\t\tpd->seq_val);\n\t\t\tif (ps) {\n\t\t\t\tif (pd->seq_val < num_vreg) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Disable Regulator");\n\t\t\t\t\tret =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_name[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_min_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_max_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_op_mode[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_delay[ps->seq_val]);\n\t\t\t\t\tif (ret) {\n\t\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Reg: %s disable failed",\n\t\t\t\t\t\tsoc_info->rgltr_name[\n\t\t\t\t\t\t\tps->seq_val]);\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val] =\n\t\t\t\t\t\t\tNULL;\n\t\t\t\t\t\tmsm_cam_sensor_handle_reg_gpio(\n\t\t\t\t\t\t\tpd->seq_type,\n\t\t\t\t\t\t\tgpio_num_info,\n\t\t\t\t\t\t\tGPIOF_OUT_INIT_LOW);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tps->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val];\n\n\t\t\t\t\tregulator_put(\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val]);\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val] = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"seq_val:%d > num_vreg: %d",\n\t\t\t\t\t\t pd->seq_val,\n\t\t\t\t\t\tnum_vreg);\n\t\t\t} else\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"error in power up/down seq");\n\n\t\t\tret = msm_cam_sensor_handle_reg_gpio(pd->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tif (ret < 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error disabling VREG GPIO");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpd->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (pd->delay > 20)\n\t\t\tmsleep(pd->delay);\n\t\telse if (pd->delay)\n\t\t\tusleep_range(pd->delay * 1000,\n\t\t\t\t(pd->delay * 1000) + 1000);\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn 0;\n}'
p1115
g1109
sS'int msm_camera_power_down(struct cam_sensor_power_ctrl_t *ctrl,\n\t\tstruct cam_hw_soc_info *soc_info)\n{\n\tint index = 0, ret = 0, num_vreg = 0, i;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct msm_camera_gpio_num_info *gpio_num_info = NULL;\n\n\tCAM_DBG(CAM_SENSOR, "Enter");\n\tif (!ctrl || !soc_info) {\n\t\tCAM_ERR(CAM_SENSOR, "failed ctrl %pK",  ctrl);\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_num_info = ctrl->gpio_num_info;\n\tnum_vreg = soc_info->num_rgltr;\n\n\tif ((num_vreg <= 0) || (num_vreg > CAM_SOC_MAX_REGULATOR)) {\n\t\tCAM_ERR(CAM_SENSOR, "failed: num_vreg %d", num_vreg);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (index = 0; index < ctrl->power_down_setting_size; index++) {\n\t\tCAM_DBG(CAM_SENSOR, "index %d",  index);\n\t\tpd = &ctrl->power_down_setting[index];\n\t\tif (!pd) {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Invalid power down settings for index %d",\n\t\t\t\tindex);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tps = NULL;\n\t\tCAM_DBG(CAM_SENSOR, "type %d",  pd->seq_type);\n\t\tswitch (pd->seq_type) {\n\t\tcase SENSOR_MCLK:\n\t\t\tret = cam_config_mclk_reg(ctrl, soc_info, index);\n\t\t\tif (ret < 0) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"config clk reg failed rc: %d", ret);\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t//cam_soc_util_clk_disable_default(soc_info);\n\t\t\tfor (i = soc_info->num_clk - 1; i >= 0; i--) {\n\t\t\t\tcam_soc_util_clk_disable(soc_info->clk[i],\n\t\t\t\t\tsoc_info->clk_name[i]);\n\t\t\t}\n\n\t\t\tbreak;\n\t\tcase SENSOR_RESET:\n\t\tcase SENSOR_STANDBY:\n\t\tcase SENSOR_CUSTOM_GPIO1:\n\t\tcase SENSOR_CUSTOM_GPIO2:\n\n\t\t\tif (!gpio_num_info->valid[pd->seq_type])\n\t\t\t\tcontinue;\n\n\t\t\tcam_res_mgr_gpio_set_value(\n\t\t\t\tgpio_num_info->gpio_num\n\t\t\t\t[pd->seq_type],\n\t\t\t\t(int) pd->config_val);\n\n\t\t\tbreak;\n\t\tcase SENSOR_VANA:\n\t\tcase SENSOR_VDIG:\n\t\tcase SENSOR_VIO:\n\t\tcase SENSOR_VAF:\n\t\tcase SENSOR_VAF_PWDM:\n\t\tcase SENSOR_CUSTOM_REG1:\n\t\tcase SENSOR_CUSTOM_REG2:\n\t\t\tif (pd->seq_val == INVALID_VREG)\n\t\t\t\tbreak;\n\n\t\t\tps = msm_camera_get_power_settings(\n\t\t\t\tctrl, pd->seq_type,\n\t\t\t\tpd->seq_val);\n\t\t\tif (ps) {\n\t\t\t\tif (pd->seq_val < num_vreg) {\n\t\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t\t"Disable Regulator");\n\t\t\t\t\tret =  cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_name[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_min_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_max_volt[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_op_mode[ps->seq_val],\n\t\t\t\t\tsoc_info->rgltr_delay[ps->seq_val]);\n\n\t\t\t\t\tps->data[0] =\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val];\n\n\t\t\t\t\tregulator_put(\n\t\t\t\t\t\tsoc_info->rgltr[ps->seq_val]);\n\t\t\t\t\tsoc_info->rgltr[ps->seq_val] = NULL;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"seq_val:%d > num_vreg: %d",\n\t\t\t\t\t\t pd->seq_val,\n\t\t\t\t\t\tnum_vreg);\n\t\t\t} else\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"error in power up/down seq");\n\n\t\t\tret = msm_cam_sensor_handle_reg_gpio(pd->seq_type,\n\t\t\t\tgpio_num_info, GPIOF_OUT_INIT_LOW);\n\n\t\t\tif (ret < 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Error disabling VREG GPIO");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tCAM_ERR(CAM_SENSOR, "error power seq type %d",\n\t\t\t\tpd->seq_type);\n\t\t\tbreak;\n\t\t}\n\t\tif (pd->delay > 20)\n\t\t\tmsleep(pd->delay);\n\t\telse if (pd->delay)\n\t\t\tusleep_range(pd->delay * 1000,\n\t\t\t\t(pd->delay * 1000) + 1000);\n\t}\n\n\tif (ctrl->cam_pinctrl_status) {\n\t\tret = pinctrl_select_state(\n\t\t\t\tctrl->pinctrl_info.pinctrl,\n\t\t\t\tctrl->pinctrl_info.gpio_state_suspend);\n\t\tif (ret)\n\t\t\tCAM_ERR(CAM_SENSOR, "cannot set pin to suspend state");\n\n\t\tcam_res_mgr_shared_pinctrl_select_state(false);\n\t\tdevm_pinctrl_put(ctrl->pinctrl_info.pinctrl);\n\t\tcam_res_mgr_shared_pinctrl_put();\n\t}\n\n\tif (soc_info->use_shared_clk)\n\t\tcam_res_mgr_shared_clk_config(false);\n\n\tctrl->cam_pinctrl_status = 0;\n\n\tcam_sensor_util_request_gpio_table(soc_info, 0);\n\n\treturn 0;\n}'
p1116
g1111
ss(g1090
S'cam_sensor_shutdown'
p1117
tp1118
(dp1119
S'void cam_sensor_shutdown(struct cam_sensor_ctrl_t *s_ctrl)\n{\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tint rc = 0;\n\n\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&\n\t\t(s_ctrl->is_probe_succeed == 0))\n\t\treturn;\n\n\tcam_sensor_release_stream_rsc(s_ctrl);\n\tcam_sensor_release_per_frame_resource(s_ctrl);\n\tcam_sensor_power_down(s_ctrl);\n\n\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\tif (rc < 0)\n\t\tCAM_ERR(CAM_SENSOR, " failed destroying dhdl");\n\ts_ctrl->bridge_intf.device_hdl = -1;\n\ts_ctrl->bridge_intf.link_hdl = -1;\n\ts_ctrl->bridge_intf.session_hdl = -1;\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_down_setting_size = 0;\n\ts_ctrl->streamon_count = 0;\n\ts_ctrl->streamoff_count = 0;\n\ts_ctrl->is_probe_succeed = 0;\n\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n}'
p1120
g1103
sS'void cam_sensor_shutdown(struct cam_sensor_ctrl_t *s_ctrl)\n{\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tint rc = 0;\n\n\ts_ctrl->is_probe_succeed = 0;\n\tif (s_ctrl->sensor_state == CAM_SENSOR_INIT)\n\t\treturn;\n\n\tcam_sensor_release_resource(s_ctrl);\n\tcam_sensor_release_stream_rsc(s_ctrl);\n\tif (s_ctrl->sensor_state >= CAM_SENSOR_ACQUIRE)\n\t\tcam_sensor_power_down(s_ctrl);\n\n\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\tif (rc < 0)\n\t\tCAM_ERR(CAM_SENSOR, " failed destroying dhdl");\n\ts_ctrl->bridge_intf.device_hdl = -1;\n\ts_ctrl->bridge_intf.link_hdl = -1;\n\ts_ctrl->bridge_intf.session_hdl = -1;\n\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\n\ts_ctrl->streamon_count = 0;\n\ts_ctrl->streamoff_count = 0;\n\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n}'
p1121
g1099
sS'void cam_sensor_shutdown(struct cam_sensor_ctrl_t *s_ctrl)\n{\n\tstruct cam_sensor_power_ctrl_t *power_info =\n\t\t&s_ctrl->sensordata->power_info;\n\tint rc = 0;\n\n\tif ((s_ctrl->sensor_state == CAM_SENSOR_INIT) &&\n\t\t(s_ctrl->is_probe_succeed == 0))\n\t\treturn;\n\n\tcam_sensor_release_resource(s_ctrl);\n\tcam_sensor_release_stream_rsc(s_ctrl);\n\tif (s_ctrl->sensor_state >= CAM_SENSOR_ACQUIRE)\n\t\tcam_sensor_power_down(s_ctrl);\n\n\trc = cam_destroy_device_hdl(s_ctrl->bridge_intf.device_hdl);\n\tif (rc < 0)\n\t\tCAM_ERR(CAM_SENSOR, " failed destroying dhdl");\n\ts_ctrl->bridge_intf.device_hdl = -1;\n\ts_ctrl->bridge_intf.link_hdl = -1;\n\ts_ctrl->bridge_intf.session_hdl = -1;\n\tkfree(power_info->power_setting);\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_down_setting_size = 0;\n\ts_ctrl->streamon_count = 0;\n\ts_ctrl->streamoff_count = 0;\n\ts_ctrl->is_probe_succeed = 0;\n\ts_ctrl->sensor_state = CAM_SENSOR_INIT;\n}'
p1122
g1095
ss(g1104
S'cam_sensor_update_power_settings'
p1123
tp1124
(dp1125
S'int32_t cam_sensor_update_power_settings(void *cmd_buf,\n\tint cmd_length, struct cam_sensor_power_ctrl_t *power_info)\n{\n\tint32_t rc = 0, tot_size = 0, last_cmd_type = 0;\n\tint32_t i = 0, pwr_up = 0, pwr_down = 0;\n\tstruct cam_sensor_power_setting *pwr_settings;\n\tvoid *ptr = cmd_buf, *scr;\n\tstruct cam_cmd_power *pwr_cmd = (struct cam_cmd_power *)cmd_buf;\n\tstruct common_header *cmm_hdr = (struct common_header *)cmd_buf;\n\n\tif (!pwr_cmd || !cmd_length) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Args: pwr_cmd %pK, cmd_length: %d",\n\t\t\tpwr_cmd, cmd_length);\n\t\treturn -EINVAL;\n\t}\n\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_setting)\n\t\treturn -ENOMEM;\n\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_down_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_down_setting) {\n\t\trc = -ENOMEM;\n\t\tgoto free_power_settings;\n\t}\n\n\twhile (tot_size < cmd_length) {\n\t\tif (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tpower_info->power_setting_size += pwr_cmd->count;\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_WARN(CAM_SENSOR, "Un expected Command");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_up++) {\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpower_info->power_setting[pwr_up].config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_setting[pwr_up].delay = 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size = tot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Error: Cmd Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_down_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t"Seq Type[%d]: %d Config_val: %ld", pwr_up,\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type,\n\t\t\t\tpower_info->power_setting[pwr_up].config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_UP;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type == CAMERA_SENSOR_CMD_TYPE_WAIT) {\n\t\t\tstruct cam_cmd_unconditional_wait *wait_cmd =\n\t\t\t\t(struct cam_cmd_unconditional_wait *)ptr;\n\t\t\tif ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP)) {\n\t\t\t\tif (pwr_up > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_setting[pwr_up - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else if ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN)) {\n\t\t\t\tif (pwr_down > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_down_setting[\n\t\t\t\t\t\tpwr_down - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Invalid op code: %d",\n\t\t\t\t\twait_cmd->op_code);\n\t\t\t}\n\n\t\t\ttot_size = tot_size +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait);\n\t\t\tif (tot_size > cmd_length) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Command Buffer is wrong");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscr = (void *) (wait_cmd);\n\t\t\tptr = (void *)\n\t\t\t\t(scr +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait));\n\t\t\tCAM_DBG(CAM_SENSOR, "ptr: %pK sizeof: %d Next: %pK",\n\t\t\t\tscr, (int32_t)sizeof(\n\t\t\t\tstruct cam_cmd_unconditional_wait), ptr);\n\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\t\t\tpower_info->power_down_setting_size += pwr_cmd->count;\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Invalid Command");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_down++) {\n\t\t\t\tpwr_settings =\n\t\t\t\t&power_info->power_down_setting[pwr_down];\n\t\t\t\tpwr_settings->seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpwr_settings->config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_down_setting[pwr_down].delay\n\t\t\t\t\t= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size =\n\t\t\t\t\t\ttot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Command Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_down_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t"Seq Type[%d]: %d Config_val: %ld",\n\t\t\t\t\tpwr_down, pwr_settings->seq_type,\n\t\t\t\t\tpwr_settings->config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_DOWN;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Error: Un expected Header Type: %d",\n\t\t\t\tcmm_hdr->cmd_type);\n\t\t}\n\t}\n\n\treturn rc;\nfree_power_down_settings:\n\tkfree(power_info->power_down_setting);\n\tpower_info->power_down_setting = NULL;\nfree_power_settings:\n\tkfree(power_info->power_setting);\n\tpower_info->power_setting = NULL;\n\treturn rc;\n}'
p1126
g1111
sS'int32_t cam_sensor_update_power_settings(void *cmd_buf,\n\tint cmd_length, struct cam_sensor_power_ctrl_t *power_info)\n{\n\tint32_t rc = 0, tot_size = 0, last_cmd_type = 0;\n\tint32_t i = 0, pwr_up = 0, pwr_down = 0;\n\tstruct cam_sensor_power_setting *pwr_settings;\n\tvoid *ptr = cmd_buf, *scr;\n\tstruct cam_cmd_power *pwr_cmd = (struct cam_cmd_power *)cmd_buf;\n\tstruct common_header *cmm_hdr = (struct common_header *)cmd_buf;\n\n\tif (!pwr_cmd || !cmd_length) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Args: pwr_cmd %pK, cmd_length: %d",\n\t\t\tpwr_cmd, cmd_length);\n\t\treturn -EINVAL;\n\t}\n\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_setting)\n\t\treturn -ENOMEM;\n\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_down_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_down_setting) {\n\t\tkfree(power_info->power_setting);\n\t\tpower_info->power_setting = NULL;\n\t\tpower_info->power_setting_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (tot_size < cmd_length) {\n\t\tif (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tpower_info->power_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_setting_size > MAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power up setting size %d",\n\t\t\t\t\tpower_info->power_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_WARN(CAM_SENSOR, "pwr_up_size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_up++) {\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpower_info->power_setting[pwr_up].config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_setting[pwr_up].delay = 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size = tot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Error: Cmd Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t"Seq Type[%d]: %d Config_val: %ld", pwr_up,\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type,\n\t\t\t\tpower_info->power_setting[pwr_up].config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_UP;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type == CAMERA_SENSOR_CMD_TYPE_WAIT) {\n\t\t\tstruct cam_cmd_unconditional_wait *wait_cmd =\n\t\t\t\t(struct cam_cmd_unconditional_wait *)ptr;\n\t\t\tif ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP)) {\n\t\t\t\tif (pwr_up > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_setting[pwr_up - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else if ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN)) {\n\t\t\t\tif (pwr_down > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_down_setting[\n\t\t\t\t\t\tpwr_down - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Invalid op code: %d",\n\t\t\t\t\twait_cmd->op_code);\n\t\t\t}\n\n\t\t\ttot_size = tot_size +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait);\n\t\t\tif (tot_size > cmd_length) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Command Buffer is wrong");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscr = (void *) (wait_cmd);\n\t\t\tptr = (void *)\n\t\t\t\t(scr +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait));\n\t\t\tCAM_DBG(CAM_SENSOR, "ptr: %pK sizeof: %d Next: %pK",\n\t\t\t\tscr, (int32_t)sizeof(\n\t\t\t\tstruct cam_cmd_unconditional_wait), ptr);\n\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\t\t\tpower_info->power_down_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_down_setting_size >\n\t\t\t\tMAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power down setting size %d",\n\t\t\t\t\tpower_info->power_down_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR, "pwr_down size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_down++) {\n\t\t\t\tpwr_settings =\n\t\t\t\t&power_info->power_down_setting[pwr_down];\n\t\t\t\tpwr_settings->seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpwr_settings->config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_down_setting[pwr_down].delay\n\t\t\t\t\t= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size =\n\t\t\t\t\t\ttot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Command Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t"Seq Type[%d]: %d Config_val: %ld",\n\t\t\t\t\tpwr_down, pwr_settings->seq_type,\n\t\t\t\t\tpwr_settings->config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_DOWN;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Error: Un expected Header Type: %d",\n\t\t\t\tcmm_hdr->cmd_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_power_settings;\n\t\t}\n\t}\n\n\treturn rc;\nfree_power_settings:\n\tkfree(power_info->power_down_setting);\n\tkfree(power_info->power_setting);\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\treturn rc;\n}'
p1127
g1109
sS'int32_t cam_sensor_update_power_settings(void *cmd_buf,\n\tuint32_t cmd_length, struct cam_sensor_power_ctrl_t *power_info,\n\tsize_t cmd_buf_len)\n{\n\tint32_t rc = 0, tot_size = 0, last_cmd_type = 0;\n\tint32_t i = 0, pwr_up = 0, pwr_down = 0;\n\tstruct cam_sensor_power_setting *pwr_settings;\n\tvoid *ptr = cmd_buf, *scr;\n\tstruct cam_cmd_power *pwr_cmd = (struct cam_cmd_power *)cmd_buf;\n\tstruct common_header *cmm_hdr = (struct common_header *)cmd_buf;\n\n\tif (!pwr_cmd || !cmd_length || cmd_buf_len < (size_t)cmd_length ||\n\t\tcam_sensor_validate(cmd_buf, cmd_buf_len)) {\n\t\tCAM_ERR(CAM_SENSOR, "Invalid Args: pwr_cmd %pK, cmd_length: %d",\n\t\t\tpwr_cmd, cmd_length);\n\t\treturn -EINVAL;\n\t}\n\n\tpower_info->power_setting_size = 0;\n\tpower_info->power_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_setting)\n\t\treturn -ENOMEM;\n\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_down_setting =\n\t\t(struct cam_sensor_power_setting *)\n\t\tkzalloc(sizeof(struct cam_sensor_power_setting) *\n\t\t\tMAX_POWER_CONFIG, GFP_KERNEL);\n\tif (!power_info->power_down_setting) {\n\t\tkfree(power_info->power_setting);\n\t\tpower_info->power_setting = NULL;\n\t\tpower_info->power_setting_size = 0;\n\t\treturn -ENOMEM;\n\t}\n\n\twhile (tot_size < cmd_length) {\n\t\tif (cam_sensor_validate(ptr, (cmd_length - tot_size))) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_power_settings;\n\t\t}\n\t\tif (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tpower_info->power_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_setting_size > MAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power up setting size %d",\n\t\t\t\t\tpower_info->power_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_WARN(CAM_SENSOR, "pwr_up_size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_up++) {\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpower_info->power_setting[pwr_up].config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_setting[pwr_up].delay = 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size = tot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Error: Cmd Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t"Seq Type[%d]: %d Config_val: %ld", pwr_up,\n\t\t\t\tpower_info->power_setting[pwr_up].seq_type,\n\t\t\t\tpower_info->power_setting[pwr_up].config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_UP;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type == CAMERA_SENSOR_CMD_TYPE_WAIT) {\n\t\t\tstruct cam_cmd_unconditional_wait *wait_cmd =\n\t\t\t\t(struct cam_cmd_unconditional_wait *)ptr;\n\t\t\tif ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_UP)) {\n\t\t\t\tif (pwr_up > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_setting[pwr_up - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else if ((wait_cmd->op_code ==\n\t\t\t\tCAMERA_SENSOR_WAIT_OP_SW_UCND) &&\n\t\t\t\t(last_cmd_type ==\n\t\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN)) {\n\t\t\t\tif (pwr_down > 0) {\n\t\t\t\t\tpwr_settings =\n\t\t\t\t\t&power_info->power_down_setting[\n\t\t\t\t\t\tpwr_down - 1];\n\t\t\t\t\tpwr_settings->delay +=\n\t\t\t\t\t\twait_cmd->delay;\n\t\t\t\t} else {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Delay is expected only after valid power up setting");\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Invalid op code: %d",\n\t\t\t\t\twait_cmd->op_code);\n\t\t\t}\n\n\t\t\ttot_size = tot_size +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait);\n\t\t\tif (tot_size > cmd_length) {\n\t\t\t\tCAM_ERR(CAM_SENSOR, "Command Buffer is wrong");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tscr = (void *) (wait_cmd);\n\t\t\tptr = (void *)\n\t\t\t\t(scr +\n\t\t\t\tsizeof(struct cam_cmd_unconditional_wait));\n\t\t\tCAM_DBG(CAM_SENSOR, "ptr: %pK sizeof: %d Next: %pK",\n\t\t\t\tscr, (int32_t)sizeof(\n\t\t\t\tstruct cam_cmd_unconditional_wait), ptr);\n\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else if (cmm_hdr->cmd_type ==\n\t\t\tCAMERA_SENSOR_CMD_TYPE_PWR_DOWN) {\n\t\t\tstruct cam_cmd_power *pwr_cmd =\n\t\t\t\t(struct cam_cmd_power *)ptr;\n\n\t\t\tscr = ptr + sizeof(struct cam_cmd_power);\n\t\t\ttot_size = tot_size + sizeof(struct cam_cmd_power);\n\t\t\tpower_info->power_down_setting_size += pwr_cmd->count;\n\t\t\tif (power_info->power_down_setting_size >\n\t\t\t\tMAX_POWER_CONFIG) {\n\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t"Invalid: power down setting size %d",\n\t\t\t\t\tpower_info->power_down_setting_size);\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto free_power_settings;\n\t\t\t}\n\n\t\t\tif (pwr_cmd->count == 0)\n\t\t\t\tCAM_ERR(CAM_SENSOR, "pwr_down size is zero");\n\n\t\t\tfor (i = 0; i < pwr_cmd->count; i++, pwr_down++) {\n\t\t\t\tpwr_settings =\n\t\t\t\t&power_info->power_down_setting[pwr_down];\n\t\t\t\tpwr_settings->seq_type =\n\t\t\t\tpwr_cmd->power_settings[i].power_seq_type;\n\t\t\t\tpwr_settings->config_val =\n\t\t\t\tpwr_cmd->power_settings[i].config_val_low;\n\t\t\t\tpower_info->power_down_setting[pwr_down].delay\n\t\t\t\t\t= 0;\n\t\t\t\tif (i) {\n\t\t\t\t\tscr = scr +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t\ttot_size =\n\t\t\t\t\t\ttot_size +\n\t\t\t\t\t\tsizeof(\n\t\t\t\t\t\tstruct cam_power_settings);\n\t\t\t\t}\n\t\t\t\tif (tot_size > cmd_length) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"Command Buffer is wrong");\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto free_power_settings;\n\t\t\t\t}\n\t\t\t\tCAM_DBG(CAM_SENSOR,\n\t\t\t\t\t"Seq Type[%d]: %d Config_val: %ld",\n\t\t\t\t\tpwr_down, pwr_settings->seq_type,\n\t\t\t\t\tpwr_settings->config_val);\n\t\t\t}\n\t\t\tlast_cmd_type = CAMERA_SENSOR_CMD_TYPE_PWR_DOWN;\n\t\t\tptr = (void *) scr;\n\t\t\tcmm_hdr = (struct common_header *)ptr;\n\t\t} else {\n\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t"Error: Un expected Header Type: %d",\n\t\t\t\tcmm_hdr->cmd_type);\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_power_settings;\n\t\t}\n\t}\n\n\treturn rc;\nfree_power_settings:\n\tkfree(power_info->power_down_setting);\n\tkfree(power_info->power_setting);\n\tpower_info->power_down_setting = NULL;\n\tpower_info->power_setting = NULL;\n\tpower_info->power_down_setting_size = 0;\n\tpower_info->power_setting_size = 0;\n\treturn rc;\n}'
p1128
S'1d7b97667c43'
p1129
ss(g1104
S'cam_config_mclk_reg'
p1130
tp1131
(dp1132
S'static int cam_config_mclk_reg(struct cam_sensor_power_ctrl_t *ctrl,\n\tstruct cam_hw_soc_info *soc_info, int32_t index)\n{\n\tint32_t num_vreg = 0, j = 0, rc = 0, idx = 0;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\n\tnum_vreg = soc_info->num_rgltr;\n\n\tpd = &ctrl->power_down_setting[index];\n\n\tfor (j = 0; j < num_vreg; j++) {\n\t\tif (!strcmp(soc_info->rgltr_name[j], "cam_clk")) {\n\n\t\t\tps = NULL;\n\t\t\tfor (idx = 0; idx <\n\t\t\t\tctrl->power_setting_size; idx++) {\n\t\t\t\tif (ctrl->power_setting[idx].\n\t\t\t\t\tseq_type == pd->seq_type) {\n\t\t\t\t\tps = &ctrl->power_setting[idx];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps != NULL) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable Regulator");\n\n\t\t\t\trc = cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\n\t\t\t\tps->data[0] =\n\t\t\t\t\tsoc_info->rgltr[j];\n\n\t\t\t\tregulator_put(\n\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}'
p1133
g1111
sS'static int cam_config_mclk_reg(struct cam_sensor_power_ctrl_t *ctrl,\n\tstruct cam_hw_soc_info *soc_info, int32_t index)\n{\n\tint32_t num_vreg = 0, j = 0, rc = 0, idx = 0;\n\tstruct cam_sensor_power_setting *ps = NULL;\n\tstruct cam_sensor_power_setting *pd = NULL;\n\n\tnum_vreg = soc_info->num_rgltr;\n\n\tpd = &ctrl->power_down_setting[index];\n\n\tfor (j = 0; j < num_vreg; j++) {\n\t\tif (!strcmp(soc_info->rgltr_name[j], "cam_clk")) {\n\t\t\tps = NULL;\n\t\t\tfor (idx = 0; idx < ctrl->power_setting_size; idx++) {\n\t\t\t\tif (ctrl->power_setting[idx].seq_type ==\n\t\t\t\t\tpd->seq_type) {\n\t\t\t\t\tps = &ctrl->power_setting[idx];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ps != NULL) {\n\t\t\t\tCAM_DBG(CAM_SENSOR, "Disable MCLK Regulator");\n\t\t\t\trc = cam_soc_util_regulator_disable(\n\t\t\t\t\tsoc_info->rgltr[j],\n\t\t\t\t\tsoc_info->rgltr_name[j],\n\t\t\t\t\tsoc_info->rgltr_min_volt[j],\n\t\t\t\t\tsoc_info->rgltr_max_volt[j],\n\t\t\t\t\tsoc_info->rgltr_op_mode[j],\n\t\t\t\t\tsoc_info->rgltr_delay[j]);\n\n\t\t\t\tif (rc) {\n\t\t\t\t\tCAM_ERR(CAM_SENSOR,\n\t\t\t\t\t\t"MCLK REG DISALBE FAILED: %d",\n\t\t\t\t\t\trc);\n\t\t\t\t\treturn rc;\n\t\t\t\t}\n\n\t\t\t\tps->data[0] =\n\t\t\t\t\tsoc_info->rgltr[j];\n\n\t\t\t\tregulator_put(\n\t\t\t\t\tsoc_info->rgltr[j]);\n\t\t\t\tsoc_info->rgltr[j] = NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn rc;\n}'
p1134
g1109
sssS'CVE-2019-2314'
p1135
(dp1136
(S'drivers/gpu/drm/msm/dp/dp_debug.c'
p1137
S'dp_debug_write_edid'
p1138
tp1139
(dp1140
S'static ssize_t dp_debug_write_edid(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *edid = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t edid_size = 0;\n\tsize_t size = 0, edid_buf_index = 0;\n\tssize_t rc = count;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_1K);\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tedid_size = size / char_to_nib;\n\tbuf_t = buf;\n\n\tif (dp_debug_get_edid_buf(debug))\n\t\tgoto bail;\n\n\tif (edid_size != debug->edid_size) {\n\t\tpr_debug("realloc debug edid\\n");\n\n\t\tif (debug->edid) {\n\t\t\tdevm_kfree(debug->dev, debug->edid);\n\n\t\t\tdebug->edid = devm_kzalloc(debug->dev,\n\t\t\t\t\t\tedid_size, GFP_KERNEL);\n\t\t\tif (!debug->edid) {\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bail;\n\t\t\t}\n\n\t\t\tdebug->edid_size = edid_size;\n\n\t\t\tdebug->aux->set_sim_mode(debug->aux,\n\t\t\t\t\tdebug->dp_debug.sim_mode,\n\t\t\t\t\tdebug->edid, debug->dpcd);\n\t\t}\n\t}\n\n\twhile (edid_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (edid_buf_index < debug->edid_size)\n\t\t\tdebug->edid[edid_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tedid = debug->edid;\nbail:\n\tkfree(buf);\n\n\tif (!debug->dp_debug.sim_mode)\n\t\tdebug->panel->set_edid(debug->panel, edid);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p1141
S'70f432282130'
p1142
sS'static ssize_t dp_debug_write_edid(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *edid = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t edid_size = 0;\n\tsize_t size = 0, edid_buf_index = 0;\n\tssize_t rc = count;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_1K);\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tedid_size = size / char_to_nib;\n\tbuf_t = buf;\n\n\tif (dp_debug_get_edid_buf(debug))\n\t\tgoto bail;\n\n\tif (edid_size != debug->edid_size) {\n\t\tpr_debug("clearing debug edid\\n");\n\t\tgoto bail;\n\t}\n\n\twhile (edid_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (edid_buf_index < debug->edid_size)\n\t\t\tdebug->edid[edid_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tedid = debug->edid;\nbail:\n\tkfree(buf);\n\n\tif (!debug->dp_debug.sim_mode)\n\t\tdebug->panel->set_edid(debug->panel, edid);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p1143
S'19a8101c2309'
p1144
ss(g1137
S'dp_debug_get'
p1145
tp1146
(dp1147
S'struct dp_debug *dp_debug_get(struct device *dev, struct dp_panel *panel,\n\t\t\tstruct dp_usbpd *usbpd, struct dp_link *link,\n\t\t\tstruct dp_aux *aux, struct drm_connector **connector,\n\t\t\tstruct dp_catalog *catalog)\n{\n\tint rc = 0;\n\tstruct dp_debug_private *debug;\n\tstruct dp_debug *dp_debug;\n\n\tif (!dev || !panel || !usbpd || !link || !catalog) {\n\t\tpr_err("invalid input\\n");\n\t\trc = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tdebug = devm_kzalloc(dev, sizeof(*debug), GFP_KERNEL);\n\tif (!debug) {\n\t\trc = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tINIT_WORK(&debug->sim_work, dp_debug_sim_work);\n\n\tdebug->dp_debug.debug_en = false;\n\tdebug->usbpd = usbpd;\n\tdebug->link = link;\n\tdebug->panel = panel;\n\tdebug->aux = aux;\n\tdebug->dev = dev;\n\tdebug->connector = connector;\n\tdebug->catalog = catalog;\n\n\tdp_debug = &debug->dp_debug;\n\tdp_debug->vdisplay = 0;\n\tdp_debug->hdisplay = 0;\n\tdp_debug->vrefresh = 0;\n\n\tmutex_init(&debug->lock);\n\n\trc = dp_debug_init(dp_debug);\n\tif (rc) {\n\t\tdevm_kfree(dev, debug);\n\t\tgoto error;\n\t}\n\n\treturn dp_debug;\nerror:\n\treturn ERR_PTR(rc);\n}'
p1148
g1144
ss(g1137
S'dp_debug_write_sim'
p1149
tp1150
(dp1151
S"static ssize_t dp_debug_write_sim(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tchar buf[SZ_8];\n\tsize_t len = 0;\n\tint sim;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tif (*ppos)\n\t\treturn 0;\n\n\tmutex_lock(&debug->lock);\n\n\t/* Leave room for termination char */\n\tlen = min_t(size_t, count, SZ_8 - 1);\n\tif (copy_from_user(buf, user_buff, len))\n\t\tgoto end;\n\n\tbuf[len] = '\\0';\n\n\tif (kstrtoint(buf, 10, &sim) != 0)\n\t\tgoto end;\n\n\tif (sim) {\n\t\tif (dp_debug_get_edid_buf(debug))\n\t\t\tgoto end;\n\n\t\tif (dp_debug_get_dpcd_buf(debug))\n\t\t\tgoto error;\n\t} else {\n\t\tif (debug->edid) {\n\t\t\tdevm_kfree(debug->dev, debug->edid);\n\t\t\tdebug->edid = NULL;\n\t\t}\n\n\t\tif (debug->dpcd) {\n\t\t\tdevm_kfree(debug->dev, debug->dpcd);\n\t\t\tdebug->dpcd = NULL;\n\t\t}\n\t}\n\n\tdebug->dp_debug.sim_mode = !!sim;\n\n\tdebug->aux->set_sim_mode(debug->aux, debug->dp_debug.sim_mode,\n\t\t\tdebug->edid, debug->dpcd);\nend:\n\tmutex_unlock(&debug->lock);\n\treturn len;\nerror:\n\tdevm_kfree(debug->dev, debug->edid);\n\tmutex_unlock(&debug->lock);\n\treturn len;\n}"
p1152
g1144
ss(g1137
S'dp_debug_write_dpcd'
p1153
tp1154
(dp1155
S'static ssize_t dp_debug_write_dpcd(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *dpcd = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t dpcd_size = 0;\n\tsize_t size = 0, dpcd_buf_index = 0;\n\tssize_t rc = count;\n\tchar offset_ch[5];\n\tu32 offset;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_2K);\n\tif (size < 4)\n\t\tgoto bail;\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tmemcpy(offset_ch, buf, 4);\n\toffset_ch[4] = \'\\0\';\n\n\tif (kstrtoint(offset_ch, 16, &offset)) {\n\t\tpr_err("offset kstrtoint error\\n");\n\t\tgoto bail;\n\t}\n\n\tif (dp_debug_get_dpcd_buf(debug))\n\t\tgoto bail;\n\n\tif (offset == 0xFFFF) {\n\t\tpr_err("clearing dpcd\\n");\n\t\tmemset(debug->dpcd, 0, debug->dpcd_size);\n\t\tgoto bail;\n\t}\n\n\tsize -= 4;\n\tif (size == 0)\n\t\tgoto bail;\n\n\tdpcd_size = size / char_to_nib;\n\tbuf_t = buf + 4;\n\n\tdpcd_buf_index = offset;\n\n\twhile (dpcd_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (dpcd_buf_index < debug->dpcd_size)\n\t\t\tdebug->dpcd[dpcd_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tdpcd = debug->dpcd;\nbail:\n\tkfree(buf);\n\tif (debug->dp_debug.sim_mode)\n\t\tdebug->aux->dpcd_updated(debug->aux);\n\telse\n\t\tdebug->panel->set_dpcd(debug->panel, dpcd);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p1156
S'1d1a62b98700'
p1157
sS'static ssize_t dp_debug_write_dpcd(struct file *file,\n\t\tconst char __user *user_buff, size_t count, loff_t *ppos)\n{\n\tstruct dp_debug_private *debug = file->private_data;\n\tu8 *buf = NULL, *buf_t = NULL, *dpcd = NULL;\n\tconst int char_to_nib = 2;\n\tsize_t dpcd_size = 0;\n\tsize_t size = 0, dpcd_buf_index = 0;\n\tssize_t rc = count;\n\tchar offset_ch[5];\n\tu32 offset;\n\n\tif (!debug)\n\t\treturn -ENODEV;\n\n\tmutex_lock(&debug->lock);\n\n\tif (*ppos)\n\t\tgoto bail;\n\n\tsize = min_t(size_t, count, SZ_2K);\n\n\tbuf = kzalloc(size, GFP_KERNEL);\n\tif (ZERO_OR_NULL_PTR(buf)) {\n\t\trc = -ENOMEM;\n\t\tgoto bail;\n\t}\n\n\tif (copy_from_user(buf, user_buff, size))\n\t\tgoto bail;\n\n\tmemcpy(offset_ch, buf, 4);\n\toffset_ch[4] = \'\\0\';\n\n\tif (kstrtoint(offset_ch, 16, &offset)) {\n\t\tpr_err("offset kstrtoint error\\n");\n\t\tgoto bail;\n\t}\n\n\tif (dp_debug_get_dpcd_buf(debug))\n\t\tgoto bail;\n\n\tif (offset == 0xFFFF) {\n\t\tpr_err("clearing dpcd\\n");\n\t\tmemset(debug->dpcd, 0, debug->dpcd_size);\n\t\tgoto bail;\n\t}\n\n\tsize -= 4;\n\n\tdpcd_size = size / char_to_nib;\n\tbuf_t = buf + 4;\n\n\tdpcd_buf_index = offset;\n\n\twhile (dpcd_size--) {\n\t\tchar t[3];\n\t\tint d;\n\n\t\tmemcpy(t, buf_t, sizeof(char) * char_to_nib);\n\t\tt[char_to_nib] = \'\\0\';\n\n\t\tif (kstrtoint(t, 16, &d)) {\n\t\t\tpr_err("kstrtoint error\\n");\n\t\t\tgoto bail;\n\t\t}\n\n\t\tif (dpcd_buf_index < debug->dpcd_size)\n\t\t\tdebug->dpcd[dpcd_buf_index++] = d;\n\n\t\tbuf_t += char_to_nib;\n\t}\n\n\tdpcd = debug->dpcd;\nbail:\n\tkfree(buf);\n\tif (debug->dp_debug.sim_mode)\n\t\tdebug->aux->dpcd_updated(debug->aux);\n\telse\n\t\tdebug->panel->set_dpcd(debug->panel, dpcd);\n\n\tmutex_unlock(&debug->lock);\n\treturn rc;\n}'
p1158
g1144
ss(g1137
S'dp_debug_put'
p1159
tp1160
(dp1161
S'void dp_debug_put(struct dp_debug *dp_debug)\n{\n\tstruct dp_debug_private *debug;\n\n\tif (!dp_debug)\n\t\treturn;\n\n\tdebug = container_of(dp_debug, struct dp_debug_private, dp_debug);\n\n\tdp_debug_deinit(dp_debug);\n\n\tmutex_destroy(&debug->lock);\n\n\tif (debug->edid)\n\t\tdevm_kfree(debug->dev, debug->edid);\n\n\tif (debug->dpcd)\n\t\tdevm_kfree(debug->dev, debug->dpcd);\n\n\tdevm_kfree(debug->dev, debug);\n}'
p1162
g1144
sss.